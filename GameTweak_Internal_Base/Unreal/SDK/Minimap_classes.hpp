#pragma once

/*
* SDK generated by Dumper-69
*
* https://github.com/Encryqed/Dumper-69
*/

// Package: Minimap

#include "Basic.hpp"

#include "Engine_classes.hpp"
#include "SlateCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Minimap_structs.hpp"
#include "BPGLib_classes.hpp"
#include "UMG_classes.hpp"


namespace SDK
{

// Class Minimap.MinimapSpot
// 0x00D8 (0x0100 - 0x0028)
class UMinimapSpot final : public UObject
{
public:
	class FText                                   Name_MinimapSpot;                                  // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   ID;                                                // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TextColor;                                         // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         Font;                                              // 0x0058(0x0058)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ShadowOffset;                                      // 0x00B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ShadowColor;                                       // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Pos;                                               // 0x00D0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OriginalPos;                                       // 0x00E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MinimapSpot">();
	}
	static class UMinimapSpot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMinimapSpot>();
	}
};
static_assert(alignof(UMinimapSpot) == 0x000008, "Wrong alignment on UMinimapSpot");
static_assert(sizeof(UMinimapSpot) == 0x000100, "Wrong size on UMinimapSpot");
static_assert(offsetof(UMinimapSpot, Name_MinimapSpot) == 0x000028, "Member 'UMinimapSpot::Name_MinimapSpot' has a wrong offset!");
static_assert(offsetof(UMinimapSpot, ID) == 0x000040, "Member 'UMinimapSpot::ID' has a wrong offset!");
static_assert(offsetof(UMinimapSpot, TextColor) == 0x000048, "Member 'UMinimapSpot::TextColor' has a wrong offset!");
static_assert(offsetof(UMinimapSpot, Font) == 0x000058, "Member 'UMinimapSpot::Font' has a wrong offset!");
static_assert(offsetof(UMinimapSpot, ShadowOffset) == 0x0000B0, "Member 'UMinimapSpot::ShadowOffset' has a wrong offset!");
static_assert(offsetof(UMinimapSpot, ShadowColor) == 0x0000C0, "Member 'UMinimapSpot::ShadowColor' has a wrong offset!");
static_assert(offsetof(UMinimapSpot, Pos) == 0x0000D0, "Member 'UMinimapSpot::Pos' has a wrong offset!");
static_assert(offsetof(UMinimapSpot, OriginalPos) == 0x0000E8, "Member 'UMinimapSpot::OriginalPos' has a wrong offset!");

// Class Minimap.Minimap
// 0x00C8 (0x00F0 - 0x0028)
class UMinimap final : public UObject
{
public:
	class FText                                   MapName;                                           // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UTexture*                               Map;                                               // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CA6[0x8];                                     // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	struct FMatrix                                ToMapMatrix;                                       // 0x0050(0x0080)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FloorHeight;                                       // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CeilHeight;                                        // 0x00D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMinimapSpot*>                   _Spots;                                            // 0x00D8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CA7[0x8];                                     // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Minimap">();
	}
	static class UMinimap* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMinimap>();
	}
};
static_assert(alignof(UMinimap) == 0x000010, "Wrong alignment on UMinimap");
static_assert(sizeof(UMinimap) == 0x0000F0, "Wrong size on UMinimap");
static_assert(offsetof(UMinimap, MapName) == 0x000028, "Member 'UMinimap::MapName' has a wrong offset!");
static_assert(offsetof(UMinimap, Map) == 0x000040, "Member 'UMinimap::Map' has a wrong offset!");
static_assert(offsetof(UMinimap, ToMapMatrix) == 0x000050, "Member 'UMinimap::ToMapMatrix' has a wrong offset!");
static_assert(offsetof(UMinimap, FloorHeight) == 0x0000D0, "Member 'UMinimap::FloorHeight' has a wrong offset!");
static_assert(offsetof(UMinimap, CeilHeight) == 0x0000D4, "Member 'UMinimap::CeilHeight' has a wrong offset!");
static_assert(offsetof(UMinimap, _Spots) == 0x0000D8, "Member 'UMinimap::_Spots' has a wrong offset!");

// Class Minimap.MinimapConfig
// 0x0030 (0x0058 - 0x0028)
class UMinimapConfig final : public UObject
{
public:
	uint8                                         Pad_1CA8[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	struct FLinearColor                           FloorColor;                                        // 0x0030(0x0010)(Edit, ZeroConstructor, Config, EditConst, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           WallColor;                                         // 0x0040(0x0010)(Edit, ZeroConstructor, Config, EditConst, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkableHeight;                                    // 0x0050(0x0004)(Edit, ZeroConstructor, Config, EditConst, GlobalConfig, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CA9[0x4];                                     // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MinimapConfig">();
	}
	static class UMinimapConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMinimapConfig>();
	}
};
static_assert(alignof(UMinimapConfig) == 0x000008, "Wrong alignment on UMinimapConfig");
static_assert(sizeof(UMinimapConfig) == 0x000058, "Wrong size on UMinimapConfig");
static_assert(offsetof(UMinimapConfig, FloorColor) == 0x000030, "Member 'UMinimapConfig::FloorColor' has a wrong offset!");
static_assert(offsetof(UMinimapConfig, WallColor) == 0x000040, "Member 'UMinimapConfig::WallColor' has a wrong offset!");
static_assert(offsetof(UMinimapConfig, WalkableHeight) == 0x000050, "Member 'UMinimapConfig::WalkableHeight' has a wrong offset!");

// Class Minimap.MinimapMarker
// 0x0038 (0x0528 - 0x04F0)
class UMinimapMarker : public UPreviewableWidget
{
public:
	uint8                                         Pad_1CAA[0x8];                                     // 0x04F0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          _RotateToFront;                                    // 0x04F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CAB[0x7];                                     // 0x04F9(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FVector2D                              _RotationPivot;                                    // 0x0500(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              _FrontDirection;                                   // 0x0510(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TickInternal;                                      // 0x0520(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CAC[0x4];                                     // 0x0524(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool OnBindActor(class AActor* _Actor);
	bool OnTick(const struct FGeometry& MyGeometry, float _delta);

	class AActor* GetBoundActor() const;
	bool IsRotatingEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MinimapMarker">();
	}
	static class UMinimapMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMinimapMarker>();
	}
};
static_assert(alignof(UMinimapMarker) == 0x000008, "Wrong alignment on UMinimapMarker");
static_assert(sizeof(UMinimapMarker) == 0x000528, "Wrong size on UMinimapMarker");
static_assert(offsetof(UMinimapMarker, _RotateToFront) == 0x0004F8, "Member 'UMinimapMarker::_RotateToFront' has a wrong offset!");
static_assert(offsetof(UMinimapMarker, _RotationPivot) == 0x000500, "Member 'UMinimapMarker::_RotationPivot' has a wrong offset!");
static_assert(offsetof(UMinimapMarker, _FrontDirection) == 0x000510, "Member 'UMinimapMarker::_FrontDirection' has a wrong offset!");
static_assert(offsetof(UMinimapMarker, TickInternal) == 0x000520, "Member 'UMinimapMarker::TickInternal' has a wrong offset!");

// Class Minimap.MinimapMarkerFactory
// 0x0000 (0x0028 - 0x0028)
class UMinimapMarkerFactory : public UObject
{
public:
	TSubclassOf<class UMinimapMarker> GetMarkerType(class AActor* _target);

	class APlayerController* GetLocalPlayerController() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MinimapMarkerFactory">();
	}
	static class UMinimapMarkerFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMinimapMarkerFactory>();
	}
};
static_assert(alignof(UMinimapMarkerFactory) == 0x000008, "Wrong alignment on UMinimapMarkerFactory");
static_assert(sizeof(UMinimapMarkerFactory) == 0x000028, "Wrong size on UMinimapMarkerFactory");

// Class Minimap.MinimapView
// 0x00E8 (0x0290 - 0x01A8)
class UMinimapView final : public UOverlay
{
public:
	TSubclassOf<class UMinimapMarkerFactory>      _FactoryType;                                      // 0x01A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMinimapMarkerFactory*                  _Factory;                                          // 0x01B0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AMinimapVolume*>                 _Volumes;                                          // 0x01B8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class AActor*, class UMinimapMarker*>    _MarkerMap;                                        // 0x01C8(0x0050)(ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class APlayerState*, class UMinimapMarker*> _PlayerMarkerMap;                                  // 0x0218(0x0050)(ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CAF[0x28];                                    // 0x0268(0x0028)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void AddActor(class AActor* _Actor);
	void AddPlayer(class APlayerState* _player_state);
	class UMinimapMarker* FindMarker(class AActor* _Actor);
	class FText GetCurrentMinimapName();
	void RemoveMarker(class AActor* _Actor);
	void RemovePlayerMarker(class APlayerState* _player_state);
	void SetToFocusActor(class AActor* _Actor);
	void SetZoomScale(float _scale);

	class UMinimap* GetCurrentMinimap() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MinimapView">();
	}
	static class UMinimapView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMinimapView>();
	}
};
static_assert(alignof(UMinimapView) == 0x000008, "Wrong alignment on UMinimapView");
static_assert(sizeof(UMinimapView) == 0x000290, "Wrong size on UMinimapView");
static_assert(offsetof(UMinimapView, _FactoryType) == 0x0001A8, "Member 'UMinimapView::_FactoryType' has a wrong offset!");
static_assert(offsetof(UMinimapView, _Factory) == 0x0001B0, "Member 'UMinimapView::_Factory' has a wrong offset!");
static_assert(offsetof(UMinimapView, _Volumes) == 0x0001B8, "Member 'UMinimapView::_Volumes' has a wrong offset!");
static_assert(offsetof(UMinimapView, _MarkerMap) == 0x0001C8, "Member 'UMinimapView::_MarkerMap' has a wrong offset!");
static_assert(offsetof(UMinimapView, _PlayerMarkerMap) == 0x000218, "Member 'UMinimapView::_PlayerMarkerMap' has a wrong offset!");

// Class Minimap.MinimapVolume
// 0x0048 (0x0318 - 0x02D0)
class AMinimapVolume final : public AVolume
{
public:
	struct FMinimapRef                            MinimapRef;                                        // 0x02D0(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         MapWidth;                                          // 0x02D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MapHeight;                                         // 0x02DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1CB0[0x38];                                    // 0x02E0(0x0038)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MinimapVolume">();
	}
	static class AMinimapVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMinimapVolume>();
	}
};
static_assert(alignof(AMinimapVolume) == 0x000008, "Wrong alignment on AMinimapVolume");
static_assert(sizeof(AMinimapVolume) == 0x000318, "Wrong size on AMinimapVolume");
static_assert(offsetof(AMinimapVolume, MinimapRef) == 0x0002D0, "Member 'AMinimapVolume::MinimapRef' has a wrong offset!");
static_assert(offsetof(AMinimapVolume, MapWidth) == 0x0002D8, "Member 'AMinimapVolume::MapWidth' has a wrong offset!");
static_assert(offsetof(AMinimapVolume, MapHeight) == 0x0002DC, "Member 'AMinimapVolume::MapHeight' has a wrong offset!");

// Class Minimap.MinimapWidget
// 0x0018 (0x0198 - 0x0180)
class UMinimapWidget final : public UWidget
{
public:
	uint8                                         Pad_1CB1[0x10];                                    // 0x0180(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class UMinimap*                               _Minimap;                                          // 0x0190(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MinimapWidget">();
	}
	static class UMinimapWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMinimapWidget>();
	}
};
static_assert(alignof(UMinimapWidget) == 0x000008, "Wrong alignment on UMinimapWidget");
static_assert(sizeof(UMinimapWidget) == 0x000198, "Wrong size on UMinimapWidget");
static_assert(offsetof(UMinimapWidget, _Minimap) == 0x000190, "Member 'UMinimapWidget::_Minimap' has a wrong offset!");

}


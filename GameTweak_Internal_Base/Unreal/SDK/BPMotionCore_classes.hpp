#pragma once

/*
* SDK generated by Dumper-69
*
* https://github.com/Encryqed/Dumper-69
*/

// Package: BPMotionCore

#include "Basic.hpp"

#include "BPMotionCore_structs.hpp"
#include "BPGLib_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class BPMotionCore.BPMotionMovementComponent
// 0x06C0 (0x24A0 - 0x1DE0)
class UBPMotionMovementComponent : public UBPGMovementComponent
{
public:
	uint8                                         Pad_1C32[0x4];                                     // 0x1DE0(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          EnableMotionMatching;                              // 0x1DE4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C33[0x3];                                     // 0x1DE5(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	struct FMotionMatchingConfig                  _MotionMatchingSettings;                           // 0x1DE8(0x0048)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FMotionMatchingDriver                  _MM_Driver;                                        // 0x1E30(0x0668)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C34[0x8];                                     // 0x2498(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void SetGravityScaleInRootMotion(float _value);

	class FString GetCorrectionInfo() const;
	class FString GetPendingMoveInfo() const;
	class FString GetRootMotionInfo() const;
	class FString GetSmoothingInfo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPMotionMovementComponent">();
	}
	static class UBPMotionMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPMotionMovementComponent>();
	}
};
static_assert(alignof(UBPMotionMovementComponent) == 0x000010, "Wrong alignment on UBPMotionMovementComponent");
static_assert(sizeof(UBPMotionMovementComponent) == 0x0024A0, "Wrong size on UBPMotionMovementComponent");
static_assert(offsetof(UBPMotionMovementComponent, EnableMotionMatching) == 0x001DE4, "Member 'UBPMotionMovementComponent::EnableMotionMatching' has a wrong offset!");
static_assert(offsetof(UBPMotionMovementComponent, _MotionMatchingSettings) == 0x001DE8, "Member 'UBPMotionMovementComponent::_MotionMatchingSettings' has a wrong offset!");
static_assert(offsetof(UBPMotionMovementComponent, _MM_Driver) == 0x001E30, "Member 'UBPMotionMovementComponent::_MM_Driver' has a wrong offset!");

// Class BPMotionCore.BPMTreeNode
// 0x0010 (0x0038 - 0x0028)
class UBPMTreeNode : public UObject
{
public:
	TArray<struct FMotionMatchingIndex>           Keys;                                              // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPMTreeNode">();
	}
	static class UBPMTreeNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPMTreeNode>();
	}
};
static_assert(alignof(UBPMTreeNode) == 0x000008, "Wrong alignment on UBPMTreeNode");
static_assert(sizeof(UBPMTreeNode) == 0x000038, "Wrong size on UBPMTreeNode");
static_assert(offsetof(UBPMTreeNode, Keys) == 0x000028, "Member 'UBPMTreeNode::Keys' has a wrong offset!");

// Class BPMotionCore.BPMTreeNode_Directional
// 0x0050 (0x0088 - 0x0038)
class UBPMTreeNode_Directional : public UBPMTreeNode
{
public:
	float                                         AcceptableBorderError;                             // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C35[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UBPMTreeNode*                           Children[0x9];                                     // 0x0040(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPMTreeNode_Directional">();
	}
	static class UBPMTreeNode_Directional* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPMTreeNode_Directional>();
	}
};
static_assert(alignof(UBPMTreeNode_Directional) == 0x000008, "Wrong alignment on UBPMTreeNode_Directional");
static_assert(sizeof(UBPMTreeNode_Directional) == 0x000088, "Wrong size on UBPMTreeNode_Directional");
static_assert(offsetof(UBPMTreeNode_Directional, AcceptableBorderError) == 0x000038, "Member 'UBPMTreeNode_Directional::AcceptableBorderError' has a wrong offset!");
static_assert(offsetof(UBPMTreeNode_Directional, Children) == 0x000040, "Member 'UBPMTreeNode_Directional::Children' has a wrong offset!");

// Class BPMotionCore.BPMTreeNode_StartVelocity
// 0x0000 (0x0088 - 0x0088)
class UBPMTreeNode_StartVelocity final : public UBPMTreeNode_Directional
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPMTreeNode_StartVelocity">();
	}
	static class UBPMTreeNode_StartVelocity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPMTreeNode_StartVelocity>();
	}
};
static_assert(alignof(UBPMTreeNode_StartVelocity) == 0x000008, "Wrong alignment on UBPMTreeNode_StartVelocity");
static_assert(sizeof(UBPMTreeNode_StartVelocity) == 0x000088, "Wrong size on UBPMTreeNode_StartVelocity");

// Class BPMotionCore.BPMTreeNode_SubBoneVelocity
// 0x0008 (0x0090 - 0x0088)
class UBPMTreeNode_SubBoneVelocity final : public UBPMTreeNode_Directional
{
public:
	int32                                         SubboneIndex;                                      // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C36[0x4];                                     // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPMTreeNode_SubBoneVelocity">();
	}
	static class UBPMTreeNode_SubBoneVelocity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPMTreeNode_SubBoneVelocity>();
	}
};
static_assert(alignof(UBPMTreeNode_SubBoneVelocity) == 0x000008, "Wrong alignment on UBPMTreeNode_SubBoneVelocity");
static_assert(sizeof(UBPMTreeNode_SubBoneVelocity) == 0x000090, "Wrong size on UBPMTreeNode_SubBoneVelocity");
static_assert(offsetof(UBPMTreeNode_SubBoneVelocity, SubboneIndex) == 0x000088, "Member 'UBPMTreeNode_SubBoneVelocity::SubboneIndex' has a wrong offset!");

// Class BPMotionCore.BPMTreeNode_Vector
// 0x0038 (0x0070 - 0x0038)
class UBPMTreeNode_Vector : public UBPMTreeNode
{
public:
	struct FVector2D                              Pivot;                                             // 0x0038(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AcceptableBorderError;                             // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C37[0x4];                                     // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UBPMTreeNode*                           Children[0x4];                                     // 0x0050(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPMTreeNode_Vector">();
	}
	static class UBPMTreeNode_Vector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPMTreeNode_Vector>();
	}
};
static_assert(alignof(UBPMTreeNode_Vector) == 0x000008, "Wrong alignment on UBPMTreeNode_Vector");
static_assert(sizeof(UBPMTreeNode_Vector) == 0x000070, "Wrong size on UBPMTreeNode_Vector");
static_assert(offsetof(UBPMTreeNode_Vector, Pivot) == 0x000038, "Member 'UBPMTreeNode_Vector::Pivot' has a wrong offset!");
static_assert(offsetof(UBPMTreeNode_Vector, AcceptableBorderError) == 0x000048, "Member 'UBPMTreeNode_Vector::AcceptableBorderError' has a wrong offset!");
static_assert(offsetof(UBPMTreeNode_Vector, Children) == 0x000050, "Member 'UBPMTreeNode_Vector::Children' has a wrong offset!");

// Class BPMotionCore.BPMTreeNode_TargetPosition
// 0x0000 (0x0070 - 0x0070)
class UBPMTreeNode_TargetPosition final : public UBPMTreeNode_Vector
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPMTreeNode_TargetPosition">();
	}
	static class UBPMTreeNode_TargetPosition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPMTreeNode_TargetPosition>();
	}
};
static_assert(alignof(UBPMTreeNode_TargetPosition) == 0x000008, "Wrong alignment on UBPMTreeNode_TargetPosition");
static_assert(sizeof(UBPMTreeNode_TargetPosition) == 0x000070, "Wrong size on UBPMTreeNode_TargetPosition");

// Class BPMotionCore.BPMTreeNode_SubBonePosition
// 0x0008 (0x0078 - 0x0070)
class UBPMTreeNode_SubBonePosition final : public UBPMTreeNode_Vector
{
public:
	int32                                         SubboneIndex;                                      // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C38[0x4];                                     // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BPMTreeNode_SubBonePosition">();
	}
	static class UBPMTreeNode_SubBonePosition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPMTreeNode_SubBonePosition>();
	}
};
static_assert(alignof(UBPMTreeNode_SubBonePosition) == 0x000008, "Wrong alignment on UBPMTreeNode_SubBonePosition");
static_assert(sizeof(UBPMTreeNode_SubBonePosition) == 0x000078, "Wrong size on UBPMTreeNode_SubBonePosition");
static_assert(offsetof(UBPMTreeNode_SubBonePosition, SubboneIndex) == 0x000070, "Member 'UBPMTreeNode_SubBonePosition::SubboneIndex' has a wrong offset!");

// Class BPMotionCore.MotionMatching
// 0x0100 (0x0128 - 0x0028)
class UMotionMatching final : public UObject
{
public:
	uint8                                         Pad_1C39[0x10];                                    // 0x0028(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class USkeleton*                              _Skeleton;                                         // 0x0038(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAnimSource*>                    _Sources;                                          // 0x0040(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UAnimSequence*>                  _Idles;                                            // 0x0050(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FAnimDataSet>                   _DataSet;                                          // 0x0060(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UBPMTreeNode*                           _Root;                                             // 0x0070(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMMConfigBone                          Root;                                              // 0x0078(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FMMConfigBone>                  _AdditionalBones;                                  // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         KeySamplingInterval;                               // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TrajectoryInterval;                                // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDirectional                           MaxSpeed;                                          // 0x0098(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FDirectional                           MaxAcceleration;                                   // 0x00B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FMotionMatchingIndex                   StartingIndex;                                     // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UAssetUserData*>                 AssetUserData;                                     // 0x00D0(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBPMSplitConfig>                _SplitConfigs;                                     // 0x00E0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C3A[0x38];                                    // 0x00F0(0x0038)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void SetSkeleton(class USkeleton* _skel);

	const TArray<class UAnimSequence*> GetIdles() const;
	class USkeleton* GetSkeleton() const;
	const TArray<class UAnimSource*> GetSources() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MotionMatching">();
	}
	static class UMotionMatching* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMotionMatching>();
	}
};
static_assert(alignof(UMotionMatching) == 0x000008, "Wrong alignment on UMotionMatching");
static_assert(sizeof(UMotionMatching) == 0x000128, "Wrong size on UMotionMatching");
static_assert(offsetof(UMotionMatching, _Skeleton) == 0x000038, "Member 'UMotionMatching::_Skeleton' has a wrong offset!");
static_assert(offsetof(UMotionMatching, _Sources) == 0x000040, "Member 'UMotionMatching::_Sources' has a wrong offset!");
static_assert(offsetof(UMotionMatching, _Idles) == 0x000050, "Member 'UMotionMatching::_Idles' has a wrong offset!");
static_assert(offsetof(UMotionMatching, _DataSet) == 0x000060, "Member 'UMotionMatching::_DataSet' has a wrong offset!");
static_assert(offsetof(UMotionMatching, _Root) == 0x000070, "Member 'UMotionMatching::_Root' has a wrong offset!");
static_assert(offsetof(UMotionMatching, Root) == 0x000078, "Member 'UMotionMatching::Root' has a wrong offset!");
static_assert(offsetof(UMotionMatching, _AdditionalBones) == 0x000080, "Member 'UMotionMatching::_AdditionalBones' has a wrong offset!");
static_assert(offsetof(UMotionMatching, KeySamplingInterval) == 0x000090, "Member 'UMotionMatching::KeySamplingInterval' has a wrong offset!");
static_assert(offsetof(UMotionMatching, TrajectoryInterval) == 0x000094, "Member 'UMotionMatching::TrajectoryInterval' has a wrong offset!");
static_assert(offsetof(UMotionMatching, MaxSpeed) == 0x000098, "Member 'UMotionMatching::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UMotionMatching, MaxAcceleration) == 0x0000B0, "Member 'UMotionMatching::MaxAcceleration' has a wrong offset!");
static_assert(offsetof(UMotionMatching, StartingIndex) == 0x0000C8, "Member 'UMotionMatching::StartingIndex' has a wrong offset!");
static_assert(offsetof(UMotionMatching, AssetUserData) == 0x0000D0, "Member 'UMotionMatching::AssetUserData' has a wrong offset!");
static_assert(offsetof(UMotionMatching, _SplitConfigs) == 0x0000E0, "Member 'UMotionMatching::_SplitConfigs' has a wrong offset!");

// Class BPMotionCore.AnimSource
// 0x0010 (0x0038 - 0x0028)
class UAnimSource final : public UObject
{
public:
	class UAnimSequence*                          Animation;                                         // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Loop;                                              // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C3B[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimSource">();
	}
	static class UAnimSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimSource>();
	}
};
static_assert(alignof(UAnimSource) == 0x000008, "Wrong alignment on UAnimSource");
static_assert(sizeof(UAnimSource) == 0x000038, "Wrong size on UAnimSource");
static_assert(offsetof(UAnimSource, Animation) == 0x000028, "Member 'UAnimSource::Animation' has a wrong offset!");
static_assert(offsetof(UAnimSource, Loop) == 0x000030, "Member 'UAnimSource::Loop' has a wrong offset!");

}


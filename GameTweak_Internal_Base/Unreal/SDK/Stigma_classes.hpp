#pragma once

/*
* SDK generated by Dumper-69
*
* https://github.com/Encryqed/Dumper-69
*/

// Package: Stigma

#include "Basic.hpp"

#include "SlateCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "Stigma_structs.hpp"
#include "InputCore_structs.hpp"
#include "BPGLib_structs.hpp"
#include "BPGLib_classes.hpp"
#include "Niagara_classes.hpp"
#include "ActionGraph_structs.hpp"
#include "ActionGraph_classes.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "Slate_structs.hpp"
#include "Minimap_classes.hpp"
#include "NiagaraAnimNotifies_classes.hpp"
#include "BPMotionCore_classes.hpp"
#include "PhysicsCore_classes.hpp"
#include "CommonUI_classes.hpp"
#include "EnhancedInput_structs.hpp"


namespace SDK
{

// Class Stigma.StigmaPlayerController
// 0x00D8 (0x0990 - 0x08B8)
class AStigmaPlayerController : public ABPGPlayerController
{
public:
	TSubclassOf<class UUI_ToastMessageContainerBase> _ToastMessageContainerClass;                       // 0x08B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_ToastMessageContainerBase*          _ToastMessageContainer;                            // 0x08C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTickTaskComponent*                     _TickTaskComponent;                                // 0x08C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_RewardedPopup>          _RewardedUIClass;                                  // 0x08D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F24[0x90];                                    // 0x08D8(0x0090)(Fixing Size After Last Property [ Dumper-69 ])
	class AVoiceSound2DActor*                     _Announcer2DActor;                                 // 0x0968(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AVoiceSound2DActor*>             _CharacterVoice2DActors;                           // 0x0970(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UUI_GameNotifyContainer*                _GameNotifyContainer;                              // 0x0980(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_ShopQuickPurchase>      _QuickPurchaseUIClass;                             // 0x0988(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddChara2DVoice(const class FString& _voice_id, class APlayerState* _player_state, ECharaType _speak_chara_type, bool _is_radio);
	void AddGameNotify(const class FName& _notify_name, const class FText& _text, float _time);
	void AddTickTask(float _duration, const TDelegate<void(float _delta, float _elaped, ETickTaskState _state)>& _task);
	void AddVoice(const class FString& _voice_id, class ACharaBase* _speak_chara, bool _is_3d_voice);
	void ClearAllGameNotifies();
	void HideAllGameNotifies(bool _hide);
	void MapJump(class FName _level_name, float _fadeout_time);
	void OnEnterChatAction();
	void PlayVoice();
	void RemoveGameNotify(const class FName& _notify_name, bool _force_remove);
	void ShowQuickPurchaseCurrencyPopup(const struct FItemID_Currency& _currency_id);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StigmaPlayerController">();
	}
	static class AStigmaPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStigmaPlayerController>();
	}
};
static_assert(alignof(AStigmaPlayerController) == 0x000008, "Wrong alignment on AStigmaPlayerController");
static_assert(sizeof(AStigmaPlayerController) == 0x000990, "Wrong size on AStigmaPlayerController");
static_assert(offsetof(AStigmaPlayerController, _ToastMessageContainerClass) == 0x0008B8, "Member 'AStigmaPlayerController::_ToastMessageContainerClass' has a wrong offset!");
static_assert(offsetof(AStigmaPlayerController, _ToastMessageContainer) == 0x0008C0, "Member 'AStigmaPlayerController::_ToastMessageContainer' has a wrong offset!");
static_assert(offsetof(AStigmaPlayerController, _TickTaskComponent) == 0x0008C8, "Member 'AStigmaPlayerController::_TickTaskComponent' has a wrong offset!");
static_assert(offsetof(AStigmaPlayerController, _RewardedUIClass) == 0x0008D0, "Member 'AStigmaPlayerController::_RewardedUIClass' has a wrong offset!");
static_assert(offsetof(AStigmaPlayerController, _Announcer2DActor) == 0x000968, "Member 'AStigmaPlayerController::_Announcer2DActor' has a wrong offset!");
static_assert(offsetof(AStigmaPlayerController, _CharacterVoice2DActors) == 0x000970, "Member 'AStigmaPlayerController::_CharacterVoice2DActors' has a wrong offset!");
static_assert(offsetof(AStigmaPlayerController, _GameNotifyContainer) == 0x000980, "Member 'AStigmaPlayerController::_GameNotifyContainer' has a wrong offset!");
static_assert(offsetof(AStigmaPlayerController, _QuickPurchaseUIClass) == 0x000988, "Member 'AStigmaPlayerController::_QuickPurchaseUIClass' has a wrong offset!");

// Class Stigma.MatchServicedPlayerController
// 0x0028 (0x09B8 - 0x0990)
class AMatchServicedPlayerController : public AStigmaPlayerController
{
public:
	uint8                                         Pad_1F29[0x8];                                     // 0x0990(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	struct FNetID                                 _NetID;                                            // 0x0998(0x0002)(Edit, BlueprintVisible, Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F2A[0x6];                                     // 0x099A(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             _OnConfirm_ACK;                                    // 0x09A0(0x0010)(Edit, ZeroConstructor, EditConst, InstancedReference, BlueprintAssignable, Protected, BlueprintCallable, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F2B[0x8];                                     // 0x09B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ExitToLobby();
	bool OnChangeServerState(EServerStatus _server_state);
	void OnClient_UpdateSharedPlayerState(class AMatchServicedPlayerState* _player_state);
	void OnRep_NetID(const struct FNetID& _old_id);
	void QuitToLobby();
	void RPC_CLI_SendChat(const struct FChatMsg& _msg);
	void RPC_CLIENT_Quit_ACK();
	void RPC_CLIENT_TryReady_ACK(const struct FConfirmResponse& _response);
	void RPC_CLIENT_WarnChangingGun(ECharaType _chara_type, const struct FGunPreset& _gun_preset);
	void RPC_DEBUG_FinishBattle();
	void RPC_SERVER_ConfirmEndSession();
	void RPC_SERVER_Quit();
	void RPC_SERVER_SendChat(const struct FChatMsg& _msg);
	void RPC_SERVER_SetCharacterSetting(int32 _zidx_chara, const struct FItemID& _item_id, int32 _slot_zidx);
	void RPC_SERVER_SetCostume(const TArray<struct FLocalCharacterSet>& _local_picked_charas, int32 _zidx_chara, const struct FItemID& _item_id);
	void RPC_SERVER_SetGunPreset(const TArray<struct FLocalCharacterSet>& _local_picked_charas, int32 _zidx_chara, const struct FGunPreset& _gun_preset);
	void RPC_SERVER_TryReady(const TArray<struct FLocalCharacterSet>& _local_picked_charas, bool _i_am_ready, bool _forced);
	void RPC_SERVER_UpdateBooster(int32 _slot_index, const struct FItemID& _item_id);
	void RPC_SERVER_UpdateInvenByItems();
	void SERVER_SetNetID(const struct FNetID& _net_id);
	void Setter_NetID(const struct FNetID& _new_id);
	void ShowRewardedPopup(const struct FRewardPlain& _reward_plain);

	const struct FCharacterInfo GetCurrentCharacterInfo() const;
	struct FNetID GetNetID() const;
	class ACharaBase* GetOwnCharacter() const;
	ETeams GetTeam() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchServicedPlayerController">();
	}
	static class AMatchServicedPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchServicedPlayerController>();
	}
};
static_assert(alignof(AMatchServicedPlayerController) == 0x000008, "Wrong alignment on AMatchServicedPlayerController");
static_assert(sizeof(AMatchServicedPlayerController) == 0x0009B8, "Wrong size on AMatchServicedPlayerController");
static_assert(offsetof(AMatchServicedPlayerController, _NetID) == 0x000998, "Member 'AMatchServicedPlayerController::_NetID' has a wrong offset!");
static_assert(offsetof(AMatchServicedPlayerController, _OnConfirm_ACK) == 0x0009A0, "Member 'AMatchServicedPlayerController::_OnConfirm_ACK' has a wrong offset!");

// Class Stigma.BattlePlayerControllerBase
// 0x0488 (0x0E40 - 0x09B8)
class ABattlePlayerControllerBase : public AMatchServicedPlayerController
{
public:
	TSubclassOf<class UUI_HUDBase>                HUD_Type;                                          // 0x09B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_ResultBase>             ResultUI_Type;                                     // 0x09C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_TabBase>                TabUI_Type;                                        // 0x09C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_RoundResultBase>        RoundResultUI_Type;                                // 0x09D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_HUDBase*                            UI_HUD;                                            // 0x09D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_ResultBase*                         UI_Result;                                         // 0x09E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_RoundResultBase*                    UI_RoundResult;                                    // 0x09E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_TabBase*                            UI_Tab;                                            // 0x09F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPopupBase*                             UI_Help;                                           // 0x09F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPopupBase*                             UI_WaitingRoom_InGame;                             // 0x0A00(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPopupBase>                 HelpUI_Type;                                       // 0x0A08(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPopupBase>                 WaitingRoomUI_Type;                                // 0x0A10(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  CharacterPickInGameMapFile;                        // 0x0A18(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShakeBase>           Shake_Strong;                                      // 0x0A40(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShakeBase>           Shake_Weak;                                        // 0x0A48(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShakeBase>           Shake_OnFire;                                      // 0x0A50(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_CheatBase>              UICheatType;                                       // 0x0A58(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_CheatBase*                          UI_Cheat;                                          // 0x0A60(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserOption*                            _UserOption;                                       // 0x0A68(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       _MinimapWidget;                                    // 0x0A70(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F33[0x8];                                     // 0x0A78(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class UWidget*>                        _WidgetsToAddToHUD;                                // 0x0A80(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FDominantPopupUIOption                 DominantPopupUIOption;                             // 0x0A90(0x0010)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class ACharaBase*                             _UIBoundChara;                                     // 0x0AA0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F34[0x1];                                     // 0x0AA8(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          _IsBattleStoreEnabled;                             // 0x0AA9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _CanOpenBattleStore;                               // 0x0AAA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F35[0x5];                                     // 0x0AAB(0x0005)(Fixing Size After Last Property [ Dumper-69 ])
	TSet<EBattleStoreTab>                         _BattleStoreTabs;                                  // 0x0AB0(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_BattleStorePopup>       _BattleStoreUI_Type;                               // 0x0B00(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_BattleStorePopup*                   _BattleStoreUI;                                    // 0x0B08(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBattleStoreHistoryRecorder            _BattleStoreHistoryRecorder;                       // 0x0B10(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             Event_OnUpdateBattleStore;                         // 0x0B70(0x0010)(Edit, ZeroConstructor, EditConst, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	struct FRoundResult                           _LastRoundResult;                                  // 0x0B80(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F36[0x20];                                    // 0x0B88(0x0020)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UUserWidget>                _DEBUG_ShowAimDistanceWidgetClass;                 // 0x0BA8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            _DEBUG_ShowAimDistanceWidget;                      // 0x0BB0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UKillcamPlayback*                       _KillCam;                                          // 0x0BB8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F37[0x10];                                    // 0x0BC0(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class UUI_ActionWheelMenu*                    _ActionWheelMenu;                                  // 0x0BD0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F38[0x20];                                    // 0x0BD8(0x0020)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class UAutoBoosterTrigger*>            _AutoBoosters;                                     // 0x0BF8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class ALevelSequenceActor*                    _Outro_Sequencer;                                  // 0x0C08(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F39[0x160];                                   // 0x0C10(0x0160)(Fixing Size After Last Property [ Dumper-69 ])
	class ULevelSequencePlayer*                   _CutScenePlayer;                                   // 0x0D70(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULevelStreamingDynamic*                 _Level_Outro;                                      // 0x0D78(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F3A[0x8];                                     // 0x0D80(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UUserWidget>                UI_Outro;                                          // 0x0D88(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULevelStreamingDynamic*                 _Level_CharacterPick;                              // 0x0D90(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPOPUP_ChangeMaster*                    _UI_ChangeMaster;                                  // 0x0D98(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ACameraActor>               _PreloadCamera;                                    // 0x0DA0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACameraActor*                           _CachedPreloadCamera;                              // 0x0DA8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UNiagaraComponent*>              _SpawnedPreloadFX;                                 // 0x0DB0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class AActor*                                 _PrevViewTarget;                                   // 0x0DC0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F3B[0x60];                                    // 0x0DC8(0x0060)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             OnPreloadWarmUpComplete;                           // 0x0E28(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F3C[0x8];                                     // 0x0E38(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void AddChatActiveFunctions();
	void AddChatIfCanToggleSight();
	void AddFullScreenWidget(class UWidget* _widget);
	void AddToastAndChatIfCanToggleSight();
	void AddToastIfCanToggleSight();
	void AddToastIfLackControlPower(class AGunBase* _gun);
	void CloseBattleStorePopup();
	class ACharaBase* DEBUG_CreateNewCharacter(ECharaType _type, EGunType _gun_type);
	void DEBUG_PlaceOverlappedLocation();
	void DEBUG_SetShowAimDistance(bool _is_showed);
	struct FBattleStoreHistory GetLastPurchaseHistory(const struct FItemID& _item_id);
	class UTextureRenderTarget2D* GetMinimapRenderTarget();
	const class AActor* GetNextAllySpectator();
	bool IsChangeMasterUIOpened();
	void OnActionWheelCanceled();
	bool OnALL_ChangeActionSetting();
	bool OnALL_Damaged(const struct FDamagedData& _data);
	void OnALL_Respawn(const struct FVector& _loc, const struct FRotator& _Rot);
	bool OnCLIENT_BattleResult(const struct FBattleDecisionDetail& _result);
	void OnCLIENT_ChangeBattlePhase(EBattleModePhase _phase);
	bool OnCLIENT_Hit(const struct FHitData& _hit);
	bool OnCLIENT_ShowResult();
	void OnCloseCharacterPick();
	bool OnKillLog(const struct FKillLog& _log);
	bool OnSERVER_Died(const struct FHitData& _last_hit_data);
	bool OnShowResult();
	void OnShowRoundResult(const struct FRoundResult& _result);
	void OnShowRoundStart(const struct FRoundStartNotify& _notify);
	void PlayKillcam();
	void RemoveFullScreenWidget(class UWidget* _widget);
	void RPC_ALL_DEBUG_Slomo(int32 _slomo);
	void RPC_CLIENT_BattleResult(const struct FBattleDecisionDetail& _result);
	void RPC_CLIENT_ChangeMasterMessage(bool _is_enable_change, ECharaType _change_chara_type);
	void RPC_CLIENT_Command_Stat_Startfile_ACK();
	void RPC_CLIENT_Command_Stat_Stopfile_ACK();
	void RPC_CLIENT_DEBUG_MissionProgress(const struct FItemID& _task_id, const struct FItemID_Mission& _mission_id, int32 _count);
	void RPC_CLIENT_Emoticon(const struct FEmoticonData& _emoticon);
	void RPC_CLIENT_KillerInfo(const class ACharaBase* _killer, const class ACharaBase* _victim);
	void RPC_CLIENT_KillLog(const struct FNetKillLog& _log);
	void RPC_CLIENT_KillStreak(const TArray<EKillStreak>& _streaks);
	void RPC_CLIENT_MissionSuccess(const struct FItemID_Mission& _mission_id);
	void RPC_CLIENT_OnGetIngameMoney(int32 _inc_money, EGoldRewardType _reward_type);
	void RPC_CLIENT_Ping(const struct FPingData& _ping);
	void RPC_CLIENT_RechargeArmor(float _inc_armor_rate);
	void RPC_CLIENT_Refund_Item_ACK(bool _is_success, const struct FBattleStoreHistory& _history);
	void RPC_CLIENT_RequestClearBattleStoreHistory();
	void RPC_CLIENT_RequestPurchase_BattleStore_ACK(bool _is_success, const struct FItemID& _item_id, const struct FBattleStoreHistory& _history);
	void RPC_Client_Revive_Alert(class ACharaBase* _revived_chara, class ACharaBase* _saver_chara);
	void RPC_CLIENT_RoundStart(const struct FRoundStartNotify& _notify);
	void RPC_CLIENT_SendRadioChat(const struct FUserID& _speacker_user_id, const struct FRadioChatID& _radio_chat_id);
	void RPC_CLIENT_StartChangeMaster();
	void RPC_SERVER_ChangeSpectator();
	void RPC_SERVER_Command_Stat_Startfile();
	void RPC_SERVER_Command_Stat_Stopfile();
	void RPC_SERVER_DEBUG_AddAI(const class FString& _nickname, ETeams _Team, ECharaType _chara_type, EArmorType _armor_type, EGunType _gun_type, const struct FAI_Characteristic& _characteristic);
	void RPC_SERVER_DEBUG_Change_Gun();
	void RPC_SERVER_DEBUG_ChangeCharacterType(ECharaType _chara_type);
	void RPC_SERVER_DEBUG_MakeSpectator();
	void RPC_SERVER_DEBUG_Slomo(int32 _slomo);
	void RPC_SERVER_PleaseChangeMaster(ECharaType _new_chara_type);
	void RPC_SERVER_Refund_Item(const struct FBattleStoreHistory& _history);
	void RPC_SERVER_RequestChangeMaster();
	void RPC_SERVER_RequestClearBattleStoreHistory();
	void RPC_SERVER_RequestEmoticon(const struct FEmoticonData& _emoticon);
	void RPC_SERVER_RequestPing(const struct FPingData& _ping);
	void RPC_SERVER_RequestPurchase_BattleStore(const struct FItemID& _item_id, int32 _params);
	void RPC_SERVER_RequestRadioChat(const struct FRadioChatID& _radio_chat_id);
	void RPC_SERVER_RespawnInPlace();
	void RPC_SERVER_ResumeRespawn();
	void RPC_SERVER_SpectateCCTV(int32 _idx);
	void RPC_SERVER_SpectatePlayer(ETeams _Team, int32 _idx);
	void RPC_SERVER_UpdatePlayerFPS(uint8 _fps);
	bool SetInteractionProgressBar(bool _visible, float _duration);
	void ShowHelpUI(bool _show);
	void ShowHUD(bool _is_visible, class UObject* _caller);
	void ShowMissionArea(const class FString& _area_name, bool _show);
	void ShowTabUI(bool _show);
	void StopKillcam();

	float CLIENT_GetDeviationAngle(float _deviation) const;
	bool DEBUG_GetShowAimDistance() const;
	class ACharaBase* GetChara() const;
	ECharaType GetCharacterType() const;
	class ACharaBase* GetCurrentTargetChara() const;
	const struct FRoundResult GetLastRoundResult() const;
	void GetLookAtRay(float _distance, struct FVector* _start, struct FVector* _end) const;
	float GetRadioChatCooltime() const;
	int32 GetRadioChatStock() const;
	bool IsBattleStoreOpened() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattlePlayerControllerBase">();
	}
	static class ABattlePlayerControllerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattlePlayerControllerBase>();
	}
};
static_assert(alignof(ABattlePlayerControllerBase) == 0x000008, "Wrong alignment on ABattlePlayerControllerBase");
static_assert(sizeof(ABattlePlayerControllerBase) == 0x000E40, "Wrong size on ABattlePlayerControllerBase");
static_assert(offsetof(ABattlePlayerControllerBase, HUD_Type) == 0x0009B8, "Member 'ABattlePlayerControllerBase::HUD_Type' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, ResultUI_Type) == 0x0009C0, "Member 'ABattlePlayerControllerBase::ResultUI_Type' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, TabUI_Type) == 0x0009C8, "Member 'ABattlePlayerControllerBase::TabUI_Type' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, RoundResultUI_Type) == 0x0009D0, "Member 'ABattlePlayerControllerBase::RoundResultUI_Type' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, UI_HUD) == 0x0009D8, "Member 'ABattlePlayerControllerBase::UI_HUD' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, UI_Result) == 0x0009E0, "Member 'ABattlePlayerControllerBase::UI_Result' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, UI_RoundResult) == 0x0009E8, "Member 'ABattlePlayerControllerBase::UI_RoundResult' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, UI_Tab) == 0x0009F0, "Member 'ABattlePlayerControllerBase::UI_Tab' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, UI_Help) == 0x0009F8, "Member 'ABattlePlayerControllerBase::UI_Help' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, UI_WaitingRoom_InGame) == 0x000A00, "Member 'ABattlePlayerControllerBase::UI_WaitingRoom_InGame' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, HelpUI_Type) == 0x000A08, "Member 'ABattlePlayerControllerBase::HelpUI_Type' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, WaitingRoomUI_Type) == 0x000A10, "Member 'ABattlePlayerControllerBase::WaitingRoomUI_Type' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, CharacterPickInGameMapFile) == 0x000A18, "Member 'ABattlePlayerControllerBase::CharacterPickInGameMapFile' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, Shake_Strong) == 0x000A40, "Member 'ABattlePlayerControllerBase::Shake_Strong' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, Shake_Weak) == 0x000A48, "Member 'ABattlePlayerControllerBase::Shake_Weak' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, Shake_OnFire) == 0x000A50, "Member 'ABattlePlayerControllerBase::Shake_OnFire' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, UICheatType) == 0x000A58, "Member 'ABattlePlayerControllerBase::UICheatType' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, UI_Cheat) == 0x000A60, "Member 'ABattlePlayerControllerBase::UI_Cheat' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, _UserOption) == 0x000A68, "Member 'ABattlePlayerControllerBase::_UserOption' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, _MinimapWidget) == 0x000A70, "Member 'ABattlePlayerControllerBase::_MinimapWidget' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, _WidgetsToAddToHUD) == 0x000A80, "Member 'ABattlePlayerControllerBase::_WidgetsToAddToHUD' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, DominantPopupUIOption) == 0x000A90, "Member 'ABattlePlayerControllerBase::DominantPopupUIOption' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, _UIBoundChara) == 0x000AA0, "Member 'ABattlePlayerControllerBase::_UIBoundChara' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, _IsBattleStoreEnabled) == 0x000AA9, "Member 'ABattlePlayerControllerBase::_IsBattleStoreEnabled' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, _CanOpenBattleStore) == 0x000AAA, "Member 'ABattlePlayerControllerBase::_CanOpenBattleStore' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, _BattleStoreTabs) == 0x000AB0, "Member 'ABattlePlayerControllerBase::_BattleStoreTabs' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, _BattleStoreUI_Type) == 0x000B00, "Member 'ABattlePlayerControllerBase::_BattleStoreUI_Type' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, _BattleStoreUI) == 0x000B08, "Member 'ABattlePlayerControllerBase::_BattleStoreUI' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, _BattleStoreHistoryRecorder) == 0x000B10, "Member 'ABattlePlayerControllerBase::_BattleStoreHistoryRecorder' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, Event_OnUpdateBattleStore) == 0x000B70, "Member 'ABattlePlayerControllerBase::Event_OnUpdateBattleStore' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, _LastRoundResult) == 0x000B80, "Member 'ABattlePlayerControllerBase::_LastRoundResult' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, _DEBUG_ShowAimDistanceWidgetClass) == 0x000BA8, "Member 'ABattlePlayerControllerBase::_DEBUG_ShowAimDistanceWidgetClass' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, _DEBUG_ShowAimDistanceWidget) == 0x000BB0, "Member 'ABattlePlayerControllerBase::_DEBUG_ShowAimDistanceWidget' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, _KillCam) == 0x000BB8, "Member 'ABattlePlayerControllerBase::_KillCam' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, _ActionWheelMenu) == 0x000BD0, "Member 'ABattlePlayerControllerBase::_ActionWheelMenu' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, _AutoBoosters) == 0x000BF8, "Member 'ABattlePlayerControllerBase::_AutoBoosters' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, _Outro_Sequencer) == 0x000C08, "Member 'ABattlePlayerControllerBase::_Outro_Sequencer' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, _CutScenePlayer) == 0x000D70, "Member 'ABattlePlayerControllerBase::_CutScenePlayer' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, _Level_Outro) == 0x000D78, "Member 'ABattlePlayerControllerBase::_Level_Outro' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, UI_Outro) == 0x000D88, "Member 'ABattlePlayerControllerBase::UI_Outro' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, _Level_CharacterPick) == 0x000D90, "Member 'ABattlePlayerControllerBase::_Level_CharacterPick' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, _UI_ChangeMaster) == 0x000D98, "Member 'ABattlePlayerControllerBase::_UI_ChangeMaster' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, _PreloadCamera) == 0x000DA0, "Member 'ABattlePlayerControllerBase::_PreloadCamera' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, _CachedPreloadCamera) == 0x000DA8, "Member 'ABattlePlayerControllerBase::_CachedPreloadCamera' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, _SpawnedPreloadFX) == 0x000DB0, "Member 'ABattlePlayerControllerBase::_SpawnedPreloadFX' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, _PrevViewTarget) == 0x000DC0, "Member 'ABattlePlayerControllerBase::_PrevViewTarget' has a wrong offset!");
static_assert(offsetof(ABattlePlayerControllerBase, OnPreloadWarmUpComplete) == 0x000E28, "Member 'ABattlePlayerControllerBase::OnPreloadWarmUpComplete' has a wrong offset!");

// Class Stigma.TrainingRoomPlayerController
// 0x0190 (0x0FD0 - 0x0E40)
class ATrainingRoomPlayerController : public ABattlePlayerControllerBase
{
public:
	struct FHitResult                             _PointingTarget;                                   // 0x0E40(0x00E8)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F4E[0xA8];                                    // 0x0F28(0x00A8)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnMatchChanged();
	bool OnPointingActor(class AActor* _Actor);
	void OpenBattleStore_ChangeGunPopup();
	void RPC_CLIENT_ResetStockAndCooltime();
	void RPC_SERVER_ResetStockAndCooltime();

	class AActor* GetPointingTargetActor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrainingRoomPlayerController">();
	}
	static class ATrainingRoomPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrainingRoomPlayerController>();
	}
};
static_assert(alignof(ATrainingRoomPlayerController) == 0x000008, "Wrong alignment on ATrainingRoomPlayerController");
static_assert(sizeof(ATrainingRoomPlayerController) == 0x000FD0, "Wrong size on ATrainingRoomPlayerController");
static_assert(offsetof(ATrainingRoomPlayerController, _PointingTarget) == 0x000E40, "Member 'ATrainingRoomPlayerController::_PointingTarget' has a wrong offset!");

// Class Stigma.AbnormalsBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UAbnormalsBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool IsNone(const struct FAbnormals& _Flags);
	static bool IsSet(const struct FAbnormals& _Flags, EAbnormal _abnormal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbnormalsBlueprintLibrary">();
	}
	static class UAbnormalsBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbnormalsBlueprintLibrary>();
	}
};
static_assert(alignof(UAbnormalsBlueprintLibrary) == 0x000008, "Wrong alignment on UAbnormalsBlueprintLibrary");
static_assert(sizeof(UAbnormalsBlueprintLibrary) == 0x000028, "Wrong size on UAbnormalsBlueprintLibrary");

// Class Stigma.AISpawnVolume
// 0x0010 (0x02A8 - 0x0298)
class AAISpawnVolume final : public AActor
{
public:
	TArray<class AAIRoamingPointVolume*>          RoamingPointVolumeArray;                           // 0x0298(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	struct FVector GetRandomLocationInVolume() const;
	struct FVector GetRandomRoamingPoint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISpawnVolume">();
	}
	static class AAISpawnVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAISpawnVolume>();
	}
};
static_assert(alignof(AAISpawnVolume) == 0x000008, "Wrong alignment on AAISpawnVolume");
static_assert(sizeof(AAISpawnVolume) == 0x0002A8, "Wrong size on AAISpawnVolume");
static_assert(offsetof(AAISpawnVolume, RoamingPointVolumeArray) == 0x000298, "Member 'AAISpawnVolume::RoamingPointVolumeArray' has a wrong offset!");

// Class Stigma.ActionGraphNode_Specter
// 0x0040 (0x0260 - 0x0220)
class UActionGraphNode_Specter : public UActionGraphNode_Anim
{
public:
	bool                                          SyncStartTimeWithMate;                             // 0x0220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMotionSource                                 MotionSource;                                      // 0x0221(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AimOffset;                                         // 0x0222(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMoveMode                                     StartMoveMode;                                     // 0x0223(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsStopAllMontage;                                  // 0x0224(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsLockTransformExceptRootMotion;                   // 0x0225(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F50[0x2];                                     // 0x0226(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         AngleLimit;                                        // 0x0228(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanPlayPassiveEvenIfLie;                           // 0x022C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F51[0x33];                                    // 0x022D(0x0033)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionGraphNode_Specter">();
	}
	static class UActionGraphNode_Specter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionGraphNode_Specter>();
	}
};
static_assert(alignof(UActionGraphNode_Specter) == 0x000010, "Wrong alignment on UActionGraphNode_Specter");
static_assert(sizeof(UActionGraphNode_Specter) == 0x000260, "Wrong size on UActionGraphNode_Specter");
static_assert(offsetof(UActionGraphNode_Specter, SyncStartTimeWithMate) == 0x000220, "Member 'UActionGraphNode_Specter::SyncStartTimeWithMate' has a wrong offset!");
static_assert(offsetof(UActionGraphNode_Specter, MotionSource) == 0x000221, "Member 'UActionGraphNode_Specter::MotionSource' has a wrong offset!");
static_assert(offsetof(UActionGraphNode_Specter, AimOffset) == 0x000222, "Member 'UActionGraphNode_Specter::AimOffset' has a wrong offset!");
static_assert(offsetof(UActionGraphNode_Specter, StartMoveMode) == 0x000223, "Member 'UActionGraphNode_Specter::StartMoveMode' has a wrong offset!");
static_assert(offsetof(UActionGraphNode_Specter, IsStopAllMontage) == 0x000224, "Member 'UActionGraphNode_Specter::IsStopAllMontage' has a wrong offset!");
static_assert(offsetof(UActionGraphNode_Specter, IsLockTransformExceptRootMotion) == 0x000225, "Member 'UActionGraphNode_Specter::IsLockTransformExceptRootMotion' has a wrong offset!");
static_assert(offsetof(UActionGraphNode_Specter, AngleLimit) == 0x000228, "Member 'UActionGraphNode_Specter::AngleLimit' has a wrong offset!");
static_assert(offsetof(UActionGraphNode_Specter, CanPlayPassiveEvenIfLie) == 0x00022C, "Member 'UActionGraphNode_Specter::CanPlayPassiveEvenIfLie' has a wrong offset!");

// Class Stigma.ActionGraphNode_RandomAnim
// 0x0020 (0x0280 - 0x0260)
class UActionGraphNode_RandomAnim final : public UActionGraphNode_Specter
{
public:
	TArray<class UAnimSequenceBase*>              _AdditionalRandomAnims;                            // 0x0260(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UAnimSequenceBase*>              _Anims;                                            // 0x0270(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionGraphNode_RandomAnim">();
	}
	static class UActionGraphNode_RandomAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionGraphNode_RandomAnim>();
	}
};
static_assert(alignof(UActionGraphNode_RandomAnim) == 0x000010, "Wrong alignment on UActionGraphNode_RandomAnim");
static_assert(sizeof(UActionGraphNode_RandomAnim) == 0x000280, "Wrong size on UActionGraphNode_RandomAnim");
static_assert(offsetof(UActionGraphNode_RandomAnim, _AdditionalRandomAnims) == 0x000260, "Member 'UActionGraphNode_RandomAnim::_AdditionalRandomAnims' has a wrong offset!");
static_assert(offsetof(UActionGraphNode_RandomAnim, _Anims) == 0x000270, "Member 'UActionGraphNode_RandomAnim::_Anims' has a wrong offset!");

// Class Stigma.FocusDriver
// 0x0008 (0x0030 - 0x0028)
class UFocusDriver : public UObject
{
public:
	class AAdvancedAIController*                  _controller;                                       // 0x0028(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FocusDriver">();
	}
	static class UFocusDriver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFocusDriver>();
	}
};
static_assert(alignof(UFocusDriver) == 0x000008, "Wrong alignment on UFocusDriver");
static_assert(sizeof(UFocusDriver) == 0x000030, "Wrong size on UFocusDriver");
static_assert(offsetof(UFocusDriver, _controller) == 0x000028, "Member 'UFocusDriver::_controller' has a wrong offset!");

// Class Stigma.FocusDriver_Forward
// 0x0050 (0x0080 - 0x0030)
class UFocusDriver_Forward final : public UFocusDriver
{
public:
	struct FFocusInterp_FitInRange_Setting        _ViewSetting;                                      // 0x0030(0x0014)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F52[0x3C];                                    // 0x0044(0x003C)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FocusDriver_Forward">();
	}
	static class UFocusDriver_Forward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFocusDriver_Forward>();
	}
};
static_assert(alignof(UFocusDriver_Forward) == 0x000008, "Wrong alignment on UFocusDriver_Forward");
static_assert(sizeof(UFocusDriver_Forward) == 0x000080, "Wrong size on UFocusDriver_Forward");
static_assert(offsetof(UFocusDriver_Forward, _ViewSetting) == 0x000030, "Member 'UFocusDriver_Forward::_ViewSetting' has a wrong offset!");

// Class Stigma.BT_V3_BuyBuff
// 0x0058 (0x00C8 - 0x0070)
class UBT_V3_BuyBuff final : public UBTTaskNode
{
public:
	EBTNodeResult                                 Result;                                            // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F53[0x7];                                     // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TSet<struct FItemIDRef_Buff>                  Buffs;                                             // 0x0078(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BT_V3_BuyBuff">();
	}
	static class UBT_V3_BuyBuff* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBT_V3_BuyBuff>();
	}
};
static_assert(alignof(UBT_V3_BuyBuff) == 0x000008, "Wrong alignment on UBT_V3_BuyBuff");
static_assert(sizeof(UBT_V3_BuyBuff) == 0x0000C8, "Wrong size on UBT_V3_BuyBuff");
static_assert(offsetof(UBT_V3_BuyBuff, Result) == 0x000070, "Member 'UBT_V3_BuyBuff::Result' has a wrong offset!");
static_assert(offsetof(UBT_V3_BuyBuff, Buffs) == 0x000078, "Member 'UBT_V3_BuyBuff::Buffs' has a wrong offset!");

// Class Stigma.ActionNotify
// 0x0010 (0x0040 - 0x0030)
class UActionNotify final : public UAnimNotifyState
{
public:
	EMoveMode                                     MoveMode;                                          // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F54[0x3];                                     // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         RotationYawRate;                                   // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECameraWalkMode                               CameraWalk;                                        // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESideViewSide                                 CameraWalkSide;                                    // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F55[0x6];                                     // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActionNotify">();
	}
	static class UActionNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActionNotify>();
	}
};
static_assert(alignof(UActionNotify) == 0x000008, "Wrong alignment on UActionNotify");
static_assert(sizeof(UActionNotify) == 0x000040, "Wrong size on UActionNotify");
static_assert(offsetof(UActionNotify, MoveMode) == 0x000030, "Member 'UActionNotify::MoveMode' has a wrong offset!");
static_assert(offsetof(UActionNotify, RotationYawRate) == 0x000034, "Member 'UActionNotify::RotationYawRate' has a wrong offset!");
static_assert(offsetof(UActionNotify, CameraWalk) == 0x000038, "Member 'UActionNotify::CameraWalk' has a wrong offset!");
static_assert(offsetof(UActionNotify, CameraWalkSide) == 0x000039, "Member 'UActionNotify::CameraWalkSide' has a wrong offset!");

// Class Stigma.UI_BattlePassLevelUpPopup
// 0x0000 (0x0570 - 0x0570)
class UUI_BattlePassLevelUpPopup : public UPopupBase
{
public:
	void InitWidget(const class FText& _Title, int32 _level);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_BattlePassLevelUpPopup">();
	}
	static class UUI_BattlePassLevelUpPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_BattlePassLevelUpPopup>();
	}
};
static_assert(alignof(UUI_BattlePassLevelUpPopup) == 0x000008, "Wrong alignment on UUI_BattlePassLevelUpPopup");
static_assert(sizeof(UUI_BattlePassLevelUpPopup) == 0x000570, "Wrong size on UUI_BattlePassLevelUpPopup");

// Class Stigma.StigmaAIControllerBase
// 0x0020 (0x03E0 - 0x03C0)
class AStigmaAIControllerBase : public AAIController
{
public:
	uint8                                         Pad_1F57[0x20];                                    // 0x03C0(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool OnSERVER_Died(const struct FHitData& _last_hit_data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StigmaAIControllerBase">();
	}
	static class AStigmaAIControllerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStigmaAIControllerBase>();
	}
};
static_assert(alignof(AStigmaAIControllerBase) == 0x000008, "Wrong alignment on AStigmaAIControllerBase");
static_assert(sizeof(AStigmaAIControllerBase) == 0x0003E0, "Wrong size on AStigmaAIControllerBase");

// Class Stigma.AutoBoosterTrigger
// 0x0188 (0x01B0 - 0x0028)
class UAutoBoosterTrigger : public UObject
{
public:
	uint8                                         Pad_1F59[0x188];                                   // 0x0028(0x0188)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoBoosterTrigger">();
	}
	static class UAutoBoosterTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutoBoosterTrigger>();
	}
};
static_assert(alignof(UAutoBoosterTrigger) == 0x000008, "Wrong alignment on UAutoBoosterTrigger");
static_assert(sizeof(UAutoBoosterTrigger) == 0x0001B0, "Wrong size on UAutoBoosterTrigger");

// Class Stigma.AutoBooster_AntiStun
// 0x0000 (0x01B0 - 0x01B0)
class UAutoBooster_AntiStun final : public UAutoBoosterTrigger
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoBooster_AntiStun">();
	}
	static class UAutoBooster_AntiStun* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutoBooster_AntiStun>();
	}
};
static_assert(alignof(UAutoBooster_AntiStun) == 0x000008, "Wrong alignment on UAutoBooster_AntiStun");
static_assert(sizeof(UAutoBooster_AntiStun) == 0x0001B0, "Wrong size on UAutoBooster_AntiStun");

// Class Stigma.AdvancedAIController
// 0x02F8 (0x06D8 - 0x03E0)
class AAdvancedAIController : public AStigmaAIControllerBase
{
public:
	float                                         TimeToLostSight;                                   // 0x03E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimeToForget;                                      // 0x03E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EAI_Tactics, struct FAI_Patterns>        _TacticalPatterns;                                 // 0x03E8(0x0050)(Edit, BlueprintVisible, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class ACharaBase*                             _TargetEnemy;                                      // 0x0438(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharaBase*                             _TargetAlly;                                       // 0x0440(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F5A[0x48];                                    // 0x0448(0x0048)(Fixing Size After Last Property [ Dumper-69 ])
	TMap<class AActor*, struct FRecognizedActor>  _RecognizedActors;                                 // 0x0490(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F5B[0x18];                                    // 0x04E0(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	TMap<EAIFocusMode, struct FFocusDrivers>      _FocusDrivers;                                     // 0x04F8(0x0050)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UFocusDriver*                           _FocusDriver;                                      // 0x0548(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F5C[0x18];                                    // 0x0550(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	struct FGlobalAISetting                       _GlobalConfig;                                     // 0x0568(0x0044)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F5D[0x5C];                                    // 0x05AC(0x005C)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class AAIRoamingPointVolume*>          _Waypoints;                                        // 0x0608(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F5E[0xC0];                                    // 0x0618(0x00C0)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static struct FAI_Characteristic MakeCharacteristic(int32 _elo, float _coward, float _shooting_oriented);

	void BoostTargetEnemy(class ACharaBase* _enemy);
	void OnTargetPerceptionForgotten(class AActor* _target);
	void OnTargetPerceptionUpdated(class AActor* _target, const struct FAIStimulus& _stimulus);
	void Setup(EAIRole _role, int32 _elo, float _coward, float _shooting_oriented);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AdvancedAIController">();
	}
	static class AAdvancedAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAdvancedAIController>();
	}
};
static_assert(alignof(AAdvancedAIController) == 0x000008, "Wrong alignment on AAdvancedAIController");
static_assert(sizeof(AAdvancedAIController) == 0x0006D8, "Wrong size on AAdvancedAIController");
static_assert(offsetof(AAdvancedAIController, TimeToLostSight) == 0x0003E0, "Member 'AAdvancedAIController::TimeToLostSight' has a wrong offset!");
static_assert(offsetof(AAdvancedAIController, TimeToForget) == 0x0003E4, "Member 'AAdvancedAIController::TimeToForget' has a wrong offset!");
static_assert(offsetof(AAdvancedAIController, _TacticalPatterns) == 0x0003E8, "Member 'AAdvancedAIController::_TacticalPatterns' has a wrong offset!");
static_assert(offsetof(AAdvancedAIController, _TargetEnemy) == 0x000438, "Member 'AAdvancedAIController::_TargetEnemy' has a wrong offset!");
static_assert(offsetof(AAdvancedAIController, _TargetAlly) == 0x000440, "Member 'AAdvancedAIController::_TargetAlly' has a wrong offset!");
static_assert(offsetof(AAdvancedAIController, _RecognizedActors) == 0x000490, "Member 'AAdvancedAIController::_RecognizedActors' has a wrong offset!");
static_assert(offsetof(AAdvancedAIController, _FocusDrivers) == 0x0004F8, "Member 'AAdvancedAIController::_FocusDrivers' has a wrong offset!");
static_assert(offsetof(AAdvancedAIController, _FocusDriver) == 0x000548, "Member 'AAdvancedAIController::_FocusDriver' has a wrong offset!");
static_assert(offsetof(AAdvancedAIController, _GlobalConfig) == 0x000568, "Member 'AAdvancedAIController::_GlobalConfig' has a wrong offset!");
static_assert(offsetof(AAdvancedAIController, _Waypoints) == 0x000608, "Member 'AAdvancedAIController::_Waypoints' has a wrong offset!");

// Class Stigma.AdvancedBlueprintMapLibrary
// 0x0000 (0x0028 - 0x0028)
class UAdvancedBlueprintMapLibrary final : public UBlueprintMapLibrary
{
public:
	static void Map_KeyValue(const TMap<int32, int32>& _target_map, const int32 _index, int32* _out_Key, int32* _out_value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AdvancedBlueprintMapLibrary">();
	}
	static class UAdvancedBlueprintMapLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAdvancedBlueprintMapLibrary>();
	}
};
static_assert(alignof(UAdvancedBlueprintMapLibrary) == 0x000008, "Wrong alignment on UAdvancedBlueprintMapLibrary");
static_assert(sizeof(UAdvancedBlueprintMapLibrary) == 0x000028, "Wrong size on UAdvancedBlueprintMapLibrary");

// Class Stigma.BT_V3_DrawDebugShape
// 0x0040 (0x00B0 - 0x0070)
class UBT_V3_DrawDebugShape final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 BlackboardKey;                                     // 0x0070(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 Color;                                             // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Lifetime;                                          // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBTNodeResult                                 Result;                                            // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F61[0x7];                                     // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BT_V3_DrawDebugShape">();
	}
	static class UBT_V3_DrawDebugShape* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBT_V3_DrawDebugShape>();
	}
};
static_assert(alignof(UBT_V3_DrawDebugShape) == 0x000008, "Wrong alignment on UBT_V3_DrawDebugShape");
static_assert(sizeof(UBT_V3_DrawDebugShape) == 0x0000B0, "Wrong size on UBT_V3_DrawDebugShape");
static_assert(offsetof(UBT_V3_DrawDebugShape, BlackboardKey) == 0x000070, "Member 'UBT_V3_DrawDebugShape::BlackboardKey' has a wrong offset!");
static_assert(offsetof(UBT_V3_DrawDebugShape, Radius) == 0x000098, "Member 'UBT_V3_DrawDebugShape::Radius' has a wrong offset!");
static_assert(offsetof(UBT_V3_DrawDebugShape, Thickness) == 0x00009C, "Member 'UBT_V3_DrawDebugShape::Thickness' has a wrong offset!");
static_assert(offsetof(UBT_V3_DrawDebugShape, Color) == 0x0000A0, "Member 'UBT_V3_DrawDebugShape::Color' has a wrong offset!");
static_assert(offsetof(UBT_V3_DrawDebugShape, Lifetime) == 0x0000A4, "Member 'UBT_V3_DrawDebugShape::Lifetime' has a wrong offset!");
static_assert(offsetof(UBT_V3_DrawDebugShape, Result) == 0x0000A8, "Member 'UBT_V3_DrawDebugShape::Result' has a wrong offset!");

// Class Stigma.AfterImageComponent
// 0x0010 (0x00B0 - 0x00A0)
class UAfterImageComponent final : public UActorComponent
{
public:
	TArray<struct FAfterImageData>                _AfterImages;                                      // 0x00A0(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AfterImageComponent">();
	}
	static class UAfterImageComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAfterImageComponent>();
	}
};
static_assert(alignof(UAfterImageComponent) == 0x000008, "Wrong alignment on UAfterImageComponent");
static_assert(sizeof(UAfterImageComponent) == 0x0000B0, "Wrong size on UAfterImageComponent");
static_assert(offsetof(UAfterImageComponent, _AfterImages) == 0x0000A0, "Member 'UAfterImageComponent::_AfterImages' has a wrong offset!");

// Class Stigma.UI_CompetitionRewardPopup
// 0x0000 (0x0570 - 0x0570)
class UUI_CompetitionRewardPopup : public UPopupBase
{
public:
	void SetValue(const struct FBC_CompetitionEnd& _packet);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_CompetitionRewardPopup">();
	}
	static class UUI_CompetitionRewardPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_CompetitionRewardPopup>();
	}
};
static_assert(alignof(UUI_CompetitionRewardPopup) == 0x000008, "Wrong alignment on UUI_CompetitionRewardPopup");
static_assert(sizeof(UUI_CompetitionRewardPopup) == 0x000570, "Wrong size on UUI_CompetitionRewardPopup");

// Class Stigma.AGC_BulletCount
// 0x0008 (0x0038 - 0x0030)
class UAGC_BulletCount final : public UActionGraphCondition
{
public:
	int32                                         _value;                                            // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECompare                                      _CompareFunc;                                      // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsMainGun;                                         // 0x0035(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsSubGun;                                          // 0x0036(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IncludeMagazine;                                  // 0x0037(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGC_BulletCount">();
	}
	static class UAGC_BulletCount* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGC_BulletCount>();
	}
};
static_assert(alignof(UAGC_BulletCount) == 0x000008, "Wrong alignment on UAGC_BulletCount");
static_assert(sizeof(UAGC_BulletCount) == 0x000038, "Wrong size on UAGC_BulletCount");
static_assert(offsetof(UAGC_BulletCount, _value) == 0x000030, "Member 'UAGC_BulletCount::_value' has a wrong offset!");
static_assert(offsetof(UAGC_BulletCount, _CompareFunc) == 0x000034, "Member 'UAGC_BulletCount::_CompareFunc' has a wrong offset!");
static_assert(offsetof(UAGC_BulletCount, IsMainGun) == 0x000035, "Member 'UAGC_BulletCount::IsMainGun' has a wrong offset!");
static_assert(offsetof(UAGC_BulletCount, IsSubGun) == 0x000036, "Member 'UAGC_BulletCount::IsSubGun' has a wrong offset!");
static_assert(offsetof(UAGC_BulletCount, _IncludeMagazine) == 0x000037, "Member 'UAGC_BulletCount::_IncludeMagazine' has a wrong offset!");

// Class Stigma.AGC_Common
// 0x0008 (0x0038 - 0x0030)
class UAGC_Common final : public UActionGraphCondition
{
public:
	bool                                          IsAlive;                                           // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CanOnStanding;                                     // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CanOnCrouching;                                    // 0x0032(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CanOnAiming;                                       // 0x0033(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CanOnLyingDown;                                    // 0x0034(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CanOnLegInjury;                                    // 0x0035(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          HasMate;                                           // 0x0036(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F62[0x1];                                     // 0x0037(0x0001)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGC_Common">();
	}
	static class UAGC_Common* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGC_Common>();
	}
};
static_assert(alignof(UAGC_Common) == 0x000008, "Wrong alignment on UAGC_Common");
static_assert(sizeof(UAGC_Common) == 0x000038, "Wrong size on UAGC_Common");
static_assert(offsetof(UAGC_Common, IsAlive) == 0x000030, "Member 'UAGC_Common::IsAlive' has a wrong offset!");
static_assert(offsetof(UAGC_Common, CanOnStanding) == 0x000031, "Member 'UAGC_Common::CanOnStanding' has a wrong offset!");
static_assert(offsetof(UAGC_Common, CanOnCrouching) == 0x000032, "Member 'UAGC_Common::CanOnCrouching' has a wrong offset!");
static_assert(offsetof(UAGC_Common, CanOnAiming) == 0x000033, "Member 'UAGC_Common::CanOnAiming' has a wrong offset!");
static_assert(offsetof(UAGC_Common, CanOnLyingDown) == 0x000034, "Member 'UAGC_Common::CanOnLyingDown' has a wrong offset!");
static_assert(offsetof(UAGC_Common, CanOnLegInjury) == 0x000035, "Member 'UAGC_Common::CanOnLegInjury' has a wrong offset!");
static_assert(offsetof(UAGC_Common, HasMate) == 0x000036, "Member 'UAGC_Common::HasMate' has a wrong offset!");

// Class Stigma.FocusDriver_FocalPoint
// 0x0050 (0x0080 - 0x0030)
class UFocusDriver_FocalPoint final : public UFocusDriver
{
public:
	struct FFocusInterp_FitInRange_Setting        _ViewSetting;                                      // 0x0030(0x0014)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F63[0x3C];                                    // 0x0044(0x003C)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FocusDriver_FocalPoint">();
	}
	static class UFocusDriver_FocalPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFocusDriver_FocalPoint>();
	}
};
static_assert(alignof(UFocusDriver_FocalPoint) == 0x000008, "Wrong alignment on UFocusDriver_FocalPoint");
static_assert(sizeof(UFocusDriver_FocalPoint) == 0x000080, "Wrong size on UFocusDriver_FocalPoint");
static_assert(offsetof(UFocusDriver_FocalPoint, _ViewSetting) == 0x000030, "Member 'UFocusDriver_FocalPoint::_ViewSetting' has a wrong offset!");

// Class Stigma.BT_V3_CustomFocusNode
// 0x0000 (0x0070 - 0x0070)
class UBT_V3_CustomFocusNode : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BT_V3_CustomFocusNode">();
	}
	static class UBT_V3_CustomFocusNode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBT_V3_CustomFocusNode>();
	}
};
static_assert(alignof(UBT_V3_CustomFocusNode) == 0x000008, "Wrong alignment on UBT_V3_CustomFocusNode");
static_assert(sizeof(UBT_V3_CustomFocusNode) == 0x000070, "Wrong size on UBT_V3_CustomFocusNode");

// Class Stigma.AGC_Delay
// 0x0008 (0x0038 - 0x0030)
class UAGC_Delay final : public UActionGraphCondition
{
public:
	float                                         _DelayTime;                                        // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F64[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGC_Delay">();
	}
	static class UAGC_Delay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGC_Delay>();
	}
};
static_assert(alignof(UAGC_Delay) == 0x000008, "Wrong alignment on UAGC_Delay");
static_assert(sizeof(UAGC_Delay) == 0x000038, "Wrong size on UAGC_Delay");
static_assert(offsetof(UAGC_Delay, _DelayTime) == 0x000030, "Member 'UAGC_Delay::_DelayTime' has a wrong offset!");

// Class Stigma.GameContext
// 0x0458 (0x0488 - 0x0030)
class UGameContext final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_1F65[0x3C8];                                   // 0x0030(0x03C8)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class UTeamContext*>                   _Teams;                                            // 0x03F8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<struct FUserID, class UPlayerContext*>   _Players;                                          // 0x0408(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F66[0x8];                                     // 0x0458(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class UPlayerContext*>                 ArchivedPlayers;                                   // 0x0460(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F67[0x18];                                    // 0x0470(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	int32 GetEmptyPlayerCount() const;
	int32 GetMaxPlayerCount() const;
	int32 GetMaxTeamCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameContext">();
	}
	static class UGameContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameContext>();
	}
};
static_assert(alignof(UGameContext) == 0x000008, "Wrong alignment on UGameContext");
static_assert(sizeof(UGameContext) == 0x000488, "Wrong size on UGameContext");
static_assert(offsetof(UGameContext, _Teams) == 0x0003F8, "Member 'UGameContext::_Teams' has a wrong offset!");
static_assert(offsetof(UGameContext, _Players) == 0x000408, "Member 'UGameContext::_Players' has a wrong offset!");
static_assert(offsetof(UGameContext, ArchivedPlayers) == 0x000460, "Member 'UGameContext::ArchivedPlayers' has a wrong offset!");

// Class Stigma.NetSyncBase
// 0x00A0 (0x0338 - 0x0298)
class ANetSyncBase : public AActor
{
public:
	float                                         UpdateInterval;                                    // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F68[0x4];                                     // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UPrimitiveComponent*                    _TransformSourceComponent;                         // 0x02A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F69[0x90];                                    // 0x02A8(0x0090)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void FinishSync();
	void RPC_ALL_SyncTx(const struct FSyncTransform& Tx);
	void RPC_SERVER_SyncTx(const struct FSyncTransform& Tx);
	void StartToSync(class UPrimitiveComponent* Source, const struct FVector& Initial_velocity, bool As_author);
	void UpdateSyncRole();

	bool IsAuthor() const;
	bool IsSyncing() const;
	bool IsSyncingAndValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetSyncBase">();
	}
	static class ANetSyncBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANetSyncBase>();
	}
};
static_assert(alignof(ANetSyncBase) == 0x000008, "Wrong alignment on ANetSyncBase");
static_assert(sizeof(ANetSyncBase) == 0x000338, "Wrong size on ANetSyncBase");
static_assert(offsetof(ANetSyncBase, UpdateInterval) == 0x000298, "Member 'ANetSyncBase::UpdateInterval' has a wrong offset!");
static_assert(offsetof(ANetSyncBase, _TransformSourceComponent) == 0x0002A0, "Member 'ANetSyncBase::_TransformSourceComponent' has a wrong offset!");

// Class Stigma.ObjectBase
// 0x0258 (0x0590 - 0x0338)
#pragma pack(push, 0x1)
class alignas(0x10) AObjectBase : public ANetSyncBase
{
public:
	uint8                                         Pad_1F6B[0x69];                                    // 0x0338(0x0069)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          ShouldTickEvenInPlaced;                            // 0x03A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F6C[0x2];                                     // 0x03A2(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	class FName                                   _OverrideClassName;                                // 0x03A4(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F6D[0x45];                                    // 0x03AC(0x0045)(Fixing Size After Last Property [ Dumper-69 ])
	EObjectState                                  State;                                             // 0x03F1(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F6E[0xAE];                                    // 0x03F2(0x00AE)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         _Durability;                                       // 0x04A0(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EObjectLife                                   _Life;                                             // 0x04A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F6F[0x3];                                     // 0x04A5(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class UMaterialInstanceDynamic*               _DissolveMaterial;                                 // 0x04A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DisappearDuration;                                 // 0x04B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F70[0xC];                                     // 0x04B4(0x000C)(Fixing Size After Last Property [ Dumper-69 ])
	class UMeshComponent*                         _Mesh;                                             // 0x04C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F71[0x98];                                    // 0x04C8(0x0098)(Fixing Size After Last Property [ Dumper-69 ])
	class FName                                   _PropAttachmentSocketName;                         // 0x0560(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F72[0x8];                                     // 0x0568(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UNiagaraSystem*                         TrailFXTemplate;                                   // 0x0570(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      ThrowTrailFX;                                      // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F73[0x8];                                     // 0x0580(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void EndThrowTrail();
	void NotifyAttachmentChanged();
	void OnAttachmentReplicated();
	bool OnChangeDurability(float _new_durability);
	bool OnChangeLife(EObjectLife _new_life);
	void OnRep_Durability(float _old_durability);
	void OnRep_State(EObjectState _old_state);
	void SetObjectState(EObjectState _state);
	void Setter_Durability(float _new_durability);
	void Setter_State(EObjectState _state);
	void StartThrowTrail();

	class FText GetDisplayNameText() const;
	bool IsPossessed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectBase">();
	}
	static class AObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AObjectBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(AObjectBase) == 0x000010, "Wrong alignment on AObjectBase");
static_assert(sizeof(AObjectBase) == 0x000590, "Wrong size on AObjectBase");
static_assert(offsetof(AObjectBase, ShouldTickEvenInPlaced) == 0x0003A1, "Member 'AObjectBase::ShouldTickEvenInPlaced' has a wrong offset!");
static_assert(offsetof(AObjectBase, _OverrideClassName) == 0x0003A4, "Member 'AObjectBase::_OverrideClassName' has a wrong offset!");
static_assert(offsetof(AObjectBase, State) == 0x0003F1, "Member 'AObjectBase::State' has a wrong offset!");
static_assert(offsetof(AObjectBase, _Durability) == 0x0004A0, "Member 'AObjectBase::_Durability' has a wrong offset!");
static_assert(offsetof(AObjectBase, _Life) == 0x0004A4, "Member 'AObjectBase::_Life' has a wrong offset!");
static_assert(offsetof(AObjectBase, _DissolveMaterial) == 0x0004A8, "Member 'AObjectBase::_DissolveMaterial' has a wrong offset!");
static_assert(offsetof(AObjectBase, DisappearDuration) == 0x0004B0, "Member 'AObjectBase::DisappearDuration' has a wrong offset!");
static_assert(offsetof(AObjectBase, _Mesh) == 0x0004C0, "Member 'AObjectBase::_Mesh' has a wrong offset!");
static_assert(offsetof(AObjectBase, _PropAttachmentSocketName) == 0x000560, "Member 'AObjectBase::_PropAttachmentSocketName' has a wrong offset!");
static_assert(offsetof(AObjectBase, TrailFXTemplate) == 0x000570, "Member 'AObjectBase::TrailFXTemplate' has a wrong offset!");
static_assert(offsetof(AObjectBase, ThrowTrailFX) == 0x000578, "Member 'AObjectBase::ThrowTrailFX' has a wrong offset!");

// Class Stigma.AntidoteArea
// 0x00A0 (0x0630 - 0x0590)
class AAntidoteArea final : public AObjectBase
{
public:
	struct FConfig_AntidoteArea                   _Config_AntidoteArea;                              // 0x0588(0x0060)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class USphereComponent*                       _collision;                                        // 0x05E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharaBase*                             _Spawner;                                          // 0x05F0(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AObjectBase*                            _Weapon;                                           // 0x05F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F75[0x8];                                     // 0x0600(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UNiagaraComponent*                      _FX_Gas;                                           // 0x0608(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ACharaBase*>                     _EnteredActors;                                    // 0x0610(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F76[0x10];                                    // 0x0620(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnLoadSettings(struct FConfig_AntidoteArea* _settings);
	void Start(class ACharaBase* _thrower, class AObjectBase* _weapon_obj, const struct FActionGraphOperatorID& _op_id);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AntidoteArea">();
	}
	static class AAntidoteArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAntidoteArea>();
	}
};
static_assert(alignof(AAntidoteArea) == 0x000010, "Wrong alignment on AAntidoteArea");
static_assert(sizeof(AAntidoteArea) == 0x000630, "Wrong size on AAntidoteArea");
static_assert(offsetof(AAntidoteArea, _Config_AntidoteArea) == 0x000588, "Member 'AAntidoteArea::_Config_AntidoteArea' has a wrong offset!");
static_assert(offsetof(AAntidoteArea, _collision) == 0x0005E8, "Member 'AAntidoteArea::_collision' has a wrong offset!");
static_assert(offsetof(AAntidoteArea, _Spawner) == 0x0005F0, "Member 'AAntidoteArea::_Spawner' has a wrong offset!");
static_assert(offsetof(AAntidoteArea, _Weapon) == 0x0005F8, "Member 'AAntidoteArea::_Weapon' has a wrong offset!");
static_assert(offsetof(AAntidoteArea, _FX_Gas) == 0x000608, "Member 'AAntidoteArea::_FX_Gas' has a wrong offset!");
static_assert(offsetof(AAntidoteArea, _EnteredActors) == 0x000610, "Member 'AAntidoteArea::_EnteredActors' has a wrong offset!");

// Class Stigma.AGC_GunnerMode
// 0x0008 (0x0038 - 0x0030)
class UAGC_GunnerMode final : public UActionGraphCondition
{
public:
	EGunnerType                                   TargetGunnerType;                                  // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F7A[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGC_GunnerMode">();
	}
	static class UAGC_GunnerMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGC_GunnerMode>();
	}
};
static_assert(alignof(UAGC_GunnerMode) == 0x000008, "Wrong alignment on UAGC_GunnerMode");
static_assert(sizeof(UAGC_GunnerMode) == 0x000038, "Wrong size on UAGC_GunnerMode");
static_assert(offsetof(UAGC_GunnerMode, TargetGunnerType) == 0x000030, "Member 'UAGC_GunnerMode::TargetGunnerType' has a wrong offset!");

// Class Stigma.UI_BoosterSlot
// 0x0070 (0x0560 - 0x04F0)
class UUI_BoosterSlot : public UPreviewableWidget
{
public:
	class URadioButton*                           BTN_Body;                                          // 0x04F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               AREA_Icon;                                         // 0x04F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               AREA_Lock;                                         // 0x0500(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               AREA_Timer;                                        // 0x0508(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               AREA_Plus;                                         // 0x0510(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               AREA_Level;                                        // 0x0518(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_Level;                                         // 0x0520(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           AREA_Selected;                                     // 0x0528(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Icon;                                          // 0x0530(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _SlotIndex;                                        // 0x0538(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F7B[0x24];                                    // 0x053C(0x0024)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnClickSlot();
	void OnRightClickSlot();

	struct FItemID GetBoosterID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_BoosterSlot">();
	}
	static class UUI_BoosterSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_BoosterSlot>();
	}
};
static_assert(alignof(UUI_BoosterSlot) == 0x000008, "Wrong alignment on UUI_BoosterSlot");
static_assert(sizeof(UUI_BoosterSlot) == 0x000560, "Wrong size on UUI_BoosterSlot");
static_assert(offsetof(UUI_BoosterSlot, BTN_Body) == 0x0004F0, "Member 'UUI_BoosterSlot::BTN_Body' has a wrong offset!");
static_assert(offsetof(UUI_BoosterSlot, AREA_Icon) == 0x0004F8, "Member 'UUI_BoosterSlot::AREA_Icon' has a wrong offset!");
static_assert(offsetof(UUI_BoosterSlot, AREA_Lock) == 0x000500, "Member 'UUI_BoosterSlot::AREA_Lock' has a wrong offset!");
static_assert(offsetof(UUI_BoosterSlot, AREA_Timer) == 0x000508, "Member 'UUI_BoosterSlot::AREA_Timer' has a wrong offset!");
static_assert(offsetof(UUI_BoosterSlot, AREA_Plus) == 0x000510, "Member 'UUI_BoosterSlot::AREA_Plus' has a wrong offset!");
static_assert(offsetof(UUI_BoosterSlot, AREA_Level) == 0x000518, "Member 'UUI_BoosterSlot::AREA_Level' has a wrong offset!");
static_assert(offsetof(UUI_BoosterSlot, Txt_Level) == 0x000520, "Member 'UUI_BoosterSlot::Txt_Level' has a wrong offset!");
static_assert(offsetof(UUI_BoosterSlot, AREA_Selected) == 0x000528, "Member 'UUI_BoosterSlot::AREA_Selected' has a wrong offset!");
static_assert(offsetof(UUI_BoosterSlot, Img_Icon) == 0x000530, "Member 'UUI_BoosterSlot::Img_Icon' has a wrong offset!");
static_assert(offsetof(UUI_BoosterSlot, _SlotIndex) == 0x000538, "Member 'UUI_BoosterSlot::_SlotIndex' has a wrong offset!");

// Class Stigma.AGC_IsFullChargedGun
// 0x0008 (0x0038 - 0x0030)
class UAGC_IsFullChargedGun final : public UActionGraphCondition
{
public:
	bool                                          _ForMainGun;                                       // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F7C[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGC_IsFullChargedGun">();
	}
	static class UAGC_IsFullChargedGun* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGC_IsFullChargedGun>();
	}
};
static_assert(alignof(UAGC_IsFullChargedGun) == 0x000008, "Wrong alignment on UAGC_IsFullChargedGun");
static_assert(sizeof(UAGC_IsFullChargedGun) == 0x000038, "Wrong size on UAGC_IsFullChargedGun");
static_assert(offsetof(UAGC_IsFullChargedGun, _ForMainGun) == 0x000030, "Member 'UAGC_IsFullChargedGun::_ForMainGun' has a wrong offset!");

// Class Stigma.BattlePassLevelItem
// 0x0030 (0x0058 - 0x0028)
class UBattlePassLevelItem final : public UObject
{
public:
	struct FItemID_BattlePass                     _PassID;                                           // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _IsPremiumActived;                                 // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F7D[0x3];                                     // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         _level;                                            // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERewardItemState                              _RewardState;                                      // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F7E[0x17];                                    // 0x0041(0x0017)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattlePassLevelItem">();
	}
	static class UBattlePassLevelItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattlePassLevelItem>();
	}
};
static_assert(alignof(UBattlePassLevelItem) == 0x000008, "Wrong alignment on UBattlePassLevelItem");
static_assert(sizeof(UBattlePassLevelItem) == 0x000058, "Wrong size on UBattlePassLevelItem");
static_assert(offsetof(UBattlePassLevelItem, _PassID) == 0x000028, "Member 'UBattlePassLevelItem::_PassID' has a wrong offset!");
static_assert(offsetof(UBattlePassLevelItem, _IsPremiumActived) == 0x000038, "Member 'UBattlePassLevelItem::_IsPremiumActived' has a wrong offset!");
static_assert(offsetof(UBattlePassLevelItem, _level) == 0x00003C, "Member 'UBattlePassLevelItem::_level' has a wrong offset!");
static_assert(offsetof(UBattlePassLevelItem, _RewardState) == 0x000040, "Member 'UBattlePassLevelItem::_RewardState' has a wrong offset!");

// Class Stigma.AGC_IsSprinting
// 0x0000 (0x0030 - 0x0030)
class UAGC_IsSprinting final : public UActionGraphCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGC_IsSprinting">();
	}
	static class UAGC_IsSprinting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGC_IsSprinting>();
	}
};
static_assert(alignof(UAGC_IsSprinting) == 0x000008, "Wrong alignment on UAGC_IsSprinting");
static_assert(sizeof(UAGC_IsSprinting) == 0x000030, "Wrong size on UAGC_IsSprinting");

// Class Stigma.AGC_MateLowerState
// 0x0008 (0x0038 - 0x0030)
class UAGC_MateLowerState final : public UActionGraphCondition
{
public:
	EBodyLowerState                               LowerState;                                        // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F7F[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGC_MateLowerState">();
	}
	static class UAGC_MateLowerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGC_MateLowerState>();
	}
};
static_assert(alignof(UAGC_MateLowerState) == 0x000008, "Wrong alignment on UAGC_MateLowerState");
static_assert(sizeof(UAGC_MateLowerState) == 0x000038, "Wrong size on UAGC_MateLowerState");
static_assert(offsetof(UAGC_MateLowerState, LowerState) == 0x000030, "Member 'UAGC_MateLowerState::LowerState' has a wrong offset!");

// Class Stigma.AutoBooster_HP
// 0x0000 (0x01B0 - 0x01B0)
class UAutoBooster_HP final : public UAutoBoosterTrigger
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoBooster_HP">();
	}
	static class UAutoBooster_HP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutoBooster_HP>();
	}
};
static_assert(alignof(UAutoBooster_HP) == 0x000008, "Wrong alignment on UAutoBooster_HP");
static_assert(sizeof(UAutoBooster_HP) == 0x0001B0, "Wrong size on UAutoBooster_HP");

// Class Stigma.AGC_OnCounterAttack
// 0x0010 (0x0040 - 0x0030)
class UAGC_OnCounterAttack final : public UActionGraphCondition
{
public:
	uint8                                         Pad_1F80[0x10];                                    // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGC_OnCounterAttack">();
	}
	static class UAGC_OnCounterAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGC_OnCounterAttack>();
	}
};
static_assert(alignof(UAGC_OnCounterAttack) == 0x000008, "Wrong alignment on UAGC_OnCounterAttack");
static_assert(sizeof(UAGC_OnCounterAttack) == 0x000040, "Wrong size on UAGC_OnCounterAttack");

// Class Stigma.UI_PlayerJoinDetectable
// 0x0058 (0x0548 - 0x04F0)
class UUI_PlayerJoinDetectable : public UPreviewableWidget
{
public:
	TMap<class AMatchServicedPlayerState*, class UUserWidget*> _PlayerWidgetMap;                                  // 0x04F0(0x0050)(BlueprintVisible, ExportObject, BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F81[0x8];                                     // 0x0540(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool OnPlayerJoin(class AMatchServicedPlayerState* _ps);
	bool OnPlayerLeaved(class AMatchServicedPlayerState* _ps);
	bool OnPlayerUpdate(class AMatchServicedPlayerState* _ps);
	void RemovePlayerWidget(class AMatchServicedPlayerState* _ps);
	void SetPlayerWidget(class AMatchServicedPlayerState* _ps, class UUserWidget* _widget);
	void SortAllyPlayers();

	class UUserWidget* GetPlayerWidget(class AMatchServicedPlayerState* _ps) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_PlayerJoinDetectable">();
	}
	static class UUI_PlayerJoinDetectable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_PlayerJoinDetectable>();
	}
};
static_assert(alignof(UUI_PlayerJoinDetectable) == 0x000008, "Wrong alignment on UUI_PlayerJoinDetectable");
static_assert(sizeof(UUI_PlayerJoinDetectable) == 0x000548, "Wrong size on UUI_PlayerJoinDetectable");
static_assert(offsetof(UUI_PlayerJoinDetectable, _PlayerWidgetMap) == 0x0004F0, "Member 'UUI_PlayerJoinDetectable::_PlayerWidgetMap' has a wrong offset!");

// Class Stigma.UI_CustomGame
// 0x0000 (0x0548 - 0x0548)
class UUI_CustomGame final : public UUI_PlayerJoinDetectable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_CustomGame">();
	}
	static class UUI_CustomGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_CustomGame>();
	}
};
static_assert(alignof(UUI_CustomGame) == 0x000008, "Wrong alignment on UUI_CustomGame");
static_assert(sizeof(UUI_CustomGame) == 0x000548, "Wrong size on UUI_CustomGame");

// Class Stigma.AGC_OnDamaged
// 0x0010 (0x0040 - 0x0030)
class UAGC_OnDamaged final : public UActionGraphCondition
{
public:
	uint8                                         Pad_1F85[0x10];                                    // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGC_OnDamaged">();
	}
	static class UAGC_OnDamaged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGC_OnDamaged>();
	}
};
static_assert(alignof(UAGC_OnDamaged) == 0x000008, "Wrong alignment on UAGC_OnDamaged");
static_assert(sizeof(UAGC_OnDamaged) == 0x000040, "Wrong size on UAGC_OnDamaged");

// Class Stigma.AGC_OnHacking
// 0x0000 (0x0030 - 0x0030)
class UAGC_OnHacking final : public UActionGraphCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGC_OnHacking">();
	}
	static class UAGC_OnHacking* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGC_OnHacking>();
	}
};
static_assert(alignof(UAGC_OnHacking) == 0x000008, "Wrong alignment on UAGC_OnHacking");
static_assert(sizeof(UAGC_OnHacking) == 0x000030, "Wrong size on UAGC_OnHacking");

// Class Stigma.FXCustomizable
// 0x0000 (0x0028 - 0x0028)
class IFXCustomizable final : public IInterface
{
public:
	struct FCustomFX OnQueryFX(const struct FHitData& _hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FXCustomizable">();
	}
	static class IFXCustomizable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFXCustomizable>();
	}
};
static_assert(alignof(IFXCustomizable) == 0x000008, "Wrong alignment on IFXCustomizable");
static_assert(sizeof(IFXCustomizable) == 0x000028, "Wrong size on IFXCustomizable");

// Class Stigma.AGC_OnHit
// 0x0000 (0x0030 - 0x0030)
class UAGC_OnHit final : public UActionGraphCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGC_OnHit">();
	}
	static class UAGC_OnHit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGC_OnHit>();
	}
};
static_assert(alignof(UAGC_OnHit) == 0x000008, "Wrong alignment on UAGC_OnHit");
static_assert(sizeof(UAGC_OnHit) == 0x000030, "Wrong size on UAGC_OnHit");

// Class Stigma.GoToWidget
// 0x0010 (0x0038 - 0x0028)
class UGoToWidget : public UObject
{
public:
	class UPreviewableWidget*                     _TargetWidget;                                     // 0x0028(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGoToWidgetDetailer*                    _Detailer;                                         // 0x0030(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ChangeTargetWidget(class UPreviewableWidget* _new_target_widget);
	void OnWidgetOpened(class UAnimatableWidget* _widget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GoToWidget">();
	}
	static class UGoToWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGoToWidget>();
	}
};
static_assert(alignof(UGoToWidget) == 0x000008, "Wrong alignment on UGoToWidget");
static_assert(sizeof(UGoToWidget) == 0x000038, "Wrong size on UGoToWidget");
static_assert(offsetof(UGoToWidget, _TargetWidget) == 0x000028, "Member 'UGoToWidget::_TargetWidget' has a wrong offset!");
static_assert(offsetof(UGoToWidget, _Detailer) == 0x000030, "Member 'UGoToWidget::_Detailer' has a wrong offset!");

// Class Stigma.GoToWidget_PopupBase
// 0x0000 (0x0038 - 0x0038)
class UGoToWidget_PopupBase final : public UGoToWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GoToWidget_PopupBase">();
	}
	static class UGoToWidget_PopupBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGoToWidget_PopupBase>();
	}
};
static_assert(alignof(UGoToWidget_PopupBase) == 0x000008, "Wrong alignment on UGoToWidget_PopupBase");
static_assert(sizeof(UGoToWidget_PopupBase) == 0x000038, "Wrong size on UGoToWidget_PopupBase");

// Class Stigma.BattleResultBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UBattleResultBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FUserBattleResult_ExpDetail GetReport_ExpDetails(const class UObject* _world_ctx, const struct FBattleDecisionDetail& _decision, ETeams _my_team, const struct FUserBattleResult& _result, const struct FMyBattleResult& _my_result);
	static struct FUserBattleResult_UIValues GetReport_LevelAndExp(const class UObject* _world_ctx, const struct FUserBattleResult& _result);
	static int32 GetTotalExp(const struct FMyBattleResult& _my_result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleResultBlueprintLibrary">();
	}
	static class UBattleResultBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleResultBlueprintLibrary>();
	}
};
static_assert(alignof(UBattleResultBlueprintLibrary) == 0x000008, "Wrong alignment on UBattleResultBlueprintLibrary");
static_assert(sizeof(UBattleResultBlueprintLibrary) == 0x000028, "Wrong size on UBattleResultBlueprintLibrary");

// Class Stigma.AGC_OnKey
// 0x0020 (0x0050 - 0x0030)
class UAGC_OnKey final : public UActionGraphCondition
{
public:
	EInputConditionType                           KeyType;                                           // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F8A[0x1F];                                    // 0x0031(0x001F)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGC_OnKey">();
	}
	static class UAGC_OnKey* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGC_OnKey>();
	}
};
static_assert(alignof(UAGC_OnKey) == 0x000008, "Wrong alignment on UAGC_OnKey");
static_assert(sizeof(UAGC_OnKey) == 0x000050, "Wrong size on UAGC_OnKey");
static_assert(offsetof(UAGC_OnKey, KeyType) == 0x000030, "Member 'UAGC_OnKey::KeyType' has a wrong offset!");

// Class Stigma.FocusDriver_Default
// 0x00F0 (0x0120 - 0x0030)
class UFocusDriver_Default final : public UFocusDriver
{
public:
	struct FProficiency                           _PitchShift;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FFocusInterp_FitInRange_Setting        _ViewSetting_Beginner;                             // 0x0038(0x0014)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FFocusInterp_FitInRange_Setting        _ViewSetting_Veteran;                              // 0x004C(0x0014)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FProficiency                           _PredictionError;                                  // 0x0060(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         _PredictionShift;                                  // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FProficiency                           _InAim_Bar;                                        // 0x006C(0x0008)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FConcentration                         _Concentration_Beginner;                           // 0x0074(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FConcentration                         _Concentration_Veteran;                            // 0x0084(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F8B[0x8C];                                    // 0x0094(0x008C)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FocusDriver_Default">();
	}
	static class UFocusDriver_Default* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFocusDriver_Default>();
	}
};
static_assert(alignof(UFocusDriver_Default) == 0x000008, "Wrong alignment on UFocusDriver_Default");
static_assert(sizeof(UFocusDriver_Default) == 0x000120, "Wrong size on UFocusDriver_Default");
static_assert(offsetof(UFocusDriver_Default, _PitchShift) == 0x000030, "Member 'UFocusDriver_Default::_PitchShift' has a wrong offset!");
static_assert(offsetof(UFocusDriver_Default, _ViewSetting_Beginner) == 0x000038, "Member 'UFocusDriver_Default::_ViewSetting_Beginner' has a wrong offset!");
static_assert(offsetof(UFocusDriver_Default, _ViewSetting_Veteran) == 0x00004C, "Member 'UFocusDriver_Default::_ViewSetting_Veteran' has a wrong offset!");
static_assert(offsetof(UFocusDriver_Default, _PredictionError) == 0x000060, "Member 'UFocusDriver_Default::_PredictionError' has a wrong offset!");
static_assert(offsetof(UFocusDriver_Default, _PredictionShift) == 0x000068, "Member 'UFocusDriver_Default::_PredictionShift' has a wrong offset!");
static_assert(offsetof(UFocusDriver_Default, _InAim_Bar) == 0x00006C, "Member 'UFocusDriver_Default::_InAim_Bar' has a wrong offset!");
static_assert(offsetof(UFocusDriver_Default, _Concentration_Beginner) == 0x000074, "Member 'UFocusDriver_Default::_Concentration_Beginner' has a wrong offset!");
static_assert(offsetof(UFocusDriver_Default, _Concentration_Veteran) == 0x000084, "Member 'UFocusDriver_Default::_Concentration_Veteran' has a wrong offset!");

// Class Stigma.UI_GunTypeBoxItem
// 0x0078 (0x0568 - 0x04F0)
class UUI_GunTypeBoxItem : public UPreviewableWidget
{
public:
	uint8                                         Pad_1F8C[0x8];                                     // 0x04F0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UWrapBox*                               WrapBox_GunPresetItem;                             // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_GunPresetItem*                      GunPreset1;                                        // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_GunPresetItem*                      GunPreset2;                                        // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_GunPresetItem*                      GunPreset3;                                        // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_GunPresetItem*                      GunPreset4;                                        // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULVData_Gun*                            _BoxItemObject;                                    // 0x0520(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUI_GunPresetItem*>              _GunPresetItemWidgets;                             // 0x0528(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_GunPresetItem>          _GunPresetItemWidgetClass;                         // 0x0538(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _SelectedMasterIdx;                                // 0x0540(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F8D[0x4];                                     // 0x0544(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             OnSelectGun;                                       // 0x0548(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangedHoveredGunPresetItem;                     // 0x0558(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnChangedGun(const struct FGunPreset& _gun_preset);
	void OnHoverGunPresetItem(class UObject* _item, bool _is_hovered);
	void SetTitle(const class FText& _gun_name);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_GunTypeBoxItem">();
	}
	static class UUI_GunTypeBoxItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_GunTypeBoxItem>();
	}
};
static_assert(alignof(UUI_GunTypeBoxItem) == 0x000008, "Wrong alignment on UUI_GunTypeBoxItem");
static_assert(sizeof(UUI_GunTypeBoxItem) == 0x000568, "Wrong size on UUI_GunTypeBoxItem");
static_assert(offsetof(UUI_GunTypeBoxItem, WrapBox_GunPresetItem) == 0x0004F8, "Member 'UUI_GunTypeBoxItem::WrapBox_GunPresetItem' has a wrong offset!");
static_assert(offsetof(UUI_GunTypeBoxItem, GunPreset1) == 0x000500, "Member 'UUI_GunTypeBoxItem::GunPreset1' has a wrong offset!");
static_assert(offsetof(UUI_GunTypeBoxItem, GunPreset2) == 0x000508, "Member 'UUI_GunTypeBoxItem::GunPreset2' has a wrong offset!");
static_assert(offsetof(UUI_GunTypeBoxItem, GunPreset3) == 0x000510, "Member 'UUI_GunTypeBoxItem::GunPreset3' has a wrong offset!");
static_assert(offsetof(UUI_GunTypeBoxItem, GunPreset4) == 0x000518, "Member 'UUI_GunTypeBoxItem::GunPreset4' has a wrong offset!");
static_assert(offsetof(UUI_GunTypeBoxItem, _BoxItemObject) == 0x000520, "Member 'UUI_GunTypeBoxItem::_BoxItemObject' has a wrong offset!");
static_assert(offsetof(UUI_GunTypeBoxItem, _GunPresetItemWidgets) == 0x000528, "Member 'UUI_GunTypeBoxItem::_GunPresetItemWidgets' has a wrong offset!");
static_assert(offsetof(UUI_GunTypeBoxItem, _GunPresetItemWidgetClass) == 0x000538, "Member 'UUI_GunTypeBoxItem::_GunPresetItemWidgetClass' has a wrong offset!");
static_assert(offsetof(UUI_GunTypeBoxItem, _SelectedMasterIdx) == 0x000540, "Member 'UUI_GunTypeBoxItem::_SelectedMasterIdx' has a wrong offset!");
static_assert(offsetof(UUI_GunTypeBoxItem, OnSelectGun) == 0x000548, "Member 'UUI_GunTypeBoxItem::OnSelectGun' has a wrong offset!");
static_assert(offsetof(UUI_GunTypeBoxItem, OnChangedHoveredGunPresetItem) == 0x000558, "Member 'UUI_GunTypeBoxItem::OnChangedHoveredGunPresetItem' has a wrong offset!");

// Class Stigma.AGC_ParamVector
// 0x0018 (0x0048 - 0x0030)
class UAGC_ParamVector final : public UActionGraphCondition
{
public:
	struct FVector                                _vector;                                           // 0x0030(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGC_ParamVector">();
	}
	static class UAGC_ParamVector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGC_ParamVector>();
	}
};
static_assert(alignof(UAGC_ParamVector) == 0x000008, "Wrong alignment on UAGC_ParamVector");
static_assert(sizeof(UAGC_ParamVector) == 0x000048, "Wrong size on UAGC_ParamVector");
static_assert(offsetof(UAGC_ParamVector, _vector) == 0x000030, "Member 'UAGC_ParamVector::_vector' has a wrong offset!");

// Class Stigma.MatchServicedPlayerState
// 0x0250 (0x05A0 - 0x0350)
class AMatchServicedPlayerState : public APlayerState
{
public:
	struct FNetID                                 _NetID;                                            // 0x0350(0x0002)(Edit, BlueprintVisible, Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F8F[0x6];                                     // 0x0352(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	struct FUserID                                _UserID;                                           // 0x0358(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJoinType                                     _JoinType;                                         // 0x0360(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F90[0x7];                                     // 0x0361(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FUserInBattle                          _user;                                             // 0x0368(0x00A0)(Edit, BlueprintVisible, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FPlayerKPI                             _KPI;                                              // 0x0408(0x000C)(Edit, BlueprintVisible, Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F91[0x4];                                     // 0x0414(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class ACharaBase*                             _OwnChara;                                         // 0x0418(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _UsedBoosterCount;                                 // 0x0420(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F92[0x4];                                     // 0x0424(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UUserWidget*                            _RelatedWidget;                                    // 0x0428(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserProfile*                           _UserProfile;                                      // 0x0430(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F93[0x8];                                     // 0x0438(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UPlayerContext*                         _PlayerCtx;                                        // 0x0440(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F94[0x20];                                    // 0x0448(0x0020)(Fixing Size After Last Property [ Dumper-69 ])
	struct FCharacterSet                          _PickedCharas;                                     // 0x0468(0x0118)(Edit, BlueprintVisible, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         _CurrentCharaIdx;                                  // 0x0580(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsReadyToFight;                                   // 0x0581(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _EnableChangeMasterImmediately;                    // 0x0582(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECharaType                                    _NewCharaType;                                     // 0x0583(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F95[0x4];                                     // 0x0584(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FLocalCharacterSet>             _LocalPickedCharas;                                // 0x0588(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F96[0x8];                                     // 0x0598(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool IsSummonedBot();
	void LocalRandomSelectCharacter();
	void LocalSelectCharacter(ECharaType _chara_type, bool _is_chara_change, bool _is_init);
	void LocalSelectCostume(int32 _zidx, const struct FItemID& _item);
	void LocalSelectGun(int32 _zidx, const struct FGunPreset& _gun_preset);
	void OnRep_CurrentCharaIdx();
	void OnRep_EnableChangeMaster();
	void OnRep_IsReadyToFight();
	void OnRep_JoinType(EJoinType _old_join_type);
	void OnRep_KPI();
	void OnRep_NetID();
	void OnRep_NewCharaType();
	void OnRep_OwnChara();
	void OnRep_PickedCharas();
	void OnRep_User();
	void ResetLocalPickedInfo();
	void SERVER_SetGun(int32 _zidx, const struct FGunSpec& _spec);
	void SERVER_SetIsReadyToFight(bool _i_am_ready);
	void SERVER_SetNetID(const struct FNetID& _net_id);
	void SERVER_SetUserID(const struct FUserID& _user_id);
	void SetLocalCharacterIndex(int32 _zidx);
	void SetLocalNewCharaType(ECharaType _chara_type);
	void SetRelatedWidget(class UUserWidget* _widget);
	void Setter_CurrentCharaIdx(uint8 _idx);
	void Setter_EnableChangeMaster(bool _value);
	void Setter_IsReadyToFight(bool _ready);
	void Setter_JoinType(EJoinType _join_type);
	void Setter_KPI(const struct FPlayerKPI& _player_kpi);
	void Setter_NewCharaType(ECharaType _chara_type);
	void Setter_PickedCharas(const struct FCharacterSet& _charas);
	void Setter_User(const struct FUserInBattle& _user_in_battle);
	void SetUserProfile(class UUserProfile* _profile);
	void Subscribe_OnChanged(const TDelegate<void(EChangedPlayerState _reason, class AMatchServicedPlayerState* _ps)>& _proc);
	bool TakeHasBeenChanged();
	void Unsubscribe_OnChanged(const class UObject* _obj);

	bool CanBeReady() const;
	bool CanPickCharacter(ECharaType _chara_type) const;
	EArmorType GetArmorType() const;
	struct FItemID_Skin_Body GetBodyID(int32 _zidx_chara) const;
	struct FItemID_Booster GetBoosterID(int32 _slot_zidx) const;
	int32 GetBoosterIndex(const struct FItemID_Booster& _item_id) const;
	const TArray<struct FItemID_Booster> GetBoosters() const;
	int32 GetBoosterTicketCount() const;
	const struct FCharacterSetting GetCharacter() const;
	TSoftObjectPtr<class UTexture2D> GetCharacterIcon() const;
	int32 GetCurrentCharacterIndex() const;
	ECharaType GetCurrentCharaType() const;
	const struct FGunPreset GetCurrentGunPreset() const;
	const struct FGunSpec GetCurrentGunSpec() const;
	ECharaType GetCurrentlySelectedCharaType() const;
	float GetELO() const;
	struct FItemID GetEmblem() const;
	bool GetEnableChangeMaster() const;
	const struct FGunPreset GetGunPreset(int32 _zidx) const;
	const struct FGunSpec GetGunSpec(int32 _zidx) const;
	struct FItemID_Skin_Head GetHeadID(int32 _zidx_chara) const;
	EJoinType GetJoinType() const;
	const struct FPlayerKPI GetKPI() const;
	const struct FLocalCharacterSet GetLocalCharacter() const;
	int32 GetLocalCharacterIndex() const;
	ECharaType GetLocalCurrentCharaType() const;
	ECharaType GetLocalNewCharaType() const;
	const struct FLocalCharacterSet GetLocalPickedCharacter(int32 _zidx) const;
	const TArray<struct FLocalCharacterSet> GetLocalPickedCharacters() const;
	struct FNetID GetNetID() const;
	ECharaType GetNewCharaType() const;
	const struct FUserName GetNickname() const;
	struct FItemID GetNicknameFX() const;
	class ACharaBase* GetOwnCharacter() const;
	const TArray<struct FPassiveSkill> GetPassiveSkills() const;
	const struct FCharacterSetting GetPickedCharacter(int32 _zidx) const;
	int32 GetPickedCharacterIndex(ECharaType _chara_type) const;
	ECharaType GetPickedCharaType(int32 _zidx_chara) const;
	EPlayerSide GetPlayerSideAgainstLocalPlayer() const;
	struct FItemID GetProfileCard() const;
	class UUserWidget* GetRelatedWidget() const;
	ETeams GetTeam() const;
	struct FLinearColor GetTeamColorForHUD() const;
	ETier GetTier() const;
	int32 GetUsedBoosterCount() const;
	const struct FUserInBattle GetUser() const;
	struct FUserID GetUserID() const;
	int32 GetUserLevel() const;
	class UUserProfile* GetUserProfile() const;
	bool HasValidNetID() const;
	bool HasValidUserID() const;
	bool HasValidValue() const;
	bool IsACoach() const;
	bool IsAObserver() const;
	bool IsAPlayer() const;
	bool IsBlueSideForHUD() const;
	bool IsBoosterSlotEnabled(int32 _slot_zidx) const;
	bool IsLocal() const;
	bool IsNotPlayer() const;
	bool IsReadyToFight() const;
	bool IsRoomLeader() const;
	bool IsRoomManager() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchServicedPlayerState">();
	}
	static class AMatchServicedPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchServicedPlayerState>();
	}
};
static_assert(alignof(AMatchServicedPlayerState) == 0x000008, "Wrong alignment on AMatchServicedPlayerState");
static_assert(sizeof(AMatchServicedPlayerState) == 0x0005A0, "Wrong size on AMatchServicedPlayerState");
static_assert(offsetof(AMatchServicedPlayerState, _NetID) == 0x000350, "Member 'AMatchServicedPlayerState::_NetID' has a wrong offset!");
static_assert(offsetof(AMatchServicedPlayerState, _UserID) == 0x000358, "Member 'AMatchServicedPlayerState::_UserID' has a wrong offset!");
static_assert(offsetof(AMatchServicedPlayerState, _JoinType) == 0x000360, "Member 'AMatchServicedPlayerState::_JoinType' has a wrong offset!");
static_assert(offsetof(AMatchServicedPlayerState, _user) == 0x000368, "Member 'AMatchServicedPlayerState::_user' has a wrong offset!");
static_assert(offsetof(AMatchServicedPlayerState, _KPI) == 0x000408, "Member 'AMatchServicedPlayerState::_KPI' has a wrong offset!");
static_assert(offsetof(AMatchServicedPlayerState, _OwnChara) == 0x000418, "Member 'AMatchServicedPlayerState::_OwnChara' has a wrong offset!");
static_assert(offsetof(AMatchServicedPlayerState, _UsedBoosterCount) == 0x000420, "Member 'AMatchServicedPlayerState::_UsedBoosterCount' has a wrong offset!");
static_assert(offsetof(AMatchServicedPlayerState, _RelatedWidget) == 0x000428, "Member 'AMatchServicedPlayerState::_RelatedWidget' has a wrong offset!");
static_assert(offsetof(AMatchServicedPlayerState, _UserProfile) == 0x000430, "Member 'AMatchServicedPlayerState::_UserProfile' has a wrong offset!");
static_assert(offsetof(AMatchServicedPlayerState, _PlayerCtx) == 0x000440, "Member 'AMatchServicedPlayerState::_PlayerCtx' has a wrong offset!");
static_assert(offsetof(AMatchServicedPlayerState, _PickedCharas) == 0x000468, "Member 'AMatchServicedPlayerState::_PickedCharas' has a wrong offset!");
static_assert(offsetof(AMatchServicedPlayerState, _CurrentCharaIdx) == 0x000580, "Member 'AMatchServicedPlayerState::_CurrentCharaIdx' has a wrong offset!");
static_assert(offsetof(AMatchServicedPlayerState, _IsReadyToFight) == 0x000581, "Member 'AMatchServicedPlayerState::_IsReadyToFight' has a wrong offset!");
static_assert(offsetof(AMatchServicedPlayerState, _EnableChangeMasterImmediately) == 0x000582, "Member 'AMatchServicedPlayerState::_EnableChangeMasterImmediately' has a wrong offset!");
static_assert(offsetof(AMatchServicedPlayerState, _NewCharaType) == 0x000583, "Member 'AMatchServicedPlayerState::_NewCharaType' has a wrong offset!");
static_assert(offsetof(AMatchServicedPlayerState, _LocalPickedCharas) == 0x000588, "Member 'AMatchServicedPlayerState::_LocalPickedCharas' has a wrong offset!");

// Class Stigma.BattlePlayerState
// 0x06E8 (0x0C88 - 0x05A0)
class ABattlePlayerState : public AMatchServicedPlayerState
{
public:
	bool                                          _IsBreakInUser;                                    // 0x05A0(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FA5[0x3];                                     // 0x05A1(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         _EnteredRound;                                     // 0x05A4(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _KillCount;                                        // 0x05A8(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FA6[0x4];                                     // 0x05AC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         _AssistCount;                                      // 0x05B0(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _DeathCount;                                       // 0x05B4(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _InSafeArea;                                       // 0x05B8(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FA7[0x3];                                     // 0x05B9(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         _ReviveCount;                                      // 0x05BC(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsCanRevive;                                      // 0x05C0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsSpectating;                                     // 0x05C1(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FA8[0x6];                                     // 0x05C2(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         _RespawnCount;                                     // 0x05C8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _InGameMoney;                                      // 0x05CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FA9[0x8];                                     // 0x05D0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	struct FBattleStore_BuffStackList             _BattleStoreBuffStacks;                            // 0x05D8(0x0118)(Edit, BlueprintVisible, BlueprintReadOnly, Net, Transient, Protected, NativeAccessSpecifierProtected)
	struct FBattleStore_ItemPriceList             _BattleStoreItemPrices;                            // 0x06F0(0x0118)(Edit, BlueprintVisible, BlueprintReadOnly, Net, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGoldRewardHistory>             _InGameMoneyRewardHistory;                         // 0x0808(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FArmorRechargeHistory>          _InGameArmorRechargeHistory;                       // 0x0818(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FAA[0x18];                                    // 0x0828(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	struct FAssignedBuffList                      StaticBuffs;                                       // 0x0840(0x0118)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FAssignedBuffList                      DynamicBuffs;                                      // 0x0958(0x0118)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FBuffStats                             BuffStats;                                         // 0x0A70(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TMap<struct FBuffKey, class UBuffBase*>       ActivatedBuffMap;                                  // 0x0A88(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FAB[0x160];                                   // 0x0AD8(0x0160)(Fixing Size After Last Property [ Dumper-69 ])
	TMap<class ABattlePlayerState*, struct FKillerInfo> _KillerInfos;                                      // 0x0C38(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	void DEBUG_ActivateInfinitedBullet(bool _is_activated);
	const struct FBattleStore_BuffStack GetBattleStoreBuffStackByItemID(const struct FItemID& _id, bool* _out_is_success);
	void IncReviveCount();
	void OnRep_AssistCount();
	void OnRep_DynamicBuffs();
	void OnRep_InGameMoney(int32 _old_money);
	void OnRep_IsSpectating();
	void OnRep_KillCount();
	void OnRep_StaticBuffs();
	void SERVER_AddAssistCount(const struct FHitData& _hit);
	void SERVER_AddDeathCount(const struct FHitData& _hit);
	void SERVER_AddKillCount(const struct FHitData& _hit);
	void SERVER_IncreaseInGameMoney(int32 _inc_money, EGoldRewardType _reward_type, int32 _round);
	bool SERVER_PayInGameMoney(int32 _payment);
	void SERVER_SetInSafeArea(bool _in_safe_area);

	bool CanRespawn() const;
	bool CanRevive() const;
	bool DEBUG_IsActivatedInfinitedBullet() const;
	class UBuffBase* FindBuffByCausingItemID(const struct FItemID& _item_id) const;
	int32 GetAssistCount() const;
	int32 GetBattleStoreItemPrice(const struct FItemID& _id) const;
	int32 GetDeathCount() const;
	int32 GetEnteredRound() const;
	float GetHP() const;
	float GetHPRate() const;
	int32 GetInGameMoney() const;
	int32 GetKillCount() const;
	float GetRespawnDelayTime() const;
	int32 GetReviveCount() const;
	bool IsBreakInUser() const;
	bool IsCharacterDied(int32 _zidx) const;
	bool IsDied() const;
	bool IsInSafeArea() const;
	bool IsInvincible() const;
	bool IsSpectating() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattlePlayerState">();
	}
	static class ABattlePlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattlePlayerState>();
	}
};
static_assert(alignof(ABattlePlayerState) == 0x000008, "Wrong alignment on ABattlePlayerState");
static_assert(sizeof(ABattlePlayerState) == 0x000C88, "Wrong size on ABattlePlayerState");
static_assert(offsetof(ABattlePlayerState, _IsBreakInUser) == 0x0005A0, "Member 'ABattlePlayerState::_IsBreakInUser' has a wrong offset!");
static_assert(offsetof(ABattlePlayerState, _EnteredRound) == 0x0005A4, "Member 'ABattlePlayerState::_EnteredRound' has a wrong offset!");
static_assert(offsetof(ABattlePlayerState, _KillCount) == 0x0005A8, "Member 'ABattlePlayerState::_KillCount' has a wrong offset!");
static_assert(offsetof(ABattlePlayerState, _AssistCount) == 0x0005B0, "Member 'ABattlePlayerState::_AssistCount' has a wrong offset!");
static_assert(offsetof(ABattlePlayerState, _DeathCount) == 0x0005B4, "Member 'ABattlePlayerState::_DeathCount' has a wrong offset!");
static_assert(offsetof(ABattlePlayerState, _InSafeArea) == 0x0005B8, "Member 'ABattlePlayerState::_InSafeArea' has a wrong offset!");
static_assert(offsetof(ABattlePlayerState, _ReviveCount) == 0x0005BC, "Member 'ABattlePlayerState::_ReviveCount' has a wrong offset!");
static_assert(offsetof(ABattlePlayerState, _IsCanRevive) == 0x0005C0, "Member 'ABattlePlayerState::_IsCanRevive' has a wrong offset!");
static_assert(offsetof(ABattlePlayerState, _IsSpectating) == 0x0005C1, "Member 'ABattlePlayerState::_IsSpectating' has a wrong offset!");
static_assert(offsetof(ABattlePlayerState, _RespawnCount) == 0x0005C8, "Member 'ABattlePlayerState::_RespawnCount' has a wrong offset!");
static_assert(offsetof(ABattlePlayerState, _InGameMoney) == 0x0005CC, "Member 'ABattlePlayerState::_InGameMoney' has a wrong offset!");
static_assert(offsetof(ABattlePlayerState, _BattleStoreBuffStacks) == 0x0005D8, "Member 'ABattlePlayerState::_BattleStoreBuffStacks' has a wrong offset!");
static_assert(offsetof(ABattlePlayerState, _BattleStoreItemPrices) == 0x0006F0, "Member 'ABattlePlayerState::_BattleStoreItemPrices' has a wrong offset!");
static_assert(offsetof(ABattlePlayerState, _InGameMoneyRewardHistory) == 0x000808, "Member 'ABattlePlayerState::_InGameMoneyRewardHistory' has a wrong offset!");
static_assert(offsetof(ABattlePlayerState, _InGameArmorRechargeHistory) == 0x000818, "Member 'ABattlePlayerState::_InGameArmorRechargeHistory' has a wrong offset!");
static_assert(offsetof(ABattlePlayerState, StaticBuffs) == 0x000840, "Member 'ABattlePlayerState::StaticBuffs' has a wrong offset!");
static_assert(offsetof(ABattlePlayerState, DynamicBuffs) == 0x000958, "Member 'ABattlePlayerState::DynamicBuffs' has a wrong offset!");
static_assert(offsetof(ABattlePlayerState, BuffStats) == 0x000A70, "Member 'ABattlePlayerState::BuffStats' has a wrong offset!");
static_assert(offsetof(ABattlePlayerState, ActivatedBuffMap) == 0x000A88, "Member 'ABattlePlayerState::ActivatedBuffMap' has a wrong offset!");
static_assert(offsetof(ABattlePlayerState, _KillerInfos) == 0x000C38, "Member 'ABattlePlayerState::_KillerInfos' has a wrong offset!");

// Class Stigma.BountyTDM_PlayerState
// 0x0018 (0x0CA0 - 0x0C88)
class ABountyTDM_PlayerState : public ABattlePlayerState
{
public:
	int32                                         _Money;                                            // 0x0C88(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         _TransferID;                                       // 0x0C8C(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FB1[0x3];                                     // 0x0C8D(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         _TotalTransferedMoney;                             // 0x0C90(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FB2[0xC];                                     // 0x0C94(0x000C)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnRep_Money();
	void OnRep_TransferID();

	int32 GetMoney() const;
	float GetTransferTime() const;
	bool IsSendingMoney() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BountyTDM_PlayerState">();
	}
	static class ABountyTDM_PlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABountyTDM_PlayerState>();
	}
};
static_assert(alignof(ABountyTDM_PlayerState) == 0x000008, "Wrong alignment on ABountyTDM_PlayerState");
static_assert(sizeof(ABountyTDM_PlayerState) == 0x000CA0, "Wrong size on ABountyTDM_PlayerState");
static_assert(offsetof(ABountyTDM_PlayerState, _Money) == 0x000C88, "Member 'ABountyTDM_PlayerState::_Money' has a wrong offset!");
static_assert(offsetof(ABountyTDM_PlayerState, _TransferID) == 0x000C8C, "Member 'ABountyTDM_PlayerState::_TransferID' has a wrong offset!");
static_assert(offsetof(ABountyTDM_PlayerState, _TotalTransferedMoney) == 0x000C90, "Member 'ABountyTDM_PlayerState::_TotalTransferedMoney' has a wrong offset!");

// Class Stigma.AGC_Speed
// 0x0008 (0x0038 - 0x0030)
class UAGC_Speed final : public UActionGraphCondition
{
public:
	float                                         Speed;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FB3[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGC_Speed">();
	}
	static class UAGC_Speed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGC_Speed>();
	}
};
static_assert(alignof(UAGC_Speed) == 0x000008, "Wrong alignment on UAGC_Speed");
static_assert(sizeof(UAGC_Speed) == 0x000038, "Wrong size on UAGC_Speed");
static_assert(offsetof(UAGC_Speed, Speed) == 0x000030, "Member 'UAGC_Speed::Speed' has a wrong offset!");

// Class Stigma.AGO_AddAbnormal
// 0x0008 (0x0060 - 0x0058)
class UAGO_AddAbnormal final : public UActionGraphOperator
{
public:
	EAbnormal                                     AbnormalType;                                      // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FB4[0x7];                                     // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_AddAbnormal">();
	}
	static class UAGO_AddAbnormal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_AddAbnormal>();
	}
};
static_assert(alignof(UAGO_AddAbnormal) == 0x000008, "Wrong alignment on UAGO_AddAbnormal");
static_assert(sizeof(UAGO_AddAbnormal) == 0x000060, "Wrong size on UAGO_AddAbnormal");
static_assert(offsetof(UAGO_AddAbnormal, AbnormalType) == 0x000058, "Member 'UAGO_AddAbnormal::AbnormalType' has a wrong offset!");

// Class Stigma.BodyPhysicalState
// 0x0008 (0x0038 - 0x0030)
class UBodyPhysicalState final : public UAnimNotifyState
{
public:
	EBodyPhysicalState                            BodyState;                                         // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CallEnd;                                           // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FB5[0x6];                                     // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BodyPhysicalState">();
	}
	static class UBodyPhysicalState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBodyPhysicalState>();
	}
};
static_assert(alignof(UBodyPhysicalState) == 0x000008, "Wrong alignment on UBodyPhysicalState");
static_assert(sizeof(UBodyPhysicalState) == 0x000038, "Wrong size on UBodyPhysicalState");
static_assert(offsetof(UBodyPhysicalState, BodyState) == 0x000030, "Member 'UBodyPhysicalState::BodyState' has a wrong offset!");
static_assert(offsetof(UBodyPhysicalState, CallEnd) == 0x000031, "Member 'UBodyPhysicalState::CallEnd' has a wrong offset!");

// Class Stigma.AGO_AddGun
// 0x0008 (0x0060 - 0x0058)
class UAGO_AddGun final : public UActionGraphOperator
{
public:
	int32                                         AdditionalCount;                                   // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FB6[0x4];                                     // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_AddGun">();
	}
	static class UAGO_AddGun* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_AddGun>();
	}
};
static_assert(alignof(UAGO_AddGun) == 0x000008, "Wrong alignment on UAGO_AddGun");
static_assert(sizeof(UAGO_AddGun) == 0x000060, "Wrong size on UAGO_AddGun");
static_assert(offsetof(UAGO_AddGun, AdditionalCount) == 0x000058, "Member 'UAGO_AddGun::AdditionalCount' has a wrong offset!");

// Class Stigma.UI_DuplicateKeyPanelBase
// 0x0058 (0x0548 - 0x04F0)
class UUI_DuplicateKeyPanelBase : public UPreviewableWidget
{
public:
	TArray<EInputAction>                          _DuplicatedActions;                                // 0x04F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FKeyMapping                            _KeyMapping;                                       // 0x0500(0x0030)(Edit, BlueprintVisible, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FB7[0x18];                                    // 0x0530(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void InvokeOnDuplicateKeyChanged();
	void RegisterOnDuplicateKeyChanged(const TDelegate<void(struct FKeyMapping& _key_mapping, TArray<EInputAction>& _duplicated_actions)>& _callback);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_DuplicateKeyPanelBase">();
	}
	static class UUI_DuplicateKeyPanelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_DuplicateKeyPanelBase>();
	}
};
static_assert(alignof(UUI_DuplicateKeyPanelBase) == 0x000008, "Wrong alignment on UUI_DuplicateKeyPanelBase");
static_assert(sizeof(UUI_DuplicateKeyPanelBase) == 0x000548, "Wrong size on UUI_DuplicateKeyPanelBase");
static_assert(offsetof(UUI_DuplicateKeyPanelBase, _DuplicatedActions) == 0x0004F0, "Member 'UUI_DuplicateKeyPanelBase::_DuplicatedActions' has a wrong offset!");
static_assert(offsetof(UUI_DuplicateKeyPanelBase, _KeyMapping) == 0x000500, "Member 'UUI_DuplicateKeyPanelBase::_KeyMapping' has a wrong offset!");

// Class Stigma.AGO_AdditiveAnim
// 0x00A0 (0x00F8 - 0x0058)
class UAGO_AdditiveAnim final : public UActionGraphOperator
{
public:
	bool                                          PlayOnHit;                                         // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FB8[0x7];                                     // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UAnimSequenceBase*                      _Animation;                                        // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMontageSlot                           SlotName;                                          // 0x0068(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         PlayRate;                                          // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FB9[0x4];                                     // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FAlphaBlend                            BlendIn;                                           // 0x0088(0x0030)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAlphaBlend                            BlendOut;                                          // 0x00B8(0x0030)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         BlendOutTriggerTime;                               // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsLooping;                                        // 0x00EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FBA[0x3];                                     // 0x00ED(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class UAnimMontage*                           _TransientMontage;                                 // 0x00F0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_AdditiveAnim">();
	}
	static class UAGO_AdditiveAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_AdditiveAnim>();
	}
};
static_assert(alignof(UAGO_AdditiveAnim) == 0x000008, "Wrong alignment on UAGO_AdditiveAnim");
static_assert(sizeof(UAGO_AdditiveAnim) == 0x0000F8, "Wrong size on UAGO_AdditiveAnim");
static_assert(offsetof(UAGO_AdditiveAnim, PlayOnHit) == 0x000058, "Member 'UAGO_AdditiveAnim::PlayOnHit' has a wrong offset!");
static_assert(offsetof(UAGO_AdditiveAnim, _Animation) == 0x000060, "Member 'UAGO_AdditiveAnim::_Animation' has a wrong offset!");
static_assert(offsetof(UAGO_AdditiveAnim, SlotName) == 0x000068, "Member 'UAGO_AdditiveAnim::SlotName' has a wrong offset!");
static_assert(offsetof(UAGO_AdditiveAnim, PlayRate) == 0x000080, "Member 'UAGO_AdditiveAnim::PlayRate' has a wrong offset!");
static_assert(offsetof(UAGO_AdditiveAnim, BlendIn) == 0x000088, "Member 'UAGO_AdditiveAnim::BlendIn' has a wrong offset!");
static_assert(offsetof(UAGO_AdditiveAnim, BlendOut) == 0x0000B8, "Member 'UAGO_AdditiveAnim::BlendOut' has a wrong offset!");
static_assert(offsetof(UAGO_AdditiveAnim, BlendOutTriggerTime) == 0x0000E8, "Member 'UAGO_AdditiveAnim::BlendOutTriggerTime' has a wrong offset!");
static_assert(offsetof(UAGO_AdditiveAnim, _IsLooping) == 0x0000EC, "Member 'UAGO_AdditiveAnim::_IsLooping' has a wrong offset!");
static_assert(offsetof(UAGO_AdditiveAnim, _TransientMontage) == 0x0000F0, "Member 'UAGO_AdditiveAnim::_TransientMontage' has a wrong offset!");

// Class Stigma.AGO_AfterImage
// 0x0040 (0x0098 - 0x0058)
class UAGO_AfterImage final : public UActionGraphOperator
{
public:
	class UMaterialInterface*                     _materialinterface;                                // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _LifeTime;                                         // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _MaterialBaseColor;                                // 0x0064(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FBB[0x4];                                     // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FAfterImageParameterAndCurve>   _ParamAndCurves;                                   // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FAfterImageFX                          _AttachFX;                                         // 0x0088(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_AfterImage">();
	}
	static class UAGO_AfterImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_AfterImage>();
	}
};
static_assert(alignof(UAGO_AfterImage) == 0x000008, "Wrong alignment on UAGO_AfterImage");
static_assert(sizeof(UAGO_AfterImage) == 0x000098, "Wrong size on UAGO_AfterImage");
static_assert(offsetof(UAGO_AfterImage, _materialinterface) == 0x000058, "Member 'UAGO_AfterImage::_materialinterface' has a wrong offset!");
static_assert(offsetof(UAGO_AfterImage, _LifeTime) == 0x000060, "Member 'UAGO_AfterImage::_LifeTime' has a wrong offset!");
static_assert(offsetof(UAGO_AfterImage, _MaterialBaseColor) == 0x000064, "Member 'UAGO_AfterImage::_MaterialBaseColor' has a wrong offset!");
static_assert(offsetof(UAGO_AfterImage, _ParamAndCurves) == 0x000078, "Member 'UAGO_AfterImage::_ParamAndCurves' has a wrong offset!");
static_assert(offsetof(UAGO_AfterImage, _AttachFX) == 0x000088, "Member 'UAGO_AfterImage::_AttachFX' has a wrong offset!");

// Class Stigma.GoToWidget_LobbyPage
// 0x0000 (0x0038 - 0x0038)
class UGoToWidget_LobbyPage final : public UGoToWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GoToWidget_LobbyPage">();
	}
	static class UGoToWidget_LobbyPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGoToWidget_LobbyPage>();
	}
};
static_assert(alignof(UGoToWidget_LobbyPage) == 0x000008, "Wrong alignment on UGoToWidget_LobbyPage");
static_assert(sizeof(UGoToWidget_LobbyPage) == 0x000038, "Wrong size on UGoToWidget_LobbyPage");

// Class Stigma.AutoBooster_Speed
// 0x0000 (0x01B0 - 0x01B0)
class UAutoBooster_Speed final : public UAutoBoosterTrigger
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoBooster_Speed">();
	}
	static class UAutoBooster_Speed* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutoBooster_Speed>();
	}
};
static_assert(alignof(UAutoBooster_Speed) == 0x000008, "Wrong alignment on UAutoBooster_Speed");
static_assert(sizeof(UAutoBooster_Speed) == 0x0001B0, "Wrong size on UAutoBooster_Speed");

// Class Stigma.AGO_AimingShot
// 0x0008 (0x0060 - 0x0058)
class UAGO_AimingShot final : public UActionGraphOperator
{
public:
	EBodyParts                                    AimParts;                                          // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FBC[0x7];                                     // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_AimingShot">();
	}
	static class UAGO_AimingShot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_AimingShot>();
	}
};
static_assert(alignof(UAGO_AimingShot) == 0x000008, "Wrong alignment on UAGO_AimingShot");
static_assert(sizeof(UAGO_AimingShot) == 0x000060, "Wrong size on UAGO_AimingShot");
static_assert(offsetof(UAGO_AimingShot, AimParts) == 0x000058, "Member 'UAGO_AimingShot::AimParts' has a wrong offset!");

// Class Stigma.GunnerSystemComponent
// 0x0018 (0x00B8 - 0x00A0)
class UGunnerSystemComponent : public UActorComponent
{
public:
	uint8                                         Pad_1FBD[0x18];                                    // 0x00A0(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GunnerSystemComponent">();
	}
	static class UGunnerSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGunnerSystemComponent>();
	}
};
static_assert(alignof(UGunnerSystemComponent) == 0x000008, "Wrong alignment on UGunnerSystemComponent");
static_assert(sizeof(UGunnerSystemComponent) == 0x0000B8, "Wrong size on UGunnerSystemComponent");

// Class Stigma.MatchServicedGameState
// 0x0468 (0x0758 - 0x02F0)
class AMatchServicedGameState : public AGameStateBase
{
public:
	EServerStatus                                 _ServerState;                                      // 0x02F0(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FBE[0x7];                                     // 0x02F1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FGameSetting                           _GameSetting;                                      // 0x02F8(0x0040)(BlueprintVisible, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FBF[0x370];                                   // 0x0338(0x0370)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             _OnPlayerJoin;                                     // 0x06A8(0x0010)(ZeroConstructor, InstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FC0[0x18];                                    // 0x06B8(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class AMatchServicedPlayerState*>      _JoinQueue;                                        // 0x06D0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FC1[0x78];                                    // 0x06E0(0x0078)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnRep_GameSetting();
	void OnRep_ServerState(EServerStatus _old_state);
	void RegisterGameSettingNotification(const TDelegate<void(struct FGameSetting& _setting)>& _func);
	void RegisterPlayerJoinNotification(const TDelegate<void(class APlayerState* _ps, EPlayerJoinEvent _event)>& _callback);
	void SERVER_SetServerState(EServerStatus _state);
	void Setter_GameSetting(const struct FGameSetting& _setting);
	void Setter_ServerState(EServerStatus _state);
	void UnregisterGameSettingNotification(const class UObject* _obj);
	void UnregisterPlayerJoinNotification(const class UObject* _obj);

	const struct FGameSetting GetGameSetting() const;
	int32 GetMaxPlayableCharacterCount() const;
	const struct FMode GetModeConfig() const;
	int32 GetRealPlayerCount() const;
	EServerStatus GetServerState() const;
	int32 GetTeamMemberCount(ETeams _Team) const;
	bool IsInBattle() const;
	bool IsPickedCharaInTeam(const struct FUserID& _asker_id, ECharaType _chara_type) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchServicedGameState">();
	}
	static class AMatchServicedGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchServicedGameState>();
	}
};
static_assert(alignof(AMatchServicedGameState) == 0x000008, "Wrong alignment on AMatchServicedGameState");
static_assert(sizeof(AMatchServicedGameState) == 0x000758, "Wrong size on AMatchServicedGameState");
static_assert(offsetof(AMatchServicedGameState, _ServerState) == 0x0002F0, "Member 'AMatchServicedGameState::_ServerState' has a wrong offset!");
static_assert(offsetof(AMatchServicedGameState, _GameSetting) == 0x0002F8, "Member 'AMatchServicedGameState::_GameSetting' has a wrong offset!");
static_assert(offsetof(AMatchServicedGameState, _OnPlayerJoin) == 0x0006A8, "Member 'AMatchServicedGameState::_OnPlayerJoin' has a wrong offset!");
static_assert(offsetof(AMatchServicedGameState, _JoinQueue) == 0x0006D0, "Member 'AMatchServicedGameState::_JoinQueue' has a wrong offset!");

// Class Stigma.BattleGameStateBase
// 0x01B0 (0x0908 - 0x0758)
class ABattleGameStateBase : public AMatchServicedGameState
{
public:
	class UAudioComponent*                        _AlertAudioComp;                                   // 0x0758(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<uint8, struct FCharaEntry>               _CharaMap;                                         // 0x0760(0x0050)(Protected, NativeAccessSpecifierProtected)
	EGameMode                                     _GameMode;                                         // 0x07B0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FC4[0x7];                                     // 0x07B1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FTeamDataArray                         _TeamData;                                         // 0x07B8(0x0118)(Edit, BlueprintVisible, Net, Transient, EditConst, RepNotify, Protected, NativeAccessSpecifierProtected)
	EBattleModePhase                              _CurrentBattlePhase;                               // 0x08D0(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FC5[0x3];                                     // 0x08D1(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         _CurrentRound;                                     // 0x08D4(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _BattlePhaseRemainSec;                             // 0x08D8(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _BattlePhaseDurationSec;                           // 0x08DC(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBarrierData>                   _BarrierData;                                      // 0x08E0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FC6[0x18];                                    // 0x08F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void GetRemainTime(int32* _out_min, int32* _out_sec);
	void OnRep_BattlePhaseDurationSec();
	void OnRep_BattlePhaseRemainSec();
	void OnRep_CurrentBattlePhase();
	void OnRep_CurrentRound();
	void OnRep_TeamData();
	void SetBattlePhase(EBattleModePhase _phase);
	void SetCurrentRound(int32 _round);
	void Setter_BattlePhaseDurationSec(int32 _sec);
	void Setter_BattlePhaseRemainSec(int32 _sec);

	EBattleModePhase GetBattlePhase() const;
	int32 GetBattlePhaseElapsedSec() const;
	int32 GetBattlePhaseRemainSec() const;
	int32 GetCurrentRound() const;
	int32 GetKillCountByTeam(ETeams _Team) const;
	const struct FTeamData GetTeamData(ETeams _Team) const;
	int32 GetTeamRank(ETeams _Team) const;
	int32 GetTeamScore(ETeams _Team) const;
	ETeams GetWinningTeam(bool* _is_tie) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleGameStateBase">();
	}
	static class ABattleGameStateBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattleGameStateBase>();
	}
};
static_assert(alignof(ABattleGameStateBase) == 0x000008, "Wrong alignment on ABattleGameStateBase");
static_assert(sizeof(ABattleGameStateBase) == 0x000908, "Wrong size on ABattleGameStateBase");
static_assert(offsetof(ABattleGameStateBase, _AlertAudioComp) == 0x000758, "Member 'ABattleGameStateBase::_AlertAudioComp' has a wrong offset!");
static_assert(offsetof(ABattleGameStateBase, _CharaMap) == 0x000760, "Member 'ABattleGameStateBase::_CharaMap' has a wrong offset!");
static_assert(offsetof(ABattleGameStateBase, _GameMode) == 0x0007B0, "Member 'ABattleGameStateBase::_GameMode' has a wrong offset!");
static_assert(offsetof(ABattleGameStateBase, _TeamData) == 0x0007B8, "Member 'ABattleGameStateBase::_TeamData' has a wrong offset!");
static_assert(offsetof(ABattleGameStateBase, _CurrentBattlePhase) == 0x0008D0, "Member 'ABattleGameStateBase::_CurrentBattlePhase' has a wrong offset!");
static_assert(offsetof(ABattleGameStateBase, _CurrentRound) == 0x0008D4, "Member 'ABattleGameStateBase::_CurrentRound' has a wrong offset!");
static_assert(offsetof(ABattleGameStateBase, _BattlePhaseRemainSec) == 0x0008D8, "Member 'ABattleGameStateBase::_BattlePhaseRemainSec' has a wrong offset!");
static_assert(offsetof(ABattleGameStateBase, _BattlePhaseDurationSec) == 0x0008DC, "Member 'ABattleGameStateBase::_BattlePhaseDurationSec' has a wrong offset!");
static_assert(offsetof(ABattleGameStateBase, _BarrierData) == 0x0008E0, "Member 'ABattleGameStateBase::_BarrierData' has a wrong offset!");

// Class Stigma.BountyTDM_GameState
// 0x01D8 (0x0AE0 - 0x0908)
class ABountyTDM_GameState : public ABattleGameStateBase
{
public:
	struct FGTATeamDataArray                      _GTATeamData;                                      // 0x0908(0x0118)(BlueprintVisible, Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	uint8                                         _CurrentPhase;                                     // 0x0A20(0x0001)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _ShouldFinishEarly;                                // 0x0A21(0x0001)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FCB[0x6];                                     // 0x0A22(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	struct FBountyRule                            _BountyRule;                                       // 0x0A28(0x00A0)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FBounty_GoldRule                       _GoldRule;                                         // 0x0AC8(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FCC[0x4];                                     // 0x0ADC(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void IncTeamTotalBounty(ETeams _Team, int32 _inc_bounty, class ABountyTDM_PlayerState* _increased_by);
	void OnRep_CurrentPhase();
	void OnRep_GTATeamData();
	void OnRep_ShouldFinishEarly();
	void SetCurrentPhase(int32 _phase);

	const struct FBountyRule GetBountyRule() const;
	uint8 GetCurrentBountyPhase() const;
	const struct FBountyPhaseDefine GetCurrentBountyPhaseDefine() const;
	const struct FBounty_GoldRule GetGoldRule() const;
	float GetStealProgressRatio(ETeams _Team) const;
	float GetStealProgressTime(ETeams _Team) const;
	int32 GetTransferUnit() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BountyTDM_GameState">();
	}
	static class ABountyTDM_GameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABountyTDM_GameState>();
	}
};
static_assert(alignof(ABountyTDM_GameState) == 0x000008, "Wrong alignment on ABountyTDM_GameState");
static_assert(sizeof(ABountyTDM_GameState) == 0x000AE0, "Wrong size on ABountyTDM_GameState");
static_assert(offsetof(ABountyTDM_GameState, _GTATeamData) == 0x000908, "Member 'ABountyTDM_GameState::_GTATeamData' has a wrong offset!");
static_assert(offsetof(ABountyTDM_GameState, _CurrentPhase) == 0x000A20, "Member 'ABountyTDM_GameState::_CurrentPhase' has a wrong offset!");
static_assert(offsetof(ABountyTDM_GameState, _ShouldFinishEarly) == 0x000A21, "Member 'ABountyTDM_GameState::_ShouldFinishEarly' has a wrong offset!");
static_assert(offsetof(ABountyTDM_GameState, _BountyRule) == 0x000A28, "Member 'ABountyTDM_GameState::_BountyRule' has a wrong offset!");
static_assert(offsetof(ABountyTDM_GameState, _GoldRule) == 0x000AC8, "Member 'ABountyTDM_GameState::_GoldRule' has a wrong offset!");

// Class Stigma.AGO_AntiAbnormal
// 0x0008 (0x0060 - 0x0058)
class UAGO_AntiAbnormal final : public UActionGraphOperator
{
public:
	bool                                          Anti_DoubleTap;                                    // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Anti_LegInjury;                                    // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Anti_ElectricShock;                                // 0x005A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FD0[0x5];                                     // 0x005B(0x0005)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_AntiAbnormal">();
	}
	static class UAGO_AntiAbnormal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_AntiAbnormal>();
	}
};
static_assert(alignof(UAGO_AntiAbnormal) == 0x000008, "Wrong alignment on UAGO_AntiAbnormal");
static_assert(sizeof(UAGO_AntiAbnormal) == 0x000060, "Wrong size on UAGO_AntiAbnormal");
static_assert(offsetof(UAGO_AntiAbnormal, Anti_DoubleTap) == 0x000058, "Member 'UAGO_AntiAbnormal::Anti_DoubleTap' has a wrong offset!");
static_assert(offsetof(UAGO_AntiAbnormal, Anti_LegInjury) == 0x000059, "Member 'UAGO_AntiAbnormal::Anti_LegInjury' has a wrong offset!");
static_assert(offsetof(UAGO_AntiAbnormal, Anti_ElectricShock) == 0x00005A, "Member 'UAGO_AntiAbnormal::Anti_ElectricShock' has a wrong offset!");

// Class Stigma.FullScreenComponent
// 0x0010 (0x0580 - 0x0570)
class UFullScreenComponent final : public UPrimitiveComponent
{
public:
	class UMaterialInterface*                     _Material;                                         // 0x0570(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FD1[0x8];                                     // 0x0578(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FullScreenComponent">();
	}
	static class UFullScreenComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFullScreenComponent>();
	}
};
static_assert(alignof(UFullScreenComponent) == 0x000010, "Wrong alignment on UFullScreenComponent");
static_assert(sizeof(UFullScreenComponent) == 0x000580, "Wrong size on UFullScreenComponent");
static_assert(offsetof(UFullScreenComponent, _Material) == 0x000570, "Member 'UFullScreenComponent::_Material' has a wrong offset!");

// Class Stigma.UI_HUDMission
// 0x0028 (0x0518 - 0x04F0)
class UUI_HUDMission : public UPreviewableWidget
{
public:
	class UCtrl_CommonProgressBar*                ProgressBar;                                       // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FD2[0x20];                                    // 0x04F8(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void InitWidget();
	void OnMissionUpdated(EMissionUpdateType _type, class UMission* _mission);
	void SetCompleted();
	void SetDesc(const class FText& _text);
	void SetTitle(const class FText& _text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_HUDMission">();
	}
	static class UUI_HUDMission* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_HUDMission>();
	}
};
static_assert(alignof(UUI_HUDMission) == 0x000008, "Wrong alignment on UUI_HUDMission");
static_assert(sizeof(UUI_HUDMission) == 0x000518, "Wrong size on UUI_HUDMission");
static_assert(offsetof(UUI_HUDMission, ProgressBar) == 0x0004F0, "Member 'UUI_HUDMission::ProgressBar' has a wrong offset!");

// Class Stigma.AGO_AntiGunDamage
// 0x0008 (0x0060 - 0x0058)
class UAGO_AntiGunDamage final : public UActionGraphOperator
{
public:
	float                                         _DamageRate;                                       // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FD4[0x4];                                     // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_AntiGunDamage">();
	}
	static class UAGO_AntiGunDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_AntiGunDamage>();
	}
};
static_assert(alignof(UAGO_AntiGunDamage) == 0x000008, "Wrong alignment on UAGO_AntiGunDamage");
static_assert(sizeof(UAGO_AntiGunDamage) == 0x000060, "Wrong size on UAGO_AntiGunDamage");
static_assert(offsetof(UAGO_AntiGunDamage, _DamageRate) == 0x000058, "Member 'UAGO_AntiGunDamage::_DamageRate' has a wrong offset!");

// Class Stigma.BTScore
// 0x0008 (0x0030 - 0x0028)
class UBTScore : public UObject
{
public:
	bool                                          Enable;                                            // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD5[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	float GetScore(class AAdvancedAIController* _controller);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTScore">();
	}
	static class UBTScore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTScore>();
	}
};
static_assert(alignof(UBTScore) == 0x000008, "Wrong alignment on UBTScore");
static_assert(sizeof(UBTScore) == 0x000030, "Wrong size on UBTScore");
static_assert(offsetof(UBTScore, Enable) == 0x000028, "Member 'UBTScore::Enable' has a wrong offset!");

// Class Stigma.BTScore_Const
// 0x0010 (0x0040 - 0x0030)
class UBTScore_Const final : public UBTScore
{
public:
	EScoreFrom                                    From;                                              // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FD7[0x3];                                     // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         Score;                                             // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DumbScaler;                                        // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoDumbScaler;                                      // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTScore_Const">();
	}
	static class UBTScore_Const* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTScore_Const>();
	}
};
static_assert(alignof(UBTScore_Const) == 0x000008, "Wrong alignment on UBTScore_Const");
static_assert(sizeof(UBTScore_Const) == 0x000040, "Wrong size on UBTScore_Const");
static_assert(offsetof(UBTScore_Const, From) == 0x000030, "Member 'UBTScore_Const::From' has a wrong offset!");
static_assert(offsetof(UBTScore_Const, Score) == 0x000034, "Member 'UBTScore_Const::Score' has a wrong offset!");
static_assert(offsetof(UBTScore_Const, DumbScaler) == 0x000038, "Member 'UBTScore_Const::DumbScaler' has a wrong offset!");
static_assert(offsetof(UBTScore_Const, NoDumbScaler) == 0x00003C, "Member 'UBTScore_Const::NoDumbScaler' has a wrong offset!");

// Class Stigma.AGO_AttachObject
// 0x0068 (0x00C0 - 0x0058)
class UAGO_AttachObject final : public UActionGraphOperator
{
public:
	TMap<struct FItemID, TSubclassOf<class AObjectBase>> _BodyID_With_ObjectBase;                           // 0x0058(0x0050)(Edit, BlueprintVisible, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSubclassOf<class AObjectBase>                ObjectType;                                        // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SocketName;                                        // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FD8[0x8];                                     // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_AttachObject">();
	}
	static class UAGO_AttachObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_AttachObject>();
	}
};
static_assert(alignof(UAGO_AttachObject) == 0x000008, "Wrong alignment on UAGO_AttachObject");
static_assert(sizeof(UAGO_AttachObject) == 0x0000C0, "Wrong size on UAGO_AttachObject");
static_assert(offsetof(UAGO_AttachObject, _BodyID_With_ObjectBase) == 0x000058, "Member 'UAGO_AttachObject::_BodyID_With_ObjectBase' has a wrong offset!");
static_assert(offsetof(UAGO_AttachObject, ObjectType) == 0x0000A8, "Member 'UAGO_AttachObject::ObjectType' has a wrong offset!");
static_assert(offsetof(UAGO_AttachObject, SocketName) == 0x0000B0, "Member 'UAGO_AttachObject::SocketName' has a wrong offset!");

// Class Stigma.AGO_Base
// 0x0000 (0x0058 - 0x0058)
class UAGO_Base : public UActionGraphOperator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_Base">();
	}
	static class UAGO_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_Base>();
	}
};
static_assert(alignof(UAGO_Base) == 0x000008, "Wrong alignment on UAGO_Base");
static_assert(sizeof(UAGO_Base) == 0x000058, "Wrong size on UAGO_Base");

// Class Stigma.Breakable
// 0x0030 (0x02C8 - 0x0298)
class ABreakable final : public AActor
{
public:
	uint8                                         Pad_1FD9[0x8];                                     // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         _MaxHP;                                            // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _hp;                                               // 0x02A4(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UBreakStepComponent*>            _Steps;                                            // 0x02A8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class USceneComponent*                        _Root;                                             // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FDA[0x8];                                     // 0x02C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool OnBreaked(class FName _step_name, float _current_hp);
	void OnRep_HP(float _old_hp);
	void Setter_HP(float _new_hp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Breakable">();
	}
	static class ABreakable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABreakable>();
	}
};
static_assert(alignof(ABreakable) == 0x000008, "Wrong alignment on ABreakable");
static_assert(sizeof(ABreakable) == 0x0002C8, "Wrong size on ABreakable");
static_assert(offsetof(ABreakable, _MaxHP) == 0x0002A0, "Member 'ABreakable::_MaxHP' has a wrong offset!");
static_assert(offsetof(ABreakable, _hp) == 0x0002A4, "Member 'ABreakable::_hp' has a wrong offset!");
static_assert(offsetof(ABreakable, _Steps) == 0x0002A8, "Member 'ABreakable::_Steps' has a wrong offset!");
static_assert(offsetof(ABreakable, _Root) == 0x0002B8, "Member 'ABreakable::_Root' has a wrong offset!");

// Class Stigma.AGO_BlendUpperStrongly
// 0x00A0 (0x00F8 - 0x0058)
class UAGO_BlendUpperStrongly final : public UActionGraphOperator
{
public:
	struct FActionStock                           ActionStock;                                       // 0x0058(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FDC[0x50];                                    // 0x00A8(0x0050)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_BlendUpperStrongly">();
	}
	static class UAGO_BlendUpperStrongly* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_BlendUpperStrongly>();
	}
};
static_assert(alignof(UAGO_BlendUpperStrongly) == 0x000008, "Wrong alignment on UAGO_BlendUpperStrongly");
static_assert(sizeof(UAGO_BlendUpperStrongly) == 0x0000F8, "Wrong size on UAGO_BlendUpperStrongly");
static_assert(offsetof(UAGO_BlendUpperStrongly, ActionStock) == 0x000058, "Member 'UAGO_BlendUpperStrongly::ActionStock' has a wrong offset!");

// Class Stigma.UI_BattlePassBriefBackground
// 0x0000 (0x04F0 - 0x04F0)
class UUI_BattlePassBriefBackground : public UPreviewableWidget
{
public:
	void ShowDetail(bool _show);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_BattlePassBriefBackground">();
	}
	static class UUI_BattlePassBriefBackground* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_BattlePassBriefBackground>();
	}
};
static_assert(alignof(UUI_BattlePassBriefBackground) == 0x000008, "Wrong alignment on UUI_BattlePassBriefBackground");
static_assert(sizeof(UUI_BattlePassBriefBackground) == 0x0004F0, "Wrong size on UUI_BattlePassBriefBackground");

// Class Stigma.AGO_Blocking
// 0x0008 (0x0060 - 0x0058)
class UAGO_Blocking final : public UActionGraphOperator
{
public:
	float                                         DamageBlockRate;                                   // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FDD[0x4];                                     // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_Blocking">();
	}
	static class UAGO_Blocking* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_Blocking>();
	}
};
static_assert(alignof(UAGO_Blocking) == 0x000008, "Wrong alignment on UAGO_Blocking");
static_assert(sizeof(UAGO_Blocking) == 0x000060, "Wrong size on UAGO_Blocking");
static_assert(offsetof(UAGO_Blocking, DamageBlockRate) == 0x000058, "Member 'UAGO_Blocking::DamageBlockRate' has a wrong offset!");

// Class Stigma.AGO_BodyPhysicalState
// 0x0008 (0x0060 - 0x0058)
class UAGO_BodyPhysicalState final : public UActionGraphOperator
{
public:
	EBodyPhysicalState                            BodyState;                                         // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CallEnd;                                           // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FDE[0x6];                                     // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_BodyPhysicalState">();
	}
	static class UAGO_BodyPhysicalState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_BodyPhysicalState>();
	}
};
static_assert(alignof(UAGO_BodyPhysicalState) == 0x000008, "Wrong alignment on UAGO_BodyPhysicalState");
static_assert(sizeof(UAGO_BodyPhysicalState) == 0x000060, "Wrong size on UAGO_BodyPhysicalState");
static_assert(offsetof(UAGO_BodyPhysicalState, BodyState) == 0x000058, "Member 'UAGO_BodyPhysicalState::BodyState' has a wrong offset!");
static_assert(offsetof(UAGO_BodyPhysicalState, CallEnd) == 0x000059, "Member 'UAGO_BodyPhysicalState::CallEnd' has a wrong offset!");

// Class Stigma.GunGraphValuesBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UGunGraphValuesBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FGunGraphValues GetGunBuffedGraphValues(ECharaType _chara_type, const struct FGunEntry_Main& _Config, const struct FGunEntry_Body& _body_config, const struct FGunAttribute_Common& _gun_object_attribute, const struct FGunBuffEffect& _effect);
	static struct FGunBuffEffect GetGunBuffEffectOfBoosters(const TArray<struct FItemID_Booster>& _boosters);
	static struct FGunBuffEffect GetGunBuffEffectOfPassiveSkills(const TArray<struct FPassiveSkill>& _passive_skills);
	static struct FGunGraphValues GetGunGraphValues(ECharaType _chara_type, const struct FGunEntry_Main& _Config, const struct FGunEntry_Body& _body_config, const struct FGunBuffEffect& _effect);
	static struct FGunGraphValues GetGunObjectGraphValues(ECharaType _chara_type, const struct FGunEntry_Main& _Config, const struct FGunEntry_Body& _body_config, const struct FGunAttribute_Common& _gun_object_attribute, const struct FGunBuffEffect& _effect);
	static struct FGunGraphValues GetGunPartsGraphValues(ECharaType _chara_type, const struct FGunEntry_Main& _Config, const struct FGunEntry_Body& _body_config, const struct FGunAttribute_Common& _gun_parts_attribute, const struct FGunBuffEffect& _effect);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GunGraphValuesBlueprintLibrary">();
	}
	static class UGunGraphValuesBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGunGraphValuesBlueprintLibrary>();
	}
};
static_assert(alignof(UGunGraphValuesBlueprintLibrary) == 0x000008, "Wrong alignment on UGunGraphValuesBlueprintLibrary");
static_assert(sizeof(UGunGraphValuesBlueprintLibrary) == 0x000028, "Wrong size on UGunGraphValuesBlueprintLibrary");

// Class Stigma.ThrowBase
// 0x0250 (0x07E0 - 0x0590)
class AThrowBase : public AObjectBase
{
public:
	uint8                                         Pad_1FE4[0x8];                                     // 0x0588(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UArrowComponent*                        _RootRotationPivot;                                // 0x0590(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrowComponent*                        _RotationPivot;                                    // 0x0598(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrowComponent*                        _StuckPoint;                                       // 0x05A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USplineComponent*                       _Spline;                                           // 0x05A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         _SplineNiagaraSystem;                              // 0x05B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USplineComponent*                       _Spline_Guide;                                     // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      _Spline_NiagaraComponent;                          // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ATargetArea*                            _EndTrajectoryArea;                                // 0x05C8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELifeControlByColliding                       _LifeControlByColliding;                           // 0x05D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FE5[0x7];                                     // 0x05D1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TSet<EAntiAbnormal>                           _AntiAbnormals;                                    // 0x05D8(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	int32                                         PointCount;                                        // 0x0628(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SplintSamplingInterval;                            // 0x062C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetPoint;                                       // 0x0630(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharaBase*                             _thrower;                                          // 0x0648(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeams                                        _Team;                                             // 0x0650(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FE6[0x7];                                     // 0x0651(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class AActor*>                         _IgnoreCollisionActors;                            // 0x0658(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FE7[0x178];                                   // 0x0668(0x0178)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool OnCollide(const struct FHitResult& _hit);
	struct FRotator OnGetStuckRotation();

	struct FVector GetLastVelocity() const;
	struct FActionGraphOperatorID GetThrowActionGraphOperatorID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThrowBase">();
	}
	static class AThrowBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AThrowBase>();
	}
};
static_assert(alignof(AThrowBase) == 0x000010, "Wrong alignment on AThrowBase");
static_assert(sizeof(AThrowBase) == 0x0007E0, "Wrong size on AThrowBase");
static_assert(offsetof(AThrowBase, _RootRotationPivot) == 0x000590, "Member 'AThrowBase::_RootRotationPivot' has a wrong offset!");
static_assert(offsetof(AThrowBase, _RotationPivot) == 0x000598, "Member 'AThrowBase::_RotationPivot' has a wrong offset!");
static_assert(offsetof(AThrowBase, _StuckPoint) == 0x0005A0, "Member 'AThrowBase::_StuckPoint' has a wrong offset!");
static_assert(offsetof(AThrowBase, _Spline) == 0x0005A8, "Member 'AThrowBase::_Spline' has a wrong offset!");
static_assert(offsetof(AThrowBase, _SplineNiagaraSystem) == 0x0005B0, "Member 'AThrowBase::_SplineNiagaraSystem' has a wrong offset!");
static_assert(offsetof(AThrowBase, _Spline_Guide) == 0x0005B8, "Member 'AThrowBase::_Spline_Guide' has a wrong offset!");
static_assert(offsetof(AThrowBase, _Spline_NiagaraComponent) == 0x0005C0, "Member 'AThrowBase::_Spline_NiagaraComponent' has a wrong offset!");
static_assert(offsetof(AThrowBase, _EndTrajectoryArea) == 0x0005C8, "Member 'AThrowBase::_EndTrajectoryArea' has a wrong offset!");
static_assert(offsetof(AThrowBase, _LifeControlByColliding) == 0x0005D0, "Member 'AThrowBase::_LifeControlByColliding' has a wrong offset!");
static_assert(offsetof(AThrowBase, _AntiAbnormals) == 0x0005D8, "Member 'AThrowBase::_AntiAbnormals' has a wrong offset!");
static_assert(offsetof(AThrowBase, PointCount) == 0x000628, "Member 'AThrowBase::PointCount' has a wrong offset!");
static_assert(offsetof(AThrowBase, SplintSamplingInterval) == 0x00062C, "Member 'AThrowBase::SplintSamplingInterval' has a wrong offset!");
static_assert(offsetof(AThrowBase, TargetPoint) == 0x000630, "Member 'AThrowBase::TargetPoint' has a wrong offset!");
static_assert(offsetof(AThrowBase, _thrower) == 0x000648, "Member 'AThrowBase::_thrower' has a wrong offset!");
static_assert(offsetof(AThrowBase, _Team) == 0x000650, "Member 'AThrowBase::_Team' has a wrong offset!");
static_assert(offsetof(AThrowBase, _IgnoreCollisionActors) == 0x000658, "Member 'AThrowBase::_IgnoreCollisionActors' has a wrong offset!");

// Class Stigma.BombBase
// 0x0080 (0x0860 - 0x07E0)
#pragma pack(push, 0x1)
class alignas(0x10) ABombBase : public AThrowBase
{
public:
	uint8                                         Pad_1FE9[0x38];                                    // 0x07E0(0x0038)(Fixing Size After Last Property [ Dumper-69 ])
	EObjectState                                  HitObjectState;                                    // 0x0818(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FEA[0x3];                                     // 0x0819(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         InnerRange;                                        // 0x081C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OuterRange;                                        // 0x0820(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FEB[0x2C];                                    // 0x0824(0x002C)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UUI_IndicatorWidget>        _IndicatorWidgetClass;                             // 0x0850(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool OnExplosion();
	void SERVER_HittedBombChara(class ACharaBase* _hitted, const struct FHitData& _hit_data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BombBase">();
	}
	static class ABombBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABombBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(ABombBase) == 0x000010, "Wrong alignment on ABombBase");
static_assert(sizeof(ABombBase) == 0x000860, "Wrong size on ABombBase");
static_assert(offsetof(ABombBase, HitObjectState) == 0x000818, "Member 'ABombBase::HitObjectState' has a wrong offset!");
static_assert(offsetof(ABombBase, InnerRange) == 0x00081C, "Member 'ABombBase::InnerRange' has a wrong offset!");
static_assert(offsetof(ABombBase, OuterRange) == 0x000820, "Member 'ABombBase::OuterRange' has a wrong offset!");
static_assert(offsetof(ABombBase, _IndicatorWidgetClass) == 0x000850, "Member 'ABombBase::_IndicatorWidgetClass' has a wrong offset!");

// Class Stigma.AGO_BodyState
// 0x0008 (0x0060 - 0x0058)
class UAGO_BodyState final : public UActionGraphOperator
{
public:
	EBodyLowerState                               BeginState;                                        // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBodyLowerState                               EndState;                                          // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CallEndState;                                      // 0x005A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FEC[0x5];                                     // 0x005B(0x0005)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_BodyState">();
	}
	static class UAGO_BodyState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_BodyState>();
	}
};
static_assert(alignof(UAGO_BodyState) == 0x000008, "Wrong alignment on UAGO_BodyState");
static_assert(sizeof(UAGO_BodyState) == 0x000060, "Wrong size on UAGO_BodyState");
static_assert(offsetof(UAGO_BodyState, BeginState) == 0x000058, "Member 'UAGO_BodyState::BeginState' has a wrong offset!");
static_assert(offsetof(UAGO_BodyState, EndState) == 0x000059, "Member 'UAGO_BodyState::EndState' has a wrong offset!");
static_assert(offsetof(UAGO_BodyState, CallEndState) == 0x00005A, "Member 'UAGO_BodyState::CallEndState' has a wrong offset!");

// Class Stigma.AIDeco_CanAction
// 0x0008 (0x0070 - 0x0068)
class UAIDeco_CanAction final : public UBTDecorator
{
public:
	ECharaAction                                  Action;                                            // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FED[0x7];                                     // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDeco_CanAction">();
	}
	static class UAIDeco_CanAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDeco_CanAction>();
	}
};
static_assert(alignof(UAIDeco_CanAction) == 0x000008, "Wrong alignment on UAIDeco_CanAction");
static_assert(sizeof(UAIDeco_CanAction) == 0x000070, "Wrong size on UAIDeco_CanAction");
static_assert(offsetof(UAIDeco_CanAction, Action) == 0x000068, "Member 'UAIDeco_CanAction::Action' has a wrong offset!");

// Class Stigma.AGO_CallAction
// 0x0008 (0x0060 - 0x0058)
class UAGO_CallAction final : public UActionGraphOperator
{
public:
	ECharaAction                                  _action;                                           // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FEE[0x7];                                     // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_CallAction">();
	}
	static class UAGO_CallAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_CallAction>();
	}
};
static_assert(alignof(UAGO_CallAction) == 0x000008, "Wrong alignment on UAGO_CallAction");
static_assert(sizeof(UAGO_CallAction) == 0x000060, "Wrong size on UAGO_CallAction");
static_assert(offsetof(UAGO_CallAction, _action) == 0x000058, "Member 'UAGO_CallAction::_action' has a wrong offset!");

// Class Stigma.UI_ContentUnlocker
// 0x0020 (0x0510 - 0x04F0)
class UUI_ContentUnlocker : public UPreviewableWidget
{
public:
	float                                         _LifeTime;                                         // 0x04F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FEF[0x1C];                                    // 0x04F4(0x001C)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnClickGoToBtn();
	void SetDesc(const class FText& _Desc);
	void SetIcon(const TSoftObjectPtr<class UTexture2D>& _Icon);
	void SetSubDesc(const class FText& _sub_desc);
	void SetTitle(const class FText& _Title);
	void ShowGoToButton(bool _show);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_ContentUnlocker">();
	}
	static class UUI_ContentUnlocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_ContentUnlocker>();
	}
};
static_assert(alignof(UUI_ContentUnlocker) == 0x000008, "Wrong alignment on UUI_ContentUnlocker");
static_assert(sizeof(UUI_ContentUnlocker) == 0x000510, "Wrong size on UUI_ContentUnlocker");
static_assert(offsetof(UUI_ContentUnlocker, _LifeTime) == 0x0004F0, "Member 'UUI_ContentUnlocker::_LifeTime' has a wrong offset!");

// Class Stigma.AGO_CameraDirecting
// 0x0030 (0x0088 - 0x0058)
class UAGO_CameraDirecting final : public UActionGraphOperator
{
public:
	struct FCameraLagParams                       LaggingParams;                                     // 0x0058(0x0010)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FCameraDirectingParams                 DirectingParam;                                    // 0x0068(0x0020)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_CameraDirecting">();
	}
	static class UAGO_CameraDirecting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_CameraDirecting>();
	}
};
static_assert(alignof(UAGO_CameraDirecting) == 0x000008, "Wrong alignment on UAGO_CameraDirecting");
static_assert(sizeof(UAGO_CameraDirecting) == 0x000088, "Wrong size on UAGO_CameraDirecting");
static_assert(offsetof(UAGO_CameraDirecting, LaggingParams) == 0x000058, "Member 'UAGO_CameraDirecting::LaggingParams' has a wrong offset!");
static_assert(offsetof(UAGO_CameraDirecting, DirectingParam) == 0x000068, "Member 'UAGO_CameraDirecting::DirectingParam' has a wrong offset!");

// Class Stigma.BTService_GTA_Strategy
// 0x0000 (0x0070 - 0x0070)
class UBTService_GTA_Strategy final : public UBTService
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_GTA_Strategy">();
	}
	static class UBTService_GTA_Strategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_GTA_Strategy>();
	}
};
static_assert(alignof(UBTService_GTA_Strategy) == 0x000008, "Wrong alignment on UBTService_GTA_Strategy");
static_assert(sizeof(UBTService_GTA_Strategy) == 0x000070, "Wrong size on UBTService_GTA_Strategy");

// Class Stigma.AGO_CameraWalk
// 0x0010 (0x0068 - 0x0058)
class UAGO_CameraWalk final : public UActionGraphOperator
{
public:
	ECameraWalkMode                               Mode;                                              // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESideViewSide                                 Side;                                              // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ChangeLagging;                                     // 0x005A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          EnableLagging;                                     // 0x005B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LocationLaggingSpeed;                              // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          EnableRotationLagging;                             // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FF0[0x3];                                     // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         RotationLaggingSpeed;                              // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_CameraWalk">();
	}
	static class UAGO_CameraWalk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_CameraWalk>();
	}
};
static_assert(alignof(UAGO_CameraWalk) == 0x000008, "Wrong alignment on UAGO_CameraWalk");
static_assert(sizeof(UAGO_CameraWalk) == 0x000068, "Wrong size on UAGO_CameraWalk");
static_assert(offsetof(UAGO_CameraWalk, Mode) == 0x000058, "Member 'UAGO_CameraWalk::Mode' has a wrong offset!");
static_assert(offsetof(UAGO_CameraWalk, Side) == 0x000059, "Member 'UAGO_CameraWalk::Side' has a wrong offset!");
static_assert(offsetof(UAGO_CameraWalk, ChangeLagging) == 0x00005A, "Member 'UAGO_CameraWalk::ChangeLagging' has a wrong offset!");
static_assert(offsetof(UAGO_CameraWalk, EnableLagging) == 0x00005B, "Member 'UAGO_CameraWalk::EnableLagging' has a wrong offset!");
static_assert(offsetof(UAGO_CameraWalk, LocationLaggingSpeed) == 0x00005C, "Member 'UAGO_CameraWalk::LocationLaggingSpeed' has a wrong offset!");
static_assert(offsetof(UAGO_CameraWalk, EnableRotationLagging) == 0x000060, "Member 'UAGO_CameraWalk::EnableRotationLagging' has a wrong offset!");
static_assert(offsetof(UAGO_CameraWalk, RotationLaggingSpeed) == 0x000064, "Member 'UAGO_CameraWalk::RotationLaggingSpeed' has a wrong offset!");

// Class Stigma.AGO_CanTransit
// 0x0008 (0x0060 - 0x0058)
class UAGO_CanTransit final : public UActionGraphOperator
{
public:
	int32                                         Flags_AGO_CanTransit;                              // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1FF1[0x4];                                     // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_CanTransit">();
	}
	static class UAGO_CanTransit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_CanTransit>();
	}
};
static_assert(alignof(UAGO_CanTransit) == 0x000008, "Wrong alignment on UAGO_CanTransit");
static_assert(sizeof(UAGO_CanTransit) == 0x000060, "Wrong size on UAGO_CanTransit");
static_assert(offsetof(UAGO_CanTransit, Flags_AGO_CanTransit) == 0x000058, "Member 'UAGO_CanTransit::Flags_AGO_CanTransit' has a wrong offset!");

// Class Stigma.AIDeco_CharacterBase
// 0x0000 (0x0068 - 0x0068)
class UAIDeco_CharacterBase : public UBTDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDeco_CharacterBase">();
	}
	static class UAIDeco_CharacterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDeco_CharacterBase>();
	}
};
static_assert(alignof(UAIDeco_CharacterBase) == 0x000008, "Wrong alignment on UAIDeco_CharacterBase");
static_assert(sizeof(UAIDeco_CharacterBase) == 0x000068, "Wrong size on UAIDeco_CharacterBase");

// Class Stigma.AIDeco__V3_IsAlive
// 0x0000 (0x0068 - 0x0068)
class UAIDeco__V3_IsAlive final : public UAIDeco_CharacterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDeco__V3_IsAlive">();
	}
	static class UAIDeco__V3_IsAlive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDeco__V3_IsAlive>();
	}
};
static_assert(alignof(UAIDeco__V3_IsAlive) == 0x000008, "Wrong alignment on UAIDeco__V3_IsAlive");
static_assert(sizeof(UAIDeco__V3_IsAlive) == 0x000068, "Wrong size on UAIDeco__V3_IsAlive");

// Class Stigma.AGO_CapsuleCollision
// 0x0008 (0x0060 - 0x0058)
class UAGO_CapsuleCollision final : public UActionGraphOperator
{
public:
	bool                                          CollisionOff;                                      // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          GravityOff;                                        // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FF2[0x6];                                     // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_CapsuleCollision">();
	}
	static class UAGO_CapsuleCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_CapsuleCollision>();
	}
};
static_assert(alignof(UAGO_CapsuleCollision) == 0x000008, "Wrong alignment on UAGO_CapsuleCollision");
static_assert(sizeof(UAGO_CapsuleCollision) == 0x000060, "Wrong size on UAGO_CapsuleCollision");
static_assert(offsetof(UAGO_CapsuleCollision, CollisionOff) == 0x000058, "Member 'UAGO_CapsuleCollision::CollisionOff' has a wrong offset!");
static_assert(offsetof(UAGO_CapsuleCollision, GravityOff) == 0x000059, "Member 'UAGO_CapsuleCollision::GravityOff' has a wrong offset!");

// Class Stigma.StigmaGameInstance
// 0x05B8 (0x0828 - 0x0270)
class UStigmaGameInstance final : public UBPGGameInstance
{
public:
	class UServiceConnection*                     _ServiceConnection;                                // 0x0270(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClientSession*                         _ClientSession;                                    // 0x0278(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULocalPlayerContext*                    _LocalPlayerCtx;                                   // 0x0280(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FF3[0x130];                                   // 0x0288(0x0130)(Fixing Size After Last Property [ Dumper-69 ])
	class UDiscordSDK*                            _DiscordSDK;                                       // 0x03B8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FF4[0x8];                                     // 0x03C0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UToastManager*                          _ToastManager;                                     // 0x03C8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UChatManager*                           _ChatManager;                                      // 0x03D0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UUserProfile*>                   _EmptyFriendList;                                  // 0x03D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UServerSession*                         _ServerSession;                                    // 0x03E8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMQConnection*                          _MQConnection;                                     // 0x03F0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FF5[0x390];                                   // 0x03F8(0x0390)(Fixing Size After Last Property [ Dumper-69 ])
	class FString                                 _NoticeBannerURL;                                  // 0x0788(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FF6[0x90];                                    // 0x0798(0x0090)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static void ShowLoadingScreen(const class UObject* _world_ctx, bool Show);

	void AddWishedGameMode(EGameMode _mode);
	void DISCORD_StartBattle();
	void DISCORD_StartLobby();
	class UChatManager* GetChatManager();
	const TArray<class UUserProfile*> GetEmptyFriendList();
	EGameMode GetRecommendedGameMode();
	class USocialContext* GetSocialContext();
	class UToastManager* GetToastManager();
	void LoadFromService_Characters(const TArray<struct FNetCharacter>& _infos);
	void LoadFromService_LastUsedCharaType(ECharaType _chara_type);
	bool OnQueryCloseWindow();
	void RegisterOnLobbyUIInitialized(const TDelegate<void()>& _callback);
	void RemoveWishedGameMode(EGameMode _mode);
	void RevertPreviewCharaSettings();
	void SetBattleSettingsForClient(EGameMode _game_mode, const class FString& _map_name, bool _is_tutorial_match, const class FString& _option);
	void SetGunPreset(ECharaType _chara_type, const struct FGunPreset& _gun_preset);
	void SetPickRegion(const class FString& _region_code, bool _picked);
	void SetPreviewChara(ECharaType _chara_type);
	void SetPreviewCharaArmor(EArmorType _Armor);
	void SetPreviewCharaBodyID(const struct FItemID_Skin_Body& _body_id);
	void SetPreviewCharaHeadID(const struct FItemID_Skin_Head& _head_id);
	void SetUserPlayingAt(EUserPlayingAt _playing_at);
	void SetWishedGameMode(EGameMode _mode);
	void UpdateMatch_Finish();
	void UpdateMatch_Matched(const struct FMatchMakingInfo& _match_info);
	void UpdateMatch_Start();
	void UpdateMatch_WaitAck(bool _is_custom_game);

	bool AmIMatchBanned() const;
	bool CanStartMatchMaking() const;
	TArray<class FString> GetAllRegionCodes() const;
	const struct FBattleDecisionDetail GetBattleResult_Decision() const;
	ETeams GetBattleResult_MyTeam() const;
	const struct FRegion GetBestPickedRegionData() const;
	class ULocalPlayerContext* GetLocalPlayerContext() const;
	float GetLoginElapsedSec() const;
	const struct FMatchContext GetMatchMakingContext() const;
	struct FTimespan GetMatchMakingElapsedTime() const;
	const class FText GetMatchMakingErrorMessage() const;
	EFindMatchStatus GetMatchMakingStatus() const;
	const struct FMatchOption GetMatchOption() const;
	class FString GetNoticeBannerURL() const;
	const struct FUserName GetPlayerData_Nickname() const;
	struct FUserID GetPlayerData_UserID() const;
	const struct FRegion GetRegionData(const class FString& _region_code) const;
	EServerSessionStatus GetServerSessionStatus() const;
	bool IsInWishedGameMode(EGameMode _game_mode) const;
	bool IsMatchMaking() const;
	bool IsMatchMakingCompleted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StigmaGameInstance">();
	}
	static class UStigmaGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStigmaGameInstance>();
	}
};
static_assert(alignof(UStigmaGameInstance) == 0x000008, "Wrong alignment on UStigmaGameInstance");
static_assert(sizeof(UStigmaGameInstance) == 0x000828, "Wrong size on UStigmaGameInstance");
static_assert(offsetof(UStigmaGameInstance, _ServiceConnection) == 0x000270, "Member 'UStigmaGameInstance::_ServiceConnection' has a wrong offset!");
static_assert(offsetof(UStigmaGameInstance, _ClientSession) == 0x000278, "Member 'UStigmaGameInstance::_ClientSession' has a wrong offset!");
static_assert(offsetof(UStigmaGameInstance, _LocalPlayerCtx) == 0x000280, "Member 'UStigmaGameInstance::_LocalPlayerCtx' has a wrong offset!");
static_assert(offsetof(UStigmaGameInstance, _DiscordSDK) == 0x0003B8, "Member 'UStigmaGameInstance::_DiscordSDK' has a wrong offset!");
static_assert(offsetof(UStigmaGameInstance, _ToastManager) == 0x0003C8, "Member 'UStigmaGameInstance::_ToastManager' has a wrong offset!");
static_assert(offsetof(UStigmaGameInstance, _ChatManager) == 0x0003D0, "Member 'UStigmaGameInstance::_ChatManager' has a wrong offset!");
static_assert(offsetof(UStigmaGameInstance, _EmptyFriendList) == 0x0003D8, "Member 'UStigmaGameInstance::_EmptyFriendList' has a wrong offset!");
static_assert(offsetof(UStigmaGameInstance, _ServerSession) == 0x0003E8, "Member 'UStigmaGameInstance::_ServerSession' has a wrong offset!");
static_assert(offsetof(UStigmaGameInstance, _MQConnection) == 0x0003F0, "Member 'UStigmaGameInstance::_MQConnection' has a wrong offset!");
static_assert(offsetof(UStigmaGameInstance, _NoticeBannerURL) == 0x000788, "Member 'UStigmaGameInstance::_NoticeBannerURL' has a wrong offset!");

// Class Stigma.AGO_ChangeGunnerMode
// 0x0008 (0x0060 - 0x0058)
class UAGO_ChangeGunnerMode final : public UActionGraphOperator
{
public:
	EGunnerType                                   GunnerType;                                        // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FFC[0x7];                                     // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_ChangeGunnerMode">();
	}
	static class UAGO_ChangeGunnerMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_ChangeGunnerMode>();
	}
};
static_assert(alignof(UAGO_ChangeGunnerMode) == 0x000008, "Wrong alignment on UAGO_ChangeGunnerMode");
static_assert(sizeof(UAGO_ChangeGunnerMode) == 0x000060, "Wrong size on UAGO_ChangeGunnerMode");
static_assert(offsetof(UAGO_ChangeGunnerMode, GunnerType) == 0x000058, "Member 'UAGO_ChangeGunnerMode::GunnerType' has a wrong offset!");

// Class Stigma.StigmaCharacter
// 0x0050 (0x1640 - 0x15F0)
class AStigmaCharacter : public AActionGraphCharacter
{
public:
	ECharaType                                    _CharaType;                                        // 0x15E8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FFD[0x7];                                     // 0x15E9(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class USkeletalMeshComponent*                 _HeadMesh;                                         // 0x15F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 _ClothMesh;                                        // 0x15F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class USceneComponent*>                _DuplicatedMeshComponents;                         // 0x1600(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1FFE[0x30];                                    // 0x1610(0x0030)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void SetMesh(const struct FItemID& _body_id, const struct FItemID& _head_id, EArmorType _armor_type);

	ECharaType GetClassCharacterType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StigmaCharacter">();
	}
	static class AStigmaCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStigmaCharacter>();
	}
};
static_assert(alignof(AStigmaCharacter) == 0x000010, "Wrong alignment on AStigmaCharacter");
static_assert(sizeof(AStigmaCharacter) == 0x001640, "Wrong size on AStigmaCharacter");
static_assert(offsetof(AStigmaCharacter, _CharaType) == 0x0015E8, "Member 'AStigmaCharacter::_CharaType' has a wrong offset!");
static_assert(offsetof(AStigmaCharacter, _HeadMesh) == 0x0015F0, "Member 'AStigmaCharacter::_HeadMesh' has a wrong offset!");
static_assert(offsetof(AStigmaCharacter, _ClothMesh) == 0x0015F8, "Member 'AStigmaCharacter::_ClothMesh' has a wrong offset!");
static_assert(offsetof(AStigmaCharacter, _DuplicatedMeshComponents) == 0x001600, "Member 'AStigmaCharacter::_DuplicatedMeshComponents' has a wrong offset!");

// Class Stigma.CharaBase
// 0x2010 (0x3650 - 0x1640)
class ACharaBase : public AStigmaCharacter
{
public:
	uint8                                         Pad_2000[0x88];                                    // 0x1640(0x0088)(Fixing Size After Last Property [ Dumper-69 ])
	class AMatchServicedPlayerState*              _OwningPlayerState;                                // 0x16C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCharacterDefine                       _Config;                                           // 0x16D0(0x09E0)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FConfig_Armor                          _Config_Armor;                                     // 0x20B0(0x01A8)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         _Config_TensionSustainDelay;                       // 0x2258(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2001[0x4];                                     // 0x225C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FConfig_Game                           _GameConfig;                                       // 0x2260(0x0560)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UGunnerSystemComponent>     GunnerSystemCompClass;                             // 0x27C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          RespawnInvincible;                                 // 0x27C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2002[0x7];                                     // 0x27C9(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UUI_Indicator_Scan*                     _ScanIndicator;                                    // 0x27D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2003[0x8];                                     // 0x27D8(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         HP;                                                // 0x27E0(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FHPRecovery                            _CurrentRecovery;                                  // 0x27E4(0x0014)(BlueprintVisible, Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         _Armor;                                            // 0x27F8(0x0004)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2004[0x4];                                     // 0x27FC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FGear>                          _Gears;                                            // 0x2800(0x0010)(Edit, BlueprintVisible, Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	bool                                          _IsScopeMode;                                      // 0x2810(0x0001)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2005[0x7];                                     // 0x2811(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class UDestructibleComponent*>         DestructibleCompGears;                             // 0x2818(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<EBodyParts, struct FGear_SectionMeshDatas> _GearMeshes;                                       // 0x2828(0x0050)(Edit, BlueprintVisible, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          _CanTakeDamage;                                    // 0x2878(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBodyLowerState                               LowerState;                                        // 0x2879(0x0001)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBodyLowerAction                              LowerAction;                                       // 0x287A(0x0001)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBodyUpperState                               UpperState;                                        // 0x287B(0x0001)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsUnfireable;                                     // 0x287C(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsFalling;                                        // 0x287D(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsJumping;                                        // 0x287E(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _PostponedDeath;                                   // 0x287F(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsAlreadyLiedDeathPose;                           // 0x2880(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _KeepPlayingPassive;                               // 0x2881(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IgnoreDieKeepPlayingPassive;                      // 0x2882(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _EnableFootReplacement;                            // 0x2883(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2006[0x4];                                     // 0x2884(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FDamagedData                           _SavedDeathData;                                   // 0x2888(0x0030)(BlueprintVisible, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2007[0x60];                                    // 0x28B8(0x0060)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             EVENT_LOCAL_OnLowerState;                          // 0x2918(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EVENT_LOCAL_OnLowerAction;                         // 0x2928(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EVENT_LOCAL_OnUpperState;                          // 0x2938(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2008[0x60];                                    // 0x2948(0x0060)(Fixing Size After Last Property [ Dumper-69 ])
	TMap<ECharaFacialType, class UAnimMontage*>   Facials;                                           // 0x29A8(0x0050)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UAnimMontage*                           _CurrentFacialMontage;                             // 0x29F8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2009[0x58];                                    // 0x2A00(0x0058)(Fixing Size After Last Property [ Dumper-69 ])
	class ACharaBase*                             _DuoMate;                                          // 0x2A58(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_200A[0x10];                                    // 0x2A60(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	struct FMeleeData                             _Melee;                                            // 0x2A70(0x0024)(BlueprintVisible, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_200B[0x4];                                     // 0x2A94(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UNiagaraComponent*                      _MeleeFX;                                          // 0x2A98(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_200C[0x70];                                    // 0x2AA0(0x0070)(Fixing Size After Last Property [ Dumper-69 ])
	class UBoxComponent*                          _CounterAttack_Collider;                           // 0x2B10(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_200D[0x8];                                     // 0x2B18(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class AActor*>                         _ActorsToIgnore;                                   // 0x2B20(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UBodySetup*                             _BoxBodySetup;                                     // 0x2B30(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          _BoxComponent;                                     // 0x2B38(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStigmaPhysicalAnimationComponent*      _PhysicalAnimationComponent;                       // 0x2B40(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FKAggregateGeom                        CollGeometries;                                    // 0x2B48(0x0078)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_200E[0x10];                                    // 0x2BC0(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class UCurveFloat*                            HitPhysicalAnimCurve;                              // 0x2BD0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_200F[0x20];                                    // 0x2BD8(0x0020)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FDOTContext>                    _DOTs;                                             // 0x2BF8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class AMatchServicedPlayerState*, float> _DamageLog;                                        // 0x2C08(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2010[0x8];                                     // 0x2C58(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class ACharaBase*                             _LastAttackerWithSkill;                            // 0x2C60(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2011[0x8];                                     // 0x2C68(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class ACharaBase*                             _LastAttacker;                                     // 0x2C70(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _FXSizeCurve;                                      // 0x2C78(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _FXScaleByDistanceCurve;                           // 0x2C80(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2012[0x20];                                    // 0x2C88(0x0020)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class UFXSystemComponent*>             AttachedParticles;                                 // 0x2CA8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2013[0xB8];                                    // 0x2CB8(0x00B8)(Fixing Size After Last Property [ Dumper-69 ])
	struct FDoubleTapContext                      _TwoTapCtx;                                        // 0x2D70(0x0028)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2014[0x20];                                    // 0x2D98(0x0020)(Fixing Size After Last Property [ Dumper-69 ])
	struct FVector                                InputDirection;                                    // 0x2DB8(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                _MoveMode_Changer;                                 // 0x2DD0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2015[0x8];                                     // 0x2DD8(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UFireSystemComponent*                   _FireSys_Main;                                     // 0x2DE0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFireSystemComponent*                   _FireSys_Sub;                                      // 0x2DE8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGunnerSystemComponent*                 _GunnerSystemComponent;                            // 0x2DF0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2016[0x20];                                    // 0x2DF8(0x0020)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         _TotalBulletCount;                                 // 0x2E18(0x0004)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2017[0xD4];                                    // 0x2E1C(0x00D4)(Fixing Size After Last Property [ Dumper-69 ])
	class AGunBase*                               _OwnGun_Left;                                      // 0x2EF0(0x0008)(BlueprintVisible, Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGunBase*                               _OwnGun_Right;                                     // 0x2EF8(0x0008)(BlueprintVisible, Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGunBase*                               _LootedGun;                                        // 0x2F00(0x0008)(BlueprintVisible, Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGunBase*                               _SpecialGun_Left;                                  // 0x2F08(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGunBase*                               _SpecialGun_Right;                                 // 0x2F10(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGunBase*                               _PrevGun;                                          // 0x2F18(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2018[0x4];                                     // 0x2F20(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         Deviation_Gun;                                     // 0x2F24(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Deviation_Body;                                    // 0x2F28(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2019[0x20];                                    // 0x2F2C(0x0020)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         ContinuousFiringCount;                             // 0x2F4C(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InputYaw;                                          // 0x2F50(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InputPitch;                                        // 0x2F54(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              Recoil;                                            // 0x2F58(0x0010)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              LastRecoil_Camera;                                 // 0x2F68(0x0010)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RecoilScale_1PV;                                   // 0x2F78(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_201A[0x30];                                    // 0x2F7C(0x0030)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         Penalty_LegInjury_Elapsed;                         // 0x2FAC(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBodyParts                                    Penalty_LegInjury_Parts;                           // 0x2FB0(0x0001)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_201B[0x3];                                     // 0x2FB1(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         _DelayDuration;                                    // 0x2FB4(0x0004)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_201C[0x8];                                     // 0x2FB8(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	EInvincibleMode                               _InvincibleMode;                                   // 0x2FC0(0x0001)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_201D[0xF];                                     // 0x2FC1(0x000F)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class USkeletalMeshComponent*>         ChildMeshComponents;                               // 0x2FD0(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UFXSystemAsset*                         _BreakingArmorFX;                                  // 0x2FE0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFXSystemAsset*                         _HealingSkinFX;                                    // 0x2FE8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         _IsDisarmed : 1;                                   // 0x2FF0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, Net, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_201E[0x7];                                     // 0x2FF1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FStunFX_Param                          _StunParam;                                        // 0x2FF8(0x00A0)(BlueprintVisible, Transient, Protected, NativeAccessSpecifierProtected)
	EStunType                                     _StunType;                                         // 0x3098(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_201F[0xB];                                     // 0x3099(0x000B)(Fixing Size After Last Property [ Dumper-69 ])
	struct FStunTypeParam                         _SavedStunTypeParam;                               // 0x30A4(0x0003)(BlueprintVisible, Net, Transient, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2020[0x19];                                    // 0x30A7(0x0019)(Fixing Size After Last Property [ Dumper-69 ])
	class UMaterialInstanceDynamic*               _StunPP;                                           // 0x30C0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FAbnormals                             _LastAbnormals;                                    // 0x30C8(0x0001)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2021[0x3];                                     // 0x30C9(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	uint8                                         _IsTurnoffSound : 1;                               // 0x30CC(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         _IsAntidoteState : 1;                              // 0x30CC(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (BlueprintVisible, Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         _IsBoneBreaked : 1;                                // 0x30CC(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (BlueprintVisible, Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_2022[0xB];                                     // 0x30CD(0x000B)(Fixing Size After Last Property [ Dumper-69 ])
	struct FNetID                                 _NetID;                                            // 0x30D8(0x0002)(BlueprintVisible, Net, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2023[0x6];                                     // 0x30DA(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	class UMaterialInterface*                     _OverlayMaterial;                                  // 0x30E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               _OverlayMaterialDynamic;                           // 0x30E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2024[0x8];                                     // 0x30F0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UCooltimeComponent*                     Cooltime;                                          // 0x30F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraBoomComponent*                   _CameraBoom;                                       // 0x3100(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCameraComponent*                       _Camera;                                           // 0x3108(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsZoomIn;                                         // 0x3110(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2025[0x3];                                     // 0x3111(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         _ArmLength;                                        // 0x3114(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _TargetArmLength;                                  // 0x3118(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2026[0x4];                                     // 0x311C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FVector                                _CamOffset;                                        // 0x3120(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _TargetCamOffset;                                  // 0x3138(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _LookAtOffset;                                     // 0x3150(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _TargetLookAtOffset;                               // 0x3168(0x0018)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECameraWalkMode                               _CameraWalkMode;                                   // 0x3180(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2027[0x7];                                     // 0x3181(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UAudioComponent*                        _FootstepAudio;                                    // 0x3188(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        _SFXAudio;                                         // 0x3190(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        _VoiceAudio;                                       // 0x3198(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             _BreakingArmorSound;                               // 0x31A0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             _BreakingArmorSound_1PV;                           // 0x31A8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             _TurnOffSound;                                     // 0x31B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        _TurnOffAudioComponent;                            // 0x31B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FSoundUnit>                     PlayingSoundUnits;                                 // 0x31C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2028[0x68];                                    // 0x31D0(0x0068)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          IsAI;                                              // 0x3238(0x0001)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2029[0x27];                                    // 0x3239(0x0027)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class UDecalComponent*>                _HitBloods;                                        // 0x3260(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       BloodMaterials_Body;                               // 0x3270(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       BloodMaterials_Head;                               // 0x3280(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UMaterialInstanceDynamic*>       BloodMaterials_Cloth;                              // 0x3290(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class UDecalComponent*                        _HitBloodTemplate;                                 // 0x32A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         _BloodPool;                                        // 0x32A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraComponent*                      _NC_BloodPool;                                     // 0x32B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_202A[0x18];                                    // 0x32B8(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	class UInteractionComponent*                  Interaction;                                       // 0x32D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       _InteractionOverlapComponent;                      // 0x32D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoClear, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_202B[0x8];                                     // 0x32E0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class AThrowBase*                             _HoldingProp;                                      // 0x32E8(0x0008)(BlueprintVisible, Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPropJointComponent*                    _PropJoint;                                        // 0x32F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_202C[0x10];                                    // 0x32F8(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class APiercingObjectBase*                    _PiercingProp;                                     // 0x3308(0x0008)(BlueprintVisible, Net, ZeroConstructor, Transient, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECharaAction                                  _DEBUG_RepeatAction;                               // 0x3310(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_202D[0x17];                                    // 0x3311(0x0017)(Fixing Size After Last Property [ Dumper-69 ])
	class UWidgetComponent*                       _DEBUG_Panel;                                      // 0x3328(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _DEBUG_Panel_ActiveIndex;                          // 0x3330(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_202E[0x4];                                     // 0x3334(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UMaterialBillboardComponent*            ExclamationComponent;                              // 0x3338(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_202F[0x10];                                    // 0x3340(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class UWidgetComponent*                       _UI_Nickname;                                      // 0x3350(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       _UI_Emoticon;                                      // 0x3358(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _EnableTurnInPlace;                                // 0x3360(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2030[0x7];                                     // 0x3361(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UArrowComponent*                        _1PV_Anchor;                                       // 0x3368(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFovSkeletalMeshComponent*              _Mesh_1PV;                                         // 0x3370(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2031[0x10];                                    // 0x3378(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class UCapsuleComponent*                      _InnerCapsule;                                     // 0x3388(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _MuscleStrength;                                   // 0x3390(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _MuscleStrength_DEAD;                              // 0x3394(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2032[0x4];                                     // 0x3398(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         _GoldAlertTime;                                    // 0x339C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstance*                      _MI_ScanWorld_PP;                                  // 0x33A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             _ScanWorld_Sound;                                  // 0x33A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               _MID_ScanWorld_PP;                                 // 0x33B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2033[0xA0];                                    // 0x33B8(0x00A0)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UDebug_DamageViewerComponent> _DamageViewerClass;                                // 0x3458(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDebug_DamageViewerComponent*           _DamageViewerComponent;                            // 0x3460(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2034[0x58];                                    // 0x3468(0x0058)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class AReviverBase*>                   Revivers;                                          // 0x34C0(0x0010)(BlueprintVisible, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	class AReviverBase*                           MineReviver;                                       // 0x34D0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               _PP_DistanceGuide;                                 // 0x34D8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2035[0x8];                                     // 0x34E0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TMap<class UMeshComponent*, struct FOriginMaterials> _AllMaterials;                                     // 0x34E8(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class UMaterialInterface*, struct FMeshMaterials> _TimedMeshMaterials;                               // 0x3538(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	bool                                          _IsCopyOrigineMaterials;                           // 0x3588(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2036[0x7];                                     // 0x3589(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<int32>                                 _ExcludeMaterials;                                 // 0x3590(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2037[0xB0];                                    // 0x35A0(0x00B0)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static bool GetShowLinkedSkillGuide();
	static void SetShowLinkedSkillGuide(bool _show);

	void ALL_FireOneShot(class AGunBase* _gun, const struct FShot& _shot);
	void ALL_MakeDiedState(bool _died);
	void AttachMesh(bool _attach);
	void BindGun(bool _for_main, class AGunBase* _gun);
	struct FDamageDef CalcDamage(const struct FHitData& _hit);
	bool CanUseBooster(int32 _slot_zidx);
	void ChangeUpperState(EBodyUpperState _state, bool _is_force);
	void CLIENT_EndRequest(ECharaAction _new_action);
	void CLIENT_Request(ECharaAction _new_action, const struct FVector& _direction);
	void CLIENT_StartRequest(ECharaAction _new_action, const struct FVector& _direction);
	void CLIENT_StunPostProcess(bool _enable);
	void CopyOrigineMaterials();
	class AGunBase* CreateGun(const struct FGunSpec& _spec, bool _righthand);
	void DEBUG_ActivateInfinitedStock(bool _inf_stock);
	void DEBUG_Adjust1PVMeshOffsetToCenter();
	class FString DEBUG_GetDebugString();
	bool DEBUG_PlayHitEffects_BP(const struct FHitData& _hit);
	void DEBUG_Reset();
	void DEBUG_Set1PVIdleBlendWeight(float _weight);
	void DEBUG_SetAutoStandUp(EAutoStandUp _type);
	void DEBUG_SetCameraDistance(float _dist, bool _for_1pv);
	void DEBUG_SetCameraOffset(const struct FVector& _offset, bool _for_target, bool _for_1pv);
	void DEBUG_SetInvincible(bool _state);
	void DEBUG_SetNoCPPenalty(bool _value);
	void DEBUG_SetPeriodicRepeatDuration(float _duration);
	void DEBUG_SetPeriodicRepeatType(EPeriodicRepeatType _type);
	void DEBUG_SetRepeatAction(ECharaAction _action_slot, float _interval);
	void DEBUG_SetShowCharaState(bool _show);
	void DEBUG_SetShowCollisionTest(bool _show);
	void DEBUG_SetShowDamage(bool _show, EDebug_DamageViewerType _type);
	void DEBUG_SetShowPlayingHitFX(bool _show);
	void DEBUG_SetShowState(bool _show);
	void DEBUG_SetStaticCamera(bool _state);
	void DEBUG_SetZoom(bool _is_zoom);
	void Destroy_PiercingProp();
	void DriveDeviation(float _delta);
	void DumpState();
	void EndCameraDirecting();
	void EndSideView();
	void EventLowerAction__DelegateSignature(EBodyLowerAction _data);
	void EventLowerState__DelegateSignature(EBodyLowerState _state);
	void EventUpperState__DelegateSignature(EBodyUpperState _state);
	class AActor* GetCurrentLookAtTarget();
	float GetDeviationAngle();
	bool GetInteractableActorByBounding(TArray<class AActor*>* _out_actors);
	bool GetKillReasonToAction(const struct FActionGraphOperatorID& _op_id, struct FActionGraphEntry* _entry);
	class AMatchServicedPlayerState* GetOwningPlayerState();
	float GetTotalDeviation();
	void GetUIValues(float* _deviation, float* _hp, float* _max_hp, float* _out_armor, float* _recovery_hp);
	void INPUT_EndFire();
	void INPUT_HandleMoveForward(float _value);
	void INPUT_HandleMoveRight(float _value);
	void INPUT_StartFire();
	bool IsExpired(class FName Param_Name, float* Out_remain_time, float* Out_duration);
	bool IsExpiredBoosterCooltime(int32 _booster_zidx, float* Out_remain_time, float* Out_duration);
	void OnALL_BreakArmor();
	bool OnALL_Damaged(const struct FDamagedData& _damaged_data);
	bool OnALL_Hit(const struct FHitData& _hit);
	void OnAnimNotify_LowerState(EBodyLowerState _state);
	void OnAnimNotify_MeleeAttack(bool _begin, const struct FMeleeData& _melee_data);
	void OnCapsuleHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	bool OnChange_LowerAction(EBodyLowerAction _new_action);
	bool OnChange_LowerState(EBodyLowerState _state);
	bool OnChange_UpperState(EBodyUpperState _state);
	bool OnChanged_NetID(const struct FNetID& _id);
	bool OnCLIENT_Stun(bool _stunned);
	bool OnEnabledUIMode(bool _enable);
	void OnHitImpact(const struct FHitData& _hit);
	bool OnLoadSettings();
	void OnRep_Abnormals();
	void OnRep_Armor(float _old_armor);
	void OnRep_CurrentRecovery(const struct FHPRecovery& _old_recovery);
	void OnRep_DEBUG_Panel_ActiveIndex(int32 _old_index);
	void OnRep_DelayDuration();
	void OnRep_Gears();
	void OnRep_HoldingProp(class AThrowBase* _old_prop);
	void OnRep_InvincibleMode();
	void OnRep_IsAntidoteState(bool _old_value);
	void OnRep_IsBoneBreaked(bool _old_value);
	void OnRep_IsTurnoffSound(bool _old_value);
	void OnRep_LootedGun(class AGunBase* _old_gun);
	void OnRep_LowerAction(EBodyLowerAction _old_action);
	void OnRep_LowerState(EBodyLowerState _old_state);
	void OnRep_NetID();
	void OnRep_OwnGun_Left(class AGunBase* _old_gun);
	void OnRep_OwnGun_Right(class AGunBase* _old_gun);
	void OnRep_Penalty_LegInjury_Parts();
	void OnRep_PiercingProp(class APiercingObjectBase* _old_prop);
	void OnRep_ScopeMode();
	void OnRep_StunTypeParam();
	void OnRep_UpperState(EBodyUpperState _old_state);
	bool OnSERVER_Died(const struct FHitData& _last_hit_data);
	bool OnTick(float _delta);
	bool OnUpdateMoveSpeed();
	void PlayFacialMotion(ECharaFacialType Type);
	bool PlayHitEffects(const struct FHitData& _hit);
	void RequestStandUpDirection(float _forward, float _right);
	void ResetCameraWalk();
	void ResetCurrentLookAtTarget();
	bool ResetForRespawn();
	void ResetScanWorld_PostProcess();
	void ResetStunType();
	void ResetZoom();
	void RestoreFacialMotion();
	void RPC_ALL_Damaged(const struct FNetDamagedData& _data);
	void RPC_ALL_FinishGame();
	void RPC_ALL_PiercingShot_AG(const struct FActionGraphOperatorID& _op_id, const struct FTransform& _start_point, const struct FVector& _end_point, class APiercingObjectBase* _obj);
	void RPC_ALL_Respawn(bool _for_round_reset, const struct FVector& _location, const struct FRotator& _rotation, const struct FMoveSyncID& _sync_id);
	void RPC_ALL_ThrowObject_AG(const struct FActionGraphOperatorID& _op_id, const TArray<struct FTransform>& _start_points, const TArray<struct FVector>& _end_points, class AThrowBase* _throw_object);
	void RPC_ALL_UseBooster(const struct FItemID_Booster& _item_id);
	void RPC_CLIENT_CancelInteract();
	void RPC_CLIENT_UpperState_ACK(EBodyUpperState _prev, EBodyUpperState _curr);
	void RPC_SERVER_DEBUG_AddWelcomeMatchFunctions();
	void RPC_SERVER_DEBUG_ChangeGun(EGunType _gun_type, bool _is_main_gun, bool _setup_own_gun);
	void RPC_SERVER_DEBUG_HoldProp(TSubclassOf<class AThrowBase> _prop_type);
	void RPC_SERVER_DEBUG_LowerState(EBodyLowerState _state);
	void RPC_SERVER_DEBUG_Reset();
	void RPC_SERVER_DEBUG_SetCharacterSetting(const struct FItemID& _item_id, int32 _slot);
	void RPC_SERVER_DEBUG_SetPassiveSkillLevel(const struct FPassiveSkillID& _skill_id, int32 _level);
	void RPC_SERVER_DEBUG_SpawnCorpse();
	void RPC_SERVER_P2P_Hit_AG(const struct FHitData& _data);
	void RPC_SERVER_PiercingShot_AG(const struct FActionGraphOperatorID& _op_id, const struct FTransform& _start_point, const struct FVector& _end_point);
	void RPC_SERVER_RequestPurchaseItem(class AProp_Store* Prop_Store, int32 _item_idx);
	void RPC_SERVER_ThrowObject_AG(const struct FActionGraphOperatorID& _op_id, const TArray<struct FTransform>& _start_points, const TArray<struct FVector>& _end_points);
	void RPC_SERVER_ToggleLaserSight();
	void RPC_SERVER_UpperState(EBodyUpperState _state);
	void RPC_SERVER_UseBooster(int32 _slot_zidx);
	void SaveConfig();
	EObstacleScanResult ScanObstacle();
	void SERVER_AddAbnormal(EAbnormal _abnormal_type);
	void SERVER_AssignTeamForAI(ETeams _Team);
	bool SERVER_LoadMagazine(EGunnerJobReason _reason, bool Is_main_hand_hold_gun);
	void SERVER_RemoveAbnormal(EAbnormal _abnormal_type);
	void SERVER_SetHoldingProp(class AThrowBase* _prop, EObjectState _obj_state_for_old);
	void SERVER_SetIsTurnoffSound(bool _turn_off);
	void SERVER_SetLootedGun(class AGunBase* _gun);
	void SERVER_SetNetID(const struct FNetID& _id);
	void SERVER_SetPiercingProp(class APiercingObjectBase* _prop, EObjectState _obj_state_for_old);
	void SERVER_StartDisarmed();
	void SERVER_StartStun(struct FStunTypeParam* _param);
	void SetCameraMotionBlur(bool _value);
	void SetControlSpeedRate(float _move_rate, float _rot_yaw_rate);
	void SetControlYaw(float _yaw);
	void SetForcedDeviation();
	void SetGunSpec(const struct FGunSpec& _gun_spec, bool Should_make_gun);
	void SetInputDirection_Forward(float _val);
	void SetInputDirection_Right(float _val);
	struct FOriginMaterials SetMeshMaterials(class UMeshComponent* Meshcom, class UMaterialInterface* _materialinterface, class UMaterialInterface* _materialinterface_trans, bool _copymaterial, int32 Materialindex, const struct FOriginMaterials& Timedmaterials, bool _onematerialonly);
	void SetOrigineMaterials();
	void SetPhysicalState(EBodyPhysicalState _state);
	void SetScanWorld_PostProcess(float _blendweight, float _radius);
	void Setter_Armor(float _new_armor);
	void Setter_DelayDuration(float _duration);
	void Setter_Gears(const TArray<struct FGear>& _new_gears);
	void Setter_HoldingProp(class AThrowBase* _new_prop);
	void Setter_InvincibleMode(EInvincibleMode _mode);
	void Setter_IsAntidoteState(bool _is_antidote_state);
	void Setter_IsBoneBreaked(bool _is_bone_breaked);
	void Setter_IsTurnoffSound(bool _is_turn_off);
	void Setter_LootedGun(class AGunBase* _new_gun);
	void Setter_LowerAction(EBodyLowerAction _new_action);
	void Setter_LowerState(EBodyLowerState _state);
	void Setter_OwnGun_Left(class AGunBase* _new_gun);
	void Setter_OwnGun_Right(class AGunBase* _new_gun);
	void Setter_Penalty_LegInjury_Parts(EBodyParts _parts);
	void Setter_PiercingProp(class APiercingObjectBase* _new_prop);
	void Setter_ScopeMode(bool _scope_mode);
	void Setter_StunTypeParam(struct FStunTypeParam* _param);
	void Setter_UpperState(EBodyUpperState _state);
	void SetTimedMaterial(class UMaterialInterface* _materialinterface, bool _copymaterial, bool _onematerialonly, int32 _onematerialindex, class UMaterialInterface* _materialinterface_trans, bool _bodyonly);
	TArray<int32> SetTimedMaterialExcludeMaterials(TArray<int32>* Excludematerials);
	void SetUIMode(bool _enable);
	bool SetupCameraConfig(const struct FConfig_Camera& _config_camera, bool _use_zoom_in);
	void SetupCollisionForMate(class ACharaBase* _mate);
	void SetZoom(bool _is_zoom_in, bool _force_zoom);
	bool StartActionGraph(ECharaAction _idx_ag, const struct FVector& _vector);
	void StartCameraDirecting(const struct FCameraDirectingParams& _params);
	void StartCooltime(class FName Param_Name, float Duration);
	void StartSideView(ESideViewSide _side);
	void Subscribe_OnPlayerStateChanged(const TDelegate<void(EChangedPlayerState _reason, class AMatchServicedPlayerState* _ps)>& _proc);
	void SyncRotation(float _angle, const struct FVector& _dir, const class FString& _ctx);
	void TryToInteract(bool _press_key, class AActor* _target);
	void Unsubscribe_OnPlayerStateChanged(const class UObject* _obj);
	void UpdateOutlineColor(bool _force_update);
	void ValidateSettings();

	struct FBodyDeviation CalcBodyDeviation() const;
	bool CanChangeLowerAction(EBodyLowerAction _new_action) const;
	bool CanChangeLowerState(EBodyLowerState _new_state) const;
	bool CanChangeUpperState(EBodyUpperState _state) const;
	bool CanInteract() const;
	bool CanStandUp() const;
	bool CanTurn() const;
	EAutoStandUp DEBUG_GetAutoStandUp() const;
	float DEBUG_GetCameraDistance(bool _for_1pv) const;
	struct FVector DEBUG_GetCameraOffset(bool _for_target, bool _for_1pv) const;
	bool DEBUG_GetNoCPPenalty() const;
	float DEBUG_GetPeriodicRepeatDuration() const;
	EPeriodicRepeatType DEBUG_GetPeriodicRepeatType() const;
	ECharaAction DEBUG_GetRepeatAction() const;
	bool DEBUG_GetShowCharaState() const;
	bool DEBUG_GetShowCollisionTest() const;
	bool DEBUG_GetShowDamage() const;
	bool DEBUG_GetShowPlayingHitFX() const;
	bool DEBUG_GetShowState() const;
	bool DEBUG_IsActivatedInfinitedStock() const;
	bool DEBUG_IsInvincible() const;
	bool DEBUG_IsStaticCamera() const;
	class UActionGraphNode* FindActionGraphNode(const struct FActionGraphOperatorID& _op_id) const;
	class ABattleGameStateBase* GameState() const;
	struct FVector Get1PVMeshOffset() const;
	struct FAbnormals GetAbnormals() const;
	class UActionGraph* GetActionGraph(ECharaAction _slot) const;
	struct FActionGraphID GetActionGraphID(ECharaAction _slot) const;
	class ACharaBase* GetActionMate() const;
	struct FActionGraph_ActivationInfo GetActivationInfo_ActionGraph(ECharaAction _slot) const;
	struct FVector GetAimStartPoint() const;
	TArray<EAbnormal> GetAllAbnormals() const;
	class USpecterAnimInstance* GetAnimInst() const;
	float GetArmor() const;
	float GetArmor_PriceIncrease() const;
	float GetArmorOriginPrice() const;
	float GetArmorPrice() const;
	ECharaAction GetAvailableActiveSkill(class ACharaBase* _enemy) const;
	float GetBodyDeviation() const;
	struct FItemID GetBodyItemID() const;
	EBones GetBone(class FName _bone_name) const;
	class FName GetBoneName(EBones _bones) const;
	float GetBoosterCooltimeProgress(int32 _slot_zidx, float _excluding_active_time) const;
	struct FItemID_Booster GetBoosterID(int32 _slot_zidx) const;
	struct FKeyMapping GetBoundKeyForSkill(ECharaAction _action) const;
	float GetCalculatedMaxHP() const;
	class UCameraComponent* GetCamera() const;
	class UCameraBoomComponent* GetCameraBoom() const;
	const struct FCharacterDefine GetConfig() const;
	const struct FConfig_Armor GetConfig_Armor() const;
	float GetConfig_Armor_MaxArmor() const;
	float GetConfig_BaseDamage_Fist() const;
	float GetConfig_BaseDamage_Foot() const;
	const struct FConfig_Camera GetConfig_Camera() const;
	const struct FConfig_CharaFX GetConfig_FX() const;
	float GetConfig_MaxHP() const;
	float GetConfig_Penalty_LegInjury_Duration() const;
	float GetConfig_Penalty_LegInjury_SpeedRate() const;
	const struct FConfig_CharaSound GetConfig_Sound() const;
	float GetControlPower() const;
	float GetControlPowerFactor(const class AGunBase* _gun) const;
	float GetControlPowerGap(bool _is_main_hand_gun) const;
	class UActionGraph* GetCurrentActionGraph() const;
	float GetCurrentArmor_AllGears() const;
	float GetCurrentAverageArmor() const;
	EGunnerType GetCurrentGunnerMode() const;
	class UMaterialBillboardComponent* GetExclamationComponent() const;
	struct FVector2D GetFireRecoil(class AGunBase* _gun) const;
	const struct FConfig_Game GetGameConfig() const;
	const struct FGunEntry_Main GetGunEntryMain(bool Is_main_hand_hold_gun) const;
	class AGunBase* GetGunInCurHand(bool _is_main_hand) const;
	const struct FGunPreset GetGunPreset() const;
	EScopeType GetGunScopeTypeInCurHand(bool Is_main_hand_hold_gun) const;
	const struct FGunSpec GetGunSpec() const;
	EGunType GetGunType() const;
	float GetHalfHeight() const;
	struct FItemID GetHeadItemID() const;
	class AThrowBase* GetHoldingProp() const;
	float GetHP() const;
	float GetHPRate() const;
	float GetInitialGunDeviation() const;
	struct FVector GetInputDirection() const;
	class AActor* GetInteractionTarget() const;
	bool GetIsReloading() const;
	class FText GetKillLogText(const struct FActionGraphOperatorID& _op_id) const;
	int32 GetLoadedBulletCount(bool Is_main_hand_hold_gun) const;
	void GetLookAtRay(float _distance, struct FVector* _out_start, struct FVector* _out_end) const;
	EBodyLowerAction GetLowerAction() const;
	EBodyLowerState GetLowerState() const;
	int32 GetMagazineCapacity(bool Is_main_hand_hold_gun) const;
	int32 GetMagazineCount() const;
	float GetMaxArmor_AllGears() const;
	float GetMaxAverageArmor() const;
	void GetMeleeAttackPoint(EMeleeAttackPoint _point, float _radius_scaler, float _capsule_height_scaler, struct FVector* _out_loc_start, struct FVector* _out_loc_end, float* _out_radius) const;
	struct FMagazine GetNextMagazine() const;
	const struct FUserName GetNickname() const;
	class AGunBase* GetOwnMainGun() const;
	class AGunBase* GetOwnSubGun() const;
	EBodyParts GetPartsByBone(EBones _bones) const;
	EBodyParts GetPartsByBoneName(class FName _bone_name) const;
	class APiercingObjectBase* GetPiercingProp() const;
	float GetPing() const;
	EPingQuality GetPingQuality() const;
	class FString GetPlayerName() const;
	class UTexture2D* GetPortraitIcon() const;
	float GetRecoilCameraRate() const;
	struct FVector2D GetRecoilCrosshairOffset() const;
	float GetRemainBulletPercentage(bool Is_main_hand_hold_gun) const;
	bool GetShouldShowReloadGuide() const;
	class AGunBase* GetSpecialMainGun() const;
	class AGunBase* GetSpecialSubGun() const;
	float GetSpeed() const;
	ETeams GetTeam() const;
	int32 GetTotalBulletCount() const;
	int32 GetTotalSpareBulletCount() const;
	EBodyUpperState GetUpperState() const;
	class AObjectBase* GetWeaponInCurHand(bool _is_main_hand) const;
	class AObjectBase* GetWeaponInCurMainHand() const;
	class AObjectBase* GetWeaponInCurSubHand() const;
	bool HasControlPowerPenalty(bool _is_main_hand_gun) const;
	bool HasPostPonedDeath() const;
	bool HasScopeGun() const;
	bool IsActable() const;
	bool IsActionCooltimeExpired(ECharaAction _action_type) const;
	bool IsAIControlled() const;
	bool IsAlive() const;
	bool IsAlly(const class ACharaBase* _other) const;
	bool IsAntidoteState() const;
	bool IsAnyServer() const;
	bool IsBlocking() const;
	bool IsBoneBreaked() const;
	bool IsBulletproofProtected(EBones _bone) const;
	bool IsDediServer() const;
	bool IsDied() const;
	bool IsDisarmed() const;
	bool IsDiscovered() const;
	bool IsEnemy(const class ACharaBase* _other) const;
	bool IsFalling() const;
	bool IsFullMagazine() const;
	bool IsInteracting() const;
	bool IsInvincible() const;
	bool IsJumping() const;
	bool IsListenServer() const;
	bool IsLocalOrSpectated() const;
	bool IsLyingOrPronning() const;
	bool IsMovable() const;
	bool IsUIMode() const;
	bool IsUnfireable() const;
	class USpecterCharaMovementComponent* MoveComponent() const;
	class ABattlePlayerControllerBase* PlayerController() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharaBase">();
	}
	static class ACharaBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharaBase>();
	}
};
static_assert(alignof(ACharaBase) == 0x000010, "Wrong alignment on ACharaBase");
static_assert(sizeof(ACharaBase) == 0x003650, "Wrong size on ACharaBase");
static_assert(offsetof(ACharaBase, _OwningPlayerState) == 0x0016C8, "Member 'ACharaBase::_OwningPlayerState' has a wrong offset!");
static_assert(offsetof(ACharaBase, _Config) == 0x0016D0, "Member 'ACharaBase::_Config' has a wrong offset!");
static_assert(offsetof(ACharaBase, _Config_Armor) == 0x0020B0, "Member 'ACharaBase::_Config_Armor' has a wrong offset!");
static_assert(offsetof(ACharaBase, _Config_TensionSustainDelay) == 0x002258, "Member 'ACharaBase::_Config_TensionSustainDelay' has a wrong offset!");
static_assert(offsetof(ACharaBase, _GameConfig) == 0x002260, "Member 'ACharaBase::_GameConfig' has a wrong offset!");
static_assert(offsetof(ACharaBase, GunnerSystemCompClass) == 0x0027C0, "Member 'ACharaBase::GunnerSystemCompClass' has a wrong offset!");
static_assert(offsetof(ACharaBase, RespawnInvincible) == 0x0027C8, "Member 'ACharaBase::RespawnInvincible' has a wrong offset!");
static_assert(offsetof(ACharaBase, _ScanIndicator) == 0x0027D0, "Member 'ACharaBase::_ScanIndicator' has a wrong offset!");
static_assert(offsetof(ACharaBase, HP) == 0x0027E0, "Member 'ACharaBase::HP' has a wrong offset!");
static_assert(offsetof(ACharaBase, _CurrentRecovery) == 0x0027E4, "Member 'ACharaBase::_CurrentRecovery' has a wrong offset!");
static_assert(offsetof(ACharaBase, _Armor) == 0x0027F8, "Member 'ACharaBase::_Armor' has a wrong offset!");
static_assert(offsetof(ACharaBase, _Gears) == 0x002800, "Member 'ACharaBase::_Gears' has a wrong offset!");
static_assert(offsetof(ACharaBase, _IsScopeMode) == 0x002810, "Member 'ACharaBase::_IsScopeMode' has a wrong offset!");
static_assert(offsetof(ACharaBase, DestructibleCompGears) == 0x002818, "Member 'ACharaBase::DestructibleCompGears' has a wrong offset!");
static_assert(offsetof(ACharaBase, _GearMeshes) == 0x002828, "Member 'ACharaBase::_GearMeshes' has a wrong offset!");
static_assert(offsetof(ACharaBase, _CanTakeDamage) == 0x002878, "Member 'ACharaBase::_CanTakeDamage' has a wrong offset!");
static_assert(offsetof(ACharaBase, LowerState) == 0x002879, "Member 'ACharaBase::LowerState' has a wrong offset!");
static_assert(offsetof(ACharaBase, LowerAction) == 0x00287A, "Member 'ACharaBase::LowerAction' has a wrong offset!");
static_assert(offsetof(ACharaBase, UpperState) == 0x00287B, "Member 'ACharaBase::UpperState' has a wrong offset!");
static_assert(offsetof(ACharaBase, _IsUnfireable) == 0x00287C, "Member 'ACharaBase::_IsUnfireable' has a wrong offset!");
static_assert(offsetof(ACharaBase, _IsFalling) == 0x00287D, "Member 'ACharaBase::_IsFalling' has a wrong offset!");
static_assert(offsetof(ACharaBase, _IsJumping) == 0x00287E, "Member 'ACharaBase::_IsJumping' has a wrong offset!");
static_assert(offsetof(ACharaBase, _PostponedDeath) == 0x00287F, "Member 'ACharaBase::_PostponedDeath' has a wrong offset!");
static_assert(offsetof(ACharaBase, _IsAlreadyLiedDeathPose) == 0x002880, "Member 'ACharaBase::_IsAlreadyLiedDeathPose' has a wrong offset!");
static_assert(offsetof(ACharaBase, _KeepPlayingPassive) == 0x002881, "Member 'ACharaBase::_KeepPlayingPassive' has a wrong offset!");
static_assert(offsetof(ACharaBase, _IgnoreDieKeepPlayingPassive) == 0x002882, "Member 'ACharaBase::_IgnoreDieKeepPlayingPassive' has a wrong offset!");
static_assert(offsetof(ACharaBase, _EnableFootReplacement) == 0x002883, "Member 'ACharaBase::_EnableFootReplacement' has a wrong offset!");
static_assert(offsetof(ACharaBase, _SavedDeathData) == 0x002888, "Member 'ACharaBase::_SavedDeathData' has a wrong offset!");
static_assert(offsetof(ACharaBase, EVENT_LOCAL_OnLowerState) == 0x002918, "Member 'ACharaBase::EVENT_LOCAL_OnLowerState' has a wrong offset!");
static_assert(offsetof(ACharaBase, EVENT_LOCAL_OnLowerAction) == 0x002928, "Member 'ACharaBase::EVENT_LOCAL_OnLowerAction' has a wrong offset!");
static_assert(offsetof(ACharaBase, EVENT_LOCAL_OnUpperState) == 0x002938, "Member 'ACharaBase::EVENT_LOCAL_OnUpperState' has a wrong offset!");
static_assert(offsetof(ACharaBase, Facials) == 0x0029A8, "Member 'ACharaBase::Facials' has a wrong offset!");
static_assert(offsetof(ACharaBase, _CurrentFacialMontage) == 0x0029F8, "Member 'ACharaBase::_CurrentFacialMontage' has a wrong offset!");
static_assert(offsetof(ACharaBase, _DuoMate) == 0x002A58, "Member 'ACharaBase::_DuoMate' has a wrong offset!");
static_assert(offsetof(ACharaBase, _Melee) == 0x002A70, "Member 'ACharaBase::_Melee' has a wrong offset!");
static_assert(offsetof(ACharaBase, _MeleeFX) == 0x002A98, "Member 'ACharaBase::_MeleeFX' has a wrong offset!");
static_assert(offsetof(ACharaBase, _CounterAttack_Collider) == 0x002B10, "Member 'ACharaBase::_CounterAttack_Collider' has a wrong offset!");
static_assert(offsetof(ACharaBase, _ActorsToIgnore) == 0x002B20, "Member 'ACharaBase::_ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(ACharaBase, _BoxBodySetup) == 0x002B30, "Member 'ACharaBase::_BoxBodySetup' has a wrong offset!");
static_assert(offsetof(ACharaBase, _BoxComponent) == 0x002B38, "Member 'ACharaBase::_BoxComponent' has a wrong offset!");
static_assert(offsetof(ACharaBase, _PhysicalAnimationComponent) == 0x002B40, "Member 'ACharaBase::_PhysicalAnimationComponent' has a wrong offset!");
static_assert(offsetof(ACharaBase, CollGeometries) == 0x002B48, "Member 'ACharaBase::CollGeometries' has a wrong offset!");
static_assert(offsetof(ACharaBase, HitPhysicalAnimCurve) == 0x002BD0, "Member 'ACharaBase::HitPhysicalAnimCurve' has a wrong offset!");
static_assert(offsetof(ACharaBase, _DOTs) == 0x002BF8, "Member 'ACharaBase::_DOTs' has a wrong offset!");
static_assert(offsetof(ACharaBase, _DamageLog) == 0x002C08, "Member 'ACharaBase::_DamageLog' has a wrong offset!");
static_assert(offsetof(ACharaBase, _LastAttackerWithSkill) == 0x002C60, "Member 'ACharaBase::_LastAttackerWithSkill' has a wrong offset!");
static_assert(offsetof(ACharaBase, _LastAttacker) == 0x002C70, "Member 'ACharaBase::_LastAttacker' has a wrong offset!");
static_assert(offsetof(ACharaBase, _FXSizeCurve) == 0x002C78, "Member 'ACharaBase::_FXSizeCurve' has a wrong offset!");
static_assert(offsetof(ACharaBase, _FXScaleByDistanceCurve) == 0x002C80, "Member 'ACharaBase::_FXScaleByDistanceCurve' has a wrong offset!");
static_assert(offsetof(ACharaBase, AttachedParticles) == 0x002CA8, "Member 'ACharaBase::AttachedParticles' has a wrong offset!");
static_assert(offsetof(ACharaBase, _TwoTapCtx) == 0x002D70, "Member 'ACharaBase::_TwoTapCtx' has a wrong offset!");
static_assert(offsetof(ACharaBase, InputDirection) == 0x002DB8, "Member 'ACharaBase::InputDirection' has a wrong offset!");
static_assert(offsetof(ACharaBase, _MoveMode_Changer) == 0x002DD0, "Member 'ACharaBase::_MoveMode_Changer' has a wrong offset!");
static_assert(offsetof(ACharaBase, _FireSys_Main) == 0x002DE0, "Member 'ACharaBase::_FireSys_Main' has a wrong offset!");
static_assert(offsetof(ACharaBase, _FireSys_Sub) == 0x002DE8, "Member 'ACharaBase::_FireSys_Sub' has a wrong offset!");
static_assert(offsetof(ACharaBase, _GunnerSystemComponent) == 0x002DF0, "Member 'ACharaBase::_GunnerSystemComponent' has a wrong offset!");
static_assert(offsetof(ACharaBase, _TotalBulletCount) == 0x002E18, "Member 'ACharaBase::_TotalBulletCount' has a wrong offset!");
static_assert(offsetof(ACharaBase, _OwnGun_Left) == 0x002EF0, "Member 'ACharaBase::_OwnGun_Left' has a wrong offset!");
static_assert(offsetof(ACharaBase, _OwnGun_Right) == 0x002EF8, "Member 'ACharaBase::_OwnGun_Right' has a wrong offset!");
static_assert(offsetof(ACharaBase, _LootedGun) == 0x002F00, "Member 'ACharaBase::_LootedGun' has a wrong offset!");
static_assert(offsetof(ACharaBase, _SpecialGun_Left) == 0x002F08, "Member 'ACharaBase::_SpecialGun_Left' has a wrong offset!");
static_assert(offsetof(ACharaBase, _SpecialGun_Right) == 0x002F10, "Member 'ACharaBase::_SpecialGun_Right' has a wrong offset!");
static_assert(offsetof(ACharaBase, _PrevGun) == 0x002F18, "Member 'ACharaBase::_PrevGun' has a wrong offset!");
static_assert(offsetof(ACharaBase, Deviation_Gun) == 0x002F24, "Member 'ACharaBase::Deviation_Gun' has a wrong offset!");
static_assert(offsetof(ACharaBase, Deviation_Body) == 0x002F28, "Member 'ACharaBase::Deviation_Body' has a wrong offset!");
static_assert(offsetof(ACharaBase, ContinuousFiringCount) == 0x002F4C, "Member 'ACharaBase::ContinuousFiringCount' has a wrong offset!");
static_assert(offsetof(ACharaBase, InputYaw) == 0x002F50, "Member 'ACharaBase::InputYaw' has a wrong offset!");
static_assert(offsetof(ACharaBase, InputPitch) == 0x002F54, "Member 'ACharaBase::InputPitch' has a wrong offset!");
static_assert(offsetof(ACharaBase, Recoil) == 0x002F58, "Member 'ACharaBase::Recoil' has a wrong offset!");
static_assert(offsetof(ACharaBase, LastRecoil_Camera) == 0x002F68, "Member 'ACharaBase::LastRecoil_Camera' has a wrong offset!");
static_assert(offsetof(ACharaBase, RecoilScale_1PV) == 0x002F78, "Member 'ACharaBase::RecoilScale_1PV' has a wrong offset!");
static_assert(offsetof(ACharaBase, Penalty_LegInjury_Elapsed) == 0x002FAC, "Member 'ACharaBase::Penalty_LegInjury_Elapsed' has a wrong offset!");
static_assert(offsetof(ACharaBase, Penalty_LegInjury_Parts) == 0x002FB0, "Member 'ACharaBase::Penalty_LegInjury_Parts' has a wrong offset!");
static_assert(offsetof(ACharaBase, _DelayDuration) == 0x002FB4, "Member 'ACharaBase::_DelayDuration' has a wrong offset!");
static_assert(offsetof(ACharaBase, _InvincibleMode) == 0x002FC0, "Member 'ACharaBase::_InvincibleMode' has a wrong offset!");
static_assert(offsetof(ACharaBase, ChildMeshComponents) == 0x002FD0, "Member 'ACharaBase::ChildMeshComponents' has a wrong offset!");
static_assert(offsetof(ACharaBase, _BreakingArmorFX) == 0x002FE0, "Member 'ACharaBase::_BreakingArmorFX' has a wrong offset!");
static_assert(offsetof(ACharaBase, _HealingSkinFX) == 0x002FE8, "Member 'ACharaBase::_HealingSkinFX' has a wrong offset!");
static_assert(offsetof(ACharaBase, _StunParam) == 0x002FF8, "Member 'ACharaBase::_StunParam' has a wrong offset!");
static_assert(offsetof(ACharaBase, _StunType) == 0x003098, "Member 'ACharaBase::_StunType' has a wrong offset!");
static_assert(offsetof(ACharaBase, _SavedStunTypeParam) == 0x0030A4, "Member 'ACharaBase::_SavedStunTypeParam' has a wrong offset!");
static_assert(offsetof(ACharaBase, _StunPP) == 0x0030C0, "Member 'ACharaBase::_StunPP' has a wrong offset!");
static_assert(offsetof(ACharaBase, _LastAbnormals) == 0x0030C8, "Member 'ACharaBase::_LastAbnormals' has a wrong offset!");
static_assert(offsetof(ACharaBase, _NetID) == 0x0030D8, "Member 'ACharaBase::_NetID' has a wrong offset!");
static_assert(offsetof(ACharaBase, _OverlayMaterial) == 0x0030E0, "Member 'ACharaBase::_OverlayMaterial' has a wrong offset!");
static_assert(offsetof(ACharaBase, _OverlayMaterialDynamic) == 0x0030E8, "Member 'ACharaBase::_OverlayMaterialDynamic' has a wrong offset!");
static_assert(offsetof(ACharaBase, Cooltime) == 0x0030F8, "Member 'ACharaBase::Cooltime' has a wrong offset!");
static_assert(offsetof(ACharaBase, _CameraBoom) == 0x003100, "Member 'ACharaBase::_CameraBoom' has a wrong offset!");
static_assert(offsetof(ACharaBase, _Camera) == 0x003108, "Member 'ACharaBase::_Camera' has a wrong offset!");
static_assert(offsetof(ACharaBase, _IsZoomIn) == 0x003110, "Member 'ACharaBase::_IsZoomIn' has a wrong offset!");
static_assert(offsetof(ACharaBase, _ArmLength) == 0x003114, "Member 'ACharaBase::_ArmLength' has a wrong offset!");
static_assert(offsetof(ACharaBase, _TargetArmLength) == 0x003118, "Member 'ACharaBase::_TargetArmLength' has a wrong offset!");
static_assert(offsetof(ACharaBase, _CamOffset) == 0x003120, "Member 'ACharaBase::_CamOffset' has a wrong offset!");
static_assert(offsetof(ACharaBase, _TargetCamOffset) == 0x003138, "Member 'ACharaBase::_TargetCamOffset' has a wrong offset!");
static_assert(offsetof(ACharaBase, _LookAtOffset) == 0x003150, "Member 'ACharaBase::_LookAtOffset' has a wrong offset!");
static_assert(offsetof(ACharaBase, _TargetLookAtOffset) == 0x003168, "Member 'ACharaBase::_TargetLookAtOffset' has a wrong offset!");
static_assert(offsetof(ACharaBase, _CameraWalkMode) == 0x003180, "Member 'ACharaBase::_CameraWalkMode' has a wrong offset!");
static_assert(offsetof(ACharaBase, _FootstepAudio) == 0x003188, "Member 'ACharaBase::_FootstepAudio' has a wrong offset!");
static_assert(offsetof(ACharaBase, _SFXAudio) == 0x003190, "Member 'ACharaBase::_SFXAudio' has a wrong offset!");
static_assert(offsetof(ACharaBase, _VoiceAudio) == 0x003198, "Member 'ACharaBase::_VoiceAudio' has a wrong offset!");
static_assert(offsetof(ACharaBase, _BreakingArmorSound) == 0x0031A0, "Member 'ACharaBase::_BreakingArmorSound' has a wrong offset!");
static_assert(offsetof(ACharaBase, _BreakingArmorSound_1PV) == 0x0031A8, "Member 'ACharaBase::_BreakingArmorSound_1PV' has a wrong offset!");
static_assert(offsetof(ACharaBase, _TurnOffSound) == 0x0031B0, "Member 'ACharaBase::_TurnOffSound' has a wrong offset!");
static_assert(offsetof(ACharaBase, _TurnOffAudioComponent) == 0x0031B8, "Member 'ACharaBase::_TurnOffAudioComponent' has a wrong offset!");
static_assert(offsetof(ACharaBase, PlayingSoundUnits) == 0x0031C0, "Member 'ACharaBase::PlayingSoundUnits' has a wrong offset!");
static_assert(offsetof(ACharaBase, IsAI) == 0x003238, "Member 'ACharaBase::IsAI' has a wrong offset!");
static_assert(offsetof(ACharaBase, _HitBloods) == 0x003260, "Member 'ACharaBase::_HitBloods' has a wrong offset!");
static_assert(offsetof(ACharaBase, BloodMaterials_Body) == 0x003270, "Member 'ACharaBase::BloodMaterials_Body' has a wrong offset!");
static_assert(offsetof(ACharaBase, BloodMaterials_Head) == 0x003280, "Member 'ACharaBase::BloodMaterials_Head' has a wrong offset!");
static_assert(offsetof(ACharaBase, BloodMaterials_Cloth) == 0x003290, "Member 'ACharaBase::BloodMaterials_Cloth' has a wrong offset!");
static_assert(offsetof(ACharaBase, _HitBloodTemplate) == 0x0032A0, "Member 'ACharaBase::_HitBloodTemplate' has a wrong offset!");
static_assert(offsetof(ACharaBase, _BloodPool) == 0x0032A8, "Member 'ACharaBase::_BloodPool' has a wrong offset!");
static_assert(offsetof(ACharaBase, _NC_BloodPool) == 0x0032B0, "Member 'ACharaBase::_NC_BloodPool' has a wrong offset!");
static_assert(offsetof(ACharaBase, Interaction) == 0x0032D0, "Member 'ACharaBase::Interaction' has a wrong offset!");
static_assert(offsetof(ACharaBase, _InteractionOverlapComponent) == 0x0032D8, "Member 'ACharaBase::_InteractionOverlapComponent' has a wrong offset!");
static_assert(offsetof(ACharaBase, _HoldingProp) == 0x0032E8, "Member 'ACharaBase::_HoldingProp' has a wrong offset!");
static_assert(offsetof(ACharaBase, _PropJoint) == 0x0032F0, "Member 'ACharaBase::_PropJoint' has a wrong offset!");
static_assert(offsetof(ACharaBase, _PiercingProp) == 0x003308, "Member 'ACharaBase::_PiercingProp' has a wrong offset!");
static_assert(offsetof(ACharaBase, _DEBUG_RepeatAction) == 0x003310, "Member 'ACharaBase::_DEBUG_RepeatAction' has a wrong offset!");
static_assert(offsetof(ACharaBase, _DEBUG_Panel) == 0x003328, "Member 'ACharaBase::_DEBUG_Panel' has a wrong offset!");
static_assert(offsetof(ACharaBase, _DEBUG_Panel_ActiveIndex) == 0x003330, "Member 'ACharaBase::_DEBUG_Panel_ActiveIndex' has a wrong offset!");
static_assert(offsetof(ACharaBase, ExclamationComponent) == 0x003338, "Member 'ACharaBase::ExclamationComponent' has a wrong offset!");
static_assert(offsetof(ACharaBase, _UI_Nickname) == 0x003350, "Member 'ACharaBase::_UI_Nickname' has a wrong offset!");
static_assert(offsetof(ACharaBase, _UI_Emoticon) == 0x003358, "Member 'ACharaBase::_UI_Emoticon' has a wrong offset!");
static_assert(offsetof(ACharaBase, _EnableTurnInPlace) == 0x003360, "Member 'ACharaBase::_EnableTurnInPlace' has a wrong offset!");
static_assert(offsetof(ACharaBase, _1PV_Anchor) == 0x003368, "Member 'ACharaBase::_1PV_Anchor' has a wrong offset!");
static_assert(offsetof(ACharaBase, _Mesh_1PV) == 0x003370, "Member 'ACharaBase::_Mesh_1PV' has a wrong offset!");
static_assert(offsetof(ACharaBase, _InnerCapsule) == 0x003388, "Member 'ACharaBase::_InnerCapsule' has a wrong offset!");
static_assert(offsetof(ACharaBase, _MuscleStrength) == 0x003390, "Member 'ACharaBase::_MuscleStrength' has a wrong offset!");
static_assert(offsetof(ACharaBase, _MuscleStrength_DEAD) == 0x003394, "Member 'ACharaBase::_MuscleStrength_DEAD' has a wrong offset!");
static_assert(offsetof(ACharaBase, _GoldAlertTime) == 0x00339C, "Member 'ACharaBase::_GoldAlertTime' has a wrong offset!");
static_assert(offsetof(ACharaBase, _MI_ScanWorld_PP) == 0x0033A0, "Member 'ACharaBase::_MI_ScanWorld_PP' has a wrong offset!");
static_assert(offsetof(ACharaBase, _ScanWorld_Sound) == 0x0033A8, "Member 'ACharaBase::_ScanWorld_Sound' has a wrong offset!");
static_assert(offsetof(ACharaBase, _MID_ScanWorld_PP) == 0x0033B0, "Member 'ACharaBase::_MID_ScanWorld_PP' has a wrong offset!");
static_assert(offsetof(ACharaBase, _DamageViewerClass) == 0x003458, "Member 'ACharaBase::_DamageViewerClass' has a wrong offset!");
static_assert(offsetof(ACharaBase, _DamageViewerComponent) == 0x003460, "Member 'ACharaBase::_DamageViewerComponent' has a wrong offset!");
static_assert(offsetof(ACharaBase, Revivers) == 0x0034C0, "Member 'ACharaBase::Revivers' has a wrong offset!");
static_assert(offsetof(ACharaBase, MineReviver) == 0x0034D0, "Member 'ACharaBase::MineReviver' has a wrong offset!");
static_assert(offsetof(ACharaBase, _PP_DistanceGuide) == 0x0034D8, "Member 'ACharaBase::_PP_DistanceGuide' has a wrong offset!");
static_assert(offsetof(ACharaBase, _AllMaterials) == 0x0034E8, "Member 'ACharaBase::_AllMaterials' has a wrong offset!");
static_assert(offsetof(ACharaBase, _TimedMeshMaterials) == 0x003538, "Member 'ACharaBase::_TimedMeshMaterials' has a wrong offset!");
static_assert(offsetof(ACharaBase, _IsCopyOrigineMaterials) == 0x003588, "Member 'ACharaBase::_IsCopyOrigineMaterials' has a wrong offset!");
static_assert(offsetof(ACharaBase, _ExcludeMaterials) == 0x003590, "Member 'ACharaBase::_ExcludeMaterials' has a wrong offset!");

// Class Stigma.AICharaBase
// 0x01F0 (0x3840 - 0x3650)
class AAICharaBase : public ACharaBase
{
public:
	struct FAIInstanceSetting                     _CustomSetting;                                    // 0x3650(0x0028)(Edit, BlueprintVisible, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	float                                         CurrentRotationSpeed;                              // 0x3678(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_207E[0x14];                                    // 0x367C(0x0014)(Fixing Size After Last Property [ Dumper-69 ])
	class FText                                   PlacedBotNickname;                                 // 0x3690(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_207F[0x8];                                     // 0x36A8(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	struct FAIRespawn                             _Respawn;                                          // 0x36B0(0x0070)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2080[0xE8];                                    // 0x3720(0x00E8)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          _IsSummoned;                                       // 0x3808(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2081[0x3];                                     // 0x3809(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	TWeakObjectPtr<class ACharaBase>              _owner;                                            // 0x380C(0x0008)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2082[0x4];                                     // 0x3814(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UDepthSenseComponent*                   _DepthSensor;                                      // 0x3818(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FVector>                        PatrolLocations;                                   // 0x3820(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class ACLB_PatrolPoints*                      PatrolPoints;                                      // 0x3830(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentPatrolIndex;                                // 0x3838(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _CanBeSeenToOtherAI;                               // 0x383C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2083[0x3];                                     // 0x383D(0x0003)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool ArrivePatrolLocation();
	void OnRep_CustomSetting();
	void RPC_ALL_LifeTimeEnd();
	void RPC_ALL_SummonStart();

	struct FVector GetTargetPatrolLocation() const;
	bool IsSummoned() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AICharaBase">();
	}
	static class AAICharaBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAICharaBase>();
	}
};
static_assert(alignof(AAICharaBase) == 0x000010, "Wrong alignment on AAICharaBase");
static_assert(sizeof(AAICharaBase) == 0x003840, "Wrong size on AAICharaBase");
static_assert(offsetof(AAICharaBase, _CustomSetting) == 0x003650, "Member 'AAICharaBase::_CustomSetting' has a wrong offset!");
static_assert(offsetof(AAICharaBase, CurrentRotationSpeed) == 0x003678, "Member 'AAICharaBase::CurrentRotationSpeed' has a wrong offset!");
static_assert(offsetof(AAICharaBase, PlacedBotNickname) == 0x003690, "Member 'AAICharaBase::PlacedBotNickname' has a wrong offset!");
static_assert(offsetof(AAICharaBase, _Respawn) == 0x0036B0, "Member 'AAICharaBase::_Respawn' has a wrong offset!");
static_assert(offsetof(AAICharaBase, _IsSummoned) == 0x003808, "Member 'AAICharaBase::_IsSummoned' has a wrong offset!");
static_assert(offsetof(AAICharaBase, _owner) == 0x00380C, "Member 'AAICharaBase::_owner' has a wrong offset!");
static_assert(offsetof(AAICharaBase, _DepthSensor) == 0x003818, "Member 'AAICharaBase::_DepthSensor' has a wrong offset!");
static_assert(offsetof(AAICharaBase, PatrolLocations) == 0x003820, "Member 'AAICharaBase::PatrolLocations' has a wrong offset!");
static_assert(offsetof(AAICharaBase, PatrolPoints) == 0x003830, "Member 'AAICharaBase::PatrolPoints' has a wrong offset!");
static_assert(offsetof(AAICharaBase, CurrentPatrolIndex) == 0x003838, "Member 'AAICharaBase::CurrentPatrolIndex' has a wrong offset!");
static_assert(offsetof(AAICharaBase, _CanBeSeenToOtherAI) == 0x00383C, "Member 'AAICharaBase::_CanBeSeenToOtherAI' has a wrong offset!");

// Class Stigma.AGO_ChangePerspectiveView
// 0x0008 (0x0060 - 0x0058)
class UAGO_ChangePerspectiveView final : public UActionGraphOperator
{
public:
	EPerspectiveView                              _PerspectiveView;                                  // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPerspectiveView                              _PrevPerspectiveView;                              // 0x0059(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2084[0x6];                                     // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_ChangePerspectiveView">();
	}
	static class UAGO_ChangePerspectiveView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_ChangePerspectiveView>();
	}
};
static_assert(alignof(UAGO_ChangePerspectiveView) == 0x000008, "Wrong alignment on UAGO_ChangePerspectiveView");
static_assert(sizeof(UAGO_ChangePerspectiveView) == 0x000060, "Wrong size on UAGO_ChangePerspectiveView");
static_assert(offsetof(UAGO_ChangePerspectiveView, _PerspectiveView) == 0x000058, "Member 'UAGO_ChangePerspectiveView::_PerspectiveView' has a wrong offset!");
static_assert(offsetof(UAGO_ChangePerspectiveView, _PrevPerspectiveView) == 0x000059, "Member 'UAGO_ChangePerspectiveView::_PrevPerspectiveView' has a wrong offset!");

// Class Stigma.AGO_Charge
// 0x00A8 (0x0100 - 0x0058)
class UAGO_Charge final : public UActionGraphOperator
{
public:
	struct FChargeParam                           ChargeParams;                                      // 0x0058(0x0090)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         _ElapsedTime;                                      // 0x00E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2085[0x4];                                     // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class UFXSystemComponent*>             _ChargingEffectComponents;                         // 0x00F0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void DestroyChargeComp(bool _forced);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_Charge">();
	}
	static class UAGO_Charge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_Charge>();
	}
};
static_assert(alignof(UAGO_Charge) == 0x000008, "Wrong alignment on UAGO_Charge");
static_assert(sizeof(UAGO_Charge) == 0x000100, "Wrong size on UAGO_Charge");
static_assert(offsetof(UAGO_Charge, ChargeParams) == 0x000058, "Member 'UAGO_Charge::ChargeParams' has a wrong offset!");
static_assert(offsetof(UAGO_Charge, _ElapsedTime) == 0x0000E8, "Member 'UAGO_Charge::_ElapsedTime' has a wrong offset!");
static_assert(offsetof(UAGO_Charge, _ChargingEffectComponents) == 0x0000F0, "Member 'UAGO_Charge::_ChargingEffectComponents' has a wrong offset!");

// Class Stigma.BTScore_WildShoot
// 0x0000 (0x0030 - 0x0030)
class UBTScore_WildShoot final : public UBTScore
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTScore_WildShoot">();
	}
	static class UBTScore_WildShoot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTScore_WildShoot>();
	}
};
static_assert(alignof(UBTScore_WildShoot) == 0x000008, "Wrong alignment on UBTScore_WildShoot");
static_assert(sizeof(UBTScore_WildShoot) == 0x000030, "Wrong size on UBTScore_WildShoot");

// Class Stigma.AGO_ControlPowerAnim
// 0x0018 (0x0070 - 0x0058)
class UAGO_ControlPowerAnim final : public UActionGraphOperator
{
public:
	float                                         _MaxRecoil_Light;                                  // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _MaxRecoil_Middle;                                 // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _MaxRecoil_Heavy;                                  // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2086[0xC];                                     // 0x0064(0x000C)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_ControlPowerAnim">();
	}
	static class UAGO_ControlPowerAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_ControlPowerAnim>();
	}
};
static_assert(alignof(UAGO_ControlPowerAnim) == 0x000008, "Wrong alignment on UAGO_ControlPowerAnim");
static_assert(sizeof(UAGO_ControlPowerAnim) == 0x000070, "Wrong size on UAGO_ControlPowerAnim");
static_assert(offsetof(UAGO_ControlPowerAnim, _MaxRecoil_Light) == 0x000058, "Member 'UAGO_ControlPowerAnim::_MaxRecoil_Light' has a wrong offset!");
static_assert(offsetof(UAGO_ControlPowerAnim, _MaxRecoil_Middle) == 0x00005C, "Member 'UAGO_ControlPowerAnim::_MaxRecoil_Middle' has a wrong offset!");
static_assert(offsetof(UAGO_ControlPowerAnim, _MaxRecoil_Heavy) == 0x000060, "Member 'UAGO_ControlPowerAnim::_MaxRecoil_Heavy' has a wrong offset!");

// Class Stigma.UI_DamageIndicator
// 0x0018 (0x0508 - 0x04F0)
class UUI_DamageIndicator : public UPreviewableWidget
{
public:
	float                                         Duration;                                          // 0x04F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DisappearDuration;                                 // 0x04F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharaBase*                             _target;                                           // 0x04F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _Alpha;                                            // 0x0500(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _RemainTime;                                       // 0x0504(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool OnShow(bool _show, class ACharaBase* _chara);
	bool SetHitCount(int32 _count, const struct FDamagedData& _damaged_data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_DamageIndicator">();
	}
	static class UUI_DamageIndicator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_DamageIndicator>();
	}
};
static_assert(alignof(UUI_DamageIndicator) == 0x000008, "Wrong alignment on UUI_DamageIndicator");
static_assert(sizeof(UUI_DamageIndicator) == 0x000508, "Wrong size on UUI_DamageIndicator");
static_assert(offsetof(UUI_DamageIndicator, Duration) == 0x0004F0, "Member 'UUI_DamageIndicator::Duration' has a wrong offset!");
static_assert(offsetof(UUI_DamageIndicator, DisappearDuration) == 0x0004F4, "Member 'UUI_DamageIndicator::DisappearDuration' has a wrong offset!");
static_assert(offsetof(UUI_DamageIndicator, _target) == 0x0004F8, "Member 'UUI_DamageIndicator::_target' has a wrong offset!");
static_assert(offsetof(UUI_DamageIndicator, _Alpha) == 0x000500, "Member 'UUI_DamageIndicator::_Alpha' has a wrong offset!");
static_assert(offsetof(UUI_DamageIndicator, _RemainTime) == 0x000504, "Member 'UUI_DamageIndicator::_RemainTime' has a wrong offset!");

// Class Stigma.AGO_ControlRate
// 0x0010 (0x0068 - 0x0058)
class UAGO_ControlRate final : public UActionGraphOperator
{
public:
	float                                         MovementRate;                                      // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotationYawRate;                                   // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CallEnd;                                           // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_208B[0x7];                                     // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_ControlRate">();
	}
	static class UAGO_ControlRate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_ControlRate>();
	}
};
static_assert(alignof(UAGO_ControlRate) == 0x000008, "Wrong alignment on UAGO_ControlRate");
static_assert(sizeof(UAGO_ControlRate) == 0x000068, "Wrong size on UAGO_ControlRate");
static_assert(offsetof(UAGO_ControlRate, MovementRate) == 0x000058, "Member 'UAGO_ControlRate::MovementRate' has a wrong offset!");
static_assert(offsetof(UAGO_ControlRate, RotationYawRate) == 0x00005C, "Member 'UAGO_ControlRate::RotationYawRate' has a wrong offset!");
static_assert(offsetof(UAGO_ControlRate, CallEnd) == 0x000060, "Member 'UAGO_ControlRate::CallEnd' has a wrong offset!");

// Class Stigma.BTTask_FinishMainBehavior
// 0x0008 (0x0078 - 0x0070)
class UBTTask_FinishMainBehavior final : public UBTTaskNode
{
public:
	EMainBehaviorType                             FinishedBehaviorType;                              // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_208C[0x7];                                     // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_FinishMainBehavior">();
	}
	static class UBTTask_FinishMainBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_FinishMainBehavior>();
	}
};
static_assert(alignof(UBTTask_FinishMainBehavior) == 0x000008, "Wrong alignment on UBTTask_FinishMainBehavior");
static_assert(sizeof(UBTTask_FinishMainBehavior) == 0x000078, "Wrong size on UBTTask_FinishMainBehavior");
static_assert(offsetof(UBTTask_FinishMainBehavior, FinishedBehaviorType) == 0x000070, "Member 'UBTTask_FinishMainBehavior::FinishedBehaviorType' has a wrong offset!");

// Class Stigma.AGO_CounterAttack
// 0x0008 (0x0060 - 0x0058)
class UAGO_CounterAttack final : public UAGO_Base
{
public:
	EAttackType                                   CounterAttackType;                                 // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttackPriority                               AttackPriority;                                    // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_208D[0x2];                                     // 0x005A(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         ForwardAngle;                                      // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_CounterAttack">();
	}
	static class UAGO_CounterAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_CounterAttack>();
	}
};
static_assert(alignof(UAGO_CounterAttack) == 0x000008, "Wrong alignment on UAGO_CounterAttack");
static_assert(sizeof(UAGO_CounterAttack) == 0x000060, "Wrong size on UAGO_CounterAttack");
static_assert(offsetof(UAGO_CounterAttack, CounterAttackType) == 0x000058, "Member 'UAGO_CounterAttack::CounterAttackType' has a wrong offset!");
static_assert(offsetof(UAGO_CounterAttack, AttackPriority) == 0x000059, "Member 'UAGO_CounterAttack::AttackPriority' has a wrong offset!");
static_assert(offsetof(UAGO_CounterAttack, ForwardAngle) == 0x00005C, "Member 'UAGO_CounterAttack::ForwardAngle' has a wrong offset!");

// Class Stigma.AGO_CreateGun
// 0x0008 (0x0060 - 0x0058)
class UAGO_CreateGun final : public UActionGraphOperator
{
public:
	EGunType                                      GunType;                                           // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CreateFromOwnGun;                                  // 0x0059(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsMainGun;                                         // 0x005A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsRandomGun;                                       // 0x005B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          SetupOwnGun;                                       // 0x005C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_208E[0x3];                                     // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_CreateGun">();
	}
	static class UAGO_CreateGun* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_CreateGun>();
	}
};
static_assert(alignof(UAGO_CreateGun) == 0x000008, "Wrong alignment on UAGO_CreateGun");
static_assert(sizeof(UAGO_CreateGun) == 0x000060, "Wrong size on UAGO_CreateGun");
static_assert(offsetof(UAGO_CreateGun, GunType) == 0x000058, "Member 'UAGO_CreateGun::GunType' has a wrong offset!");
static_assert(offsetof(UAGO_CreateGun, CreateFromOwnGun) == 0x000059, "Member 'UAGO_CreateGun::CreateFromOwnGun' has a wrong offset!");
static_assert(offsetof(UAGO_CreateGun, IsMainGun) == 0x00005A, "Member 'UAGO_CreateGun::IsMainGun' has a wrong offset!");
static_assert(offsetof(UAGO_CreateGun, IsRandomGun) == 0x00005B, "Member 'UAGO_CreateGun::IsRandomGun' has a wrong offset!");
static_assert(offsetof(UAGO_CreateGun, SetupOwnGun) == 0x00005C, "Member 'UAGO_CreateGun::SetupOwnGun' has a wrong offset!");

// Class Stigma.BTTask_BaseMove
// 0x0000 (0x00B0 - 0x00B0)
class UBTTask_BaseMove : public UBTTask_MoveTo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_BaseMove">();
	}
	static class UBTTask_BaseMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_BaseMove>();
	}
};
static_assert(alignof(UBTTask_BaseMove) == 0x000008, "Wrong alignment on UBTTask_BaseMove");
static_assert(sizeof(UBTTask_BaseMove) == 0x0000B0, "Wrong size on UBTTask_BaseMove");

// Class Stigma.AGO_CutScene
// 0x0010 (0x0068 - 0x0058)
class UAGO_CutScene final : public UActionGraphOperator
{
public:
	bool                                          ChangeMoveMode;                                    // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMoveMode                                     MoveMode;                                          // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_208F[0x2];                                     // 0x005A(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         RotationYawRate;                                   // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECameraWalkMode                               CameraWalk;                                        // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESideViewSide                                 CameraWalkSide;                                    // 0x0061(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2090[0x6];                                     // 0x0062(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_CutScene">();
	}
	static class UAGO_CutScene* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_CutScene>();
	}
};
static_assert(alignof(UAGO_CutScene) == 0x000008, "Wrong alignment on UAGO_CutScene");
static_assert(sizeof(UAGO_CutScene) == 0x000068, "Wrong size on UAGO_CutScene");
static_assert(offsetof(UAGO_CutScene, ChangeMoveMode) == 0x000058, "Member 'UAGO_CutScene::ChangeMoveMode' has a wrong offset!");
static_assert(offsetof(UAGO_CutScene, MoveMode) == 0x000059, "Member 'UAGO_CutScene::MoveMode' has a wrong offset!");
static_assert(offsetof(UAGO_CutScene, RotationYawRate) == 0x00005C, "Member 'UAGO_CutScene::RotationYawRate' has a wrong offset!");
static_assert(offsetof(UAGO_CutScene, CameraWalk) == 0x000060, "Member 'UAGO_CutScene::CameraWalk' has a wrong offset!");
static_assert(offsetof(UAGO_CutScene, CameraWalkSide) == 0x000061, "Member 'UAGO_CutScene::CameraWalkSide' has a wrong offset!");

// Class Stigma.TargetArea
// 0x0010 (0x02A8 - 0x0298)
class ATargetArea final : public AActor
{
public:
	class UMaterialInstance*                      _DecalMtrlInstType;                                // 0x0298(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               _DecalMtrlInst;                                    // 0x02A0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetArea">();
	}
	static class ATargetArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATargetArea>();
	}
};
static_assert(alignof(ATargetArea) == 0x000008, "Wrong alignment on ATargetArea");
static_assert(sizeof(ATargetArea) == 0x0002A8, "Wrong size on ATargetArea");
static_assert(offsetof(ATargetArea, _DecalMtrlInstType) == 0x000298, "Member 'ATargetArea::_DecalMtrlInstType' has a wrong offset!");
static_assert(offsetof(ATargetArea, _DecalMtrlInst) == 0x0002A0, "Member 'ATargetArea::_DecalMtrlInst' has a wrong offset!");

// Class Stigma.AGO_DamageProvider
// 0x0018 (0x0070 - 0x0058)
class UAGO_DamageProvider : public UAGO_Base
{
public:
	struct FDamageDef                             _DamageDef;                                        // 0x0058(0x0014)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2091[0x4];                                     // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_DamageProvider">();
	}
	static class UAGO_DamageProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_DamageProvider>();
	}
};
static_assert(alignof(UAGO_DamageProvider) == 0x000008, "Wrong alignment on UAGO_DamageProvider");
static_assert(sizeof(UAGO_DamageProvider) == 0x000070, "Wrong size on UAGO_DamageProvider");
static_assert(offsetof(UAGO_DamageProvider, _DamageDef) == 0x000058, "Member 'UAGO_DamageProvider::_DamageDef' has a wrong offset!");

// Class Stigma.BTScore_FireBase
// 0x0000 (0x0030 - 0x0030)
class UBTScore_FireBase : public UBTScore
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTScore_FireBase">();
	}
	static class UBTScore_FireBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTScore_FireBase>();
	}
};
static_assert(alignof(UBTScore_FireBase) == 0x000008, "Wrong alignment on UBTScore_FireBase");
static_assert(sizeof(UBTScore_FireBase) == 0x000030, "Wrong size on UBTScore_FireBase");

// Class Stigma.BTScore_SafeFire
// 0x0000 (0x0030 - 0x0030)
class UBTScore_SafeFire final : public UBTScore_FireBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTScore_SafeFire">();
	}
	static class UBTScore_SafeFire* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTScore_SafeFire>();
	}
};
static_assert(alignof(UBTScore_SafeFire) == 0x000008, "Wrong alignment on UBTScore_SafeFire");
static_assert(sizeof(UBTScore_SafeFire) == 0x000030, "Wrong size on UBTScore_SafeFire");

// Class Stigma.AGO_Damage
// 0x0008 (0x0078 - 0x0070)
class UAGO_Damage final : public UAGO_DamageProvider
{
public:
	EBones                                        bone;                                              // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttackType                                   AttackType;                                        // 0x0071(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2092[0x6];                                     // 0x0072(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_Damage">();
	}
	static class UAGO_Damage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_Damage>();
	}
};
static_assert(alignof(UAGO_Damage) == 0x000008, "Wrong alignment on UAGO_Damage");
static_assert(sizeof(UAGO_Damage) == 0x000078, "Wrong size on UAGO_Damage");
static_assert(offsetof(UAGO_Damage, bone) == 0x000070, "Member 'UAGO_Damage::bone' has a wrong offset!");
static_assert(offsetof(UAGO_Damage, AttackType) == 0x000071, "Member 'UAGO_Damage::AttackType' has a wrong offset!");

// Class Stigma.AGO_DeactivateLeftHandIK
// 0x0000 (0x0058 - 0x0058)
class UAGO_DeactivateLeftHandIK final : public UActionGraphOperator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_DeactivateLeftHandIK">();
	}
	static class UAGO_DeactivateLeftHandIK* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_DeactivateLeftHandIK>();
	}
};
static_assert(alignof(UAGO_DeactivateLeftHandIK) == 0x000008, "Wrong alignment on UAGO_DeactivateLeftHandIK");
static_assert(sizeof(UAGO_DeactivateLeftHandIK) == 0x000058, "Wrong size on UAGO_DeactivateLeftHandIK");

// Class Stigma.BTTask_FindLocation
// 0x0008 (0x0078 - 0x0070)
class UBTTask_FindLocation final : public UBTTaskNode
{
public:
	ETargetLocationType                           LocationType;                                      // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2093[0x3];                                     // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         Radius;                                            // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_FindLocation">();
	}
	static class UBTTask_FindLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_FindLocation>();
	}
};
static_assert(alignof(UBTTask_FindLocation) == 0x000008, "Wrong alignment on UBTTask_FindLocation");
static_assert(sizeof(UBTTask_FindLocation) == 0x000078, "Wrong size on UBTTask_FindLocation");
static_assert(offsetof(UBTTask_FindLocation, LocationType) == 0x000070, "Member 'UBTTask_FindLocation::LocationType' has a wrong offset!");
static_assert(offsetof(UBTTask_FindLocation, Radius) == 0x000074, "Member 'UBTTask_FindLocation::Radius' has a wrong offset!");

// Class Stigma.AGO_DestroyHoldingProp
// 0x0000 (0x0058 - 0x0058)
class UAGO_DestroyHoldingProp final : public UActionGraphOperator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_DestroyHoldingProp">();
	}
	static class UAGO_DestroyHoldingProp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_DestroyHoldingProp>();
	}
};
static_assert(alignof(UAGO_DestroyHoldingProp) == 0x000008, "Wrong alignment on UAGO_DestroyHoldingProp");
static_assert(sizeof(UAGO_DestroyHoldingProp) == 0x000058, "Wrong size on UAGO_DestroyHoldingProp");

// Class Stigma.UI_Announce
// 0x0030 (0x0520 - 0x04F0)
class UUI_Announce : public UPreviewableWidget
{
public:
	class UTextBlock*                             TXT_Announce;                                      // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAnnounceUIType                               _CanShowUIType;                                    // 0x04F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _AddChatWhenShow;                                  // 0x04F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2094[0x26];                                    // 0x04FA(0x0026)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	int32 GetAnnouceCount() const;
	bool IsShowing() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Announce">();
	}
	static class UUI_Announce* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Announce>();
	}
};
static_assert(alignof(UUI_Announce) == 0x000008, "Wrong alignment on UUI_Announce");
static_assert(sizeof(UUI_Announce) == 0x000520, "Wrong size on UUI_Announce");
static_assert(offsetof(UUI_Announce, TXT_Announce) == 0x0004F0, "Member 'UUI_Announce::TXT_Announce' has a wrong offset!");
static_assert(offsetof(UUI_Announce, _CanShowUIType) == 0x0004F8, "Member 'UUI_Announce::_CanShowUIType' has a wrong offset!");
static_assert(offsetof(UUI_Announce, _AddChatWhenShow) == 0x0004F9, "Member 'UUI_Announce::_AddChatWhenShow' has a wrong offset!");

// Class Stigma.AGO_DetachFromOwner
// 0x0010 (0x0068 - 0x0058)
class UAGO_DetachFromOwner final : public UActionGraphOperator
{
public:
	TSubclassOf<class AObjectBase>                _ObjectType;                                       // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsAlsoDestroy;                                    // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2095[0x7];                                     // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_DetachFromOwner">();
	}
	static class UAGO_DetachFromOwner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_DetachFromOwner>();
	}
};
static_assert(alignof(UAGO_DetachFromOwner) == 0x000008, "Wrong alignment on UAGO_DetachFromOwner");
static_assert(sizeof(UAGO_DetachFromOwner) == 0x000068, "Wrong size on UAGO_DetachFromOwner");
static_assert(offsetof(UAGO_DetachFromOwner, _ObjectType) == 0x000058, "Member 'UAGO_DetachFromOwner::_ObjectType' has a wrong offset!");
static_assert(offsetof(UAGO_DetachFromOwner, _IsAlsoDestroy) == 0x000060, "Member 'UAGO_DetachFromOwner::_IsAlsoDestroy' has a wrong offset!");

// Class Stigma.BTTask_PrepareForFight
// 0x0000 (0x0070 - 0x0070)
class UBTTask_PrepareForFight final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_PrepareForFight">();
	}
	static class UBTTask_PrepareForFight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_PrepareForFight>();
	}
};
static_assert(alignof(UBTTask_PrepareForFight) == 0x000008, "Wrong alignment on UBTTask_PrepareForFight");
static_assert(sizeof(UBTTask_PrepareForFight) == 0x000070, "Wrong size on UBTTask_PrepareForFight");

// Class Stigma.AGO_Disabled
// 0x0008 (0x0060 - 0x0058)
class UAGO_Disabled final : public UActionGraphOperator
{
public:
	float                                         Duration;                                          // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2096[0x4];                                     // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_Disabled">();
	}
	static class UAGO_Disabled* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_Disabled>();
	}
};
static_assert(alignof(UAGO_Disabled) == 0x000008, "Wrong alignment on UAGO_Disabled");
static_assert(sizeof(UAGO_Disabled) == 0x000060, "Wrong size on UAGO_Disabled");
static_assert(offsetof(UAGO_Disabled, Duration) == 0x000058, "Member 'UAGO_Disabled::Duration' has a wrong offset!");

// Class Stigma.AGO_DisableThrowPreview
// 0x0008 (0x0060 - 0x0058)
class UAGO_DisableThrowPreview final : public UActionGraphOperator
{
public:
	EThrowSourceType                              ThrowObjectSource;                                 // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2097[0x7];                                     // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_DisableThrowPreview">();
	}
	static class UAGO_DisableThrowPreview* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_DisableThrowPreview>();
	}
};
static_assert(alignof(UAGO_DisableThrowPreview) == 0x000008, "Wrong alignment on UAGO_DisableThrowPreview");
static_assert(sizeof(UAGO_DisableThrowPreview) == 0x000060, "Wrong size on UAGO_DisableThrowPreview");
static_assert(offsetof(UAGO_DisableThrowPreview, ThrowObjectSource) == 0x000058, "Member 'UAGO_DisableThrowPreview::ThrowObjectSource' has a wrong offset!");

// Class Stigma.BTTask_LookAround
// 0x0028 (0x0098 - 0x0070)
class UBTTask_LookAround final : public UBTTaskNode
{
public:
	float                                         ScanInterval;                                      // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScanInterval_Random_Min;                           // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScanInterval_Random_Max;                           // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ScanAngle_Half_Degree;                             // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SwitchLookDirectionInterval_Random_Min;            // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SwitchLookDirectionInterval_Random_Max;            // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GuideSpeed;                                        // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          LimitCount;                                        // 0x008C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2098[0x3];                                     // 0x008D(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         RotationCount;                                     // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2099[0x4];                                     // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_LookAround">();
	}
	static class UBTTask_LookAround* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_LookAround>();
	}
};
static_assert(alignof(UBTTask_LookAround) == 0x000008, "Wrong alignment on UBTTask_LookAround");
static_assert(sizeof(UBTTask_LookAround) == 0x000098, "Wrong size on UBTTask_LookAround");
static_assert(offsetof(UBTTask_LookAround, ScanInterval) == 0x000070, "Member 'UBTTask_LookAround::ScanInterval' has a wrong offset!");
static_assert(offsetof(UBTTask_LookAround, ScanInterval_Random_Min) == 0x000074, "Member 'UBTTask_LookAround::ScanInterval_Random_Min' has a wrong offset!");
static_assert(offsetof(UBTTask_LookAround, ScanInterval_Random_Max) == 0x000078, "Member 'UBTTask_LookAround::ScanInterval_Random_Max' has a wrong offset!");
static_assert(offsetof(UBTTask_LookAround, ScanAngle_Half_Degree) == 0x00007C, "Member 'UBTTask_LookAround::ScanAngle_Half_Degree' has a wrong offset!");
static_assert(offsetof(UBTTask_LookAround, SwitchLookDirectionInterval_Random_Min) == 0x000080, "Member 'UBTTask_LookAround::SwitchLookDirectionInterval_Random_Min' has a wrong offset!");
static_assert(offsetof(UBTTask_LookAround, SwitchLookDirectionInterval_Random_Max) == 0x000084, "Member 'UBTTask_LookAround::SwitchLookDirectionInterval_Random_Max' has a wrong offset!");
static_assert(offsetof(UBTTask_LookAround, GuideSpeed) == 0x000088, "Member 'UBTTask_LookAround::GuideSpeed' has a wrong offset!");
static_assert(offsetof(UBTTask_LookAround, LimitCount) == 0x00008C, "Member 'UBTTask_LookAround::LimitCount' has a wrong offset!");
static_assert(offsetof(UBTTask_LookAround, RotationCount) == 0x000090, "Member 'UBTTask_LookAround::RotationCount' has a wrong offset!");

// Class Stigma.AGO_EndOfPassive
// 0x0008 (0x0060 - 0x0058)
class UAGO_EndOfPassive final : public UActionGraphOperator
{
public:
	bool                                          ClearMate;                                         // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EActionPriority                               OverridePriority;                                  // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_209A[0x6];                                     // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_EndOfPassive">();
	}
	static class UAGO_EndOfPassive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_EndOfPassive>();
	}
};
static_assert(alignof(UAGO_EndOfPassive) == 0x000008, "Wrong alignment on UAGO_EndOfPassive");
static_assert(sizeof(UAGO_EndOfPassive) == 0x000060, "Wrong size on UAGO_EndOfPassive");
static_assert(offsetof(UAGO_EndOfPassive, ClearMate) == 0x000058, "Member 'UAGO_EndOfPassive::ClearMate' has a wrong offset!");
static_assert(offsetof(UAGO_EndOfPassive, OverridePriority) == 0x000059, "Member 'UAGO_EndOfPassive::OverridePriority' has a wrong offset!");

// Class Stigma.TimedMaterialInstance
// 0x00A8 (0x00D8 - 0x0030)
class UTimedMaterialInstance final : public UAnimNotifyState
{
public:
	uint8                                         Pad_209B[0x8];                                     // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UMaterialInterface*                     _Result_MaterialInterface;                         // 0x0038(0x0008)(BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     _Result_MaterialInterface_Trans;                   // 0x0040(0x0008)(BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FItemID, struct FMaterialOpaqueAndTrans> _BodyItemID_With_Material;                         // 0x0048(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     _materialinterface;                                // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     _materialinterface_trans;                          // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _CopyMaterialParam;                                // 0x00A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_209C[0x7];                                     // 0x00A9(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FParameterAndCurve>             ParameterAndCurves;                                // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 Excludematerials;                                  // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          _onematerialonly;                                  // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _bodyonly;                                         // 0x00D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_209D[0x2];                                     // 0x00D2(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         _onematerialindex;                                 // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimedMaterialInstance">();
	}
	static class UTimedMaterialInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimedMaterialInstance>();
	}
};
static_assert(alignof(UTimedMaterialInstance) == 0x000008, "Wrong alignment on UTimedMaterialInstance");
static_assert(sizeof(UTimedMaterialInstance) == 0x0000D8, "Wrong size on UTimedMaterialInstance");
static_assert(offsetof(UTimedMaterialInstance, _Result_MaterialInterface) == 0x000038, "Member 'UTimedMaterialInstance::_Result_MaterialInterface' has a wrong offset!");
static_assert(offsetof(UTimedMaterialInstance, _Result_MaterialInterface_Trans) == 0x000040, "Member 'UTimedMaterialInstance::_Result_MaterialInterface_Trans' has a wrong offset!");
static_assert(offsetof(UTimedMaterialInstance, _BodyItemID_With_Material) == 0x000048, "Member 'UTimedMaterialInstance::_BodyItemID_With_Material' has a wrong offset!");
static_assert(offsetof(UTimedMaterialInstance, _materialinterface) == 0x000098, "Member 'UTimedMaterialInstance::_materialinterface' has a wrong offset!");
static_assert(offsetof(UTimedMaterialInstance, _materialinterface_trans) == 0x0000A0, "Member 'UTimedMaterialInstance::_materialinterface_trans' has a wrong offset!");
static_assert(offsetof(UTimedMaterialInstance, _CopyMaterialParam) == 0x0000A8, "Member 'UTimedMaterialInstance::_CopyMaterialParam' has a wrong offset!");
static_assert(offsetof(UTimedMaterialInstance, ParameterAndCurves) == 0x0000B0, "Member 'UTimedMaterialInstance::ParameterAndCurves' has a wrong offset!");
static_assert(offsetof(UTimedMaterialInstance, Excludematerials) == 0x0000C0, "Member 'UTimedMaterialInstance::Excludematerials' has a wrong offset!");
static_assert(offsetof(UTimedMaterialInstance, _onematerialonly) == 0x0000D0, "Member 'UTimedMaterialInstance::_onematerialonly' has a wrong offset!");
static_assert(offsetof(UTimedMaterialInstance, _bodyonly) == 0x0000D1, "Member 'UTimedMaterialInstance::_bodyonly' has a wrong offset!");
static_assert(offsetof(UTimedMaterialInstance, _onematerialindex) == 0x0000D4, "Member 'UTimedMaterialInstance::_onematerialindex' has a wrong offset!");

// Class Stigma.AGO_Facial
// 0x0008 (0x0060 - 0x0058)
class UAGO_Facial final : public UActionGraphOperator
{
public:
	ECharaFacialType                              _FacialType;                                       // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_209E[0x7];                                     // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_Facial">();
	}
	static class UAGO_Facial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_Facial>();
	}
};
static_assert(alignof(UAGO_Facial) == 0x000008, "Wrong alignment on UAGO_Facial");
static_assert(sizeof(UAGO_Facial) == 0x000060, "Wrong size on UAGO_Facial");
static_assert(offsetof(UAGO_Facial, _FacialType) == 0x000058, "Member 'UAGO_Facial::_FacialType' has a wrong offset!");

// Class Stigma.BTTask_DirectlyMove
// 0x0000 (0x00B0 - 0x00B0)
class UBTTask_DirectlyMove final : public UBTTask_BaseMove
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_DirectlyMove">();
	}
	static class UBTTask_DirectlyMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_DirectlyMove>();
	}
};
static_assert(alignof(UBTTask_DirectlyMove) == 0x000008, "Wrong alignment on UBTTask_DirectlyMove");
static_assert(sizeof(UBTTask_DirectlyMove) == 0x0000B0, "Wrong size on UBTTask_DirectlyMove");

// Class Stigma.AGO_RangedAttack
// 0x0010 (0x0080 - 0x0070)
class UAGO_RangedAttack : public UAGO_DamageProvider
{
public:
	EAttackType                                   AttackType;                                        // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_209F[0x3];                                     // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         AttackRange;                                       // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AttackAngle;                                       // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20A0[0x4];                                     // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_RangedAttack">();
	}
	static class UAGO_RangedAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_RangedAttack>();
	}
};
static_assert(alignof(UAGO_RangedAttack) == 0x000008, "Wrong alignment on UAGO_RangedAttack");
static_assert(sizeof(UAGO_RangedAttack) == 0x000080, "Wrong size on UAGO_RangedAttack");
static_assert(offsetof(UAGO_RangedAttack, AttackType) == 0x000070, "Member 'UAGO_RangedAttack::AttackType' has a wrong offset!");
static_assert(offsetof(UAGO_RangedAttack, AttackRange) == 0x000074, "Member 'UAGO_RangedAttack::AttackRange' has a wrong offset!");
static_assert(offsetof(UAGO_RangedAttack, AttackAngle) == 0x000078, "Member 'UAGO_RangedAttack::AttackAngle' has a wrong offset!");

// Class Stigma.AGO_FlashBang
// 0x0010 (0x0090 - 0x0080)
class UAGO_FlashBang final : public UAGO_RangedAttack
{
public:
	struct FConfig_FlashBang                      FlashBangParam;                                    // 0x0080(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_FlashBang">();
	}
	static class UAGO_FlashBang* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_FlashBang>();
	}
};
static_assert(alignof(UAGO_FlashBang) == 0x000008, "Wrong alignment on UAGO_FlashBang");
static_assert(sizeof(UAGO_FlashBang) == 0x000090, "Wrong size on UAGO_FlashBang");
static_assert(offsetof(UAGO_FlashBang, FlashBangParam) == 0x000080, "Member 'UAGO_FlashBang::FlashBangParam' has a wrong offset!");

// Class Stigma.BTTask_PatrolMove
// 0x0000 (0x00B0 - 0x00B0)
class UBTTask_PatrolMove final : public UBTTask_BaseMove
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_PatrolMove">();
	}
	static class UBTTask_PatrolMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_PatrolMove>();
	}
};
static_assert(alignof(UBTTask_PatrolMove) == 0x000008, "Wrong alignment on UBTTask_PatrolMove");
static_assert(sizeof(UBTTask_PatrolMove) == 0x0000B0, "Wrong size on UBTTask_PatrolMove");

// Class Stigma.AGO_LoadMagazine
// 0x0008 (0x0068 - 0x0060)
class UAGO_LoadMagazine final : public UActionGraphOperator_DynamicAnimBase
{
public:
	bool                                          _ForMainGun;                                       // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20A1[0x7];                                     // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_LoadMagazine">();
	}
	static class UAGO_LoadMagazine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_LoadMagazine>();
	}
};
static_assert(alignof(UAGO_LoadMagazine) == 0x000008, "Wrong alignment on UAGO_LoadMagazine");
static_assert(sizeof(UAGO_LoadMagazine) == 0x000068, "Wrong size on UAGO_LoadMagazine");
static_assert(offsetof(UAGO_LoadMagazine, _ForMainGun) == 0x000060, "Member 'UAGO_LoadMagazine::_ForMainGun' has a wrong offset!");

// Class Stigma.UI_LobbyPage
// 0x0020 (0x0510 - 0x04F0)
class UUI_LobbyPage : public UPreviewableWidget
{
public:
	ELobbyPage                                    PreviousPage;                                      // 0x04F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20A2[0x7];                                     // 0x04F1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class FText                                   DisplayName;                                       // 0x04F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	bool GoBack();
	bool HandleOnKeyClose();
	bool OnClosePage(ELobbyPage _next_page);
	bool OnMatchChanged();
	bool OnOpenPage(EItemCategory _option, ELobbyPage _prev_page);
	bool OnParty_CharacterUpdated(const struct FUserID& _user_id, const struct FCharSpec& _chara);
	bool OnParty_Entered(const class UBriefParty* _party);
	bool OnParty_Exited();
	bool OnParty_LeaderUpdated(const struct FUserID& _leader_id);
	bool OnParty_MemberAdded(const class UBriefParty* _party, const class UUserProfile* _member);
	bool OnParty_MemberDeleted(const class UBriefParty* _party, const struct FUserID& _user_id);
	void PlaySelectionCutScene();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_LobbyPage">();
	}
	static class UUI_LobbyPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_LobbyPage>();
	}
};
static_assert(alignof(UUI_LobbyPage) == 0x000008, "Wrong alignment on UUI_LobbyPage");
static_assert(sizeof(UUI_LobbyPage) == 0x000510, "Wrong size on UUI_LobbyPage");
static_assert(offsetof(UUI_LobbyPage, PreviousPage) == 0x0004F0, "Member 'UUI_LobbyPage::PreviousPage' has a wrong offset!");
static_assert(offsetof(UUI_LobbyPage, DisplayName) == 0x0004F8, "Member 'UUI_LobbyPage::DisplayName' has a wrong offset!");

// Class Stigma.AGO_LoadBullet
// 0x0008 (0x0068 - 0x0060)
class UAGO_LoadBullet final : public UActionGraphOperator_DynamicAnimBase
{
public:
	bool                                          _ForMainGun;                                       // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20A8[0x7];                                     // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_LoadBullet">();
	}
	static class UAGO_LoadBullet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_LoadBullet>();
	}
};
static_assert(alignof(UAGO_LoadBullet) == 0x000008, "Wrong alignment on UAGO_LoadBullet");
static_assert(sizeof(UAGO_LoadBullet) == 0x000068, "Wrong size on UAGO_LoadBullet");
static_assert(offsetof(UAGO_LoadBullet, _ForMainGun) == 0x000060, "Member 'UAGO_LoadBullet::_ForMainGun' has a wrong offset!");

// Class Stigma.BT_V3_Dodge
// 0x0000 (0x0070 - 0x0070)
class UBT_V3_Dodge final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BT_V3_Dodge">();
	}
	static class UBT_V3_Dodge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBT_V3_Dodge>();
	}
};
static_assert(alignof(UBT_V3_Dodge) == 0x000008, "Wrong alignment on UBT_V3_Dodge");
static_assert(sizeof(UBT_V3_Dodge) == 0x000070, "Wrong size on UBT_V3_Dodge");

// Class Stigma.AGO_AutoFiring
// 0x0018 (0x0070 - 0x0058)
class UAGO_AutoFiring final : public UActionGraphOperator
{
public:
	float                                         _interval;                                         // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20A9[0x14];                                    // 0x005C(0x0014)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_AutoFiring">();
	}
	static class UAGO_AutoFiring* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_AutoFiring>();
	}
};
static_assert(alignof(UAGO_AutoFiring) == 0x000008, "Wrong alignment on UAGO_AutoFiring");
static_assert(sizeof(UAGO_AutoFiring) == 0x000070, "Wrong size on UAGO_AutoFiring");
static_assert(offsetof(UAGO_AutoFiring, _interval) == 0x000058, "Member 'UAGO_AutoFiring::_interval' has a wrong offset!");

// Class Stigma.AGO_EnableGunSlot
// 0x0008 (0x0060 - 0x0058)
class UAGO_EnableGunSlot final : public UActionGraphOperator
{
public:
	EGunUsage                                     _GunUsage;                                         // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGunUsage                                     _RestoreUsage;                                     // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20AA[0x6];                                     // 0x005A(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_EnableGunSlot">();
	}
	static class UAGO_EnableGunSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_EnableGunSlot>();
	}
};
static_assert(alignof(UAGO_EnableGunSlot) == 0x000008, "Wrong alignment on UAGO_EnableGunSlot");
static_assert(sizeof(UAGO_EnableGunSlot) == 0x000060, "Wrong size on UAGO_EnableGunSlot");
static_assert(offsetof(UAGO_EnableGunSlot, _GunUsage) == 0x000058, "Member 'UAGO_EnableGunSlot::_GunUsage' has a wrong offset!");
static_assert(offsetof(UAGO_EnableGunSlot, _RestoreUsage) == 0x000059, "Member 'UAGO_EnableGunSlot::_RestoreUsage' has a wrong offset!");

// Class Stigma.BTTask_TryAction
// 0x0038 (0x00A8 - 0x0070)
class UBTTask_TryAction final : public UBTTaskNode
{
public:
	ECharaAction                                  Action;                                            // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20AB[0x7];                                     // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FBlackboardKeySelector                 Toward;                                            // 0x0078(0x0028)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          InverseDirection;                                  // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ConvertToLocalSpaceDirection;                      // 0x00A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          OverrideResult;                                    // 0x00A2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBTNodeResult                                 Result;                                            // 0x00A3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20AC[0x4];                                     // 0x00A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_TryAction">();
	}
	static class UBTTask_TryAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_TryAction>();
	}
};
static_assert(alignof(UBTTask_TryAction) == 0x000008, "Wrong alignment on UBTTask_TryAction");
static_assert(sizeof(UBTTask_TryAction) == 0x0000A8, "Wrong size on UBTTask_TryAction");
static_assert(offsetof(UBTTask_TryAction, Action) == 0x000070, "Member 'UBTTask_TryAction::Action' has a wrong offset!");
static_assert(offsetof(UBTTask_TryAction, Toward) == 0x000078, "Member 'UBTTask_TryAction::Toward' has a wrong offset!");
static_assert(offsetof(UBTTask_TryAction, InverseDirection) == 0x0000A0, "Member 'UBTTask_TryAction::InverseDirection' has a wrong offset!");
static_assert(offsetof(UBTTask_TryAction, ConvertToLocalSpaceDirection) == 0x0000A1, "Member 'UBTTask_TryAction::ConvertToLocalSpaceDirection' has a wrong offset!");
static_assert(offsetof(UBTTask_TryAction, OverrideResult) == 0x0000A2, "Member 'UBTTask_TryAction::OverrideResult' has a wrong offset!");
static_assert(offsetof(UBTTask_TryAction, Result) == 0x0000A3, "Member 'UBTTask_TryAction::Result' has a wrong offset!");

// Class Stigma.AGO_FireOneShot
// 0x0008 (0x0060 - 0x0058)
class UAGO_FireOneShot final : public UActionGraphOperator
{
public:
	EGunUsage                                     _GunUsage;                                         // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20AD[0x7];                                     // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_FireOneShot">();
	}
	static class UAGO_FireOneShot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_FireOneShot>();
	}
};
static_assert(alignof(UAGO_FireOneShot) == 0x000008, "Wrong alignment on UAGO_FireOneShot");
static_assert(sizeof(UAGO_FireOneShot) == 0x000060, "Wrong size on UAGO_FireOneShot");
static_assert(offsetof(UAGO_FireOneShot, _GunUsage) == 0x000058, "Member 'UAGO_FireOneShot::_GunUsage' has a wrong offset!");

// Class Stigma.UI_ChatBox
// 0x0188 (0x0678 - 0x04F0)
class UUI_ChatBox : public UPreviewableWidget
{
public:
	EChatBoxInitType                              _InitMode;                                         // 0x04F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EChatBoxInputStateType                        _ChatBoxInputState;                                // 0x04F1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EChatBoxPanelStateType                        _ChatBoxPanelState;                                // 0x04F2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20AE[0x5];                                     // 0x04F3(0x0005)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UUI_ChatSlot>               _ChatSlotClassType;                                // 0x04F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   _IdleChannelStateHintText;                         // 0x0500(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	int32                                         _MinHistoryAreaScaleLevel;                         // 0x0518(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _CurHistoryAreaScaleLevel;                         // 0x051C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _MaxHistoryAreaScaleLevel;                         // 0x0520(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _ChatSlotHeightPerScaleLevel;                      // 0x0524(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _MaxInputLength;                                   // 0x0528(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20AF[0x10];                                    // 0x052C(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	struct FLinearColor                           _TeamChannelColor;                                 // 0x053C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _PartyChannelColor;                                // 0x054C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20B0[0x4];                                     // 0x055C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UClass*                                 BP_ChatSlotClass;                                  // 0x0560(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               SZ_HistoryArea;                                    // 0x0568(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                HiddenModeArea;                                    // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             HiddenModeText;                                    // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                ShowModeArea;                                      // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UListView*                              ChatListView;                                      // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CurChannelTypeText;                                // 0x0590(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChatText*                              ChatInputBox;                                      // 0x0598(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ChatHintText;                                      // 0x05A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WS_Chats;                                          // 0x05A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_RadioChatBox*                       RadioChatBox;                                      // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                IMG_Background;                                    // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20B1[0x8];                                     // 0x05C0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class ULVData_ChatItem*>               _TipChatSlots;                                     // 0x05C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UObject*>                        _TemporarySaveChatSlots;                           // 0x05D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<class FString, struct FFilterWordsBundle> _FilterBundleMap;                                  // 0x05E8(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_20B2[0x10];                                    // 0x0638(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             _OnUserCommitTeamChat;                             // 0x0648(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _OnUserCommitPartyChat;                            // 0x0658(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _OnUserCommitShoutChat;                            // 0x0668(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	void ChangeChannel(EChatBoxChannelType _channel, bool _change_hint_text);
	void ChangeInputState(EChatBoxInputStateType _state);
	void ChangePanelState(EChatBoxPanelStateType _state);
	void ClearAllChatHistories();
	void EnablePartyCheck(bool _flag);
	void EnqueueChatHistory(const struct FChatMsg& _slot_data);
	void FinishChatProcess();
	void Init();
	void OnStartChat();
	void OnTextChange(const class FText& Text);
	void OnTextCommit(const class FText& _text);
	void OnUserCommitPartyChatDelegate__DelegateSignature(const struct FChatMsg& _message);
	void OnUserCommitShoutChatDelegate__DelegateSignature(const struct FChatMsg& _message);
	void OnUserCommitTeamChatDelegate__DelegateSignature(const struct FChatMsg& _message);
	void SelectRadioChatCategory(int32 _idx);
	void SelectRadioChatListItem(int32 _idx);
	void SetAllowChat(bool _flag);
	void SetAllowedChannels(EChatBoxChannelType _channels);
	void SetAllowedShout(bool _flag);
	void SetHintText(const class FText& _text);
	void ToggleRadioChat();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_ChatBox">();
	}
	static class UUI_ChatBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_ChatBox>();
	}
};
static_assert(alignof(UUI_ChatBox) == 0x000008, "Wrong alignment on UUI_ChatBox");
static_assert(sizeof(UUI_ChatBox) == 0x000678, "Wrong size on UUI_ChatBox");
static_assert(offsetof(UUI_ChatBox, _InitMode) == 0x0004F0, "Member 'UUI_ChatBox::_InitMode' has a wrong offset!");
static_assert(offsetof(UUI_ChatBox, _ChatBoxInputState) == 0x0004F1, "Member 'UUI_ChatBox::_ChatBoxInputState' has a wrong offset!");
static_assert(offsetof(UUI_ChatBox, _ChatBoxPanelState) == 0x0004F2, "Member 'UUI_ChatBox::_ChatBoxPanelState' has a wrong offset!");
static_assert(offsetof(UUI_ChatBox, _ChatSlotClassType) == 0x0004F8, "Member 'UUI_ChatBox::_ChatSlotClassType' has a wrong offset!");
static_assert(offsetof(UUI_ChatBox, _IdleChannelStateHintText) == 0x000500, "Member 'UUI_ChatBox::_IdleChannelStateHintText' has a wrong offset!");
static_assert(offsetof(UUI_ChatBox, _MinHistoryAreaScaleLevel) == 0x000518, "Member 'UUI_ChatBox::_MinHistoryAreaScaleLevel' has a wrong offset!");
static_assert(offsetof(UUI_ChatBox, _CurHistoryAreaScaleLevel) == 0x00051C, "Member 'UUI_ChatBox::_CurHistoryAreaScaleLevel' has a wrong offset!");
static_assert(offsetof(UUI_ChatBox, _MaxHistoryAreaScaleLevel) == 0x000520, "Member 'UUI_ChatBox::_MaxHistoryAreaScaleLevel' has a wrong offset!");
static_assert(offsetof(UUI_ChatBox, _ChatSlotHeightPerScaleLevel) == 0x000524, "Member 'UUI_ChatBox::_ChatSlotHeightPerScaleLevel' has a wrong offset!");
static_assert(offsetof(UUI_ChatBox, _MaxInputLength) == 0x000528, "Member 'UUI_ChatBox::_MaxInputLength' has a wrong offset!");
static_assert(offsetof(UUI_ChatBox, _TeamChannelColor) == 0x00053C, "Member 'UUI_ChatBox::_TeamChannelColor' has a wrong offset!");
static_assert(offsetof(UUI_ChatBox, _PartyChannelColor) == 0x00054C, "Member 'UUI_ChatBox::_PartyChannelColor' has a wrong offset!");
static_assert(offsetof(UUI_ChatBox, BP_ChatSlotClass) == 0x000560, "Member 'UUI_ChatBox::BP_ChatSlotClass' has a wrong offset!");
static_assert(offsetof(UUI_ChatBox, SZ_HistoryArea) == 0x000568, "Member 'UUI_ChatBox::SZ_HistoryArea' has a wrong offset!");
static_assert(offsetof(UUI_ChatBox, HiddenModeArea) == 0x000570, "Member 'UUI_ChatBox::HiddenModeArea' has a wrong offset!");
static_assert(offsetof(UUI_ChatBox, HiddenModeText) == 0x000578, "Member 'UUI_ChatBox::HiddenModeText' has a wrong offset!");
static_assert(offsetof(UUI_ChatBox, ShowModeArea) == 0x000580, "Member 'UUI_ChatBox::ShowModeArea' has a wrong offset!");
static_assert(offsetof(UUI_ChatBox, ChatListView) == 0x000588, "Member 'UUI_ChatBox::ChatListView' has a wrong offset!");
static_assert(offsetof(UUI_ChatBox, CurChannelTypeText) == 0x000590, "Member 'UUI_ChatBox::CurChannelTypeText' has a wrong offset!");
static_assert(offsetof(UUI_ChatBox, ChatInputBox) == 0x000598, "Member 'UUI_ChatBox::ChatInputBox' has a wrong offset!");
static_assert(offsetof(UUI_ChatBox, ChatHintText) == 0x0005A0, "Member 'UUI_ChatBox::ChatHintText' has a wrong offset!");
static_assert(offsetof(UUI_ChatBox, WS_Chats) == 0x0005A8, "Member 'UUI_ChatBox::WS_Chats' has a wrong offset!");
static_assert(offsetof(UUI_ChatBox, RadioChatBox) == 0x0005B0, "Member 'UUI_ChatBox::RadioChatBox' has a wrong offset!");
static_assert(offsetof(UUI_ChatBox, IMG_Background) == 0x0005B8, "Member 'UUI_ChatBox::IMG_Background' has a wrong offset!");
static_assert(offsetof(UUI_ChatBox, _TipChatSlots) == 0x0005C8, "Member 'UUI_ChatBox::_TipChatSlots' has a wrong offset!");
static_assert(offsetof(UUI_ChatBox, _TemporarySaveChatSlots) == 0x0005D8, "Member 'UUI_ChatBox::_TemporarySaveChatSlots' has a wrong offset!");
static_assert(offsetof(UUI_ChatBox, _FilterBundleMap) == 0x0005E8, "Member 'UUI_ChatBox::_FilterBundleMap' has a wrong offset!");
static_assert(offsetof(UUI_ChatBox, _OnUserCommitTeamChat) == 0x000648, "Member 'UUI_ChatBox::_OnUserCommitTeamChat' has a wrong offset!");
static_assert(offsetof(UUI_ChatBox, _OnUserCommitPartyChat) == 0x000658, "Member 'UUI_ChatBox::_OnUserCommitPartyChat' has a wrong offset!");
static_assert(offsetof(UUI_ChatBox, _OnUserCommitShoutChat) == 0x000668, "Member 'UUI_ChatBox::_OnUserCommitShoutChat' has a wrong offset!");

// Class Stigma.AGO_InfiniteBullet
// 0x0000 (0x0058 - 0x0058)
class UAGO_InfiniteBullet final : public UActionGraphOperator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_InfiniteBullet">();
	}
	static class UAGO_InfiniteBullet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_InfiniteBullet>();
	}
};
static_assert(alignof(UAGO_InfiniteBullet) == 0x000008, "Wrong alignment on UAGO_InfiniteBullet");
static_assert(sizeof(UAGO_InfiniteBullet) == 0x000058, "Wrong size on UAGO_InfiniteBullet");

// Class Stigma.BTTask_MoveToSwitch
// 0x0000 (0x00B0 - 0x00B0)
class UBTTask_MoveToSwitch final : public UBTTask_BaseMove
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_MoveToSwitch">();
	}
	static class UBTTask_MoveToSwitch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_MoveToSwitch>();
	}
};
static_assert(alignof(UBTTask_MoveToSwitch) == 0x000008, "Wrong alignment on UBTTask_MoveToSwitch");
static_assert(sizeof(UBTTask_MoveToSwitch) == 0x0000B0, "Wrong size on UBTTask_MoveToSwitch");

// Class Stigma.AGO_InputDirection
// 0x0000 (0x0058 - 0x0058)
class UAGO_InputDirection final : public UActionGraphOperator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_InputDirection">();
	}
	static class UAGO_InputDirection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_InputDirection>();
	}
};
static_assert(alignof(UAGO_InputDirection) == 0x000008, "Wrong alignment on UAGO_InputDirection");
static_assert(sizeof(UAGO_InputDirection) == 0x000058, "Wrong size on UAGO_InputDirection");

// Class Stigma.AGO_LowerState
// 0x0008 (0x0060 - 0x0058)
class UAGO_LowerState final : public UActionGraphOperator
{
public:
	EBodyLowerState                               LowerState;                                        // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20B3[0x7];                                     // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_LowerState">();
	}
	static class UAGO_LowerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_LowerState>();
	}
};
static_assert(alignof(UAGO_LowerState) == 0x000008, "Wrong alignment on UAGO_LowerState");
static_assert(sizeof(UAGO_LowerState) == 0x000060, "Wrong size on UAGO_LowerState");
static_assert(offsetof(UAGO_LowerState, LowerState) == 0x000058, "Member 'UAGO_LowerState::LowerState' has a wrong offset!");

// Class Stigma.MissionArea
// 0x0038 (0x02D0 - 0x0298)
class AMissionArea final : public AActor
{
public:
	uint8                                         Pad_20B4[0x8];                                     // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class FString                                 _AreaName;                                         // 0x02A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   _DisplayName;                                      // 0x02B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	bool                                          _IsLocalCharaOverlapped;                           // 0x02C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsActivated;                                      // 0x02C9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20B5[0x6];                                     // 0x02CA(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ActivateArea(bool _activate);
	void OnCharaBeginOverlap(class ACharaBase* _chara);
	void OnCharaEndOverlap(class ACharaBase* _chara);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionArea">();
	}
	static class AMissionArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMissionArea>();
	}
};
static_assert(alignof(AMissionArea) == 0x000008, "Wrong alignment on AMissionArea");
static_assert(sizeof(AMissionArea) == 0x0002D0, "Wrong size on AMissionArea");
static_assert(offsetof(AMissionArea, _AreaName) == 0x0002A0, "Member 'AMissionArea::_AreaName' has a wrong offset!");
static_assert(offsetof(AMissionArea, _DisplayName) == 0x0002B0, "Member 'AMissionArea::_DisplayName' has a wrong offset!");
static_assert(offsetof(AMissionArea, _IsLocalCharaOverlapped) == 0x0002C8, "Member 'AMissionArea::_IsLocalCharaOverlapped' has a wrong offset!");
static_assert(offsetof(AMissionArea, _IsActivated) == 0x0002C9, "Member 'AMissionArea::_IsActivated' has a wrong offset!");

// Class Stigma.AGO_MeleeAttack
// 0x00A0 (0x0110 - 0x0070)
class UAGO_MeleeAttack final : public UAGO_DamageProvider
{
public:
	EDamageTarget                                 Target;                                            // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttackType                                   AttackType;                                        // 0x0071(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          MultiHit;                                          // 0x0072(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CanHitLyingEnemy;                                  // 0x0073(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttackPriority                               AttackPriority;                                    // 0x0074(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20B6[0x3];                                     // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	struct FLinearColor                           AttackPriorityColor;                               // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraSystem*                         AttackPriorityNiagaraSystem;                       // 0x0088(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMeleeAttackPoint                             AttackPoint;                                       // 0x0090(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20B7[0x3];                                     // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         RadiusScaler;                                      // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapsuleHeightScaler;                               // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ForwardOffset;                                     // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RightOffset;                                       // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UpOffset;                                          // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsSetupMate;                                       // 0x00A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsHitOnlyChara;                                    // 0x00A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsLockTransformExceptRootMotion;                   // 0x00AA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20B8[0x65];                                    // 0x00AB(0x0065)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void SetAttackPriorityColor(EAttackPriority _attackpriority);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_MeleeAttack">();
	}
	static class UAGO_MeleeAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_MeleeAttack>();
	}
};
static_assert(alignof(UAGO_MeleeAttack) == 0x000008, "Wrong alignment on UAGO_MeleeAttack");
static_assert(sizeof(UAGO_MeleeAttack) == 0x000110, "Wrong size on UAGO_MeleeAttack");
static_assert(offsetof(UAGO_MeleeAttack, Target) == 0x000070, "Member 'UAGO_MeleeAttack::Target' has a wrong offset!");
static_assert(offsetof(UAGO_MeleeAttack, AttackType) == 0x000071, "Member 'UAGO_MeleeAttack::AttackType' has a wrong offset!");
static_assert(offsetof(UAGO_MeleeAttack, MultiHit) == 0x000072, "Member 'UAGO_MeleeAttack::MultiHit' has a wrong offset!");
static_assert(offsetof(UAGO_MeleeAttack, CanHitLyingEnemy) == 0x000073, "Member 'UAGO_MeleeAttack::CanHitLyingEnemy' has a wrong offset!");
static_assert(offsetof(UAGO_MeleeAttack, AttackPriority) == 0x000074, "Member 'UAGO_MeleeAttack::AttackPriority' has a wrong offset!");
static_assert(offsetof(UAGO_MeleeAttack, AttackPriorityColor) == 0x000078, "Member 'UAGO_MeleeAttack::AttackPriorityColor' has a wrong offset!");
static_assert(offsetof(UAGO_MeleeAttack, AttackPriorityNiagaraSystem) == 0x000088, "Member 'UAGO_MeleeAttack::AttackPriorityNiagaraSystem' has a wrong offset!");
static_assert(offsetof(UAGO_MeleeAttack, AttackPoint) == 0x000090, "Member 'UAGO_MeleeAttack::AttackPoint' has a wrong offset!");
static_assert(offsetof(UAGO_MeleeAttack, RadiusScaler) == 0x000094, "Member 'UAGO_MeleeAttack::RadiusScaler' has a wrong offset!");
static_assert(offsetof(UAGO_MeleeAttack, CapsuleHeightScaler) == 0x000098, "Member 'UAGO_MeleeAttack::CapsuleHeightScaler' has a wrong offset!");
static_assert(offsetof(UAGO_MeleeAttack, ForwardOffset) == 0x00009C, "Member 'UAGO_MeleeAttack::ForwardOffset' has a wrong offset!");
static_assert(offsetof(UAGO_MeleeAttack, RightOffset) == 0x0000A0, "Member 'UAGO_MeleeAttack::RightOffset' has a wrong offset!");
static_assert(offsetof(UAGO_MeleeAttack, UpOffset) == 0x0000A4, "Member 'UAGO_MeleeAttack::UpOffset' has a wrong offset!");
static_assert(offsetof(UAGO_MeleeAttack, IsSetupMate) == 0x0000A8, "Member 'UAGO_MeleeAttack::IsSetupMate' has a wrong offset!");
static_assert(offsetof(UAGO_MeleeAttack, IsHitOnlyChara) == 0x0000A9, "Member 'UAGO_MeleeAttack::IsHitOnlyChara' has a wrong offset!");
static_assert(offsetof(UAGO_MeleeAttack, IsLockTransformExceptRootMotion) == 0x0000AA, "Member 'UAGO_MeleeAttack::IsLockTransformExceptRootMotion' has a wrong offset!");

// Class Stigma.AGO_MeleeBooster
// 0x0010 (0x0068 - 0x0058)
class UAGO_MeleeBooster final : public UActionGraphOperator
{
public:
	struct FLinearColor                           _FxColor;                                          // 0x0058(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_MeleeBooster">();
	}
	static class UAGO_MeleeBooster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_MeleeBooster>();
	}
};
static_assert(alignof(UAGO_MeleeBooster) == 0x000008, "Wrong alignment on UAGO_MeleeBooster");
static_assert(sizeof(UAGO_MeleeBooster) == 0x000068, "Wrong size on UAGO_MeleeBooster");
static_assert(offsetof(UAGO_MeleeBooster, _FxColor) == 0x000058, "Member 'UAGO_MeleeBooster::_FxColor' has a wrong offset!");

// Class Stigma.AGO_ModifyStock
// 0x00A0 (0x00F8 - 0x0058)
class UAGO_ModifyStock final : public UActionGraphOperator
{
public:
	struct FActionStock                           ActionStock;                                       // 0x0058(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_20B9[0x50];                                    // 0x00A8(0x0050)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_ModifyStock">();
	}
	static class UAGO_ModifyStock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_ModifyStock>();
	}
};
static_assert(alignof(UAGO_ModifyStock) == 0x000008, "Wrong alignment on UAGO_ModifyStock");
static_assert(sizeof(UAGO_ModifyStock) == 0x0000F8, "Wrong size on UAGO_ModifyStock");
static_assert(offsetof(UAGO_ModifyStock, ActionStock) == 0x000058, "Member 'UAGO_ModifyStock::ActionStock' has a wrong offset!");

// Class Stigma.MissionCondition
// 0x0040 (0x0068 - 0x0028)
class UMissionCondition : public UObject
{
public:
	EMissionConditionType                         _type;                                             // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20BA[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class FString                                 _SubType;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _CurrentValue;                                     // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20BB[0x24];                                    // 0x0044(0x0024)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnConditionReported(const struct FMissionConditionInfo& _info);

	bool FailOnCalled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition">();
	}
	static class UMissionCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition>();
	}
};
static_assert(alignof(UMissionCondition) == 0x000008, "Wrong alignment on UMissionCondition");
static_assert(sizeof(UMissionCondition) == 0x000068, "Wrong size on UMissionCondition");
static_assert(offsetof(UMissionCondition, _type) == 0x000028, "Member 'UMissionCondition::_type' has a wrong offset!");
static_assert(offsetof(UMissionCondition, _SubType) == 0x000030, "Member 'UMissionCondition::_SubType' has a wrong offset!");
static_assert(offsetof(UMissionCondition, _CurrentValue) == 0x000040, "Member 'UMissionCondition::_CurrentValue' has a wrong offset!");

// Class Stigma.MissionCondition_RoundWin
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_RoundWin final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_RoundWin">();
	}
	static class UMissionCondition_RoundWin* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_RoundWin>();
	}
};
static_assert(alignof(UMissionCondition_RoundWin) == 0x000008, "Wrong alignment on UMissionCondition_RoundWin");
static_assert(sizeof(UMissionCondition_RoundWin) == 0x000068, "Wrong size on UMissionCondition_RoundWin");

// Class Stigma.AGO_MoveMode
// 0x0008 (0x0060 - 0x0058)
class UAGO_MoveMode final : public UActionGraphOperator
{
public:
	EMoveMode                                     MoveMode;                                          // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20BC[0x3];                                     // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         RotationYawRate;                                   // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_MoveMode">();
	}
	static class UAGO_MoveMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_MoveMode>();
	}
};
static_assert(alignof(UAGO_MoveMode) == 0x000008, "Wrong alignment on UAGO_MoveMode");
static_assert(sizeof(UAGO_MoveMode) == 0x000060, "Wrong size on UAGO_MoveMode");
static_assert(offsetof(UAGO_MoveMode, MoveMode) == 0x000058, "Member 'UAGO_MoveMode::MoveMode' has a wrong offset!");
static_assert(offsetof(UAGO_MoveMode, RotationYawRate) == 0x00005C, "Member 'UAGO_MoveMode::RotationYawRate' has a wrong offset!");

// Class Stigma.HUD_KillLogPanel
// 0x0010 (0x0500 - 0x04F0)
class UHUD_KillLogPanel : public UPreviewableWidget
{
public:
	class UVerticalBox*                           Box_KillLogSlots;                                  // 0x04F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20BD[0x8];                                     // 0x04F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void AddKillLogSlot(const struct FKillLog& _kill_log);
	void AddKillLogSlot_Bounty(const struct FActionLog_Bounty& _bounty_log);
	void AddKillLogSlot_ForRevive(const struct FKillLog_ForRevive& _kill_log_revive);
	TSubclassOf<class UHUD_KillLogSlot> GetSlotClassType();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUD_KillLogPanel">();
	}
	static class UHUD_KillLogPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUD_KillLogPanel>();
	}
};
static_assert(alignof(UHUD_KillLogPanel) == 0x000008, "Wrong alignment on UHUD_KillLogPanel");
static_assert(sizeof(UHUD_KillLogPanel) == 0x000500, "Wrong size on UHUD_KillLogPanel");
static_assert(offsetof(UHUD_KillLogPanel, Box_KillLogSlots) == 0x0004F0, "Member 'UHUD_KillLogPanel::Box_KillLogSlots' has a wrong offset!");

// Class Stigma.AGO_Penalty
// 0x0008 (0x0060 - 0x0058)
class UAGO_Penalty final : public UActionGraphOperator
{
public:
	bool                                          LegInjury;                                         // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBodyParts                                    LegInjuryPart;                                     // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Disarmed;                                          // 0x005A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BoneBreak;                                         // 0x005B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20BE[0x4];                                     // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_Penalty">();
	}
	static class UAGO_Penalty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_Penalty>();
	}
};
static_assert(alignof(UAGO_Penalty) == 0x000008, "Wrong alignment on UAGO_Penalty");
static_assert(sizeof(UAGO_Penalty) == 0x000060, "Wrong size on UAGO_Penalty");
static_assert(offsetof(UAGO_Penalty, LegInjury) == 0x000058, "Member 'UAGO_Penalty::LegInjury' has a wrong offset!");
static_assert(offsetof(UAGO_Penalty, LegInjuryPart) == 0x000059, "Member 'UAGO_Penalty::LegInjuryPart' has a wrong offset!");
static_assert(offsetof(UAGO_Penalty, Disarmed) == 0x00005A, "Member 'UAGO_Penalty::Disarmed' has a wrong offset!");
static_assert(offsetof(UAGO_Penalty, BoneBreak) == 0x00005B, "Member 'UAGO_Penalty::BoneBreak' has a wrong offset!");

// Class Stigma.AGO_PiercingShot
// 0x0018 (0x0088 - 0x0070)
class UAGO_PiercingShot final : public UAGO_DamageProvider
{
public:
	TSubclassOf<class APiercingObjectBase>        PiercingObjectClass;                               // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NoDestructor, Protected, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPiercingShotFireType                         FireType;                                          // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMeleeAttackPoint                             StartAttackPoint;                                  // 0x0079(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttackType                                   AttackType;                                        // 0x007A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20BF[0x1];                                     // 0x007B(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         ProjectileSpeed;                                   // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDistance;                                       // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CollisionRadius;                                   // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_PiercingShot">();
	}
	static class UAGO_PiercingShot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_PiercingShot>();
	}
};
static_assert(alignof(UAGO_PiercingShot) == 0x000008, "Wrong alignment on UAGO_PiercingShot");
static_assert(sizeof(UAGO_PiercingShot) == 0x000088, "Wrong size on UAGO_PiercingShot");
static_assert(offsetof(UAGO_PiercingShot, PiercingObjectClass) == 0x000070, "Member 'UAGO_PiercingShot::PiercingObjectClass' has a wrong offset!");
static_assert(offsetof(UAGO_PiercingShot, FireType) == 0x000078, "Member 'UAGO_PiercingShot::FireType' has a wrong offset!");
static_assert(offsetof(UAGO_PiercingShot, StartAttackPoint) == 0x000079, "Member 'UAGO_PiercingShot::StartAttackPoint' has a wrong offset!");
static_assert(offsetof(UAGO_PiercingShot, AttackType) == 0x00007A, "Member 'UAGO_PiercingShot::AttackType' has a wrong offset!");
static_assert(offsetof(UAGO_PiercingShot, ProjectileSpeed) == 0x00007C, "Member 'UAGO_PiercingShot::ProjectileSpeed' has a wrong offset!");
static_assert(offsetof(UAGO_PiercingShot, MaxDistance) == 0x000080, "Member 'UAGO_PiercingShot::MaxDistance' has a wrong offset!");
static_assert(offsetof(UAGO_PiercingShot, CollisionRadius) == 0x000084, "Member 'UAGO_PiercingShot::CollisionRadius' has a wrong offset!");

// Class Stigma.AGO_PushBack
// 0x0000 (0x0058 - 0x0058)
class UAGO_PushBack final : public UActionGraphOperator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_PushBack">();
	}
	static class UAGO_PushBack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_PushBack>();
	}
};
static_assert(alignof(UAGO_PushBack) == 0x000008, "Wrong alignment on UAGO_PushBack");
static_assert(sizeof(UAGO_PushBack) == 0x000058, "Wrong size on UAGO_PushBack");

// Class Stigma.MissionCondition_Assist
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_Assist final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_Assist">();
	}
	static class UMissionCondition_Assist* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_Assist>();
	}
};
static_assert(alignof(UMissionCondition_Assist) == 0x000008, "Wrong alignment on UMissionCondition_Assist");
static_assert(sizeof(UMissionCondition_Assist) == 0x000068, "Wrong size on UMissionCondition_Assist");

// Class Stigma.AGO_SetGunVisibility
// 0x0008 (0x0060 - 0x0058)
class UAGO_SetGunVisibility final : public UActionGraphOperator
{
public:
	bool                                          _SetMainGun;                                       // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _SetSubGun;                                        // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _SetHide;                                          // 0x005A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _RevertAtActionCanceled;                           // 0x005B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20C0[0x4];                                     // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_SetGunVisibility">();
	}
	static class UAGO_SetGunVisibility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_SetGunVisibility>();
	}
};
static_assert(alignof(UAGO_SetGunVisibility) == 0x000008, "Wrong alignment on UAGO_SetGunVisibility");
static_assert(sizeof(UAGO_SetGunVisibility) == 0x000060, "Wrong size on UAGO_SetGunVisibility");
static_assert(offsetof(UAGO_SetGunVisibility, _SetMainGun) == 0x000058, "Member 'UAGO_SetGunVisibility::_SetMainGun' has a wrong offset!");
static_assert(offsetof(UAGO_SetGunVisibility, _SetSubGun) == 0x000059, "Member 'UAGO_SetGunVisibility::_SetSubGun' has a wrong offset!");
static_assert(offsetof(UAGO_SetGunVisibility, _SetHide) == 0x00005A, "Member 'UAGO_SetGunVisibility::_SetHide' has a wrong offset!");
static_assert(offsetof(UAGO_SetGunVisibility, _RevertAtActionCanceled) == 0x00005B, "Member 'UAGO_SetGunVisibility::_RevertAtActionCanceled' has a wrong offset!");

// Class Stigma.MissionCondition_Organization
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_Organization final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_Organization">();
	}
	static class UMissionCondition_Organization* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_Organization>();
	}
};
static_assert(alignof(UMissionCondition_Organization) == 0x000008, "Wrong alignment on UMissionCondition_Organization");
static_assert(sizeof(UMissionCondition_Organization) == 0x000068, "Wrong size on UMissionCondition_Organization");

// Class Stigma.AGO_SoundPlay
// 0x0010 (0x0068 - 0x0058)
class UAGO_SoundPlay final : public UActionGraphOperator
{
public:
	class USoundBase*                             Sound;                                             // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          Is2DSound;                                         // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20C1[0x3];                                     // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         VolumeScale;                                       // 0x0064(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_SoundPlay">();
	}
	static class UAGO_SoundPlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_SoundPlay>();
	}
};
static_assert(alignof(UAGO_SoundPlay) == 0x000008, "Wrong alignment on UAGO_SoundPlay");
static_assert(sizeof(UAGO_SoundPlay) == 0x000068, "Wrong size on UAGO_SoundPlay");
static_assert(offsetof(UAGO_SoundPlay, Sound) == 0x000058, "Member 'UAGO_SoundPlay::Sound' has a wrong offset!");
static_assert(offsetof(UAGO_SoundPlay, Is2DSound) == 0x000060, "Member 'UAGO_SoundPlay::Is2DSound' has a wrong offset!");
static_assert(offsetof(UAGO_SoundPlay, VolumeScale) == 0x000064, "Member 'UAGO_SoundPlay::VolumeScale' has a wrong offset!");

// Class Stigma.AGO_SpawnActor
// 0x0068 (0x00C0 - 0x0058)
class UAGO_SpawnActor final : public UActionGraphOperator
{
public:
	TSubclassOf<class AActor>                     ActorType;                                         // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             OffsetTransform;                                   // 0x0060(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_SpawnActor">();
	}
	static class UAGO_SpawnActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_SpawnActor>();
	}
};
static_assert(alignof(UAGO_SpawnActor) == 0x000010, "Wrong alignment on UAGO_SpawnActor");
static_assert(sizeof(UAGO_SpawnActor) == 0x0000C0, "Wrong size on UAGO_SpawnActor");
static_assert(offsetof(UAGO_SpawnActor, ActorType) == 0x000058, "Member 'UAGO_SpawnActor::ActorType' has a wrong offset!");
static_assert(offsetof(UAGO_SpawnActor, OffsetTransform) == 0x000060, "Member 'UAGO_SpawnActor::OffsetTransform' has a wrong offset!");

// Class Stigma.AGO_SpawnBot
// 0x0010 (0x0068 - 0x0058)
class UAGO_SpawnBot final : public UActionGraphOperator
{
public:
	TArray<struct FAGSpawnBotData>                _SpawnData;                                        // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_SpawnBot">();
	}
	static class UAGO_SpawnBot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_SpawnBot>();
	}
};
static_assert(alignof(UAGO_SpawnBot) == 0x000008, "Wrong alignment on UAGO_SpawnBot");
static_assert(sizeof(UAGO_SpawnBot) == 0x000068, "Wrong size on UAGO_SpawnBot");
static_assert(offsetof(UAGO_SpawnBot, _SpawnData) == 0x000058, "Member 'UAGO_SpawnBot::_SpawnData' has a wrong offset!");

// Class Stigma.MissionCondition_LevelUpPlayer
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_LevelUpPlayer final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_LevelUpPlayer">();
	}
	static class UMissionCondition_LevelUpPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_LevelUpPlayer>();
	}
};
static_assert(alignof(UMissionCondition_LevelUpPlayer) == 0x000008, "Wrong alignment on UMissionCondition_LevelUpPlayer");
static_assert(sizeof(UMissionCondition_LevelUpPlayer) == 0x000068, "Wrong size on UMissionCondition_LevelUpPlayer");

// Class Stigma.AGO_SpawnObject
// 0x0060 (0x00B8 - 0x0058)
class UAGO_SpawnObject final : public UActionGraphOperator
{
public:
	TSubclassOf<class AObjectBase>                ObjectType;                                        // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FItemID, TSubclassOf<class AThrowBase>> _BodyID_With_ThrowBase;                            // 0x0060(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          DestroyAtEndIfStillHolding;                        // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20C2[0x7];                                     // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_SpawnObject">();
	}
	static class UAGO_SpawnObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_SpawnObject>();
	}
};
static_assert(alignof(UAGO_SpawnObject) == 0x000008, "Wrong alignment on UAGO_SpawnObject");
static_assert(sizeof(UAGO_SpawnObject) == 0x0000B8, "Wrong size on UAGO_SpawnObject");
static_assert(offsetof(UAGO_SpawnObject, ObjectType) == 0x000058, "Member 'UAGO_SpawnObject::ObjectType' has a wrong offset!");
static_assert(offsetof(UAGO_SpawnObject, _BodyID_With_ThrowBase) == 0x000060, "Member 'UAGO_SpawnObject::_BodyID_With_ThrowBase' has a wrong offset!");
static_assert(offsetof(UAGO_SpawnObject, DestroyAtEndIfStillHolding) == 0x0000B0, "Member 'UAGO_SpawnObject::DestroyAtEndIfStillHolding' has a wrong offset!");

// Class Stigma.MissionCondition_KillStreak
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_KillStreak final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_KillStreak">();
	}
	static class UMissionCondition_KillStreak* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_KillStreak>();
	}
};
static_assert(alignof(UMissionCondition_KillStreak) == 0x000008, "Wrong alignment on UMissionCondition_KillStreak");
static_assert(sizeof(UMissionCondition_KillStreak) == 0x000068, "Wrong size on UMissionCondition_KillStreak");

// Class Stigma.AGO_SprintState
// 0x0000 (0x0058 - 0x0058)
class UAGO_SprintState final : public UActionGraphOperator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_SprintState">();
	}
	static class UAGO_SprintState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_SprintState>();
	}
};
static_assert(alignof(UAGO_SprintState) == 0x000008, "Wrong alignment on UAGO_SprintState");
static_assert(sizeof(UAGO_SprintState) == 0x000058, "Wrong size on UAGO_SprintState");

// Class Stigma.AGO_StayPassive
// 0x0008 (0x0060 - 0x0058)
class UAGO_StayPassive final : public UActionGraphOperator
{
public:
	bool                                          IgnoreDie;                                         // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20C3[0x7];                                     // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_StayPassive">();
	}
	static class UAGO_StayPassive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_StayPassive>();
	}
};
static_assert(alignof(UAGO_StayPassive) == 0x000008, "Wrong alignment on UAGO_StayPassive");
static_assert(sizeof(UAGO_StayPassive) == 0x000060, "Wrong size on UAGO_StayPassive");
static_assert(offsetof(UAGO_StayPassive, IgnoreDie) == 0x000058, "Member 'UAGO_StayPassive::IgnoreDie' has a wrong offset!");

// Class Stigma.PreviewActor
// 0x0078 (0x0310 - 0x0298)
class APreviewActor : public AActor
{
public:
	class USceneComponent*                        _Root;                                             // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChildActorComponent*                   _ChildActorComponent;                              // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EPreviewActorType                             _type;                                             // 0x02A8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20C4[0x7];                                     // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FTransform                             _InitialTransform;                                 // 0x02B0(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	EPreviewActorType GetPreviewActorType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PreviewActor">();
	}
	static class APreviewActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APreviewActor>();
	}
};
static_assert(alignof(APreviewActor) == 0x000010, "Wrong alignment on APreviewActor");
static_assert(sizeof(APreviewActor) == 0x000310, "Wrong size on APreviewActor");
static_assert(offsetof(APreviewActor, _Root) == 0x000298, "Member 'APreviewActor::_Root' has a wrong offset!");
static_assert(offsetof(APreviewActor, _ChildActorComponent) == 0x0002A0, "Member 'APreviewActor::_ChildActorComponent' has a wrong offset!");
static_assert(offsetof(APreviewActor, _type) == 0x0002A8, "Member 'APreviewActor::_type' has a wrong offset!");
static_assert(offsetof(APreviewActor, _InitialTransform) == 0x0002B0, "Member 'APreviewActor::_InitialTransform' has a wrong offset!");

// Class Stigma.AGO_SyncCorrection
// 0x0010 (0x0068 - 0x0058)
class UAGO_SyncCorrection final : public UActionGraphOperator
{
public:
	bool                                          ClearLockTransform;                                // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20C5[0x3];                                     // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         CorrectionScale;                                   // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ClearMate;                                         // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20C6[0x7];                                     // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_SyncCorrection">();
	}
	static class UAGO_SyncCorrection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_SyncCorrection>();
	}
};
static_assert(alignof(UAGO_SyncCorrection) == 0x000008, "Wrong alignment on UAGO_SyncCorrection");
static_assert(sizeof(UAGO_SyncCorrection) == 0x000068, "Wrong size on UAGO_SyncCorrection");
static_assert(offsetof(UAGO_SyncCorrection, ClearLockTransform) == 0x000058, "Member 'UAGO_SyncCorrection::ClearLockTransform' has a wrong offset!");
static_assert(offsetof(UAGO_SyncCorrection, CorrectionScale) == 0x00005C, "Member 'UAGO_SyncCorrection::CorrectionScale' has a wrong offset!");
static_assert(offsetof(UAGO_SyncCorrection, ClearMate) == 0x000060, "Member 'UAGO_SyncCorrection::ClearMate' has a wrong offset!");

// Class Stigma.AGO_TensionState
// 0x0008 (0x0060 - 0x0058)
class UAGO_TensionState final : public UActionGraphOperator
{
public:
	float                                         SpeedScale;                                        // 0x0058(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ClearTensionStateAtTheEnd;                         // 0x005C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20C7[0x3];                                     // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_TensionState">();
	}
	static class UAGO_TensionState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_TensionState>();
	}
};
static_assert(alignof(UAGO_TensionState) == 0x000008, "Wrong alignment on UAGO_TensionState");
static_assert(sizeof(UAGO_TensionState) == 0x000060, "Wrong size on UAGO_TensionState");
static_assert(offsetof(UAGO_TensionState, SpeedScale) == 0x000058, "Member 'UAGO_TensionState::SpeedScale' has a wrong offset!");
static_assert(offsetof(UAGO_TensionState, ClearTensionStateAtTheEnd) == 0x00005C, "Member 'UAGO_TensionState::ClearTensionStateAtTheEnd' has a wrong offset!");

// Class Stigma.MissionCondition_KillAssist
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_KillAssist final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_KillAssist">();
	}
	static class UMissionCondition_KillAssist* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_KillAssist>();
	}
};
static_assert(alignof(UMissionCondition_KillAssist) == 0x000008, "Wrong alignment on UMissionCondition_KillAssist");
static_assert(sizeof(UMissionCondition_KillAssist) == 0x000068, "Wrong size on UMissionCondition_KillAssist");

// Class Stigma.AGO_Throw
// 0x0108 (0x0178 - 0x0070)
class UAGO_Throw final : public UAGO_DamageProvider
{
public:
	EThrowSourceType                              ThrowObjectSource;                                 // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20C8[0x7];                                     // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class AThrowBase>                 ObjectType;                                        // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NoDestructor, Protected, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FItemID, TSubclassOf<class AThrowBase>> _BodyID_With_ThrowBase;                            // 0x0080(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Protected, ExposeOnSpawn, UObjectWrapper, NativeAccessSpecifierProtected)
	int32                                         ThrowCount;                                        // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EThrowCollisionType                           CollisionType;                                     // 0x00D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20C9[0x3];                                     // 0x00D5(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         CollisionRadius;                                   // 0x00D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20CA[0x4];                                     // 0x00DC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FRotator                               RootRotationSpeedRate;                             // 0x00E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	struct FRotator                               MeshRotationSpeedRate;                             // 0x00F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	EThrowStuckDirection                          StuckDirection;                                    // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttackType                                   AttackType;                                        // 0x0111(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMeleeAttackPoint                             Parts;                                             // 0x0112(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EThrowStartLocationType                       ThrowStartLocationType;                            // 0x0113(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EThrowTargetType                              ThrowTargetType;                                   // 0x0114(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20CB[0x3];                                     // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         TargetDistance;                                    // 0x0118(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20CC[0x4];                                     // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FVector                                TargetOffset;                                      // 0x0120(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrowSpeed;                                        // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDistance;                                       // 0x013C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PeakRate;                                          // 0x0140(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GravityScale;                                      // 0x0144(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RandomOffsetSize;                                  // 0x0148(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         YawRotation;                                       // 0x014C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrowPicthOffset;                                  // 0x0150(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SplinePointCount;                                  // 0x0154(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SplineSamplingInterval;                            // 0x0158(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TrailScale;                                        // 0x015C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DamageFromThrownObject;                            // 0x0160(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20CD[0x3];                                     // 0x0161(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         DecreaseStockCount;                                // 0x0164(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20CE[0x10];                                    // 0x0168(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_Throw">();
	}
	static class UAGO_Throw* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_Throw>();
	}
};
static_assert(alignof(UAGO_Throw) == 0x000008, "Wrong alignment on UAGO_Throw");
static_assert(sizeof(UAGO_Throw) == 0x000178, "Wrong size on UAGO_Throw");
static_assert(offsetof(UAGO_Throw, ThrowObjectSource) == 0x000070, "Member 'UAGO_Throw::ThrowObjectSource' has a wrong offset!");
static_assert(offsetof(UAGO_Throw, ObjectType) == 0x000078, "Member 'UAGO_Throw::ObjectType' has a wrong offset!");
static_assert(offsetof(UAGO_Throw, _BodyID_With_ThrowBase) == 0x000080, "Member 'UAGO_Throw::_BodyID_With_ThrowBase' has a wrong offset!");
static_assert(offsetof(UAGO_Throw, ThrowCount) == 0x0000D0, "Member 'UAGO_Throw::ThrowCount' has a wrong offset!");
static_assert(offsetof(UAGO_Throw, CollisionType) == 0x0000D4, "Member 'UAGO_Throw::CollisionType' has a wrong offset!");
static_assert(offsetof(UAGO_Throw, CollisionRadius) == 0x0000D8, "Member 'UAGO_Throw::CollisionRadius' has a wrong offset!");
static_assert(offsetof(UAGO_Throw, RootRotationSpeedRate) == 0x0000E0, "Member 'UAGO_Throw::RootRotationSpeedRate' has a wrong offset!");
static_assert(offsetof(UAGO_Throw, MeshRotationSpeedRate) == 0x0000F8, "Member 'UAGO_Throw::MeshRotationSpeedRate' has a wrong offset!");
static_assert(offsetof(UAGO_Throw, StuckDirection) == 0x000110, "Member 'UAGO_Throw::StuckDirection' has a wrong offset!");
static_assert(offsetof(UAGO_Throw, AttackType) == 0x000111, "Member 'UAGO_Throw::AttackType' has a wrong offset!");
static_assert(offsetof(UAGO_Throw, Parts) == 0x000112, "Member 'UAGO_Throw::Parts' has a wrong offset!");
static_assert(offsetof(UAGO_Throw, ThrowStartLocationType) == 0x000113, "Member 'UAGO_Throw::ThrowStartLocationType' has a wrong offset!");
static_assert(offsetof(UAGO_Throw, ThrowTargetType) == 0x000114, "Member 'UAGO_Throw::ThrowTargetType' has a wrong offset!");
static_assert(offsetof(UAGO_Throw, TargetDistance) == 0x000118, "Member 'UAGO_Throw::TargetDistance' has a wrong offset!");
static_assert(offsetof(UAGO_Throw, TargetOffset) == 0x000120, "Member 'UAGO_Throw::TargetOffset' has a wrong offset!");
static_assert(offsetof(UAGO_Throw, ThrowSpeed) == 0x000138, "Member 'UAGO_Throw::ThrowSpeed' has a wrong offset!");
static_assert(offsetof(UAGO_Throw, MaxDistance) == 0x00013C, "Member 'UAGO_Throw::MaxDistance' has a wrong offset!");
static_assert(offsetof(UAGO_Throw, PeakRate) == 0x000140, "Member 'UAGO_Throw::PeakRate' has a wrong offset!");
static_assert(offsetof(UAGO_Throw, GravityScale) == 0x000144, "Member 'UAGO_Throw::GravityScale' has a wrong offset!");
static_assert(offsetof(UAGO_Throw, RandomOffsetSize) == 0x000148, "Member 'UAGO_Throw::RandomOffsetSize' has a wrong offset!");
static_assert(offsetof(UAGO_Throw, YawRotation) == 0x00014C, "Member 'UAGO_Throw::YawRotation' has a wrong offset!");
static_assert(offsetof(UAGO_Throw, ThrowPicthOffset) == 0x000150, "Member 'UAGO_Throw::ThrowPicthOffset' has a wrong offset!");
static_assert(offsetof(UAGO_Throw, SplinePointCount) == 0x000154, "Member 'UAGO_Throw::SplinePointCount' has a wrong offset!");
static_assert(offsetof(UAGO_Throw, SplineSamplingInterval) == 0x000158, "Member 'UAGO_Throw::SplineSamplingInterval' has a wrong offset!");
static_assert(offsetof(UAGO_Throw, TrailScale) == 0x00015C, "Member 'UAGO_Throw::TrailScale' has a wrong offset!");
static_assert(offsetof(UAGO_Throw, DamageFromThrownObject) == 0x000160, "Member 'UAGO_Throw::DamageFromThrownObject' has a wrong offset!");
static_assert(offsetof(UAGO_Throw, DecreaseStockCount) == 0x000164, "Member 'UAGO_Throw::DecreaseStockCount' has a wrong offset!");

// Class Stigma.AGO_ThrowTrajectory
// 0x0080 (0x00D8 - 0x0058)
class UAGO_ThrowTrajectory final : public UActionGraphOperator
{
public:
	TSubclassOf<class ATargetArea>                _EndTrajectoryArea;                                // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _EndTrajectoryAreaScale;                           // 0x0060(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20CF[0x4];                                     // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FVector                                _CamPosOffset;                                     // 0x0068(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EThrowSourceType                              ThrowObjectSource;                                 // 0x0080(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20D0[0x7];                                     // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class AThrowBase>                 ObjectType;                                        // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NoDestructor, Protected, ExposeOnSpawn, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ThrowCount;                                        // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMeleeAttackPoint                             Parts;                                             // 0x0094(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EThrowTargetType                              ThrowTargetType;                                   // 0x0095(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20D1[0x2];                                     // 0x0096(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         TargetDistance;                                    // 0x0098(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20D2[0x4];                                     // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FVector                                TargetOffset;                                      // 0x00A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrowSpeed;                                        // 0x00B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxDistance;                                       // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PeakRate;                                          // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GravityScale;                                      // 0x00C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RandomOffsetSize;                                  // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         YawRotation;                                       // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ThrowPicthOffset;                                  // 0x00D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20D3[0x4];                                     // 0x00D4(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_ThrowTrajectory">();
	}
	static class UAGO_ThrowTrajectory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_ThrowTrajectory>();
	}
};
static_assert(alignof(UAGO_ThrowTrajectory) == 0x000008, "Wrong alignment on UAGO_ThrowTrajectory");
static_assert(sizeof(UAGO_ThrowTrajectory) == 0x0000D8, "Wrong size on UAGO_ThrowTrajectory");
static_assert(offsetof(UAGO_ThrowTrajectory, _EndTrajectoryArea) == 0x000058, "Member 'UAGO_ThrowTrajectory::_EndTrajectoryArea' has a wrong offset!");
static_assert(offsetof(UAGO_ThrowTrajectory, _EndTrajectoryAreaScale) == 0x000060, "Member 'UAGO_ThrowTrajectory::_EndTrajectoryAreaScale' has a wrong offset!");
static_assert(offsetof(UAGO_ThrowTrajectory, _CamPosOffset) == 0x000068, "Member 'UAGO_ThrowTrajectory::_CamPosOffset' has a wrong offset!");
static_assert(offsetof(UAGO_ThrowTrajectory, ThrowObjectSource) == 0x000080, "Member 'UAGO_ThrowTrajectory::ThrowObjectSource' has a wrong offset!");
static_assert(offsetof(UAGO_ThrowTrajectory, ObjectType) == 0x000088, "Member 'UAGO_ThrowTrajectory::ObjectType' has a wrong offset!");
static_assert(offsetof(UAGO_ThrowTrajectory, ThrowCount) == 0x000090, "Member 'UAGO_ThrowTrajectory::ThrowCount' has a wrong offset!");
static_assert(offsetof(UAGO_ThrowTrajectory, Parts) == 0x000094, "Member 'UAGO_ThrowTrajectory::Parts' has a wrong offset!");
static_assert(offsetof(UAGO_ThrowTrajectory, ThrowTargetType) == 0x000095, "Member 'UAGO_ThrowTrajectory::ThrowTargetType' has a wrong offset!");
static_assert(offsetof(UAGO_ThrowTrajectory, TargetDistance) == 0x000098, "Member 'UAGO_ThrowTrajectory::TargetDistance' has a wrong offset!");
static_assert(offsetof(UAGO_ThrowTrajectory, TargetOffset) == 0x0000A0, "Member 'UAGO_ThrowTrajectory::TargetOffset' has a wrong offset!");
static_assert(offsetof(UAGO_ThrowTrajectory, ThrowSpeed) == 0x0000B8, "Member 'UAGO_ThrowTrajectory::ThrowSpeed' has a wrong offset!");
static_assert(offsetof(UAGO_ThrowTrajectory, MaxDistance) == 0x0000BC, "Member 'UAGO_ThrowTrajectory::MaxDistance' has a wrong offset!");
static_assert(offsetof(UAGO_ThrowTrajectory, PeakRate) == 0x0000C0, "Member 'UAGO_ThrowTrajectory::PeakRate' has a wrong offset!");
static_assert(offsetof(UAGO_ThrowTrajectory, GravityScale) == 0x0000C4, "Member 'UAGO_ThrowTrajectory::GravityScale' has a wrong offset!");
static_assert(offsetof(UAGO_ThrowTrajectory, RandomOffsetSize) == 0x0000C8, "Member 'UAGO_ThrowTrajectory::RandomOffsetSize' has a wrong offset!");
static_assert(offsetof(UAGO_ThrowTrajectory, YawRotation) == 0x0000CC, "Member 'UAGO_ThrowTrajectory::YawRotation' has a wrong offset!");
static_assert(offsetof(UAGO_ThrowTrajectory, ThrowPicthOffset) == 0x0000D0, "Member 'UAGO_ThrowTrajectory::ThrowPicthOffset' has a wrong offset!");

// Class Stigma.AGO_TransientAimOffset
// 0x0008 (0x0060 - 0x0058)
class UAGO_TransientAimOffset final : public UActionGraphOperator
{
public:
	class UAimOffsetBlendSpace*                   AimOffset;                                         // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_TransientAimOffset">();
	}
	static class UAGO_TransientAimOffset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_TransientAimOffset>();
	}
};
static_assert(alignof(UAGO_TransientAimOffset) == 0x000008, "Wrong alignment on UAGO_TransientAimOffset");
static_assert(sizeof(UAGO_TransientAimOffset) == 0x000060, "Wrong size on UAGO_TransientAimOffset");
static_assert(offsetof(UAGO_TransientAimOffset, AimOffset) == 0x000058, "Member 'UAGO_TransientAimOffset::AimOffset' has a wrong offset!");

// Class Stigma.LVData_ControlPowerMaster
// 0x0010 (0x0038 - 0x0028)
class ULVData_ControlPowerMaster final : public UObject
{
public:
	ECharaType                                    _CharaType;                                        // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20D4[0x3];                                     // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         _LackControlPower;                                 // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGunObject*                             _ComparedGunObject;                                // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LVData_ControlPowerMaster">();
	}
	static class ULVData_ControlPowerMaster* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULVData_ControlPowerMaster>();
	}
};
static_assert(alignof(ULVData_ControlPowerMaster) == 0x000008, "Wrong alignment on ULVData_ControlPowerMaster");
static_assert(sizeof(ULVData_ControlPowerMaster) == 0x000038, "Wrong size on ULVData_ControlPowerMaster");
static_assert(offsetof(ULVData_ControlPowerMaster, _CharaType) == 0x000028, "Member 'ULVData_ControlPowerMaster::_CharaType' has a wrong offset!");
static_assert(offsetof(ULVData_ControlPowerMaster, _LackControlPower) == 0x00002C, "Member 'ULVData_ControlPowerMaster::_LackControlPower' has a wrong offset!");
static_assert(offsetof(ULVData_ControlPowerMaster, _ComparedGunObject) == 0x000030, "Member 'ULVData_ControlPowerMaster::_ComparedGunObject' has a wrong offset!");

// Class Stigma.AGO_TurnInPlace
// 0x0008 (0x0060 - 0x0058)
class UAGO_TurnInPlace final : public UActionGraphOperator
{
public:
	bool                                          EnabledTurnInPlace;                                // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20D5[0x7];                                     // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_TurnInPlace">();
	}
	static class UAGO_TurnInPlace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_TurnInPlace>();
	}
};
static_assert(alignof(UAGO_TurnInPlace) == 0x000008, "Wrong alignment on UAGO_TurnInPlace");
static_assert(sizeof(UAGO_TurnInPlace) == 0x000060, "Wrong size on UAGO_TurnInPlace");
static_assert(offsetof(UAGO_TurnInPlace, EnabledTurnInPlace) == 0x000058, "Member 'UAGO_TurnInPlace::EnabledTurnInPlace' has a wrong offset!");

// Class Stigma.MissionCondition_Action
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_Action final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_Action">();
	}
	static class UMissionCondition_Action* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_Action>();
	}
};
static_assert(alignof(UMissionCondition_Action) == 0x000008, "Wrong alignment on UMissionCondition_Action");
static_assert(sizeof(UMissionCondition_Action) == 0x000068, "Wrong size on UMissionCondition_Action");

// Class Stigma.AGO_VoicePlay
// 0x0018 (0x0070 - 0x0058)
class UAGO_VoicePlay final : public UActionGraphOperator
{
public:
	class FString                                 _VoiceID;                                          // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _Is3DSound;                                        // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsMateSound;                                      // 0x0069(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20D6[0x6];                                     // 0x006A(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AGO_VoicePlay">();
	}
	static class UAGO_VoicePlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAGO_VoicePlay>();
	}
};
static_assert(alignof(UAGO_VoicePlay) == 0x000008, "Wrong alignment on UAGO_VoicePlay");
static_assert(sizeof(UAGO_VoicePlay) == 0x000070, "Wrong size on UAGO_VoicePlay");
static_assert(offsetof(UAGO_VoicePlay, _VoiceID) == 0x000058, "Member 'UAGO_VoicePlay::_VoiceID' has a wrong offset!");
static_assert(offsetof(UAGO_VoicePlay, _Is3DSound) == 0x000068, "Member 'UAGO_VoicePlay::_Is3DSound' has a wrong offset!");
static_assert(offsetof(UAGO_VoicePlay, _IsMateSound) == 0x000069, "Member 'UAGO_VoicePlay::_IsMateSound' has a wrong offset!");

// Class Stigma.Record_PlayTime_ListItemData
// 0x0010 (0x0038 - 0x0028)
class URecord_PlayTime_ListItemData final : public UObject
{
public:
	uint8                                         Pad_20D7[0x10];                                    // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Record_PlayTime_ListItemData">();
	}
	static class URecord_PlayTime_ListItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecord_PlayTime_ListItemData>();
	}
};
static_assert(alignof(URecord_PlayTime_ListItemData) == 0x000008, "Wrong alignment on URecord_PlayTime_ListItemData");
static_assert(sizeof(URecord_PlayTime_ListItemData) == 0x000038, "Wrong size on URecord_PlayTime_ListItemData");

// Class Stigma.AIDeco_Base
// 0x0000 (0x0068 - 0x0068)
class UAIDeco_Base : public UBTDecorator
{
public:
	bool PerformConditionCheck(class AActor* OwnerActor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDeco_Base">();
	}
	static class UAIDeco_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDeco_Base>();
	}
};
static_assert(alignof(UAIDeco_Base) == 0x000008, "Wrong alignment on UAIDeco_Base");
static_assert(sizeof(UAIDeco_Base) == 0x000068, "Wrong size on UAIDeco_Base");

// Class Stigma.AIDeco_CanFire
// 0x0000 (0x0068 - 0x0068)
class UAIDeco_CanFire final : public UBTDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDeco_CanFire">();
	}
	static class UAIDeco_CanFire* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDeco_CanFire>();
	}
};
static_assert(alignof(UAIDeco_CanFire) == 0x000008, "Wrong alignment on UAIDeco_CanFire");
static_assert(sizeof(UAIDeco_CanFire) == 0x000068, "Wrong size on UAIDeco_CanFire");

// Class Stigma.MeleeAttack
// 0x0000 (0x0030 - 0x0030)
class UMeleeAttack final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MeleeAttack">();
	}
	static class UMeleeAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMeleeAttack>();
	}
};
static_assert(alignof(UMeleeAttack) == 0x000008, "Wrong alignment on UMeleeAttack");
static_assert(sizeof(UMeleeAttack) == 0x000030, "Wrong size on UMeleeAttack");

// Class Stigma.AIDeco_CanSeeTarget
// 0x0000 (0x0068 - 0x0068)
class UAIDeco_CanSeeTarget final : public UBTDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDeco_CanSeeTarget">();
	}
	static class UAIDeco_CanSeeTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDeco_CanSeeTarget>();
	}
};
static_assert(alignof(UAIDeco_CanSeeTarget) == 0x000008, "Wrong alignment on UAIDeco_CanSeeTarget");
static_assert(sizeof(UAIDeco_CanSeeTarget) == 0x000068, "Wrong size on UAIDeco_CanSeeTarget");

// Class Stigma.MissionCondition_KillGun
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_KillGun final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_KillGun">();
	}
	static class UMissionCondition_KillGun* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_KillGun>();
	}
};
static_assert(alignof(UMissionCondition_KillGun) == 0x000008, "Wrong alignment on UMissionCondition_KillGun");
static_assert(sizeof(UMissionCondition_KillGun) == 0x000068, "Wrong size on UMissionCondition_KillGun");

// Class Stigma.SafeBase
// 0x0038 (0x02D0 - 0x0298)
class ASafeBase : public AActor
{
public:
	uint8                                         Pad_20D9[0x10];                                    // 0x0298(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class ACharaBase*                             _InteractChara;                                    // 0x02A8(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMeshComponent*                         _Mesh;                                             // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeams                                        _OwnTeam;                                          // 0x02B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESafeState                                    _CurrentState;                                     // 0x02B9(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20DA[0x6];                                     // 0x02BA(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	class USphereComponent*                       _SafeArea;                                         // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20DB[0x8];                                     // 0x02C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void HackingComplete();
	void OnCharaBeginOverlapped(class ACharaBase* _chara);
	void OnCharaEndOverlapped(class ACharaBase* _chara);
	void OnRep_InteractChara(class ACharaBase* _old_chara);
	void OnRep_SafeState();
	void SERVER_SetSafeState(ESafeState _state);
	void Setter_InteractChara(class ACharaBase* _chara);

	bool CanInteract(class ACharaBase* _involver) const;
	class FText GetActorDisplayName() const;
	class UTexture2D* GetActorIcon() const;
	class FText GetDisplayText(class ACharaBase* _involver) const;
	ETeams GetOwnTeam() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SafeBase">();
	}
	static class ASafeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASafeBase>();
	}
};
static_assert(alignof(ASafeBase) == 0x000008, "Wrong alignment on ASafeBase");
static_assert(sizeof(ASafeBase) == 0x0002D0, "Wrong size on ASafeBase");
static_assert(offsetof(ASafeBase, _InteractChara) == 0x0002A8, "Member 'ASafeBase::_InteractChara' has a wrong offset!");
static_assert(offsetof(ASafeBase, _Mesh) == 0x0002B0, "Member 'ASafeBase::_Mesh' has a wrong offset!");
static_assert(offsetof(ASafeBase, _OwnTeam) == 0x0002B8, "Member 'ASafeBase::_OwnTeam' has a wrong offset!");
static_assert(offsetof(ASafeBase, _CurrentState) == 0x0002B9, "Member 'ASafeBase::_CurrentState' has a wrong offset!");
static_assert(offsetof(ASafeBase, _SafeArea) == 0x0002C0, "Member 'ASafeBase::_SafeArea' has a wrong offset!");

// Class Stigma.AIDeco__V3_IsMovable
// 0x0000 (0x0068 - 0x0068)
class UAIDeco__V3_IsMovable final : public UAIDeco_CharacterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDeco__V3_IsMovable">();
	}
	static class UAIDeco__V3_IsMovable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDeco__V3_IsMovable>();
	}
};
static_assert(alignof(UAIDeco__V3_IsMovable) == 0x000008, "Wrong alignment on UAIDeco__V3_IsMovable");
static_assert(sizeof(UAIDeco__V3_IsMovable) == 0x000068, "Wrong size on UAIDeco__V3_IsMovable");

// Class Stigma.AIDeco__V3_IsAnyLowerState
// 0x0050 (0x00B8 - 0x0068)
class UAIDeco__V3_IsAnyLowerState final : public UAIDeco_CharacterBase
{
public:
	TSet<EBodyLowerState>                         LowerStates;                                       // 0x0068(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDeco__V3_IsAnyLowerState">();
	}
	static class UAIDeco__V3_IsAnyLowerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDeco__V3_IsAnyLowerState>();
	}
};
static_assert(alignof(UAIDeco__V3_IsAnyLowerState) == 0x000008, "Wrong alignment on UAIDeco__V3_IsAnyLowerState");
static_assert(sizeof(UAIDeco__V3_IsAnyLowerState) == 0x0000B8, "Wrong size on UAIDeco__V3_IsAnyLowerState");
static_assert(offsetof(UAIDeco__V3_IsAnyLowerState, LowerStates) == 0x000068, "Member 'UAIDeco__V3_IsAnyLowerState::LowerStates' has a wrong offset!");

// Class Stigma.MissionCondition_Interact
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_Interact final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_Interact">();
	}
	static class UMissionCondition_Interact* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_Interact>();
	}
};
static_assert(alignof(UMissionCondition_Interact) == 0x000008, "Wrong alignment on UMissionCondition_Interact");
static_assert(sizeof(UMissionCondition_Interact) == 0x000068, "Wrong size on UMissionCondition_Interact");

// Class Stigma.AIDeco__V3_IsAiming
// 0x0000 (0x0068 - 0x0068)
class UAIDeco__V3_IsAiming final : public UAIDeco_CharacterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDeco__V3_IsAiming">();
	}
	static class UAIDeco__V3_IsAiming* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDeco__V3_IsAiming>();
	}
};
static_assert(alignof(UAIDeco__V3_IsAiming) == 0x000008, "Wrong alignment on UAIDeco__V3_IsAiming");
static_assert(sizeof(UAIDeco__V3_IsAiming) == 0x000068, "Wrong size on UAIDeco__V3_IsAiming");

// Class Stigma.AIDeco_CheckDistance
// 0x0008 (0x0070 - 0x0068)
class UAIDeco_CheckDistance final : public UBTDecorator
{
public:
	float                                         Distance;                                          // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECompareFunc                                  CompareFunction;                                   // 0x006C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20DD[0x3];                                     // 0x006D(0x0003)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDeco_CheckDistance">();
	}
	static class UAIDeco_CheckDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDeco_CheckDistance>();
	}
};
static_assert(alignof(UAIDeco_CheckDistance) == 0x000008, "Wrong alignment on UAIDeco_CheckDistance");
static_assert(sizeof(UAIDeco_CheckDistance) == 0x000070, "Wrong size on UAIDeco_CheckDistance");
static_assert(offsetof(UAIDeco_CheckDistance, Distance) == 0x000068, "Member 'UAIDeco_CheckDistance::Distance' has a wrong offset!");
static_assert(offsetof(UAIDeco_CheckDistance, CompareFunction) == 0x00006C, "Member 'UAIDeco_CheckDistance::CompareFunction' has a wrong offset!");

// Class Stigma.AIDeco_CheckThreat
// 0x0008 (0x0070 - 0x0068)
class UAIDeco_CheckThreat final : public UBTDecorator
{
public:
	ECheckThreat                                  CheckType;                                         // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20DE[0x7];                                     // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDeco_CheckThreat">();
	}
	static class UAIDeco_CheckThreat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDeco_CheckThreat>();
	}
};
static_assert(alignof(UAIDeco_CheckThreat) == 0x000008, "Wrong alignment on UAIDeco_CheckThreat");
static_assert(sizeof(UAIDeco_CheckThreat) == 0x000070, "Wrong size on UAIDeco_CheckThreat");
static_assert(offsetof(UAIDeco_CheckThreat, CheckType) == 0x000068, "Member 'UAIDeco_CheckThreat::CheckType' has a wrong offset!");

// Class Stigma.HUD_EmoticonWidgetBase
// 0x0148 (0x0638 - 0x04F0)
class UHUD_EmoticonWidgetBase : public UPreviewableWidget
{
public:
	class UImage*                                 Img_Icon;                                          // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FConfig_Emoticon                       _EmoticonDefine;                                   // 0x04F8(0x0138)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_20DF[0x8];                                     // 0x0630(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void InitWidget(const struct FConfig_Emoticon& _emoticon_def);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUD_EmoticonWidgetBase">();
	}
	static class UHUD_EmoticonWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUD_EmoticonWidgetBase>();
	}
};
static_assert(alignof(UHUD_EmoticonWidgetBase) == 0x000008, "Wrong alignment on UHUD_EmoticonWidgetBase");
static_assert(sizeof(UHUD_EmoticonWidgetBase) == 0x000638, "Wrong size on UHUD_EmoticonWidgetBase");
static_assert(offsetof(UHUD_EmoticonWidgetBase, Img_Icon) == 0x0004F0, "Member 'UHUD_EmoticonWidgetBase::Img_Icon' has a wrong offset!");
static_assert(offsetof(UHUD_EmoticonWidgetBase, _EmoticonDefine) == 0x0004F8, "Member 'UHUD_EmoticonWidgetBase::_EmoticonDefine' has a wrong offset!");

// Class Stigma.Annihilation_PlayerController
// 0x0008 (0x0E48 - 0x0E40)
class AAnnihilation_PlayerController : public ABattlePlayerControllerBase
{
public:
	class ASupplyStore*                           NearSupplyStore;                                   // 0x0E40(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void RPC_CLIENT_AddSupplyStoreLog(class ASupplyStore* _store, int32 _index, float _value, bool _is_cool);
	void RPC_SERVER_RequestPurchase_SupplyItem(class ASupplyStore* _store, int32 _index);

	ETeams GetEnemyTeam() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Annihilation_PlayerController">();
	}
	static class AAnnihilation_PlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAnnihilation_PlayerController>();
	}
};
static_assert(alignof(AAnnihilation_PlayerController) == 0x000008, "Wrong alignment on AAnnihilation_PlayerController");
static_assert(sizeof(AAnnihilation_PlayerController) == 0x000E48, "Wrong size on AAnnihilation_PlayerController");
static_assert(offsetof(AAnnihilation_PlayerController, NearSupplyStore) == 0x000E40, "Member 'AAnnihilation_PlayerController::NearSupplyStore' has a wrong offset!");

// Class Stigma.VS_PlayerController
// 0x0000 (0x0E48 - 0x0E48)
class AVS_PlayerController : public AAnnihilation_PlayerController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VS_PlayerController">();
	}
	static class AVS_PlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVS_PlayerController>();
	}
};
static_assert(alignof(AVS_PlayerController) == 0x000008, "Wrong alignment on AVS_PlayerController");
static_assert(sizeof(AVS_PlayerController) == 0x000E48, "Wrong size on AVS_PlayerController");

// Class Stigma.AIDeco_Distance
// 0x0030 (0x0098 - 0x0068)
class UAIDeco_Distance final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 From;                                              // 0x0068(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECompare                                      CompareFunction;                                   // 0x0094(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Distance2D;                                        // 0x0095(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20E2[0x2];                                     // 0x0096(0x0002)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDeco_Distance">();
	}
	static class UAIDeco_Distance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDeco_Distance>();
	}
};
static_assert(alignof(UAIDeco_Distance) == 0x000008, "Wrong alignment on UAIDeco_Distance");
static_assert(sizeof(UAIDeco_Distance) == 0x000098, "Wrong size on UAIDeco_Distance");
static_assert(offsetof(UAIDeco_Distance, From) == 0x000068, "Member 'UAIDeco_Distance::From' has a wrong offset!");
static_assert(offsetof(UAIDeco_Distance, Distance) == 0x000090, "Member 'UAIDeco_Distance::Distance' has a wrong offset!");
static_assert(offsetof(UAIDeco_Distance, CompareFunction) == 0x000094, "Member 'UAIDeco_Distance::CompareFunction' has a wrong offset!");
static_assert(offsetof(UAIDeco_Distance, Distance2D) == 0x000095, "Member 'UAIDeco_Distance::Distance2D' has a wrong offset!");

// Class Stigma.LocalPlayerContextTool
// 0x0000 (0x0028 - 0x0028)
class ULocalPlayerContextTool final : public UBlueprintFunctionLibrary
{
public:
	static bool CanRewardAnyMissions(const class UObject* _world_ctx, bool _check_only_auto_reward, const struct FItemID& _task_id);
	static bool FindAppliedFunctionsByID(const class UObject* _world_ctx, const struct FItemID& _func_id, struct FAppliedFunction* _out_function);
	static bool FindGMFunctionByGMFuncID(const class UObject* _world_ctx, int32 _gm_func_id, struct FGMFunction* _out_function);
	static class UMission* FindMission(const class UObject* _world_ctx, const struct FItemID& _task_id, int32 _idx, const struct FItemID_Mission& _mission_id);
	static class ULocalPlayerContext* Get(const class UObject* _world_ctx);
	static class UCompetitionInfoManager* GetCompetitionInfoManager(const class UObject* _world_ctx);
	static int32 GetCompletedMissionCountByTaskID(const class UObject* _world_ctx, const struct FItemID& _task_id);
	static void GetMissionsByTaskID(const class UObject* _world_ctx, const struct FItemID& _task_id, TArray<class UMission*>* _out_missions);
	static class UMission* GetProgressingTrackMission(const class UObject* _world_ctx, const struct FItemID_EventPage& _track_id, const TSet<EMissionProgressType>& _progress_types, bool _get_first);
	static bool HasMasterMission(const class UObject* _world_ctx, ECharaType _chara_type);
	static bool IsBoosterSlotActive(const class UObject* _world_ctx, int32 _slot_zidx);
	static bool IsMasterFirstMissionCompleted(const class UObject* _world_ctx, ECharaType _chara_type);
	static void MarkRefreshInventoryRedDot(const class UObject* _world_ctx);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalPlayerContextTool">();
	}
	static class ULocalPlayerContextTool* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalPlayerContextTool>();
	}
};
static_assert(alignof(ULocalPlayerContextTool) == 0x000008, "Wrong alignment on ULocalPlayerContextTool");
static_assert(sizeof(ULocalPlayerContextTool) == 0x000028, "Wrong size on ULocalPlayerContextTool");

// Class Stigma.UI_MissionBriefContainer
// 0x0030 (0x0520 - 0x04F0)
class UUI_MissionBriefContainer : public UPreviewableWidget
{
public:
	class UUniformGridPanel*                      UniformGridPanel;                                  // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_RemainDateTimer*                    RemainDateTimer;                                   // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WidgetSwitcher;                                    // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_MissionBriefSlot>       _MissionBriefSlotClass;                            // 0x0508(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20EE[0x10];                                    // 0x0510(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnMissionUpdated(EMissionUpdateType _type, class UMission* _mission);
	void SetLocked(EMissionType _mission_type, int32 _limited_level);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_MissionBriefContainer">();
	}
	static class UUI_MissionBriefContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_MissionBriefContainer>();
	}
};
static_assert(alignof(UUI_MissionBriefContainer) == 0x000008, "Wrong alignment on UUI_MissionBriefContainer");
static_assert(sizeof(UUI_MissionBriefContainer) == 0x000520, "Wrong size on UUI_MissionBriefContainer");
static_assert(offsetof(UUI_MissionBriefContainer, UniformGridPanel) == 0x0004F0, "Member 'UUI_MissionBriefContainer::UniformGridPanel' has a wrong offset!");
static_assert(offsetof(UUI_MissionBriefContainer, RemainDateTimer) == 0x0004F8, "Member 'UUI_MissionBriefContainer::RemainDateTimer' has a wrong offset!");
static_assert(offsetof(UUI_MissionBriefContainer, WidgetSwitcher) == 0x000500, "Member 'UUI_MissionBriefContainer::WidgetSwitcher' has a wrong offset!");
static_assert(offsetof(UUI_MissionBriefContainer, _MissionBriefSlotClass) == 0x000508, "Member 'UUI_MissionBriefContainer::_MissionBriefSlotClass' has a wrong offset!");

// Class Stigma.AIDeco_IsEqualBehaviorType
// 0x0008 (0x0070 - 0x0068)
class UAIDeco_IsEqualBehaviorType final : public UBTDecorator
{
public:
	EMainBehaviorType                             MainBehaviorType;                                  // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20F1[0x7];                                     // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDeco_IsEqualBehaviorType">();
	}
	static class UAIDeco_IsEqualBehaviorType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDeco_IsEqualBehaviorType>();
	}
};
static_assert(alignof(UAIDeco_IsEqualBehaviorType) == 0x000008, "Wrong alignment on UAIDeco_IsEqualBehaviorType");
static_assert(sizeof(UAIDeco_IsEqualBehaviorType) == 0x000070, "Wrong size on UAIDeco_IsEqualBehaviorType");
static_assert(offsetof(UAIDeco_IsEqualBehaviorType, MainBehaviorType) == 0x000068, "Member 'UAIDeco_IsEqualBehaviorType::MainBehaviorType' has a wrong offset!");

// Class Stigma.VertexDisplace
// 0x0010 (0x0040 - 0x0030)
class UVertexDisplace final : public UAnimNotifyState
{
public:
	uint8                                         Pad_20F2[0x8];                                     // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UCurveFloat*                            _DisplaceValue;                                    // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VertexDisplace">();
	}
	static class UVertexDisplace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVertexDisplace>();
	}
};
static_assert(alignof(UVertexDisplace) == 0x000008, "Wrong alignment on UVertexDisplace");
static_assert(sizeof(UVertexDisplace) == 0x000040, "Wrong size on UVertexDisplace");
static_assert(offsetof(UVertexDisplace, _DisplaceValue) == 0x000038, "Member 'UVertexDisplace::_DisplaceValue' has a wrong offset!");

// Class Stigma.UI_MailListItem
// 0x0060 (0x0320 - 0x02C0)
class UUI_MailListItem : public UUserWidget
{
public:
	uint8                                         Pad_20F3[0x8];                                     // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UTextBlock*                             Txt_Title;                                         // 0x02C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_RemainTime;                                    // 0x02D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Content;                                       // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_BtnReadNew;                                    // 0x02E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_ReceiveIcon;                                   // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                BTN_ReadNew;                                       // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                BTN_Read;                                          // 0x02F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCheckBox*                              CheckBox_Select;                                   // 0x0300(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_RewardItem*                         RewardItem;                                        // 0x0308(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        SWITCHER_Button;                                   // 0x0310(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20F4[0x8];                                     // 0x0318(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnClickRead();
	void OnClickSelect(bool _is_selected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_MailListItem">();
	}
	static class UUI_MailListItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_MailListItem>();
	}
};
static_assert(alignof(UUI_MailListItem) == 0x000008, "Wrong alignment on UUI_MailListItem");
static_assert(sizeof(UUI_MailListItem) == 0x000320, "Wrong size on UUI_MailListItem");
static_assert(offsetof(UUI_MailListItem, Txt_Title) == 0x0002C8, "Member 'UUI_MailListItem::Txt_Title' has a wrong offset!");
static_assert(offsetof(UUI_MailListItem, TXT_RemainTime) == 0x0002D0, "Member 'UUI_MailListItem::TXT_RemainTime' has a wrong offset!");
static_assert(offsetof(UUI_MailListItem, TXT_Content) == 0x0002D8, "Member 'UUI_MailListItem::TXT_Content' has a wrong offset!");
static_assert(offsetof(UUI_MailListItem, TXT_BtnReadNew) == 0x0002E0, "Member 'UUI_MailListItem::TXT_BtnReadNew' has a wrong offset!");
static_assert(offsetof(UUI_MailListItem, IMG_ReceiveIcon) == 0x0002E8, "Member 'UUI_MailListItem::IMG_ReceiveIcon' has a wrong offset!");
static_assert(offsetof(UUI_MailListItem, BTN_ReadNew) == 0x0002F0, "Member 'UUI_MailListItem::BTN_ReadNew' has a wrong offset!");
static_assert(offsetof(UUI_MailListItem, BTN_Read) == 0x0002F8, "Member 'UUI_MailListItem::BTN_Read' has a wrong offset!");
static_assert(offsetof(UUI_MailListItem, CheckBox_Select) == 0x000300, "Member 'UUI_MailListItem::CheckBox_Select' has a wrong offset!");
static_assert(offsetof(UUI_MailListItem, RewardItem) == 0x000308, "Member 'UUI_MailListItem::RewardItem' has a wrong offset!");
static_assert(offsetof(UUI_MailListItem, SWITCHER_Button) == 0x000310, "Member 'UUI_MailListItem::SWITCHER_Button' has a wrong offset!");

// Class Stigma.AIDeco_IsInBattle
// 0x0000 (0x0068 - 0x0068)
class UAIDeco_IsInBattle final : public UBTDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDeco_IsInBattle">();
	}
	static class UAIDeco_IsInBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDeco_IsInBattle>();
	}
};
static_assert(alignof(UAIDeco_IsInBattle) == 0x000008, "Wrong alignment on UAIDeco_IsInBattle");
static_assert(sizeof(UAIDeco_IsInBattle) == 0x000068, "Wrong size on UAIDeco_IsInBattle");

// Class Stigma.MissionCondition_PlayTime
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_PlayTime final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_PlayTime">();
	}
	static class UMissionCondition_PlayTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_PlayTime>();
	}
};
static_assert(alignof(UMissionCondition_PlayTime) == 0x000008, "Wrong alignment on UMissionCondition_PlayTime");
static_assert(sizeof(UMissionCondition_PlayTime) == 0x000068, "Wrong size on UMissionCondition_PlayTime");

// Class Stigma.AIDeco_IsInFightingDistance
// 0x0008 (0x0070 - 0x0068)
class UAIDeco_IsInFightingDistance final : public UBTDecorator
{
public:
	ECompareFunc                                  CompareFunction;                                   // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20F5[0x7];                                     // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDeco_IsInFightingDistance">();
	}
	static class UAIDeco_IsInFightingDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDeco_IsInFightingDistance>();
	}
};
static_assert(alignof(UAIDeco_IsInFightingDistance) == 0x000008, "Wrong alignment on UAIDeco_IsInFightingDistance");
static_assert(sizeof(UAIDeco_IsInFightingDistance) == 0x000070, "Wrong size on UAIDeco_IsInFightingDistance");
static_assert(offsetof(UAIDeco_IsInFightingDistance, CompareFunction) == 0x000068, "Member 'UAIDeco_IsInFightingDistance::CompareFunction' has a wrong offset!");

// Class Stigma.AIDeco_IsProperDistance
// 0x0008 (0x0070 - 0x0068)
class UAIDeco_IsProperDistance final : public UBTDecorator
{
public:
	float                                         DistancePrecision;                                 // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20F6[0x4];                                     // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDeco_IsProperDistance">();
	}
	static class UAIDeco_IsProperDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDeco_IsProperDistance>();
	}
};
static_assert(alignof(UAIDeco_IsProperDistance) == 0x000008, "Wrong alignment on UAIDeco_IsProperDistance");
static_assert(sizeof(UAIDeco_IsProperDistance) == 0x000070, "Wrong size on UAIDeco_IsProperDistance");
static_assert(offsetof(UAIDeco_IsProperDistance, DistancePrecision) == 0x000068, "Member 'UAIDeco_IsProperDistance::DistancePrecision' has a wrong offset!");

// Class Stigma.MissionCondition_PurchaseGoods
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_PurchaseGoods final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_PurchaseGoods">();
	}
	static class UMissionCondition_PurchaseGoods* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_PurchaseGoods>();
	}
};
static_assert(alignof(UMissionCondition_PurchaseGoods) == 0x000008, "Wrong alignment on UMissionCondition_PurchaseGoods");
static_assert(sizeof(UMissionCondition_PurchaseGoods) == 0x000068, "Wrong size on UMissionCondition_PurchaseGoods");

// Class Stigma.AIDeco_Threat
// 0x0008 (0x0070 - 0x0068)
class UAIDeco_Threat final : public UBTDecorator
{
public:
	float                                         Threat;                                            // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECompare                                      CompareFunction;                                   // 0x006C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20F7[0x3];                                     // 0x006D(0x0003)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDeco_Threat">();
	}
	static class UAIDeco_Threat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDeco_Threat>();
	}
};
static_assert(alignof(UAIDeco_Threat) == 0x000008, "Wrong alignment on UAIDeco_Threat");
static_assert(sizeof(UAIDeco_Threat) == 0x000070, "Wrong size on UAIDeco_Threat");
static_assert(offsetof(UAIDeco_Threat, Threat) == 0x000068, "Member 'UAIDeco_Threat::Threat' has a wrong offset!");
static_assert(offsetof(UAIDeco_Threat, CompareFunction) == 0x00006C, "Member 'UAIDeco_Threat::CompareFunction' has a wrong offset!");

// Class Stigma.AIDeco_ThrowDice
// 0x0008 (0x0070 - 0x0068)
class UAIDeco_ThrowDice final : public UBTDecorator
{
public:
	float                                         SuccessProbability;                                // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20F8[0x4];                                     // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDeco_ThrowDice">();
	}
	static class UAIDeco_ThrowDice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDeco_ThrowDice>();
	}
};
static_assert(alignof(UAIDeco_ThrowDice) == 0x000008, "Wrong alignment on UAIDeco_ThrowDice");
static_assert(sizeof(UAIDeco_ThrowDice) == 0x000070, "Wrong size on UAIDeco_ThrowDice");
static_assert(offsetof(UAIDeco_ThrowDice, SuccessProbability) == 0x000068, "Member 'UAIDeco_ThrowDice::SuccessProbability' has a wrong offset!");

// Class Stigma.AIDeco_ThrowDiceWithBB
// 0x0038 (0x00A0 - 0x0068)
class UAIDeco_ThrowDiceWithBB final : public UBTDecorator
{
public:
	struct FBlackboardKeySelector                 BlackboardKey;                                     // 0x0068(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         ValidRange_Min;                                    // 0x0090(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValidRange_Max;                                    // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scaler;                                            // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OneMinus;                                          // 0x009C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20F9[0x3];                                     // 0x009D(0x0003)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIDeco_ThrowDiceWithBB">();
	}
	static class UAIDeco_ThrowDiceWithBB* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAIDeco_ThrowDiceWithBB>();
	}
};
static_assert(alignof(UAIDeco_ThrowDiceWithBB) == 0x000008, "Wrong alignment on UAIDeco_ThrowDiceWithBB");
static_assert(sizeof(UAIDeco_ThrowDiceWithBB) == 0x0000A0, "Wrong size on UAIDeco_ThrowDiceWithBB");
static_assert(offsetof(UAIDeco_ThrowDiceWithBB, BlackboardKey) == 0x000068, "Member 'UAIDeco_ThrowDiceWithBB::BlackboardKey' has a wrong offset!");
static_assert(offsetof(UAIDeco_ThrowDiceWithBB, ValidRange_Min) == 0x000090, "Member 'UAIDeco_ThrowDiceWithBB::ValidRange_Min' has a wrong offset!");
static_assert(offsetof(UAIDeco_ThrowDiceWithBB, ValidRange_Max) == 0x000094, "Member 'UAIDeco_ThrowDiceWithBB::ValidRange_Max' has a wrong offset!");
static_assert(offsetof(UAIDeco_ThrowDiceWithBB, Scaler) == 0x000098, "Member 'UAIDeco_ThrowDiceWithBB::Scaler' has a wrong offset!");
static_assert(offsetof(UAIDeco_ThrowDiceWithBB, OneMinus) == 0x00009C, "Member 'UAIDeco_ThrowDiceWithBB::OneMinus' has a wrong offset!");

// Class Stigma.HUD_KillStreakWidget
// 0x00F0 (0x05E0 - 0x04F0)
class UHUD_KillStreakWidget : public UPreviewableWidget
{
public:
	class UImage*                                 Img_StreakIcon;                                    // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_KillStreak;                                    // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FKillStreakDefine                      _KillStreakDefine;                                 // 0x0500(0x00E0)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	void InitWidget(const struct FKillStreakDefine& _kill_streak_def);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUD_KillStreakWidget">();
	}
	static class UHUD_KillStreakWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUD_KillStreakWidget>();
	}
};
static_assert(alignof(UHUD_KillStreakWidget) == 0x000008, "Wrong alignment on UHUD_KillStreakWidget");
static_assert(sizeof(UHUD_KillStreakWidget) == 0x0005E0, "Wrong size on UHUD_KillStreakWidget");
static_assert(offsetof(UHUD_KillStreakWidget, Img_StreakIcon) == 0x0004F0, "Member 'UHUD_KillStreakWidget::Img_StreakIcon' has a wrong offset!");
static_assert(offsetof(UHUD_KillStreakWidget, Txt_KillStreak) == 0x0004F8, "Member 'UHUD_KillStreakWidget::Txt_KillStreak' has a wrong offset!");
static_assert(offsetof(UHUD_KillStreakWidget, _KillStreakDefine) == 0x000500, "Member 'UHUD_KillStreakWidget::_KillStreakDefine' has a wrong offset!");

// Class Stigma.WebSocketClient
// 0x00E8 (0x0110 - 0x0028)
class UWebSocketClient final : public UObject
{
public:
	uint8                                         Pad_20FA[0xE8];                                    // 0x0028(0x00E8)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WebSocketClient">();
	}
	static class UWebSocketClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWebSocketClient>();
	}
};
static_assert(alignof(UWebSocketClient) == 0x000008, "Wrong alignment on UWebSocketClient");
static_assert(sizeof(UWebSocketClient) == 0x000110, "Wrong size on UWebSocketClient");

// Class Stigma.AimShoot
// 0x0008 (0x0038 - 0x0030)
class UAimShoot final : public UAnimNotifyState
{
public:
	int32                                         ShootCount;                                        // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBodyParts                                    AimParts;                                          // 0x0034(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20FB[0x3];                                     // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimShoot">();
	}
	static class UAimShoot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimShoot>();
	}
};
static_assert(alignof(UAimShoot) == 0x000008, "Wrong alignment on UAimShoot");
static_assert(sizeof(UAimShoot) == 0x000038, "Wrong size on UAimShoot");
static_assert(offsetof(UAimShoot, ShootCount) == 0x000030, "Member 'UAimShoot::ShootCount' has a wrong offset!");
static_assert(offsetof(UAimShoot, AimParts) == 0x000034, "Member 'UAimShoot::AimParts' has a wrong offset!");

// Class Stigma.GunnerSystemComponent_VarietyFirearms
// 0x0018 (0x00D0 - 0x00B8)
class UGunnerSystemComponent_VarietyFirearms final : public UGunnerSystemComponent
{
public:
	TSubclassOf<class UAnimInstance>              NoGunAnimBPClass;                                  // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              SingleAnimBPClass;                                 // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UAnimInstance>              DualAnimBPClass;                                   // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GunnerSystemComponent_VarietyFirearms">();
	}
	static class UGunnerSystemComponent_VarietyFirearms* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGunnerSystemComponent_VarietyFirearms>();
	}
};
static_assert(alignof(UGunnerSystemComponent_VarietyFirearms) == 0x000008, "Wrong alignment on UGunnerSystemComponent_VarietyFirearms");
static_assert(sizeof(UGunnerSystemComponent_VarietyFirearms) == 0x0000D0, "Wrong size on UGunnerSystemComponent_VarietyFirearms");
static_assert(offsetof(UGunnerSystemComponent_VarietyFirearms, NoGunAnimBPClass) == 0x0000B8, "Member 'UGunnerSystemComponent_VarietyFirearms::NoGunAnimBPClass' has a wrong offset!");
static_assert(offsetof(UGunnerSystemComponent_VarietyFirearms, SingleAnimBPClass) == 0x0000C0, "Member 'UGunnerSystemComponent_VarietyFirearms::SingleAnimBPClass' has a wrong offset!");
static_assert(offsetof(UGunnerSystemComponent_VarietyFirearms, DualAnimBPClass) == 0x0000C8, "Member 'UGunnerSystemComponent_VarietyFirearms::DualAnimBPClass' has a wrong offset!");

// Class Stigma.UI_MissionPopupContainerMaster
// 0x0070 (0x0560 - 0x04F0)
class UUI_MissionPopupContainerMaster : public UPreviewableWidget
{
public:
	class UUniformGridPanel*                      UGP_MasterTab;                                     // 0x04F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_RemainDateTimer*                    RemainDateTimer;                                   // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VB_Missions;                                       // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             ScrollBox_LevelReward;                             // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HB_LevelReward;                                    // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _MaxMissionChangeCount;                            // 0x0518(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20FC[0x4];                                     // 0x051C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UCtrl_MasterMissionButton>  _MasterButtonClass;                                // 0x0520(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_MissionPopupSlotMaster> _MissionSlotClass;                                 // 0x0528(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                _MissionSlotPadding;                               // 0x0530(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_MasterLevelRewardSlot>  _LevelRewardSlotClass;                             // 0x0540(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemID_EventPage                      _CurrentMasterEventID;                             // 0x0548(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECharaType                                    _CurrentMasterType;                                // 0x0558(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_20FD[0x7];                                     // 0x0559(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ClearLocked();
	void FirstMissionLocked();
	void InitWidget(const struct FItemID_EventPage& _master_event_id);
	void MaxLevelLocked();
	void NoMasterLocked();
	void OnMasterButtonSelected(class UAnimatableWidget* _widget, bool _selected);
	void SetCanReward(bool _can_reward);
	void SetMasterExpPercent(float _percent);
	void SetMissionChangeCount(int32 _current_count);
	void SetTitle(const class FText& _text);
	void SetTitleReward(const class FText& _text, const struct FSlateBrush& _brush);
	void UserLevelLocked(int32 _level);

	ECharaType GetCurrentCharaType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_MissionPopupContainerMaster">();
	}
	static class UUI_MissionPopupContainerMaster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_MissionPopupContainerMaster>();
	}
};
static_assert(alignof(UUI_MissionPopupContainerMaster) == 0x000008, "Wrong alignment on UUI_MissionPopupContainerMaster");
static_assert(sizeof(UUI_MissionPopupContainerMaster) == 0x000560, "Wrong size on UUI_MissionPopupContainerMaster");
static_assert(offsetof(UUI_MissionPopupContainerMaster, UGP_MasterTab) == 0x0004F0, "Member 'UUI_MissionPopupContainerMaster::UGP_MasterTab' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupContainerMaster, RemainDateTimer) == 0x0004F8, "Member 'UUI_MissionPopupContainerMaster::RemainDateTimer' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupContainerMaster, VB_Missions) == 0x000500, "Member 'UUI_MissionPopupContainerMaster::VB_Missions' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupContainerMaster, ScrollBox_LevelReward) == 0x000508, "Member 'UUI_MissionPopupContainerMaster::ScrollBox_LevelReward' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupContainerMaster, HB_LevelReward) == 0x000510, "Member 'UUI_MissionPopupContainerMaster::HB_LevelReward' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupContainerMaster, _MaxMissionChangeCount) == 0x000518, "Member 'UUI_MissionPopupContainerMaster::_MaxMissionChangeCount' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupContainerMaster, _MasterButtonClass) == 0x000520, "Member 'UUI_MissionPopupContainerMaster::_MasterButtonClass' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupContainerMaster, _MissionSlotClass) == 0x000528, "Member 'UUI_MissionPopupContainerMaster::_MissionSlotClass' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupContainerMaster, _MissionSlotPadding) == 0x000530, "Member 'UUI_MissionPopupContainerMaster::_MissionSlotPadding' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupContainerMaster, _LevelRewardSlotClass) == 0x000540, "Member 'UUI_MissionPopupContainerMaster::_LevelRewardSlotClass' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupContainerMaster, _CurrentMasterEventID) == 0x000548, "Member 'UUI_MissionPopupContainerMaster::_CurrentMasterEventID' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupContainerMaster, _CurrentMasterType) == 0x000558, "Member 'UUI_MissionPopupContainerMaster::_CurrentMasterType' has a wrong offset!");

// Class Stigma.AIRoamingPointVolume
// 0x0008 (0x02A0 - 0x0298)
class AAIRoamingPointVolume final : public AActor
{
public:
	bool                                          _IsImportant;                                      // 0x0298(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeams                                        _Team;                                             // 0x0299(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsInSanctum;                                      // 0x029A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2100[0x5];                                     // 0x029B(0x0005)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	struct FVector GetRandomLocationInVolume() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AIRoamingPointVolume">();
	}
	static class AAIRoamingPointVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAIRoamingPointVolume>();
	}
};
static_assert(alignof(AAIRoamingPointVolume) == 0x000008, "Wrong alignment on AAIRoamingPointVolume");
static_assert(sizeof(AAIRoamingPointVolume) == 0x0002A0, "Wrong size on AAIRoamingPointVolume");
static_assert(offsetof(AAIRoamingPointVolume, _IsImportant) == 0x000298, "Member 'AAIRoamingPointVolume::_IsImportant' has a wrong offset!");
static_assert(offsetof(AAIRoamingPointVolume, _Team) == 0x000299, "Member 'AAIRoamingPointVolume::_Team' has a wrong offset!");
static_assert(offsetof(AAIRoamingPointVolume, _IsInSanctum) == 0x00029A, "Member 'AAIRoamingPointVolume::_IsInSanctum' has a wrong offset!");

// Class Stigma.MatchServicedGameMode
// 0x0478 (0x07B0 - 0x0338)
class AMatchServicedGameMode : public AGameModeBase
{
public:
	uint8                                         Pad_2101[0x478];                                   // 0x0338(0x0478)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	class AMatchServicedPlayerState* AddAIAsPlayer(const class FString& _nickname, ETeams _Team, TSubclassOf<class AAICharaBase> _Class, ECharaType _chara_type, class UBehaviorTree* _BT, const struct FAI_Characteristic& _characteristic, float _hp_scaler, float _armor_scaler, float _action_stock_scaler, float _bullet_scaler);
	void AddMissionConditionReport(const struct FUserID& _user_id, const EMissionConditionType _type, const class FString& _sub_type, const int32 _value);
	class AMatchServicedPlayerState* AddPlaceHolder(ETeams _Team, int32 _elo);
	class APlayerStart* FindPlayerStartByTeam(ETeams _Team);
	bool OnQuery_IsReadyForStarting();
	bool OnQuery_SendBattlePing();

	int32 GetTeamMemberCount(ETeams _Team) const;
	struct FBattleFinish OnQuery_FinishBattle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchServicedGameMode">();
	}
	static class AMatchServicedGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMatchServicedGameMode>();
	}
};
static_assert(alignof(AMatchServicedGameMode) == 0x000008, "Wrong alignment on AMatchServicedGameMode");
static_assert(sizeof(AMatchServicedGameMode) == 0x0007B0, "Wrong size on AMatchServicedGameMode");

// Class Stigma.WaitingRoomGameMode
// 0x00D8 (0x0888 - 0x07B0)
class AWaitingRoomGameMode final : public AMatchServicedGameMode
{
public:
	uint8                                         Pad_210A[0x88];                                    // 0x07B0(0x0088)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         CharacterPickDuration;                             // 0x0838(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StartingDuration;                                  // 0x083C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         QuitingDuration;                                   // 0x0840(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         IntroDuration;                                     // 0x0844(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AAICharaBase>               DefaultAICharaClass;                               // 0x0848(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UBehaviorTree>           DefaultBehaviorTree;                               // 0x0850(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_210B[0x10];                                    // 0x0878(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void DEBUG_SetToCustomGame();
	int32 GetStartingDuration();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaitingRoomGameMode">();
	}
	static class AWaitingRoomGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWaitingRoomGameMode>();
	}
};
static_assert(alignof(AWaitingRoomGameMode) == 0x000008, "Wrong alignment on AWaitingRoomGameMode");
static_assert(sizeof(AWaitingRoomGameMode) == 0x000888, "Wrong size on AWaitingRoomGameMode");
static_assert(offsetof(AWaitingRoomGameMode, CharacterPickDuration) == 0x000838, "Member 'AWaitingRoomGameMode::CharacterPickDuration' has a wrong offset!");
static_assert(offsetof(AWaitingRoomGameMode, StartingDuration) == 0x00083C, "Member 'AWaitingRoomGameMode::StartingDuration' has a wrong offset!");
static_assert(offsetof(AWaitingRoomGameMode, QuitingDuration) == 0x000840, "Member 'AWaitingRoomGameMode::QuitingDuration' has a wrong offset!");
static_assert(offsetof(AWaitingRoomGameMode, IntroDuration) == 0x000844, "Member 'AWaitingRoomGameMode::IntroDuration' has a wrong offset!");
static_assert(offsetof(AWaitingRoomGameMode, DefaultAICharaClass) == 0x000848, "Member 'AWaitingRoomGameMode::DefaultAICharaClass' has a wrong offset!");
static_assert(offsetof(AWaitingRoomGameMode, DefaultBehaviorTree) == 0x000850, "Member 'AWaitingRoomGameMode::DefaultBehaviorTree' has a wrong offset!");

// Class Stigma.UI_MissionBriefContainer_Track
// 0x0000 (0x0520 - 0x0520)
class UUI_MissionBriefContainer_Track : public UUI_MissionBriefContainer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_MissionBriefContainer_Track">();
	}
	static class UUI_MissionBriefContainer_Track* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_MissionBriefContainer_Track>();
	}
};
static_assert(alignof(UUI_MissionBriefContainer_Track) == 0x000008, "Wrong alignment on UUI_MissionBriefContainer_Track");
static_assert(sizeof(UUI_MissionBriefContainer_Track) == 0x000520, "Wrong size on UUI_MissionBriefContainer_Track");

// Class Stigma.AISense_CustomHearing
// 0x0000 (0x00E0 - 0x00E0)
class UAISense_CustomHearing final : public UAISense_Hearing
{
public:
	static void ReportNoiseCustomEvent(class UObject* WorldContextObject, const struct FVector& NoiseLocation, float Loudness, class AActor* Instigator, float MaxRange, class FName Tag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISense_CustomHearing">();
	}
	static class UAISense_CustomHearing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISense_CustomHearing>();
	}
};
static_assert(alignof(UAISense_CustomHearing) == 0x000008, "Wrong alignment on UAISense_CustomHearing");
static_assert(sizeof(UAISense_CustomHearing) == 0x0000E0, "Wrong size on UAISense_CustomHearing");

// Class Stigma.AISpawner
// 0x0048 (0x02E0 - 0x0298)
class AAISpawner final : public AActor
{
public:
	bool                                          EnableSpawn;                                       // 0x0298(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_210E[0x7];                                     // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FAISpawn>                       AISpawnDatas;                                      // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          UseCollisionTrigger;                               // 0x02B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_210F[0x7];                                     // 0x02B1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          IsActivated;                                       // 0x02B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2110[0x17];                                    // 0x02B9(0x0017)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class APawn>                      AICharaClass;                                      // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBehaviorTree*                          BehaviorTree;                                      // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Activate();
	void Deactivate();
	void Reset();

	int32 GetAliveCharaCount() const;
	int32 GetRemainCharaCount() const;
	int32 GetTotalSpawnCount() const;
	bool IsDestoriedAllCharas() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISpawner">();
	}
	static class AAISpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAISpawner>();
	}
};
static_assert(alignof(AAISpawner) == 0x000008, "Wrong alignment on AAISpawner");
static_assert(sizeof(AAISpawner) == 0x0002E0, "Wrong size on AAISpawner");
static_assert(offsetof(AAISpawner, EnableSpawn) == 0x000298, "Member 'AAISpawner::EnableSpawn' has a wrong offset!");
static_assert(offsetof(AAISpawner, AISpawnDatas) == 0x0002A0, "Member 'AAISpawner::AISpawnDatas' has a wrong offset!");
static_assert(offsetof(AAISpawner, UseCollisionTrigger) == 0x0002B0, "Member 'AAISpawner::UseCollisionTrigger' has a wrong offset!");
static_assert(offsetof(AAISpawner, IsActivated) == 0x0002B8, "Member 'AAISpawner::IsActivated' has a wrong offset!");
static_assert(offsetof(AAISpawner, AICharaClass) == 0x0002D0, "Member 'AAISpawner::AICharaClass' has a wrong offset!");
static_assert(offsetof(AAISpawner, BehaviorTree) == 0x0002D8, "Member 'AAISpawner::BehaviorTree' has a wrong offset!");

// Class Stigma.MannequinManager
// 0x0018 (0x0040 - 0x0028)
class UMannequinManager final : public UObject
{
public:
	class AMatchServicedPlayerState*              _PlayerState;                                      // 0x0028(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AMannequin*>                     _Mannequins;                                       // 0x0030(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void Bind(class AMatchServicedPlayerState* _ps);
	void ScanMannequins();
	void ShowDummy(int32 _idx);
	void Update();

	class AMannequin* GetCurrentMannequin() const;
	class AMannequin* GetMannequin(int32 _idx) const;
	int32 GetMannequinCount() const;
	class AMatchServicedPlayerState* GetPlayerState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MannequinManager">();
	}
	static class UMannequinManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMannequinManager>();
	}
};
static_assert(alignof(UMannequinManager) == 0x000008, "Wrong alignment on UMannequinManager");
static_assert(sizeof(UMannequinManager) == 0x000040, "Wrong size on UMannequinManager");
static_assert(offsetof(UMannequinManager, _PlayerState) == 0x000028, "Member 'UMannequinManager::_PlayerState' has a wrong offset!");
static_assert(offsetof(UMannequinManager, _Mannequins) == 0x000030, "Member 'UMannequinManager::_Mannequins' has a wrong offset!");

// Class Stigma.MissionCondition_GunCollect
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_GunCollect final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_GunCollect">();
	}
	static class UMissionCondition_GunCollect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_GunCollect>();
	}
};
static_assert(alignof(UMissionCondition_GunCollect) == 0x000008, "Wrong alignment on UMissionCondition_GunCollect");
static_assert(sizeof(UMissionCondition_GunCollect) == 0x000068, "Wrong size on UMissionCondition_GunCollect");

// Class Stigma.AISvc_UpdateBlackboard
// 0x0008 (0x0078 - 0x0070)
class UAISvc_UpdateBlackboard final : public UBTService
{
public:
	float                                         AttackProbability;                                 // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2112[0x4];                                     // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AISvc_UpdateBlackboard">();
	}
	static class UAISvc_UpdateBlackboard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAISvc_UpdateBlackboard>();
	}
};
static_assert(alignof(UAISvc_UpdateBlackboard) == 0x000008, "Wrong alignment on UAISvc_UpdateBlackboard");
static_assert(sizeof(UAISvc_UpdateBlackboard) == 0x000078, "Wrong size on UAISvc_UpdateBlackboard");
static_assert(offsetof(UAISvc_UpdateBlackboard, AttackProbability) == 0x000070, "Member 'UAISvc_UpdateBlackboard::AttackProbability' has a wrong offset!");

// Class Stigma.AITools
// 0x0000 (0x0028 - 0x0028)
class UAITools final : public UBlueprintFunctionLibrary
{
public:
	static bool CompareValue(ECompareFunc _op, float _v1, float _v2, float _tolerance);
	static bool ThrowDice(float _guide);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AITools">();
	}
	static class UAITools* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAITools>();
	}
};
static_assert(alignof(UAITools) == 0x000008, "Wrong alignment on UAITools");
static_assert(sizeof(UAITools) == 0x000028, "Wrong size on UAITools");

// Class Stigma.MissionCondition_KillRangeUnder
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_KillRangeUnder final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_KillRangeUnder">();
	}
	static class UMissionCondition_KillRangeUnder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_KillRangeUnder>();
	}
};
static_assert(alignof(UMissionCondition_KillRangeUnder) == 0x000008, "Wrong alignment on UMissionCondition_KillRangeUnder");
static_assert(sizeof(UMissionCondition_KillRangeUnder) == 0x000068, "Wrong size on UMissionCondition_KillRangeUnder");

// Class Stigma.BattleGameModeBase
// 0x0028 (0x07D8 - 0x07B0)
class ABattleGameModeBase : public AMatchServicedGameMode
{
public:
	int32                                         TimeLimit_StartSession;                            // 0x07B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimeDelay_Matched;                                 // 0x07B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultMagazineCountScaler;                        // 0x07B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          RespawnWhenStart;                                  // 0x07BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2116[0x3];                                     // 0x07BD(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class ACameraActor*>                   _CCTVs;                                            // 0x07C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2117[0x8];                                     // 0x07D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void FillUpWithBOT();
	void OnCharaIsKilled(class AController* _killer, class AController* _killed, class AController* _assist);
	bool OnQuery_EndOfRound();

	EBattleModePhase GetCurrentBattlePhase() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleGameModeBase">();
	}
	static class ABattleGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABattleGameModeBase>();
	}
};
static_assert(alignof(ABattleGameModeBase) == 0x000008, "Wrong alignment on ABattleGameModeBase");
static_assert(sizeof(ABattleGameModeBase) == 0x0007D8, "Wrong size on ABattleGameModeBase");
static_assert(offsetof(ABattleGameModeBase, TimeLimit_StartSession) == 0x0007B0, "Member 'ABattleGameModeBase::TimeLimit_StartSession' has a wrong offset!");
static_assert(offsetof(ABattleGameModeBase, TimeDelay_Matched) == 0x0007B4, "Member 'ABattleGameModeBase::TimeDelay_Matched' has a wrong offset!");
static_assert(offsetof(ABattleGameModeBase, DefaultMagazineCountScaler) == 0x0007B8, "Member 'ABattleGameModeBase::DefaultMagazineCountScaler' has a wrong offset!");
static_assert(offsetof(ABattleGameModeBase, RespawnWhenStart) == 0x0007BC, "Member 'ABattleGameModeBase::RespawnWhenStart' has a wrong offset!");
static_assert(offsetof(ABattleGameModeBase, _CCTVs) == 0x0007C0, "Member 'ABattleGameModeBase::_CCTVs' has a wrong offset!");

// Class Stigma.UI_HUDMode
// 0x0010 (0x0500 - 0x04F0)
class UUI_HUDMode : public UPreviewableWidget
{
public:
	class UUI_HUDBase*                            _HUDBase;                                          // 0x04F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharaBase*                             _TargetChara;                                      // 0x04F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool OnBind();
	bool OnHitAndDamage(const struct FDamagedData& _damage);
	bool OnTargetRespawned();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_HUDMode">();
	}
	static class UUI_HUDMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_HUDMode>();
	}
};
static_assert(alignof(UUI_HUDMode) == 0x000008, "Wrong alignment on UUI_HUDMode");
static_assert(sizeof(UUI_HUDMode) == 0x000500, "Wrong size on UUI_HUDMode");
static_assert(offsetof(UUI_HUDMode, _HUDBase) == 0x0004F0, "Member 'UUI_HUDMode::_HUDBase' has a wrong offset!");
static_assert(offsetof(UUI_HUDMode, _TargetChara) == 0x0004F8, "Member 'UUI_HUDMode::_TargetChara' has a wrong offset!");

// Class Stigma.HUD_AnnihilationMode
// 0x0000 (0x0500 - 0x0500)
class UHUD_AnnihilationMode : public UUI_HUDMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUD_AnnihilationMode">();
	}
	static class UHUD_AnnihilationMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUD_AnnihilationMode>();
	}
};
static_assert(alignof(UHUD_AnnihilationMode) == 0x000008, "Wrong alignment on UHUD_AnnihilationMode");
static_assert(sizeof(UHUD_AnnihilationMode) == 0x000500, "Wrong size on UHUD_AnnihilationMode");

// Class Stigma.UI_ModeRecords
// 0x0020 (0x0510 - 0x04F0)
class UUI_ModeRecords : public UPreviewableWidget
{
public:
	TSubclassOf<class UUI_ModeRecordItem>         _ModeRecordItemClass;                              // 0x04F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           V_RecordContainer;                                 // 0x04F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_Title;                                         // 0x0500(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Total;                                         // 0x0508(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_ModeRecords">();
	}
	static class UUI_ModeRecords* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_ModeRecords>();
	}
};
static_assert(alignof(UUI_ModeRecords) == 0x000008, "Wrong alignment on UUI_ModeRecords");
static_assert(sizeof(UUI_ModeRecords) == 0x000510, "Wrong size on UUI_ModeRecords");
static_assert(offsetof(UUI_ModeRecords, _ModeRecordItemClass) == 0x0004F0, "Member 'UUI_ModeRecords::_ModeRecordItemClass' has a wrong offset!");
static_assert(offsetof(UUI_ModeRecords, V_RecordContainer) == 0x0004F8, "Member 'UUI_ModeRecords::V_RecordContainer' has a wrong offset!");
static_assert(offsetof(UUI_ModeRecords, Txt_Title) == 0x000500, "Member 'UUI_ModeRecords::Txt_Title' has a wrong offset!");
static_assert(offsetof(UUI_ModeRecords, TXT_Total) == 0x000508, "Member 'UUI_ModeRecords::TXT_Total' has a wrong offset!");

// Class Stigma.Annihilation_GameMode
// 0x0028 (0x0800 - 0x07D8)
class AAnnihilation_GameMode : public ABattleGameModeBase
{
public:
	TArray<class ADoorBase*>                      BarrierDoorList;                                   // 0x07D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class AItemBoxBase*>                   ItemBoxList;                                       // 0x07E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	ETeams                                        _LastRoundWinTeam;                                 // 0x07F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2119[0x7];                                     // 0x07F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void RegisterBarrierDoor(class ADoorBase* _door);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Annihilation_GameMode">();
	}
	static class AAnnihilation_GameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAnnihilation_GameMode>();
	}
};
static_assert(alignof(AAnnihilation_GameMode) == 0x000008, "Wrong alignment on AAnnihilation_GameMode");
static_assert(sizeof(AAnnihilation_GameMode) == 0x000800, "Wrong size on AAnnihilation_GameMode");
static_assert(offsetof(AAnnihilation_GameMode, BarrierDoorList) == 0x0007D8, "Member 'AAnnihilation_GameMode::BarrierDoorList' has a wrong offset!");
static_assert(offsetof(AAnnihilation_GameMode, ItemBoxList) == 0x0007E8, "Member 'AAnnihilation_GameMode::ItemBoxList' has a wrong offset!");
static_assert(offsetof(AAnnihilation_GameMode, _LastRoundWinTeam) == 0x0007F8, "Member 'AAnnihilation_GameMode::_LastRoundWinTeam' has a wrong offset!");

// Class Stigma.UI_MissionPopupContainerTrack
// 0x0000 (0x04F0 - 0x04F0)
class UUI_MissionPopupContainerTrack : public UPreviewableWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_MissionPopupContainerTrack">();
	}
	static class UUI_MissionPopupContainerTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_MissionPopupContainerTrack>();
	}
};
static_assert(alignof(UUI_MissionPopupContainerTrack) == 0x000008, "Wrong alignment on UUI_MissionPopupContainerTrack");
static_assert(sizeof(UUI_MissionPopupContainerTrack) == 0x0004F0, "Wrong size on UUI_MissionPopupContainerTrack");

// Class Stigma.MissionCondition_NA
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_NA final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_NA">();
	}
	static class UMissionCondition_NA* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_NA>();
	}
};
static_assert(alignof(UMissionCondition_NA) == 0x000008, "Wrong alignment on UMissionCondition_NA");
static_assert(sizeof(UMissionCondition_NA) == 0x000068, "Wrong size on UMissionCondition_NA");

// Class Stigma.Annihilation_GameState
// 0x0090 (0x0998 - 0x0908)
class AAnnihilation_GameState : public ABattleGameStateBase
{
public:
	struct FAnnihilationRule                      _AnnihilationRule;                                 // 0x0908(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FAnnihilation_GoldRule                 _GoldRule;                                         // 0x0928(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FRoundResult                           _RedTeam_LastRoundResult;                          // 0x0988(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRoundResult                           _BlueTeam_LastRoundResult;                         // 0x0990(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	const struct FAnnihilation_GoldRule GetGoldRule() const;
	const struct FAnnihilationRule GetRule() const;
	bool IsFactionChanged() const;
	bool IsFactionChangedRound() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Annihilation_GameState">();
	}
	static class AAnnihilation_GameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAnnihilation_GameState>();
	}
};
static_assert(alignof(AAnnihilation_GameState) == 0x000008, "Wrong alignment on AAnnihilation_GameState");
static_assert(sizeof(AAnnihilation_GameState) == 0x000998, "Wrong size on AAnnihilation_GameState");
static_assert(offsetof(AAnnihilation_GameState, _AnnihilationRule) == 0x000908, "Member 'AAnnihilation_GameState::_AnnihilationRule' has a wrong offset!");
static_assert(offsetof(AAnnihilation_GameState, _GoldRule) == 0x000928, "Member 'AAnnihilation_GameState::_GoldRule' has a wrong offset!");
static_assert(offsetof(AAnnihilation_GameState, _RedTeam_LastRoundResult) == 0x000988, "Member 'AAnnihilation_GameState::_RedTeam_LastRoundResult' has a wrong offset!");
static_assert(offsetof(AAnnihilation_GameState, _BlueTeam_LastRoundResult) == 0x000990, "Member 'AAnnihilation_GameState::_BlueTeam_LastRoundResult' has a wrong offset!");

// Class Stigma.MailListItemData
// 0x0080 (0x00A8 - 0x0028)
class UMailListItemData final : public UObject
{
public:
	int32                                         _MailIDN;                                          // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMailType                                     _MailType;                                         // 0x002C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMailState                                    _Status;                                           // 0x002D(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_211A[0x2];                                     // 0x002E(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	struct FDateTime                              _ExpireAt;                                         // 0x0030(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDateTime                              _CreatedAt;                                        // 0x0038(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 _Title;                                            // 0x0040(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 _Body;                                             // 0x0050(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRewardPlain                           _RewardPlain;                                      // 0x0060(0x0020)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_211B[0x28];                                    // 0x0080(0x0028)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MailListItemData">();
	}
	static class UMailListItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMailListItemData>();
	}
};
static_assert(alignof(UMailListItemData) == 0x000008, "Wrong alignment on UMailListItemData");
static_assert(sizeof(UMailListItemData) == 0x0000A8, "Wrong size on UMailListItemData");
static_assert(offsetof(UMailListItemData, _MailIDN) == 0x000028, "Member 'UMailListItemData::_MailIDN' has a wrong offset!");
static_assert(offsetof(UMailListItemData, _MailType) == 0x00002C, "Member 'UMailListItemData::_MailType' has a wrong offset!");
static_assert(offsetof(UMailListItemData, _Status) == 0x00002D, "Member 'UMailListItemData::_Status' has a wrong offset!");
static_assert(offsetof(UMailListItemData, _ExpireAt) == 0x000030, "Member 'UMailListItemData::_ExpireAt' has a wrong offset!");
static_assert(offsetof(UMailListItemData, _CreatedAt) == 0x000038, "Member 'UMailListItemData::_CreatedAt' has a wrong offset!");
static_assert(offsetof(UMailListItemData, _Title) == 0x000040, "Member 'UMailListItemData::_Title' has a wrong offset!");
static_assert(offsetof(UMailListItemData, _Body) == 0x000050, "Member 'UMailListItemData::_Body' has a wrong offset!");
static_assert(offsetof(UMailListItemData, _RewardPlain) == 0x000060, "Member 'UMailListItemData::_RewardPlain' has a wrong offset!");

// Class Stigma.MissionCondition_Challenge_TimeLimitRound
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_Challenge_TimeLimitRound final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_Challenge_TimeLimitRound">();
	}
	static class UMissionCondition_Challenge_TimeLimitRound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_Challenge_TimeLimitRound>();
	}
};
static_assert(alignof(UMissionCondition_Challenge_TimeLimitRound) == 0x000008, "Wrong alignment on UMissionCondition_Challenge_TimeLimitRound");
static_assert(sizeof(UMissionCondition_Challenge_TimeLimitRound) == 0x000068, "Wrong size on UMissionCondition_Challenge_TimeLimitRound");

// Class Stigma.HUD_CooldownBaseSlotPanel
// 0x0058 (0x0548 - 0x04F0)
class UHUD_CooldownBaseSlotPanel : public UPreviewableWidget
{
public:
	class UPanelWidget*                           SlotPanel;                                         // 0x04F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             NotReadySound;                                     // 0x04F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             ReadySound;                                        // 0x0500(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _NotReadySoundCooltime;                            // 0x0508(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_211C[0xC];                                     // 0x050C(0x000C)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class UHUD_CooldownBaseSlot*>          _SlotList;                                         // 0x0518(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_211D[0x20];                                    // 0x0528(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnSlotNotReady();
	void OnSlotReady();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUD_CooldownBaseSlotPanel">();
	}
	static class UHUD_CooldownBaseSlotPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUD_CooldownBaseSlotPanel>();
	}
};
static_assert(alignof(UHUD_CooldownBaseSlotPanel) == 0x000008, "Wrong alignment on UHUD_CooldownBaseSlotPanel");
static_assert(sizeof(UHUD_CooldownBaseSlotPanel) == 0x000548, "Wrong size on UHUD_CooldownBaseSlotPanel");
static_assert(offsetof(UHUD_CooldownBaseSlotPanel, SlotPanel) == 0x0004F0, "Member 'UHUD_CooldownBaseSlotPanel::SlotPanel' has a wrong offset!");
static_assert(offsetof(UHUD_CooldownBaseSlotPanel, NotReadySound) == 0x0004F8, "Member 'UHUD_CooldownBaseSlotPanel::NotReadySound' has a wrong offset!");
static_assert(offsetof(UHUD_CooldownBaseSlotPanel, ReadySound) == 0x000500, "Member 'UHUD_CooldownBaseSlotPanel::ReadySound' has a wrong offset!");
static_assert(offsetof(UHUD_CooldownBaseSlotPanel, _NotReadySoundCooltime) == 0x000508, "Member 'UHUD_CooldownBaseSlotPanel::_NotReadySoundCooltime' has a wrong offset!");
static_assert(offsetof(UHUD_CooldownBaseSlotPanel, _SlotList) == 0x000518, "Member 'UHUD_CooldownBaseSlotPanel::_SlotList' has a wrong offset!");

// Class Stigma.UI_Option_DescBase
// 0x0000 (0x04F0 - 0x04F0)
class UUI_Option_DescBase : public UPreviewableWidget
{
public:
	void InitByEntry(const struct FOptionDescEntry& _entry);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Option_DescBase">();
	}
	static class UUI_Option_DescBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Option_DescBase>();
	}
};
static_assert(alignof(UUI_Option_DescBase) == 0x000008, "Wrong alignment on UUI_Option_DescBase");
static_assert(sizeof(UUI_Option_DescBase) == 0x0004F0, "Wrong size on UUI_Option_DescBase");

// Class Stigma.UI_ModeSelectPopupBase
// 0x0028 (0x0598 - 0x0570)
class UUI_ModeSelectPopupBase final : public UPopupBase
{
public:
	class UCtrl_CommonButtonBase*                 BTN_JoinCustom;                                    // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_CommonButtonBase*                 BTN_CreateCustom;                                  // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDLG_JoinCustomGameBase>    _JoinCustomGameWidgetClass;                        // 0x0580(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 _CurProcBattleIDs;                                 // 0x0588(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool DoStartCustomGame(const class FString& _battle_ids);
	struct FNetReply OnAck_DeleteParty(EResultCode _rcode, const struct FACK_PartyDelete& _ack);
	struct FNetReply OnAck_StartMatchMaking(EResultCode _rcode, const struct FACK_FindMatch& _ack);
	void OnCustomCreateBtnClick();
	void OnCustomJoinBtnClick();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_ModeSelectPopupBase">();
	}
	static class UUI_ModeSelectPopupBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_ModeSelectPopupBase>();
	}
};
static_assert(alignof(UUI_ModeSelectPopupBase) == 0x000008, "Wrong alignment on UUI_ModeSelectPopupBase");
static_assert(sizeof(UUI_ModeSelectPopupBase) == 0x000598, "Wrong size on UUI_ModeSelectPopupBase");
static_assert(offsetof(UUI_ModeSelectPopupBase, BTN_JoinCustom) == 0x000570, "Member 'UUI_ModeSelectPopupBase::BTN_JoinCustom' has a wrong offset!");
static_assert(offsetof(UUI_ModeSelectPopupBase, BTN_CreateCustom) == 0x000578, "Member 'UUI_ModeSelectPopupBase::BTN_CreateCustom' has a wrong offset!");
static_assert(offsetof(UUI_ModeSelectPopupBase, _JoinCustomGameWidgetClass) == 0x000580, "Member 'UUI_ModeSelectPopupBase::_JoinCustomGameWidgetClass' has a wrong offset!");
static_assert(offsetof(UUI_ModeSelectPopupBase, _CurProcBattleIDs) == 0x000588, "Member 'UUI_ModeSelectPopupBase::_CurProcBattleIDs' has a wrong offset!");

// Class Stigma.Annihilation_PlayerState
// 0x0000 (0x0C88 - 0x0C88)
class AAnnihilation_PlayerState : public ABattlePlayerState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Annihilation_PlayerState">();
	}
	static class AAnnihilation_PlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAnnihilation_PlayerState>();
	}
};
static_assert(alignof(AAnnihilation_PlayerState) == 0x000008, "Wrong alignment on AAnnihilation_PlayerState");
static_assert(sizeof(AAnnihilation_PlayerState) == 0x000C88, "Wrong size on AAnnihilation_PlayerState");

// Class Stigma.MissionCondition_Damage
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_Damage final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_Damage">();
	}
	static class UMissionCondition_Damage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_Damage>();
	}
};
static_assert(alignof(UMissionCondition_Damage) == 0x000008, "Wrong alignment on UMissionCondition_Damage");
static_assert(sizeof(UMissionCondition_Damage) == 0x000068, "Wrong size on UMissionCondition_Damage");

// Class Stigma.ReviverBase
// 0x0068 (0x0300 - 0x0298)
class AReviverBase : public AActor
{
public:
	uint8                                         Pad_2121[0x10];                                    // 0x0298(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	struct FReviverConfig                         Config;                                            // 0x02A8(0x0030)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class ACharaBase*                             _DiedChara;                                        // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharaBase*                             _AttachedChara;                                    // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _ReviveRemainTime_Integer;                         // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _ReviveRemainTime;                                 // 0x02EC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          _Box;                                              // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsFirstOnAttachment;                              // 0x02F8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2122[0x7];                                     // 0x02F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnAttachmentEvent();
	void OnRep_DiedChara();

	class AActor* GetAttachParent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReviverBase">();
	}
	static class AReviverBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReviverBase>();
	}
};
static_assert(alignof(AReviverBase) == 0x000008, "Wrong alignment on AReviverBase");
static_assert(sizeof(AReviverBase) == 0x000300, "Wrong size on AReviverBase");
static_assert(offsetof(AReviverBase, Config) == 0x0002A8, "Member 'AReviverBase::Config' has a wrong offset!");
static_assert(offsetof(AReviverBase, _DiedChara) == 0x0002D8, "Member 'AReviverBase::_DiedChara' has a wrong offset!");
static_assert(offsetof(AReviverBase, _AttachedChara) == 0x0002E0, "Member 'AReviverBase::_AttachedChara' has a wrong offset!");
static_assert(offsetof(AReviverBase, _ReviveRemainTime_Integer) == 0x0002E8, "Member 'AReviverBase::_ReviveRemainTime_Integer' has a wrong offset!");
static_assert(offsetof(AReviverBase, _ReviveRemainTime) == 0x0002EC, "Member 'AReviverBase::_ReviveRemainTime' has a wrong offset!");
static_assert(offsetof(AReviverBase, _Box) == 0x0002F0, "Member 'AReviverBase::_Box' has a wrong offset!");
static_assert(offsetof(AReviverBase, _IsFirstOnAttachment) == 0x0002F8, "Member 'AReviverBase::_IsFirstOnAttachment' has a wrong offset!");

// Class Stigma.MissionCondition_HitRangeOver
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_HitRangeOver final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_HitRangeOver">();
	}
	static class UMissionCondition_HitRangeOver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_HitRangeOver>();
	}
};
static_assert(alignof(UMissionCondition_HitRangeOver) == 0x000008, "Wrong alignment on UMissionCondition_HitRangeOver");
static_assert(sizeof(UMissionCondition_HitRangeOver) == 0x000068, "Wrong size on UMissionCondition_HitRangeOver");

// Class Stigma.AutoBooster_AntiSlow
// 0x0000 (0x01B0 - 0x01B0)
class UAutoBooster_AntiSlow final : public UAutoBoosterTrigger
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoBooster_AntiSlow">();
	}
	static class UAutoBooster_AntiSlow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutoBooster_AntiSlow>();
	}
};
static_assert(alignof(UAutoBooster_AntiSlow) == 0x000008, "Wrong alignment on UAutoBooster_AntiSlow");
static_assert(sizeof(UAutoBooster_AntiSlow) == 0x0001B0, "Wrong size on UAutoBooster_AntiSlow");

// Class Stigma.PlayNiagaraFPS
// 0x0098 (0x00D0 - 0x0038)
class alignas(0x10) UPlayNiagaraFPS final : public UAnimNotify
{
public:
	class UNiagaraSystem*                         Template;                                          // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0040(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0070(0x0018)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbsoluteScale;                                    // 0x0088(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2123[0x7];                                     // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UFXSystemComponent*                     SpawnedEffect;                                     // 0x0090(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2124[0x28];                                    // 0x0098(0x0028)(Fixing Size After Last Property [ Dumper-69 ])
	uint8                                         Attached : 1;                                      // 0x00C0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_2125[0x3];                                     // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class FName                                   SocketName;                                        // 0x00C4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2126[0x4];                                     // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	class UFXSystemComponent* GetSpawnedEffect() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayNiagaraFPS">();
	}
	static class UPlayNiagaraFPS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayNiagaraFPS>();
	}
};
static_assert(alignof(UPlayNiagaraFPS) == 0x000010, "Wrong alignment on UPlayNiagaraFPS");
static_assert(sizeof(UPlayNiagaraFPS) == 0x0000D0, "Wrong size on UPlayNiagaraFPS");
static_assert(offsetof(UPlayNiagaraFPS, Template) == 0x000038, "Member 'UPlayNiagaraFPS::Template' has a wrong offset!");
static_assert(offsetof(UPlayNiagaraFPS, LocationOffset) == 0x000040, "Member 'UPlayNiagaraFPS::LocationOffset' has a wrong offset!");
static_assert(offsetof(UPlayNiagaraFPS, RotationOffset) == 0x000058, "Member 'UPlayNiagaraFPS::RotationOffset' has a wrong offset!");
static_assert(offsetof(UPlayNiagaraFPS, Scale) == 0x000070, "Member 'UPlayNiagaraFPS::Scale' has a wrong offset!");
static_assert(offsetof(UPlayNiagaraFPS, bAbsoluteScale) == 0x000088, "Member 'UPlayNiagaraFPS::bAbsoluteScale' has a wrong offset!");
static_assert(offsetof(UPlayNiagaraFPS, SpawnedEffect) == 0x000090, "Member 'UPlayNiagaraFPS::SpawnedEffect' has a wrong offset!");
static_assert(offsetof(UPlayNiagaraFPS, SocketName) == 0x0000C4, "Member 'UPlayNiagaraFPS::SocketName' has a wrong offset!");

// Class Stigma.AutoBooster_Shooter
// 0x0000 (0x01B0 - 0x01B0)
class UAutoBooster_Shooter final : public UAutoBoosterTrigger
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AutoBooster_Shooter">();
	}
	static class UAutoBooster_Shooter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAutoBooster_Shooter>();
	}
};
static_assert(alignof(UAutoBooster_Shooter) == 0x000008, "Wrong alignment on UAutoBooster_Shooter");
static_assert(sizeof(UAutoBooster_Shooter) == 0x0001B0, "Wrong size on UAutoBooster_Shooter");

// Class Stigma.BarrierBase
// 0x0048 (0x02E0 - 0x0298)
class ABarrierBase final : public AActor
{
public:
	class USceneComponent*                        _RootComp;                                         // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   _BaseMesh;                                         // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          _Collsion;                                         // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeams                                        _Team;                                             // 0x02B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBarrierState                                 _BarrierState;                                     // 0x02B1(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2127[0x6];                                     // 0x02B2(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class UStaticMeshComponent*>           _MeshComps;                                        // 0x02B8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         _FadeInOutTime;                                    // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2128[0x14];                                    // 0x02CC(0x0014)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnRep_BarrierState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BarrierBase">();
	}
	static class ABarrierBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABarrierBase>();
	}
};
static_assert(alignof(ABarrierBase) == 0x000008, "Wrong alignment on ABarrierBase");
static_assert(sizeof(ABarrierBase) == 0x0002E0, "Wrong size on ABarrierBase");
static_assert(offsetof(ABarrierBase, _RootComp) == 0x000298, "Member 'ABarrierBase::_RootComp' has a wrong offset!");
static_assert(offsetof(ABarrierBase, _BaseMesh) == 0x0002A0, "Member 'ABarrierBase::_BaseMesh' has a wrong offset!");
static_assert(offsetof(ABarrierBase, _Collsion) == 0x0002A8, "Member 'ABarrierBase::_Collsion' has a wrong offset!");
static_assert(offsetof(ABarrierBase, _Team) == 0x0002B0, "Member 'ABarrierBase::_Team' has a wrong offset!");
static_assert(offsetof(ABarrierBase, _BarrierState) == 0x0002B1, "Member 'ABarrierBase::_BarrierState' has a wrong offset!");
static_assert(offsetof(ABarrierBase, _MeshComps) == 0x0002B8, "Member 'ABarrierBase::_MeshComps' has a wrong offset!");
static_assert(offsetof(ABarrierBase, _FadeInOutTime) == 0x0002C8, "Member 'ABarrierBase::_FadeInOutTime' has a wrong offset!");

// Class Stigma.ConnectionBase
// 0x0000 (0x0028 - 0x0028)
class UConnectionBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConnectionBase">();
	}
	static class UConnectionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConnectionBase>();
	}
};
static_assert(alignof(UConnectionBase) == 0x000008, "Wrong alignment on UConnectionBase");
static_assert(sizeof(UConnectionBase) == 0x000028, "Wrong size on UConnectionBase");

// Class Stigma.ServiceConnection
// 0x01E8 (0x0210 - 0x0028)
class UServiceConnection final : public UConnectionBase
{
public:
	uint8                                         Pad_2129[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UPopup_EnterAccount>        _EnterAccountUIClass;                              // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPopup_EnterNickname>       _EnterNicknameUIClass;                             // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPopup_EnterAccount*                    _Popup_EnterAccount;                               // 0x0040(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPopup_EnterNickname*                   _Popup_EnterNickname;                              // 0x0048(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_212A[0xC8];                                    // 0x0050(0x00C8)(Fixing Size After Last Property [ Dumper-69 ])
	class UWebSocketClient*                       _SocketClient;                                     // 0x0118(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_212B[0x90];                                    // 0x0120(0x0090)(Fixing Size After Last Property [ Dumper-69 ])
	class UEndPointScanner*                       _RegionScanner;                                    // 0x01B0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_212C[0x58];                                    // 0x01B8(0x0058)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServiceConnection">();
	}
	static class UServiceConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServiceConnection>();
	}
};
static_assert(alignof(UServiceConnection) == 0x000008, "Wrong alignment on UServiceConnection");
static_assert(sizeof(UServiceConnection) == 0x000210, "Wrong size on UServiceConnection");
static_assert(offsetof(UServiceConnection, _EnterAccountUIClass) == 0x000030, "Member 'UServiceConnection::_EnterAccountUIClass' has a wrong offset!");
static_assert(offsetof(UServiceConnection, _EnterNicknameUIClass) == 0x000038, "Member 'UServiceConnection::_EnterNicknameUIClass' has a wrong offset!");
static_assert(offsetof(UServiceConnection, _Popup_EnterAccount) == 0x000040, "Member 'UServiceConnection::_Popup_EnterAccount' has a wrong offset!");
static_assert(offsetof(UServiceConnection, _Popup_EnterNickname) == 0x000048, "Member 'UServiceConnection::_Popup_EnterNickname' has a wrong offset!");
static_assert(offsetof(UServiceConnection, _SocketClient) == 0x000118, "Member 'UServiceConnection::_SocketClient' has a wrong offset!");
static_assert(offsetof(UServiceConnection, _RegionScanner) == 0x0001B0, "Member 'UServiceConnection::_RegionScanner' has a wrong offset!");

// Class Stigma.BattlePassHelper
// 0x0000 (0x0028 - 0x0028)
class UBattlePassHelper final : public UBlueprintFunctionLibrary
{
public:
	static bool CalcBattlePassResult(const class UObject* _world_ctx, const struct FItemID_BattlePass& _pass_id, int32 _added_pass_exp, int32* _out_cur_level, int32* _out_level_exp, int32* _out_added_level_exp, bool* _out_is_max_level);
	static bool GetActivedBattlePassInfo(const class UObject* _world_ctx, struct FBattlePassInfo* _out_info);
	static TArray<struct FItemID_BattlePass> GetAllBattlePassIDs(const class UObject* _world_ctx);
	static int32 GetBattlePassCurrentWeek(const struct FItemID_BattlePass& _pass_id);
	static bool GetBattlePassInfo(const class UObject* _world_ctx, const struct FItemID_BattlePass& _pass_id, struct FBattlePassInfo* _out_info);
	static bool GetBattlePassLevelConfig(const struct FItemID_BattlePass& _pass_id, int32 _level, struct FBattlePassLevelConfig* _out_config);
	static int32 GetBattlePassMaxLevel(const struct FItemID_BattlePass& _pass_id);
	static bool GetBattlePassMissionConfig(const struct FItemID_BattlePass& _pass_id, int32 _week, struct FBattlePassMissionConfig* _out_config);
	static TArray<struct FItemID_BattlePass> GetNoMissionBattlePassIDs(const class UObject* _world_ctx);
	static bool IsActivedBattlePass(const class UObject* _world_ctx, const struct FItemID_BattlePass& _pass_id);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattlePassHelper">();
	}
	static class UBattlePassHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattlePassHelper>();
	}
};
static_assert(alignof(UBattlePassHelper) == 0x000008, "Wrong alignment on UBattlePassHelper");
static_assert(sizeof(UBattlePassHelper) == 0x000028, "Wrong size on UBattlePassHelper");

// Class Stigma.BattleStoreBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UBattleStoreBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TArray<struct FGunEntry_Main> SortGunListItems(const class UObject* _world_ctx, const TArray<struct FGunEntry_Main>& _entries);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattleStoreBlueprintLibrary">();
	}
	static class UBattleStoreBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattleStoreBlueprintLibrary>();
	}
};
static_assert(alignof(UBattleStoreBlueprintLibrary) == 0x000008, "Wrong alignment on UBattleStoreBlueprintLibrary");
static_assert(sizeof(UBattleStoreBlueprintLibrary) == 0x000028, "Wrong size on UBattleStoreBlueprintLibrary");

// Class Stigma.UI_ShopGridFilter
// 0x0040 (0x0530 - 0x04F0)
class UUI_ShopGridFilter : public UPreviewableWidget
{
public:
	class UUniformGridPanel*                      GridPanel;                                         // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_ShopGridFilterButton*               Btn_All;                                           // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_ShopGridFilterButton>   FilterButtonClass;                                 // 0x0500(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _MaxColumnCount;                                   // 0x0508(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2137[0x4];                                     // 0x050C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class UUI_ShopGridFilterButton*>       _ButtonList;                                       // 0x0510(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2138[0x10];                                    // 0x0520(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_ShopGridFilter">();
	}
	static class UUI_ShopGridFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_ShopGridFilter>();
	}
};
static_assert(alignof(UUI_ShopGridFilter) == 0x000008, "Wrong alignment on UUI_ShopGridFilter");
static_assert(sizeof(UUI_ShopGridFilter) == 0x000530, "Wrong size on UUI_ShopGridFilter");
static_assert(offsetof(UUI_ShopGridFilter, GridPanel) == 0x0004F0, "Member 'UUI_ShopGridFilter::GridPanel' has a wrong offset!");
static_assert(offsetof(UUI_ShopGridFilter, Btn_All) == 0x0004F8, "Member 'UUI_ShopGridFilter::Btn_All' has a wrong offset!");
static_assert(offsetof(UUI_ShopGridFilter, FilterButtonClass) == 0x000500, "Member 'UUI_ShopGridFilter::FilterButtonClass' has a wrong offset!");
static_assert(offsetof(UUI_ShopGridFilter, _MaxColumnCount) == 0x000508, "Member 'UUI_ShopGridFilter::_MaxColumnCount' has a wrong offset!");
static_assert(offsetof(UUI_ShopGridFilter, _ButtonList) == 0x000510, "Member 'UUI_ShopGridFilter::_ButtonList' has a wrong offset!");

// Class Stigma.UI_ShopGunFilter
// 0x0010 (0x0540 - 0x0530)
class UUI_ShopGunFilter : public UUI_ShopGridFilter
{
public:
	uint8                                         Pad_2139[0x10];                                    // 0x0530(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnSelectedGunFilter(int32 _idx);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_ShopGunFilter">();
	}
	static class UUI_ShopGunFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_ShopGunFilter>();
	}
};
static_assert(alignof(UUI_ShopGunFilter) == 0x000008, "Wrong alignment on UUI_ShopGunFilter");
static_assert(sizeof(UUI_ShopGunFilter) == 0x000540, "Wrong size on UUI_ShopGunFilter");

// Class Stigma.BountyTDM_GameMode
// 0x00A0 (0x0878 - 0x07D8)
class ABountyTDM_GameMode : public ABattleGameModeBase
{
public:
	uint8                                         Pad_213A[0x20];                                    // 0x07D8(0x0020)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class AGoldBox*>                       _GoldBoxList;                                      // 0x07F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class AGoldBox*>                       _RandomBoxList;                                    // 0x0808(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class ASafeBase*>                      _SafeList;                                         // 0x0818(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_213B[0x50];                                    // 0x0828(0x0050)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BountyTDM_GameMode">();
	}
	static class ABountyTDM_GameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABountyTDM_GameMode>();
	}
};
static_assert(alignof(ABountyTDM_GameMode) == 0x000008, "Wrong alignment on ABountyTDM_GameMode");
static_assert(sizeof(ABountyTDM_GameMode) == 0x000878, "Wrong size on ABountyTDM_GameMode");
static_assert(offsetof(ABountyTDM_GameMode, _GoldBoxList) == 0x0007F8, "Member 'ABountyTDM_GameMode::_GoldBoxList' has a wrong offset!");
static_assert(offsetof(ABountyTDM_GameMode, _RandomBoxList) == 0x000808, "Member 'ABountyTDM_GameMode::_RandomBoxList' has a wrong offset!");
static_assert(offsetof(ABountyTDM_GameMode, _SafeList) == 0x000818, "Member 'ABountyTDM_GameMode::_SafeList' has a wrong offset!");

// Class Stigma.MissionCondition_RoundCount
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_RoundCount final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_RoundCount">();
	}
	static class UMissionCondition_RoundCount* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_RoundCount>();
	}
};
static_assert(alignof(UMissionCondition_RoundCount) == 0x000008, "Wrong alignment on UMissionCondition_RoundCount");
static_assert(sizeof(UMissionCondition_RoundCount) == 0x000068, "Wrong size on UMissionCondition_RoundCount");

// Class Stigma.BountyTDM_PlayerController
// 0x0058 (0x0E98 - 0x0E40)
class ABountyTDM_PlayerController : public ABattlePlayerControllerBase
{
public:
	class USoundBase*                             _HackSuccessSFX;                                   // 0x0E40(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class ACharaBase*>                       _IndicatedTransfers;                               // 0x0E48(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	void RPC_ALL_Bounty_Hacking(class ACharaBase* _hacker, class ASafeBase* _target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BountyTDM_PlayerController">();
	}
	static class ABountyTDM_PlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABountyTDM_PlayerController>();
	}
};
static_assert(alignof(ABountyTDM_PlayerController) == 0x000008, "Wrong alignment on ABountyTDM_PlayerController");
static_assert(sizeof(ABountyTDM_PlayerController) == 0x000E98, "Wrong size on ABountyTDM_PlayerController");
static_assert(offsetof(ABountyTDM_PlayerController, _HackSuccessSFX) == 0x000E40, "Member 'ABountyTDM_PlayerController::_HackSuccessSFX' has a wrong offset!");
static_assert(offsetof(ABountyTDM_PlayerController, _IndicatedTransfers) == 0x000E48, "Member 'ABountyTDM_PlayerController::_IndicatedTransfers' has a wrong offset!");

// Class Stigma.BreakStepComponent
// 0x0010 (0x02B0 - 0x02A0)
class UBreakStepComponent final : public USceneComponent
{
public:
	float                                         HP;                                                // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_213C[0xC];                                     // 0x02A4(0x000C)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BreakStepComponent">();
	}
	static class UBreakStepComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBreakStepComponent>();
	}
};
static_assert(alignof(UBreakStepComponent) == 0x000010, "Wrong alignment on UBreakStepComponent");
static_assert(sizeof(UBreakStepComponent) == 0x0002B0, "Wrong size on UBreakStepComponent");
static_assert(offsetof(UBreakStepComponent, HP) == 0x0002A0, "Member 'UBreakStepComponent::HP' has a wrong offset!");

// Class Stigma.BriefUser
// 0x0000 (0x0028 - 0x0028)
class UBriefUser : public UObject
{
public:
	ECharaType GetCharaType() const;
	struct FItemID GetEmblem() const;
	int32 GetLevel() const;
	const struct FUserName GetNickname() const;
	struct FItemID GetNicknameFX() const;
	EUserPlayingAt GetPlayingAt() const;
	struct FItemID GetProfileCard() const;
	ETier GetTier() const;
	struct FUserID GetUserID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BriefUser">();
	}
	static class UBriefUser* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBriefUser>();
	}
};
static_assert(alignof(UBriefUser) == 0x000008, "Wrong alignment on UBriefUser");
static_assert(sizeof(UBriefUser) == 0x000028, "Wrong size on UBriefUser");

// Class Stigma.CustomGameSlotBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UCustomGameSlotBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool IsEmptySlot(const struct FCustomGameSlot& _slot);
	static bool IsValid(const struct FCustomGameSlotIndex& _index);
	static class FString ToString(const struct FCustomGameSlotIndex& _index);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomGameSlotBlueprintLibrary">();
	}
	static class UCustomGameSlotBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomGameSlotBlueprintLibrary>();
	}
};
static_assert(alignof(UCustomGameSlotBlueprintLibrary) == 0x000008, "Wrong alignment on UCustomGameSlotBlueprintLibrary");
static_assert(sizeof(UCustomGameSlotBlueprintLibrary) == 0x000028, "Wrong size on UCustomGameSlotBlueprintLibrary");

// Class Stigma.UI_TabBase
// 0x0018 (0x0508 - 0x04F0)
class UUI_TabBase : public UPreviewableWidget
{
public:
	class UImage*                                 IMG_FlashBang;                                     // 0x04F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMinimap*                               _Minimap;                                          // 0x04F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_213F[0x8];                                     // 0x0500(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool OnChangeActionSetting();
	bool OnDiscoverEnemy(class ACharaBase* _enemy, bool _discovered);
	bool OnShow(bool _show);
	void Show(bool _show);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_TabBase">();
	}
	static class UUI_TabBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_TabBase>();
	}
};
static_assert(alignof(UUI_TabBase) == 0x000008, "Wrong alignment on UUI_TabBase");
static_assert(sizeof(UUI_TabBase) == 0x000508, "Wrong size on UUI_TabBase");
static_assert(offsetof(UUI_TabBase, IMG_FlashBang) == 0x0004F0, "Member 'UUI_TabBase::IMG_FlashBang' has a wrong offset!");
static_assert(offsetof(UUI_TabBase, _Minimap) == 0x0004F8, "Member 'UUI_TabBase::_Minimap' has a wrong offset!");

// Class Stigma.BTScore_ChaseEnemy
// 0x0000 (0x0030 - 0x0030)
class UBTScore_ChaseEnemy final : public UBTScore
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTScore_ChaseEnemy">();
	}
	static class UBTScore_ChaseEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTScore_ChaseEnemy>();
	}
};
static_assert(alignof(UBTScore_ChaseEnemy) == 0x000008, "Wrong alignment on UBTScore_ChaseEnemy");
static_assert(sizeof(UBTScore_ChaseEnemy) == 0x000030, "Wrong size on UBTScore_ChaseEnemy");

// Class Stigma.FovStaticMeshComponent
// 0x0000 (0x0630 - 0x0630)
class UFovStaticMeshComponent final : public UStaticMeshComponent
{
public:
	float                                         _DesiredFov;                                       // 0x0628(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _EnableFov;                                        // 0x062C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2141[0x3];                                     // 0x062D(0x0003)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	struct FMatrix Get1PVMatrix(const struct FMatrix& ModelMatrix) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FovStaticMeshComponent">();
	}
	static class UFovStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFovStaticMeshComponent>();
	}
};
static_assert(alignof(UFovStaticMeshComponent) == 0x000010, "Wrong alignment on UFovStaticMeshComponent");
static_assert(sizeof(UFovStaticMeshComponent) == 0x000630, "Wrong size on UFovStaticMeshComponent");
static_assert(offsetof(UFovStaticMeshComponent, _DesiredFov) == 0x000628, "Member 'UFovStaticMeshComponent::_DesiredFov' has a wrong offset!");
static_assert(offsetof(UFovStaticMeshComponent, _EnableFov) == 0x00062C, "Member 'UFovStaticMeshComponent::_EnableFov' has a wrong offset!");

// Class Stigma.NPC_ActionDummy
// 0x0070 (0x38B0 - 0x3840)
class ANPC_ActionDummy final : public AAICharaBase
{
public:
	ECharaAction                                  _AutoAttackSkill;                                  // 0x3840(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2142[0x3];                                     // 0x3841(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         _AutoAttackInterval;                               // 0x3844(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<class ACharaBase*>                       _Targets;                                          // 0x3848(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class ACharaBase*                             _CurTarget;                                        // 0x3898(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2143[0x10];                                    // 0x38A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void AddTarget(class ACharaBase* _target);
	void RemoveTarget(class ACharaBase* _target);
	void SetAutoRepeatAttack(bool _on);

	bool IsAutoRepeatingAttack() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPC_ActionDummy">();
	}
	static class ANPC_ActionDummy* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANPC_ActionDummy>();
	}
};
static_assert(alignof(ANPC_ActionDummy) == 0x000010, "Wrong alignment on ANPC_ActionDummy");
static_assert(sizeof(ANPC_ActionDummy) == 0x0038B0, "Wrong size on ANPC_ActionDummy");
static_assert(offsetof(ANPC_ActionDummy, _AutoAttackSkill) == 0x003840, "Member 'ANPC_ActionDummy::_AutoAttackSkill' has a wrong offset!");
static_assert(offsetof(ANPC_ActionDummy, _AutoAttackInterval) == 0x003844, "Member 'ANPC_ActionDummy::_AutoAttackInterval' has a wrong offset!");
static_assert(offsetof(ANPC_ActionDummy, _Targets) == 0x003848, "Member 'ANPC_ActionDummy::_Targets' has a wrong offset!");
static_assert(offsetof(ANPC_ActionDummy, _CurTarget) == 0x003898, "Member 'ANPC_ActionDummy::_CurTarget' has a wrong offset!");

// Class Stigma.BTScore_CloseWithFire
// 0x0000 (0x0030 - 0x0030)
class UBTScore_CloseWithFire final : public UBTScore_FireBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTScore_CloseWithFire">();
	}
	static class UBTScore_CloseWithFire* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTScore_CloseWithFire>();
	}
};
static_assert(alignof(UBTScore_CloseWithFire) == 0x000008, "Wrong alignment on UBTScore_CloseWithFire");
static_assert(sizeof(UBTScore_CloseWithFire) == 0x000030, "Wrong size on UBTScore_CloseWithFire");

// Class Stigma.BTScore_CounterAttack
// 0x0000 (0x0030 - 0x0030)
class UBTScore_CounterAttack final : public UBTScore
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTScore_CounterAttack">();
	}
	static class UBTScore_CounterAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTScore_CounterAttack>();
	}
};
static_assert(alignof(UBTScore_CounterAttack) == 0x000008, "Wrong alignment on UBTScore_CounterAttack");
static_assert(sizeof(UBTScore_CounterAttack) == 0x000030, "Wrong size on UBTScore_CounterAttack");

// Class Stigma.BTScore_UseSkill
// 0x0010 (0x0040 - 0x0030)
class UBTScore_UseSkill final : public UBTScore
{
public:
	EActionUsage                                  Usage;                                             // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2144[0x3];                                     // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         DumbScaler;                                        // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2145[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTScore_UseSkill">();
	}
	static class UBTScore_UseSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTScore_UseSkill>();
	}
};
static_assert(alignof(UBTScore_UseSkill) == 0x000008, "Wrong alignment on UBTScore_UseSkill");
static_assert(sizeof(UBTScore_UseSkill) == 0x000040, "Wrong size on UBTScore_UseSkill");
static_assert(offsetof(UBTScore_UseSkill, Usage) == 0x000030, "Member 'UBTScore_UseSkill::Usage' has a wrong offset!");
static_assert(offsetof(UBTScore_UseSkill, DumbScaler) == 0x000034, "Member 'UBTScore_UseSkill::DumbScaler' has a wrong offset!");

// Class Stigma.UI_Survey
// 0x01A0 (0x0710 - 0x0570)
class UUI_Survey : public UPopupBase
{
public:
	class FName                                   _SurveyName;                                       // 0x0570(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSurveyDefine                          _Survey;                                           // 0x0578(0x0178)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	class UCtrl_QuestionBase*                     _CurrentQuestionUI;                                // 0x06F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2146[0x18];                                    // 0x06F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool OnAnswerQuestion(const struct FSurveyQuestion& _question, const struct FSurveyAnswer& _answer);
	bool OnShowQuestion(ESurveyUIPhase _phase, const struct FSurveyQuestion& _question);
	void SummitAnswer();

	ESurveyUIPhase GetCurrentPhase() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Survey">();
	}
	static class UUI_Survey* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Survey>();
	}
};
static_assert(alignof(UUI_Survey) == 0x000008, "Wrong alignment on UUI_Survey");
static_assert(sizeof(UUI_Survey) == 0x000710, "Wrong size on UUI_Survey");
static_assert(offsetof(UUI_Survey, _SurveyName) == 0x000570, "Member 'UUI_Survey::_SurveyName' has a wrong offset!");
static_assert(offsetof(UUI_Survey, _Survey) == 0x000578, "Member 'UUI_Survey::_Survey' has a wrong offset!");
static_assert(offsetof(UUI_Survey, _CurrentQuestionUI) == 0x0006F0, "Member 'UUI_Survey::_CurrentQuestionUI' has a wrong offset!");

// Class Stigma.BTScore_Dodge
// 0x0000 (0x0030 - 0x0030)
class UBTScore_Dodge final : public UBTScore
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTScore_Dodge">();
	}
	static class UBTScore_Dodge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTScore_Dodge>();
	}
};
static_assert(alignof(UBTScore_Dodge) == 0x000008, "Wrong alignment on UBTScore_Dodge");
static_assert(sizeof(UBTScore_Dodge) == 0x000030, "Wrong size on UBTScore_Dodge");

// Class Stigma.BTScore_SeizeFire
// 0x0008 (0x0038 - 0x0030)
class UBTScore_SeizeFire final : public UBTScore_FireBase
{
public:
	float                                         DistanceToUse;                                     // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_214A[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTScore_SeizeFire">();
	}
	static class UBTScore_SeizeFire* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTScore_SeizeFire>();
	}
};
static_assert(alignof(UBTScore_SeizeFire) == 0x000008, "Wrong alignment on UBTScore_SeizeFire");
static_assert(sizeof(UBTScore_SeizeFire) == 0x000038, "Wrong size on UBTScore_SeizeFire");
static_assert(offsetof(UBTScore_SeizeFire, DistanceToUse) == 0x000030, "Member 'UBTScore_SeizeFire::DistanceToUse' has a wrong offset!");

// Class Stigma.BTService_ClearBB
// 0x0020 (0x0090 - 0x0070)
class UBTService_ClearBB final : public UBTService
{
public:
	TArray<struct FBlackboardKeySelector>         ClearListForEntering;                              // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBlackboardKeySelector>         ClearListForLeaving;                               // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_ClearBB">();
	}
	static class UBTService_ClearBB* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_ClearBB>();
	}
};
static_assert(alignof(UBTService_ClearBB) == 0x000008, "Wrong alignment on UBTService_ClearBB");
static_assert(sizeof(UBTService_ClearBB) == 0x000090, "Wrong size on UBTService_ClearBB");
static_assert(offsetof(UBTService_ClearBB, ClearListForEntering) == 0x000070, "Member 'UBTService_ClearBB::ClearListForEntering' has a wrong offset!");
static_assert(offsetof(UBTService_ClearBB, ClearListForLeaving) == 0x000080, "Member 'UBTService_ClearBB::ClearListForLeaving' has a wrong offset!");

// Class Stigma.MissionCondition_Mode
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_Mode final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_Mode">();
	}
	static class UMissionCondition_Mode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_Mode>();
	}
};
static_assert(alignof(UMissionCondition_Mode) == 0x000008, "Wrong alignment on UMissionCondition_Mode");
static_assert(sizeof(UMissionCondition_Mode) == 0x000068, "Wrong size on UMissionCondition_Mode");

// Class Stigma.MissionCondition_ChangeGunSticker
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_ChangeGunSticker final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_ChangeGunSticker">();
	}
	static class UMissionCondition_ChangeGunSticker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_ChangeGunSticker>();
	}
};
static_assert(alignof(UMissionCondition_ChangeGunSticker) == 0x000008, "Wrong alignment on UMissionCondition_ChangeGunSticker");
static_assert(sizeof(UMissionCondition_ChangeGunSticker) == 0x000068, "Wrong size on UMissionCondition_ChangeGunSticker");

// Class Stigma.BTService_KTA_Strategy
// 0x0000 (0x0070 - 0x0070)
class UBTService_KTA_Strategy final : public UBTService
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTService_KTA_Strategy">();
	}
	static class UBTService_KTA_Strategy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTService_KTA_Strategy>();
	}
};
static_assert(alignof(UBTService_KTA_Strategy) == 0x000008, "Wrong alignment on UBTService_KTA_Strategy");
static_assert(sizeof(UBTService_KTA_Strategy) == 0x000070, "Wrong size on UBTService_KTA_Strategy");

// Class Stigma.ShopHelper
// 0x0000 (0x0028 - 0x0028)
class UShopHelper final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class UGoodsObject*> FilterGoodsObjects(const class UObject* _world_ctx, const TArray<class UGoodsObject*>& _goods_objects, const struct FGoodsFilterInfo& _filter);
	static TArray<class UGoodsObject*> FilterGoodsPeriod(const class UObject* _world_ctx, const TArray<class UGoodsObject*>& _goods_objects);
	static EGoodsOwningInfo GetGoodsOwningInfo(const class UObject* _world_ctx, const struct FConfig_Goods& _goods_define);
	static TArray<EItemUITag> GetUITags(const struct FGoodsTag& _goods_tag);
	static bool HasAnyGoodsTag(const struct FGoodsTag& _goods_tag);
	static bool IsBundleGoods(class UGoodsObject* _goods);
	static bool IsPurchasableCurrency(const ECurrencyTypes _currency_type);
	static bool IsPurchasableFromLevelCondition(const class UObject* _world_ctx, const struct FConfig_Goods& _goods_define);
	static class UInvenItem* MakeCurrencyItem(const struct FItemIDRef& _currency_id, int32 _currency_value);
	static class UInvenItem* MakeInvenItemFromRewardItem(const struct FRewardItem& _reward_item);
	static void ShowCantPurchasableMessageBox(const class UObject* _world_ctx, const struct FItemID_Currency& _currency_id, bool _ask_quick_purchase);
	static void ShowPurchaseFailureToastMessage(const class UObject* _world_ctx, const struct FItemID_Currency& _currency_id);
	static TArray<class UGoodsObject*> SortGoodsObjects(const class UObject* _world_ctx, TArray<class UGoodsObject*>* _goods_list, EShopSortType _sort_type, bool _is_ascending);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShopHelper">();
	}
	static class UShopHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShopHelper>();
	}
};
static_assert(alignof(UShopHelper) == 0x000008, "Wrong alignment on UShopHelper");
static_assert(sizeof(UShopHelper) == 0x000028, "Wrong size on UShopHelper");

// Class Stigma.BTTask_CustomWaitTime
// 0x0000 (0x0098 - 0x0098)
class UBTTask_CustomWaitTime final : public UBTTask_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_CustomWaitTime">();
	}
	static class UBTTask_CustomWaitTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_CustomWaitTime>();
	}
};
static_assert(alignof(UBTTask_CustomWaitTime) == 0x000008, "Wrong alignment on UBTTask_CustomWaitTime");
static_assert(sizeof(UBTTask_CustomWaitTime) == 0x000098, "Wrong size on UBTTask_CustomWaitTime");

// Class Stigma.BTTask_Fight
// 0x0008 (0x0078 - 0x0070)
class UBTTask_Fight final : public UBTTaskNode
{
public:
	float                                         DecisionInterval;                                  // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2152[0x4];                                     // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_Fight">();
	}
	static class UBTTask_Fight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_Fight>();
	}
};
static_assert(alignof(UBTTask_Fight) == 0x000008, "Wrong alignment on UBTTask_Fight");
static_assert(sizeof(UBTTask_Fight) == 0x000078, "Wrong size on UBTTask_Fight");
static_assert(offsetof(UBTTask_Fight, DecisionInterval) == 0x000070, "Member 'UBTTask_Fight::DecisionInterval' has a wrong offset!");

// Class Stigma.BTTask_FindStrategicLocation
// 0x0038 (0x00A8 - 0x0070)
class UBTTask_FindStrategicLocation final : public UBTTaskNode
{
public:
	int32                                         HowOftenFindImportance;                            // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinDistance;                                       // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2153[0x4];                                     // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FBlackboardKeySelector                 SetTo;                                             // 0x0080(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_FindStrategicLocation">();
	}
	static class UBTTask_FindStrategicLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_FindStrategicLocation>();
	}
};
static_assert(alignof(UBTTask_FindStrategicLocation) == 0x000008, "Wrong alignment on UBTTask_FindStrategicLocation");
static_assert(sizeof(UBTTask_FindStrategicLocation) == 0x0000A8, "Wrong size on UBTTask_FindStrategicLocation");
static_assert(offsetof(UBTTask_FindStrategicLocation, HowOftenFindImportance) == 0x000070, "Member 'UBTTask_FindStrategicLocation::HowOftenFindImportance' has a wrong offset!");
static_assert(offsetof(UBTTask_FindStrategicLocation, MinDistance) == 0x000074, "Member 'UBTTask_FindStrategicLocation::MinDistance' has a wrong offset!");
static_assert(offsetof(UBTTask_FindStrategicLocation, MaxDistance) == 0x000078, "Member 'UBTTask_FindStrategicLocation::MaxDistance' has a wrong offset!");
static_assert(offsetof(UBTTask_FindStrategicLocation, SetTo) == 0x000080, "Member 'UBTTask_FindStrategicLocation::SetTo' has a wrong offset!");

// Class Stigma.MissionCondition_WeaponGroup
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_WeaponGroup final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_WeaponGroup">();
	}
	static class UMissionCondition_WeaponGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_WeaponGroup>();
	}
};
static_assert(alignof(UMissionCondition_WeaponGroup) == 0x000008, "Wrong alignment on UMissionCondition_WeaponGroup");
static_assert(sizeof(UMissionCondition_WeaponGroup) == 0x000068, "Wrong size on UMissionCondition_WeaponGroup");

// Class Stigma.LVData_GunPreset
// 0x0008 (0x0030 - 0x0028)
class ULVData_GunPreset final : public UObject
{
public:
	class UGunObject*                             _GunObject;                                        // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Config(class UGunObject* _gun_object);

	class UGunObject* GetGunObject() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LVData_GunPreset">();
	}
	static class ULVData_GunPreset* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULVData_GunPreset>();
	}
};
static_assert(alignof(ULVData_GunPreset) == 0x000008, "Wrong alignment on ULVData_GunPreset");
static_assert(sizeof(ULVData_GunPreset) == 0x000030, "Wrong size on ULVData_GunPreset");
static_assert(offsetof(ULVData_GunPreset, _GunObject) == 0x000028, "Member 'ULVData_GunPreset::_GunObject' has a wrong offset!");

// Class Stigma.BTTask_HoldFight
// 0x0008 (0x0078 - 0x0070)
class UBTTask_HoldFight final : public UBTTaskNode
{
public:
	uint8                                         Pad_2154[0x8];                                     // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_HoldFight">();
	}
	static class UBTTask_HoldFight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_HoldFight>();
	}
};
static_assert(alignof(UBTTask_HoldFight) == 0x000008, "Wrong alignment on UBTTask_HoldFight");
static_assert(sizeof(UBTTask_HoldFight) == 0x000078, "Wrong size on UBTTask_HoldFight");

// Class Stigma.ModeUtil
// 0x0000 (0x0028 - 0x0028)
class UModeUtil final : public UBlueprintFunctionLibrary
{
public:
	static bool IsSatisfied(const class UObject* _world_ctx, const struct FModeUnlockCondition& _condition);
	static class FText ToText(const class UObject* _world_ctx, const struct FModeUnlockCondition& _condition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ModeUtil">();
	}
	static class UModeUtil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModeUtil>();
	}
};
static_assert(alignof(UModeUtil) == 0x000008, "Wrong alignment on UModeUtil");
static_assert(sizeof(UModeUtil) == 0x000028, "Wrong size on UModeUtil");

// Class Stigma.BTTask_MoveToFight
// 0x0000 (0x00B0 - 0x00B0)
class UBTTask_MoveToFight final : public UBTTask_MoveTo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_MoveToFight">();
	}
	static class UBTTask_MoveToFight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_MoveToFight>();
	}
};
static_assert(alignof(UBTTask_MoveToFight) == 0x000008, "Wrong alignment on UBTTask_MoveToFight");
static_assert(sizeof(UBTTask_MoveToFight) == 0x0000B0, "Wrong size on UBTTask_MoveToFight");

// Class Stigma.BTTask_MoveWithFiring
// 0x0000 (0x00B0 - 0x00B0)
class UBTTask_MoveWithFiring final : public UBTTask_MoveTo
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_MoveWithFiring">();
	}
	static class UBTTask_MoveWithFiring* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_MoveWithFiring>();
	}
};
static_assert(alignof(UBTTask_MoveWithFiring) == 0x000008, "Wrong alignment on UBTTask_MoveWithFiring");
static_assert(sizeof(UBTTask_MoveWithFiring) == 0x0000B0, "Wrong size on UBTTask_MoveWithFiring");

// Class Stigma.PooledBullethole
// 0x0028 (0x02C0 - 0x0298)
class APooledBullethole final : public AActor
{
public:
	uint8                                         Pad_2156[0x28];                                    // 0x0298(0x0028)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Deactivate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PooledBullethole">();
	}
	static class APooledBullethole* GetDefaultObj()
	{
		return GetDefaultObjImpl<APooledBullethole>();
	}
};
static_assert(alignof(APooledBullethole) == 0x000008, "Wrong alignment on APooledBullethole");
static_assert(sizeof(APooledBullethole) == 0x0002C0, "Wrong size on APooledBullethole");

// Class Stigma.BTTask_PreemptLocation
// 0x0000 (0x0098 - 0x0098)
class UBTTask_PreemptLocation final : public UBTTask_BlackboardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_PreemptLocation">();
	}
	static class UBTTask_PreemptLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_PreemptLocation>();
	}
};
static_assert(alignof(UBTTask_PreemptLocation) == 0x000008, "Wrong alignment on UBTTask_PreemptLocation");
static_assert(sizeof(UBTTask_PreemptLocation) == 0x000098, "Wrong size on UBTTask_PreemptLocation");

// Class Stigma.Marker_Chara
// 0x0000 (0x0528 - 0x0528)
class UMarker_Chara : public UMinimapMarker
{
public:
	ECharaMarkerState DetermineState() const;
	struct FLinearColor GetMarkerColor() const;
	EPlayerSide GetSide() const;
	bool IsBountyTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Marker_Chara">();
	}
	static class UMarker_Chara* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMarker_Chara>();
	}
};
static_assert(alignof(UMarker_Chara) == 0x000008, "Wrong alignment on UMarker_Chara");
static_assert(sizeof(UMarker_Chara) == 0x000528, "Wrong size on UMarker_Chara");

// Class Stigma.BTTask_RotateAround
// 0x0038 (0x00A8 - 0x0070)
class UBTTask_RotateAround final : public UBTTaskNode
{
public:
	uint8                                         Pad_2157[0x38];                                    // 0x0070(0x0038)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BTTask_RotateAround">();
	}
	static class UBTTask_RotateAround* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBTTask_RotateAround>();
	}
};
static_assert(alignof(UBTTask_RotateAround) == 0x000008, "Wrong alignment on UBTTask_RotateAround");
static_assert(sizeof(UBTTask_RotateAround) == 0x0000A8, "Wrong size on UBTTask_RotateAround");

// Class Stigma.Occupation_GameMode
// 0x0020 (0x07F8 - 0x07D8)
class AOccupation_GameMode final : public ABattleGameModeBase
{
public:
	uint8                                         Pad_2158[0x10];                                    // 0x07D8(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	struct FConfig_OccupationMode                 Config_Occpuation;                                 // 0x07E8(0x0010)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	void AddOccupyScore(ETeams _Team, int32 _additional_score);
	void NotifyOccupyArea(ETeams _prev_team, ETeams _curr_team, class ACharaBase* _occupant, class AOccupationArea* _area);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Occupation_GameMode">();
	}
	static class AOccupation_GameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOccupation_GameMode>();
	}
};
static_assert(alignof(AOccupation_GameMode) == 0x000008, "Wrong alignment on AOccupation_GameMode");
static_assert(sizeof(AOccupation_GameMode) == 0x0007F8, "Wrong size on AOccupation_GameMode");
static_assert(offsetof(AOccupation_GameMode, Config_Occpuation) == 0x0007E8, "Member 'AOccupation_GameMode::Config_Occpuation' has a wrong offset!");

// Class Stigma.BT_V3_AdaptiveFight
// 0x0008 (0x0078 - 0x0070)
class UBT_V3_AdaptiveFight final : public UBTTaskNode
{
public:
	class UEnvQuery*                              EQS_AdvanceLocation;                               // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BT_V3_AdaptiveFight">();
	}
	static class UBT_V3_AdaptiveFight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBT_V3_AdaptiveFight>();
	}
};
static_assert(alignof(UBT_V3_AdaptiveFight) == 0x000008, "Wrong alignment on UBT_V3_AdaptiveFight");
static_assert(sizeof(UBT_V3_AdaptiveFight) == 0x000078, "Wrong size on UBT_V3_AdaptiveFight");
static_assert(offsetof(UBT_V3_AdaptiveFight, EQS_AdvanceLocation) == 0x000070, "Member 'UBT_V3_AdaptiveFight::EQS_AdvanceLocation' has a wrong offset!");

// Class Stigma.BT_V3_AfterRespawnDelay
// 0x0000 (0x0070 - 0x0070)
class UBT_V3_AfterRespawnDelay final : public UBT_V3_CustomFocusNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BT_V3_AfterRespawnDelay">();
	}
	static class UBT_V3_AfterRespawnDelay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBT_V3_AfterRespawnDelay>();
	}
};
static_assert(alignof(UBT_V3_AfterRespawnDelay) == 0x000008, "Wrong alignment on UBT_V3_AfterRespawnDelay");
static_assert(sizeof(UBT_V3_AfterRespawnDelay) == 0x000070, "Wrong size on UBT_V3_AfterRespawnDelay");

// Class Stigma.PropBase
// 0x0010 (0x07F0 - 0x07E0)
class APropBase : public AThrowBase
{
public:
	uint8                                         Pad_215B[0x10];                                    // 0x07E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropBase">();
	}
	static class APropBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APropBase>();
	}
};
static_assert(alignof(APropBase) == 0x000010, "Wrong alignment on APropBase");
static_assert(sizeof(APropBase) == 0x0007F0, "Wrong size on APropBase");

// Class Stigma.Prop_Coverable
// 0x0000 (0x07F0 - 0x07F0)
class AProp_Coverable final : public APropBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Prop_Coverable">();
	}
	static class AProp_Coverable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProp_Coverable>();
	}
};
static_assert(alignof(AProp_Coverable) == 0x000010, "Wrong alignment on AProp_Coverable");
static_assert(sizeof(AProp_Coverable) == 0x0007F0, "Wrong size on AProp_Coverable");

// Class Stigma.BT_V3_CopyBB
// 0x0058 (0x00C8 - 0x0070)
class UBT_V3_CopyBB final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 Source;                                            // 0x0070(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FBlackboardKeySelector                 Destination;                                       // 0x0098(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EBTNodeResult                                 Result;                                            // 0x00C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_215C[0x7];                                     // 0x00C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BT_V3_CopyBB">();
	}
	static class UBT_V3_CopyBB* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBT_V3_CopyBB>();
	}
};
static_assert(alignof(UBT_V3_CopyBB) == 0x000008, "Wrong alignment on UBT_V3_CopyBB");
static_assert(sizeof(UBT_V3_CopyBB) == 0x0000C8, "Wrong size on UBT_V3_CopyBB");
static_assert(offsetof(UBT_V3_CopyBB, Source) == 0x000070, "Member 'UBT_V3_CopyBB::Source' has a wrong offset!");
static_assert(offsetof(UBT_V3_CopyBB, Destination) == 0x000098, "Member 'UBT_V3_CopyBB::Destination' has a wrong offset!");
static_assert(offsetof(UBT_V3_CopyBB, Result) == 0x0000C0, "Member 'UBT_V3_CopyBB::Result' has a wrong offset!");

// Class Stigma.MissionCondition_Character
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_Character final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_Character">();
	}
	static class UMissionCondition_Character* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_Character>();
	}
};
static_assert(alignof(UMissionCondition_Character) == 0x000008, "Wrong alignment on UMissionCondition_Character");
static_assert(sizeof(UMissionCondition_Character) == 0x000068, "Wrong size on UMissionCondition_Character");

// Class Stigma.BT_V3_DoSkill
// 0x0008 (0x0078 - 0x0070)
class UBT_V3_DoSkill final : public UBTTaskNode
{
public:
	EActionUsage                                  Usage;                                             // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_215D[0x7];                                     // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BT_V3_DoSkill">();
	}
	static class UBT_V3_DoSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBT_V3_DoSkill>();
	}
};
static_assert(alignof(UBT_V3_DoSkill) == 0x000008, "Wrong alignment on UBT_V3_DoSkill");
static_assert(sizeof(UBT_V3_DoSkill) == 0x000078, "Wrong size on UBT_V3_DoSkill");
static_assert(offsetof(UBT_V3_DoSkill, Usage) == 0x000070, "Member 'UBT_V3_DoSkill::Usage' has a wrong offset!");

// Class Stigma.UserProfile
// 0x0178 (0x01A0 - 0x0028)
class UUserProfile : public UObject
{
public:
	uint8                                         Pad_215E[0x178];                                   // 0x0028(0x0178)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	struct FItemID GetCharaBody() const;
	struct FItemID GetCharaHead() const;
	ECharaType GetCharaType() const;
	class FString GetElapsedCreateTimeString() const;
	struct FItemID GetEmblem() const;
	const struct FGunSpec GetGunSpec() const;
	int32 GetLevel() const;
	const struct FUserName GetNickname() const;
	struct FItemID GetNicknameFX() const;
	EUserPlayingAt GetPlayingAt() const;
	struct FItemID GetProfileCard() const;
	EUserProfileType GetProfileType() const;
	int32 GetSocialPriorityLevel() const;
	ETier GetTier() const;
	struct FUserID GetUserID() const;
	bool HasValidCharacter() const;
	bool HasValidProfile() const;
	bool IsMine() const;
	bool IsOnline() const;
	bool IsPlayingAt(EUserPlayingAt _playing_at) const;
	bool IsPlayingAtBattle() const;
	bool IsPlayingAtLobby() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserProfile">();
	}
	static class UUserProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserProfile>();
	}
};
static_assert(alignof(UUserProfile) == 0x000008, "Wrong alignment on UUserProfile");
static_assert(sizeof(UUserProfile) == 0x0001A0, "Wrong size on UUserProfile");

// Class Stigma.BriefPartyMember
// 0x0000 (0x01A0 - 0x01A0)
class UBriefPartyMember final : public UUserProfile
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BriefPartyMember">();
	}
	static class UBriefPartyMember* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBriefPartyMember>();
	}
};
static_assert(alignof(UBriefPartyMember) == 0x000008, "Wrong alignment on UBriefPartyMember");
static_assert(sizeof(UBriefPartyMember) == 0x0001A0, "Wrong size on UBriefPartyMember");

// Class Stigma.BT_V3_Fight
// 0x0000 (0x0088 - 0x0088)
class UBT_V3_Fight final : public UBTTask_RunBehaviorDynamic
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BT_V3_Fight">();
	}
	static class UBT_V3_Fight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBT_V3_Fight>();
	}
};
static_assert(alignof(UBT_V3_Fight) == 0x000008, "Wrong alignment on UBT_V3_Fight");
static_assert(sizeof(UBT_V3_Fight) == 0x000088, "Wrong size on UBT_V3_Fight");

// Class Stigma.KillcamPlayback
// 0x0098 (0x00C0 - 0x0028)
class UKillcamPlayback final : public UObject
{
public:
	uint8                                         Pad_215F[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UWorld*                                 KillcamWorld;                                      // 0x0030(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPackage*                               KillcamWorldPackage;                               // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2160[0x80];                                    // 0x0040(0x0080)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillcamPlayback">();
	}
	static class UKillcamPlayback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillcamPlayback>();
	}
};
static_assert(alignof(UKillcamPlayback) == 0x000008, "Wrong alignment on UKillcamPlayback");
static_assert(sizeof(UKillcamPlayback) == 0x0000C0, "Wrong size on UKillcamPlayback");
static_assert(offsetof(UKillcamPlayback, KillcamWorld) == 0x000030, "Member 'UKillcamPlayback::KillcamWorld' has a wrong offset!");
static_assert(offsetof(UKillcamPlayback, KillcamWorldPackage) == 0x000038, "Member 'UKillcamPlayback::KillcamWorldPackage' has a wrong offset!");

// Class Stigma.BT_V3_StartFire
// 0x0010 (0x0080 - 0x0070)
class UBT_V3_StartFire final : public UBTTaskNode
{
public:
	EAIFireType                                   FireType;                                          // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAIFireUntil                                  Until;                                             // 0x0071(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2161[0x2];                                     // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         Timeout_Min;                                       // 0x0074(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timeout_Max;                                       // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2162[0x4];                                     // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BT_V3_StartFire">();
	}
	static class UBT_V3_StartFire* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBT_V3_StartFire>();
	}
};
static_assert(alignof(UBT_V3_StartFire) == 0x000008, "Wrong alignment on UBT_V3_StartFire");
static_assert(sizeof(UBT_V3_StartFire) == 0x000080, "Wrong size on UBT_V3_StartFire");
static_assert(offsetof(UBT_V3_StartFire, FireType) == 0x000070, "Member 'UBT_V3_StartFire::FireType' has a wrong offset!");
static_assert(offsetof(UBT_V3_StartFire, Until) == 0x000071, "Member 'UBT_V3_StartFire::Until' has a wrong offset!");
static_assert(offsetof(UBT_V3_StartFire, Timeout_Min) == 0x000074, "Member 'UBT_V3_StartFire::Timeout_Min' has a wrong offset!");
static_assert(offsetof(UBT_V3_StartFire, Timeout_Max) == 0x000078, "Member 'UBT_V3_StartFire::Timeout_Max' has a wrong offset!");

// Class Stigma.UI_RewardedItems
// 0x0028 (0x0518 - 0x04F0)
class UUI_RewardedItems : public UPreviewableWidget
{
public:
	class UUniformGridPanel*                      UGP_ItemContainer;                                 // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_RefundItems;                                   // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_ItemIDListViewItem>     _ItemWidgetClass;                                  // 0x0500(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2163[0x8];                                     // 0x0508(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         _FallingDelay;                                     // 0x0510(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2164[0x4];                                     // 0x0514(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void InitWidget(const struct FRewardPlain& _reward_plain);
	void StartFalling();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_RewardedItems">();
	}
	static class UUI_RewardedItems* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_RewardedItems>();
	}
};
static_assert(alignof(UUI_RewardedItems) == 0x000008, "Wrong alignment on UUI_RewardedItems");
static_assert(sizeof(UUI_RewardedItems) == 0x000518, "Wrong size on UUI_RewardedItems");
static_assert(offsetof(UUI_RewardedItems, UGP_ItemContainer) == 0x0004F0, "Member 'UUI_RewardedItems::UGP_ItemContainer' has a wrong offset!");
static_assert(offsetof(UUI_RewardedItems, Txt_RefundItems) == 0x0004F8, "Member 'UUI_RewardedItems::Txt_RefundItems' has a wrong offset!");
static_assert(offsetof(UUI_RewardedItems, _ItemWidgetClass) == 0x000500, "Member 'UUI_RewardedItems::_ItemWidgetClass' has a wrong offset!");
static_assert(offsetof(UUI_RewardedItems, _FallingDelay) == 0x000510, "Member 'UUI_RewardedItems::_FallingDelay' has a wrong offset!");

// Class Stigma.BT_V3_EndFire
// 0x0000 (0x0070 - 0x0070)
class UBT_V3_EndFire final : public UBTTaskNode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BT_V3_EndFire">();
	}
	static class UBT_V3_EndFire* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBT_V3_EndFire>();
	}
};
static_assert(alignof(UBT_V3_EndFire) == 0x000008, "Wrong alignment on UBT_V3_EndFire");
static_assert(sizeof(UBT_V3_EndFire) == 0x000070, "Wrong size on UBT_V3_EndFire");

// Class Stigma.BT_V3_Interaction
// 0x0030 (0x00A0 - 0x0070)
class UBT_V3_Interaction final : public UBTTaskNode
{
public:
	struct FBlackboardKeySelector                 Target;                                            // 0x0070(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0098(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BT_V3_Interaction">();
	}
	static class UBT_V3_Interaction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBT_V3_Interaction>();
	}
};
static_assert(alignof(UBT_V3_Interaction) == 0x000008, "Wrong alignment on UBT_V3_Interaction");
static_assert(sizeof(UBT_V3_Interaction) == 0x0000A0, "Wrong size on UBT_V3_Interaction");
static_assert(offsetof(UBT_V3_Interaction, Target) == 0x000070, "Member 'UBT_V3_Interaction::Target' has a wrong offset!");
static_assert(offsetof(UBT_V3_Interaction, Duration) == 0x000098, "Member 'UBT_V3_Interaction::Duration' has a wrong offset!");
static_assert(offsetof(UBT_V3_Interaction, Distance) == 0x00009C, "Member 'UBT_V3_Interaction::Distance' has a wrong offset!");

// Class Stigma.EQC_Safe
// 0x0008 (0x0030 - 0x0028)
class UEQC_Safe final : public UEnvQueryContext
{
public:
	ESafeType                                     SafeType;                                          // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2165[0x7];                                     // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EQC_Safe">();
	}
	static class UEQC_Safe* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEQC_Safe>();
	}
};
static_assert(alignof(UEQC_Safe) == 0x000008, "Wrong alignment on UEQC_Safe");
static_assert(sizeof(UEQC_Safe) == 0x000030, "Wrong size on UEQC_Safe");
static_assert(offsetof(UEQC_Safe, SafeType) == 0x000028, "Member 'UEQC_Safe::SafeType' has a wrong offset!");

// Class Stigma.UI_ShopPage
// 0x0160 (0x0670 - 0x0510)
class UUI_ShopPage : public UUI_LobbyPage
{
public:
	class UCtrl_CommonTabPanel*                   MainTab;                                           // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WS_CategoryLayout;                                 // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         Layout_Normal;                                     // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         Layout_Recommend;                                  // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WS_GoodsList;                                      // 0x0530(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTileView*                              TV_GoodsList_Set;                                  // 0x0538(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTileView*                              TV_GoodsList_Normal;                               // 0x0540(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_Status*                           Ctrl_Status_Normal;                                // 0x0548(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_Status*                           Ctrl_Status_Recommend;                             // 0x0550(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPreviewableWidget*                     RecommendGoods_0;                                  // 0x0558(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPreviewableWidget*                     RecommendGoods_1;                                  // 0x0560(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPreviewableWidget*                     RecommendGoods_2;                                  // 0x0568(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPreviewableWidget*                     RecommendGoods_3;                                  // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPreviewableWidget*                     RecommendGoods_4;                                  // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WS_SubTab;                                         // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_VerticalTabPanel*                 SubTab_Set;                                        // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_VerticalTabPanel*                 SubTab_Master;                                     // 0x0590(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_VerticalTabPanel*                 SubTab_Gun;                                        // 0x0598(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_VerticalTabPanel*                 SubTab_Accesory;                                   // 0x05A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_VerticalTabPanel*                 SubTab_ProfileItem;                                // 0x05A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_VerticalTabPanel*                 SubTab_Consume;                                    // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_VerticalTabPanel*                 SubTab_Currency;                                   // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_VerticalTabPanel*                 SubTab_BSCash;                                     // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_ShopMasterFilter*                   MasterFilter;                                      // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_ShopGunFilter*                      GunFilter;                                         // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               OVL_SubTabLayout;                                  // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionDropDownBase*               DropDown_SortMenu;                                 // 0x05E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                Btn_SortOrder;                                     // 0x05E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UGoodsObject*>                   GoodsObjList;                                      // 0x05F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UPreviewableWidget*>             RecommendWidgetList;                               // 0x0600(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<EGoodsCategory, class UCtrl_VerticalTabPanel*> _SubCategoryMap;                                   // 0x0610(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2166[0x10];                                    // 0x0660(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	class UGoodsObject* FindGoodsObject(const struct FGoodsID& _goods_id);
	void OnClickSortOrder();
	void OnMainTabChanged(class FName _id, int32 _idx);
	void OnSelectGunFilter(EGunType _gun_type);
	void OnSelectionSortMenu(class FName _id, int32 _idx);
	void OnSelectMasterFilter(ECharaType _chara_type);
	void OnSubTabChanged(class FName _id, int32 _idx);
	void OnUpdateGoods(EUserEvent _event);
	void ScrollToGoods(const struct FGoodsID& _goods_id);
	void SelectCategory(EGoodsCategory _category);
	void SelectSubCategory(class FName _tab_id);
	void UpdateRecommendGoodsList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_ShopPage">();
	}
	static class UUI_ShopPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_ShopPage>();
	}
};
static_assert(alignof(UUI_ShopPage) == 0x000008, "Wrong alignment on UUI_ShopPage");
static_assert(sizeof(UUI_ShopPage) == 0x000670, "Wrong size on UUI_ShopPage");
static_assert(offsetof(UUI_ShopPage, MainTab) == 0x000510, "Member 'UUI_ShopPage::MainTab' has a wrong offset!");
static_assert(offsetof(UUI_ShopPage, WS_CategoryLayout) == 0x000518, "Member 'UUI_ShopPage::WS_CategoryLayout' has a wrong offset!");
static_assert(offsetof(UUI_ShopPage, Layout_Normal) == 0x000520, "Member 'UUI_ShopPage::Layout_Normal' has a wrong offset!");
static_assert(offsetof(UUI_ShopPage, Layout_Recommend) == 0x000528, "Member 'UUI_ShopPage::Layout_Recommend' has a wrong offset!");
static_assert(offsetof(UUI_ShopPage, WS_GoodsList) == 0x000530, "Member 'UUI_ShopPage::WS_GoodsList' has a wrong offset!");
static_assert(offsetof(UUI_ShopPage, TV_GoodsList_Set) == 0x000538, "Member 'UUI_ShopPage::TV_GoodsList_Set' has a wrong offset!");
static_assert(offsetof(UUI_ShopPage, TV_GoodsList_Normal) == 0x000540, "Member 'UUI_ShopPage::TV_GoodsList_Normal' has a wrong offset!");
static_assert(offsetof(UUI_ShopPage, Ctrl_Status_Normal) == 0x000548, "Member 'UUI_ShopPage::Ctrl_Status_Normal' has a wrong offset!");
static_assert(offsetof(UUI_ShopPage, Ctrl_Status_Recommend) == 0x000550, "Member 'UUI_ShopPage::Ctrl_Status_Recommend' has a wrong offset!");
static_assert(offsetof(UUI_ShopPage, RecommendGoods_0) == 0x000558, "Member 'UUI_ShopPage::RecommendGoods_0' has a wrong offset!");
static_assert(offsetof(UUI_ShopPage, RecommendGoods_1) == 0x000560, "Member 'UUI_ShopPage::RecommendGoods_1' has a wrong offset!");
static_assert(offsetof(UUI_ShopPage, RecommendGoods_2) == 0x000568, "Member 'UUI_ShopPage::RecommendGoods_2' has a wrong offset!");
static_assert(offsetof(UUI_ShopPage, RecommendGoods_3) == 0x000570, "Member 'UUI_ShopPage::RecommendGoods_3' has a wrong offset!");
static_assert(offsetof(UUI_ShopPage, RecommendGoods_4) == 0x000578, "Member 'UUI_ShopPage::RecommendGoods_4' has a wrong offset!");
static_assert(offsetof(UUI_ShopPage, WS_SubTab) == 0x000580, "Member 'UUI_ShopPage::WS_SubTab' has a wrong offset!");
static_assert(offsetof(UUI_ShopPage, SubTab_Set) == 0x000588, "Member 'UUI_ShopPage::SubTab_Set' has a wrong offset!");
static_assert(offsetof(UUI_ShopPage, SubTab_Master) == 0x000590, "Member 'UUI_ShopPage::SubTab_Master' has a wrong offset!");
static_assert(offsetof(UUI_ShopPage, SubTab_Gun) == 0x000598, "Member 'UUI_ShopPage::SubTab_Gun' has a wrong offset!");
static_assert(offsetof(UUI_ShopPage, SubTab_Accesory) == 0x0005A0, "Member 'UUI_ShopPage::SubTab_Accesory' has a wrong offset!");
static_assert(offsetof(UUI_ShopPage, SubTab_ProfileItem) == 0x0005A8, "Member 'UUI_ShopPage::SubTab_ProfileItem' has a wrong offset!");
static_assert(offsetof(UUI_ShopPage, SubTab_Consume) == 0x0005B0, "Member 'UUI_ShopPage::SubTab_Consume' has a wrong offset!");
static_assert(offsetof(UUI_ShopPage, SubTab_Currency) == 0x0005B8, "Member 'UUI_ShopPage::SubTab_Currency' has a wrong offset!");
static_assert(offsetof(UUI_ShopPage, SubTab_BSCash) == 0x0005C0, "Member 'UUI_ShopPage::SubTab_BSCash' has a wrong offset!");
static_assert(offsetof(UUI_ShopPage, MasterFilter) == 0x0005C8, "Member 'UUI_ShopPage::MasterFilter' has a wrong offset!");
static_assert(offsetof(UUI_ShopPage, GunFilter) == 0x0005D0, "Member 'UUI_ShopPage::GunFilter' has a wrong offset!");
static_assert(offsetof(UUI_ShopPage, OVL_SubTabLayout) == 0x0005D8, "Member 'UUI_ShopPage::OVL_SubTabLayout' has a wrong offset!");
static_assert(offsetof(UUI_ShopPage, DropDown_SortMenu) == 0x0005E0, "Member 'UUI_ShopPage::DropDown_SortMenu' has a wrong offset!");
static_assert(offsetof(UUI_ShopPage, Btn_SortOrder) == 0x0005E8, "Member 'UUI_ShopPage::Btn_SortOrder' has a wrong offset!");
static_assert(offsetof(UUI_ShopPage, GoodsObjList) == 0x0005F0, "Member 'UUI_ShopPage::GoodsObjList' has a wrong offset!");
static_assert(offsetof(UUI_ShopPage, RecommendWidgetList) == 0x000600, "Member 'UUI_ShopPage::RecommendWidgetList' has a wrong offset!");
static_assert(offsetof(UUI_ShopPage, _SubCategoryMap) == 0x000610, "Member 'UUI_ShopPage::_SubCategoryMap' has a wrong offset!");

// Class Stigma.BT_V3_MoveTo
// 0x0020 (0x00D0 - 0x00B0)
class UBT_V3_MoveTo final : public UBTTask_MoveTo
{
public:
	EAIFireType                                   FireType;                                          // 0x00B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAI_MoveType                                  MoveType;                                          // 0x00B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseSprintIfPossible;                               // 0x00B2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2167[0x1];                                     // 0x00B3(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         ScanInterval;                                      // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScanInterval_Random_Min;                           // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScanInterval_Random_Max;                           // 0x00BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScanAngle_Half_Degree;                             // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwitchLookDirectionInterval_Random_Min;            // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwitchLookDirectionInterval_Random_Max;            // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2168[0x4];                                     // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BT_V3_MoveTo">();
	}
	static class UBT_V3_MoveTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBT_V3_MoveTo>();
	}
};
static_assert(alignof(UBT_V3_MoveTo) == 0x000008, "Wrong alignment on UBT_V3_MoveTo");
static_assert(sizeof(UBT_V3_MoveTo) == 0x0000D0, "Wrong size on UBT_V3_MoveTo");
static_assert(offsetof(UBT_V3_MoveTo, FireType) == 0x0000B0, "Member 'UBT_V3_MoveTo::FireType' has a wrong offset!");
static_assert(offsetof(UBT_V3_MoveTo, MoveType) == 0x0000B1, "Member 'UBT_V3_MoveTo::MoveType' has a wrong offset!");
static_assert(offsetof(UBT_V3_MoveTo, UseSprintIfPossible) == 0x0000B2, "Member 'UBT_V3_MoveTo::UseSprintIfPossible' has a wrong offset!");
static_assert(offsetof(UBT_V3_MoveTo, ScanInterval) == 0x0000B4, "Member 'UBT_V3_MoveTo::ScanInterval' has a wrong offset!");
static_assert(offsetof(UBT_V3_MoveTo, ScanInterval_Random_Min) == 0x0000B8, "Member 'UBT_V3_MoveTo::ScanInterval_Random_Min' has a wrong offset!");
static_assert(offsetof(UBT_V3_MoveTo, ScanInterval_Random_Max) == 0x0000BC, "Member 'UBT_V3_MoveTo::ScanInterval_Random_Max' has a wrong offset!");
static_assert(offsetof(UBT_V3_MoveTo, ScanAngle_Half_Degree) == 0x0000C0, "Member 'UBT_V3_MoveTo::ScanAngle_Half_Degree' has a wrong offset!");
static_assert(offsetof(UBT_V3_MoveTo, SwitchLookDirectionInterval_Random_Min) == 0x0000C4, "Member 'UBT_V3_MoveTo::SwitchLookDirectionInterval_Random_Min' has a wrong offset!");
static_assert(offsetof(UBT_V3_MoveTo, SwitchLookDirectionInterval_Random_Max) == 0x0000C8, "Member 'UBT_V3_MoveTo::SwitchLookDirectionInterval_Random_Max' has a wrong offset!");

// Class Stigma.GoToWidgetHelper
// 0x0000 (0x0028 - 0x0028)
class UGoToWidgetHelper final : public UBlueprintFunctionLibrary
{
public:
	static void GotoMasterObtain(class UObject* _outer, ECharaType _chara_type);
	static void GoToWidget(class UObject* _outer, const class FName& _go_to_widget_id, const TArray<class FString>& _detailer_params);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GoToWidgetHelper">();
	}
	static class UGoToWidgetHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGoToWidgetHelper>();
	}
};
static_assert(alignof(UGoToWidgetHelper) == 0x000008, "Wrong alignment on UGoToWidgetHelper");
static_assert(sizeof(UGoToWidgetHelper) == 0x000028, "Wrong size on UGoToWidgetHelper");

// Class Stigma.BT_V3_ReadyFor
// 0x0008 (0x0078 - 0x0070)
class UBT_V3_ReadyFor final : public UBTTaskNode
{
public:
	EAI_ReadyFor                                  ReadyFor;                                          // 0x0070(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBTNodeResult                                 Result;                                            // 0x0071(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_216A[0x6];                                     // 0x0072(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BT_V3_ReadyFor">();
	}
	static class UBT_V3_ReadyFor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBT_V3_ReadyFor>();
	}
};
static_assert(alignof(UBT_V3_ReadyFor) == 0x000008, "Wrong alignment on UBT_V3_ReadyFor");
static_assert(sizeof(UBT_V3_ReadyFor) == 0x000078, "Wrong size on UBT_V3_ReadyFor");
static_assert(offsetof(UBT_V3_ReadyFor, ReadyFor) == 0x000070, "Member 'UBT_V3_ReadyFor::ReadyFor' has a wrong offset!");
static_assert(offsetof(UBT_V3_ReadyFor, Result) == 0x000071, "Member 'UBT_V3_ReadyFor::Result' has a wrong offset!");

// Class Stigma.UI_SelectWeaponPanel
// 0x0100 (0x05F0 - 0x04F0)
class UUI_SelectWeaponPanel : public UPreviewableWidget
{
public:
	class USizeBox*                               SZ_PickedChara1;                                   // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_Character_CheckBox*               PickedChara1;                                      // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               SZ_PickedChara2;                                   // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_Character_CheckBox*               PickedChara2;                                      // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               SZ_PickedChara3;                                   // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_Character_CheckBox*               PickedChara3;                                      // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UListView*                              LISTVIEW_GunTypeItem;                              // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTileView*                              TILEVIEW_GunTypeBox;                               // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _SelectedMasterIdx;                                // 0x0530(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_216B[0x4];                                     // 0x0534(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UGunObject*                             _SelectedGunObject;                                // 0x0538(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ULVData_Gun*>                    _GunTypeItemDatas;                                 // 0x0540(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<EGunType, class ULVData_Gun*>            _GunTypeItemDataMap;                               // 0x0550(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<class UUI_GunTypeBoxItem*>             _GunTypeBoxEntryWidgets;                           // 0x05A0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UCtrl_Character_CheckBox*>       _Item_PickedCharas;                                // 0x05B0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnSelectMaster;                                    // 0x05C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSelectGun;                                       // 0x05D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_216C[0x10];                                    // 0x05E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnChangedGun(const struct FGunPreset& _gun_preset);
	void OnChangedMaster(bool _is_selected, ECharaType _chara_type, int32 _selected_master_idx);
	void OnHoverGunPresetItem(class UObject* _item, bool _is_hover);
	void OnPlayerStateChanged(EChangedPlayerState _reason, class AMatchServicedPlayerState* _ps);
	void SetSelectMaster(int32 _master_idx);
	void UpdateDetail(class UGunObject* _origin_gun_obj, class UGunObject* _compared_gun_obj, ECharaType _chara_type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_SelectWeaponPanel">();
	}
	static class UUI_SelectWeaponPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_SelectWeaponPanel>();
	}
};
static_assert(alignof(UUI_SelectWeaponPanel) == 0x000008, "Wrong alignment on UUI_SelectWeaponPanel");
static_assert(sizeof(UUI_SelectWeaponPanel) == 0x0005F0, "Wrong size on UUI_SelectWeaponPanel");
static_assert(offsetof(UUI_SelectWeaponPanel, SZ_PickedChara1) == 0x0004F0, "Member 'UUI_SelectWeaponPanel::SZ_PickedChara1' has a wrong offset!");
static_assert(offsetof(UUI_SelectWeaponPanel, PickedChara1) == 0x0004F8, "Member 'UUI_SelectWeaponPanel::PickedChara1' has a wrong offset!");
static_assert(offsetof(UUI_SelectWeaponPanel, SZ_PickedChara2) == 0x000500, "Member 'UUI_SelectWeaponPanel::SZ_PickedChara2' has a wrong offset!");
static_assert(offsetof(UUI_SelectWeaponPanel, PickedChara2) == 0x000508, "Member 'UUI_SelectWeaponPanel::PickedChara2' has a wrong offset!");
static_assert(offsetof(UUI_SelectWeaponPanel, SZ_PickedChara3) == 0x000510, "Member 'UUI_SelectWeaponPanel::SZ_PickedChara3' has a wrong offset!");
static_assert(offsetof(UUI_SelectWeaponPanel, PickedChara3) == 0x000518, "Member 'UUI_SelectWeaponPanel::PickedChara3' has a wrong offset!");
static_assert(offsetof(UUI_SelectWeaponPanel, LISTVIEW_GunTypeItem) == 0x000520, "Member 'UUI_SelectWeaponPanel::LISTVIEW_GunTypeItem' has a wrong offset!");
static_assert(offsetof(UUI_SelectWeaponPanel, TILEVIEW_GunTypeBox) == 0x000528, "Member 'UUI_SelectWeaponPanel::TILEVIEW_GunTypeBox' has a wrong offset!");
static_assert(offsetof(UUI_SelectWeaponPanel, _SelectedMasterIdx) == 0x000530, "Member 'UUI_SelectWeaponPanel::_SelectedMasterIdx' has a wrong offset!");
static_assert(offsetof(UUI_SelectWeaponPanel, _SelectedGunObject) == 0x000538, "Member 'UUI_SelectWeaponPanel::_SelectedGunObject' has a wrong offset!");
static_assert(offsetof(UUI_SelectWeaponPanel, _GunTypeItemDatas) == 0x000540, "Member 'UUI_SelectWeaponPanel::_GunTypeItemDatas' has a wrong offset!");
static_assert(offsetof(UUI_SelectWeaponPanel, _GunTypeItemDataMap) == 0x000550, "Member 'UUI_SelectWeaponPanel::_GunTypeItemDataMap' has a wrong offset!");
static_assert(offsetof(UUI_SelectWeaponPanel, _GunTypeBoxEntryWidgets) == 0x0005A0, "Member 'UUI_SelectWeaponPanel::_GunTypeBoxEntryWidgets' has a wrong offset!");
static_assert(offsetof(UUI_SelectWeaponPanel, _Item_PickedCharas) == 0x0005B0, "Member 'UUI_SelectWeaponPanel::_Item_PickedCharas' has a wrong offset!");
static_assert(offsetof(UUI_SelectWeaponPanel, OnSelectMaster) == 0x0005C0, "Member 'UUI_SelectWeaponPanel::OnSelectMaster' has a wrong offset!");
static_assert(offsetof(UUI_SelectWeaponPanel, OnSelectGun) == 0x0005D0, "Member 'UUI_SelectWeaponPanel::OnSelectGun' has a wrong offset!");

// Class Stigma.BT_V3_Weirdo
// 0x0008 (0x0078 - 0x0070)
class UBT_V3_Weirdo final : public UBT_V3_CustomFocusNode
{
public:
	class UEnvQuery*                              MoveToDoorEQS;                                     // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BT_V3_Weirdo">();
	}
	static class UBT_V3_Weirdo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBT_V3_Weirdo>();
	}
};
static_assert(alignof(UBT_V3_Weirdo) == 0x000008, "Wrong alignment on UBT_V3_Weirdo");
static_assert(sizeof(UBT_V3_Weirdo) == 0x000078, "Wrong size on UBT_V3_Weirdo");
static_assert(offsetof(UBT_V3_Weirdo, MoveToDoorEQS) == 0x000070, "Member 'UBT_V3_Weirdo::MoveToDoorEQS' has a wrong offset!");

// Class Stigma.BuffBase
// 0x00D0 (0x00F8 - 0x0028)
class UBuffBase : public UObject
{
public:
	class UNiagaraSystem*                         _NiagaraSystem;                                    // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         _NiagaraSystem_Camera;                             // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         _NiagaraSystem_Solo;                               // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   _NiagaraSystem_Solo_SocketName;                    // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _NiagaraSystem_Solo_LocationOffset;                // 0x0048(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2171[0x58];                                    // 0x0060(0x0058)(Fixing Size After Last Property [ Dumper-69 ])
	class ABattlePlayerState*                     _PlayerState;                                      // 0x00B8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      _NC_Neck;                                          // 0x00C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      _NC_Clavicle_L;                                    // 0x00C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      _NC_UArm_L;                                        // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      _NC_Clavicle_R;                                    // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      _NC_UArm_R;                                        // 0x00E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      _NiagaraComponent_Camera;                          // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      _NiagaraComponent_Solo;                            // 0x00F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool ActivateBuff();
	bool DeactivateBuff();
	float GetActiveTimeProgress();
	void OnFirstUpdate(float _delta, struct FBuffStats* _buff_stats);
	void OnUpdateBuff(float _delta, struct FBuffStats* _buff_stats);
	void ResetForRespawn();

	TArray<struct FBuffEffectOption> GetBuffOptions(int32 _buff_level) const;
	float GetDuration() const;
	EBuffLimitType GetLimitType() const;
	bool IsActivating() const;
	bool IsProperVariable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuffBase">();
	}
	static class UBuffBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuffBase>();
	}
};
static_assert(alignof(UBuffBase) == 0x000008, "Wrong alignment on UBuffBase");
static_assert(sizeof(UBuffBase) == 0x0000F8, "Wrong size on UBuffBase");
static_assert(offsetof(UBuffBase, _NiagaraSystem) == 0x000028, "Member 'UBuffBase::_NiagaraSystem' has a wrong offset!");
static_assert(offsetof(UBuffBase, _NiagaraSystem_Camera) == 0x000030, "Member 'UBuffBase::_NiagaraSystem_Camera' has a wrong offset!");
static_assert(offsetof(UBuffBase, _NiagaraSystem_Solo) == 0x000038, "Member 'UBuffBase::_NiagaraSystem_Solo' has a wrong offset!");
static_assert(offsetof(UBuffBase, _NiagaraSystem_Solo_SocketName) == 0x000040, "Member 'UBuffBase::_NiagaraSystem_Solo_SocketName' has a wrong offset!");
static_assert(offsetof(UBuffBase, _NiagaraSystem_Solo_LocationOffset) == 0x000048, "Member 'UBuffBase::_NiagaraSystem_Solo_LocationOffset' has a wrong offset!");
static_assert(offsetof(UBuffBase, _PlayerState) == 0x0000B8, "Member 'UBuffBase::_PlayerState' has a wrong offset!");
static_assert(offsetof(UBuffBase, _NC_Neck) == 0x0000C0, "Member 'UBuffBase::_NC_Neck' has a wrong offset!");
static_assert(offsetof(UBuffBase, _NC_Clavicle_L) == 0x0000C8, "Member 'UBuffBase::_NC_Clavicle_L' has a wrong offset!");
static_assert(offsetof(UBuffBase, _NC_UArm_L) == 0x0000D0, "Member 'UBuffBase::_NC_UArm_L' has a wrong offset!");
static_assert(offsetof(UBuffBase, _NC_Clavicle_R) == 0x0000D8, "Member 'UBuffBase::_NC_Clavicle_R' has a wrong offset!");
static_assert(offsetof(UBuffBase, _NC_UArm_R) == 0x0000E0, "Member 'UBuffBase::_NC_UArm_R' has a wrong offset!");
static_assert(offsetof(UBuffBase, _NiagaraComponent_Camera) == 0x0000E8, "Member 'UBuffBase::_NiagaraComponent_Camera' has a wrong offset!");
static_assert(offsetof(UBuffBase, _NiagaraComponent_Solo) == 0x0000F0, "Member 'UBuffBase::_NiagaraComponent_Solo' has a wrong offset!");

// Class Stigma.GhostTrails
// 0x0078 (0x00A8 - 0x0030)
class UGhostTrails final : public UAnimNotifyState
{
public:
	uint8                                         Pad_2173[0x8];                                     // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TMap<struct FItemID, class UMaterialInterface*> _BodyID_With_MaterialInterfaceGhost;               // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         _MaxGhost;                                         // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _LifeTime;                                         // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _Delay;                                            // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2174[0x4];                                     // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UMaterialInterface*                     _MaterialInterfaceGhost;                           // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2175[0x8];                                     // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GhostTrails">();
	}
	static class UGhostTrails* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGhostTrails>();
	}
};
static_assert(alignof(UGhostTrails) == 0x000008, "Wrong alignment on UGhostTrails");
static_assert(sizeof(UGhostTrails) == 0x0000A8, "Wrong size on UGhostTrails");
static_assert(offsetof(UGhostTrails, _BodyID_With_MaterialInterfaceGhost) == 0x000038, "Member 'UGhostTrails::_BodyID_With_MaterialInterfaceGhost' has a wrong offset!");
static_assert(offsetof(UGhostTrails, _MaxGhost) == 0x000088, "Member 'UGhostTrails::_MaxGhost' has a wrong offset!");
static_assert(offsetof(UGhostTrails, _LifeTime) == 0x00008C, "Member 'UGhostTrails::_LifeTime' has a wrong offset!");
static_assert(offsetof(UGhostTrails, _Delay) == 0x000090, "Member 'UGhostTrails::_Delay' has a wrong offset!");
static_assert(offsetof(UGhostTrails, _MaterialInterfaceGhost) == 0x000098, "Member 'UGhostTrails::_MaterialInterfaceGhost' has a wrong offset!");

// Class Stigma.UI_Result_UserLevel
// 0x0090 (0x0350 - 0x02C0)
class UUI_Result_UserLevel : public UUserWidget
{
public:
	struct FUserBattleResult                      _PlayerResult;                                     // 0x02C0(0x0090)(Edit, BlueprintVisible, Transient, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Result_UserLevel">();
	}
	static class UUI_Result_UserLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Result_UserLevel>();
	}
};
static_assert(alignof(UUI_Result_UserLevel) == 0x000008, "Wrong alignment on UUI_Result_UserLevel");
static_assert(sizeof(UUI_Result_UserLevel) == 0x000350, "Wrong size on UUI_Result_UserLevel");
static_assert(offsetof(UUI_Result_UserLevel, _PlayerResult) == 0x0002C0, "Member 'UUI_Result_UserLevel::_PlayerResult' has a wrong offset!");

// Class Stigma.Buff_Ability
// 0x0010 (0x0108 - 0x00F8)
class UBuff_Ability : public UBuffBase
{
public:
	TArray<struct FAbilityEntry>                  Entries;                                           // 0x00F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Buff_Ability">();
	}
	static class UBuff_Ability* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuff_Ability>();
	}
};
static_assert(alignof(UBuff_Ability) == 0x000008, "Wrong alignment on UBuff_Ability");
static_assert(sizeof(UBuff_Ability) == 0x000108, "Wrong size on UBuff_Ability");
static_assert(offsetof(UBuff_Ability, Entries) == 0x0000F8, "Member 'UBuff_Ability::Entries' has a wrong offset!");

// Class Stigma.LocalPlayerBriefUser
// 0x0008 (0x0030 - 0x0028)
class ULocalPlayerBriefUser final : public UBriefUser
{
public:
	class ULocalPlayerContext*                    _LocalPlayerCtx;                                   // 0x0028(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalPlayerBriefUser">();
	}
	static class ULocalPlayerBriefUser* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalPlayerBriefUser>();
	}
};
static_assert(alignof(ULocalPlayerBriefUser) == 0x000008, "Wrong alignment on ULocalPlayerBriefUser");
static_assert(sizeof(ULocalPlayerBriefUser) == 0x000030, "Wrong size on ULocalPlayerBriefUser");
static_assert(offsetof(ULocalPlayerBriefUser, _LocalPlayerCtx) == 0x000028, "Member 'ULocalPlayerBriefUser::_LocalPlayerCtx' has a wrong offset!");

// Class Stigma.Buff_Action
// 0x00B8 (0x01B0 - 0x00F8)
class UBuff_Action : public UBuffBase
{
public:
	TArray<ECharaAction>                          ActionTypes;                                       // 0x00F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FBuffValue                             _Additional_MaxStock;                              // 0x0108(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBuffValue                             _PlayRate_Actions;                                 // 0x0140(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBuffValue                             _DamageRate_Actions;                               // 0x0178(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Buff_Action">();
	}
	static class UBuff_Action* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuff_Action>();
	}
};
static_assert(alignof(UBuff_Action) == 0x000008, "Wrong alignment on UBuff_Action");
static_assert(sizeof(UBuff_Action) == 0x0001B0, "Wrong size on UBuff_Action");
static_assert(offsetof(UBuff_Action, ActionTypes) == 0x0000F8, "Member 'UBuff_Action::ActionTypes' has a wrong offset!");
static_assert(offsetof(UBuff_Action, _Additional_MaxStock) == 0x000108, "Member 'UBuff_Action::_Additional_MaxStock' has a wrong offset!");
static_assert(offsetof(UBuff_Action, _PlayRate_Actions) == 0x000140, "Member 'UBuff_Action::_PlayRate_Actions' has a wrong offset!");
static_assert(offsetof(UBuff_Action, _DamageRate_Actions) == 0x000178, "Member 'UBuff_Action::_DamageRate_Actions' has a wrong offset!");

// Class Stigma.UI_RoundResultBase
// 0x0018 (0x0588 - 0x0570)
class UUI_RoundResultBase : public UPopupBase
{
public:
	struct FRoundResult                           _RoundResult;                                      // 0x0570(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         _LifeTime;                                         // 0x0578(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2176[0x4];                                     // 0x057C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	ETeams                                        _MyTeam;                                           // 0x0580(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2177[0x7];                                     // 0x0581(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void InitWidget(const struct FRoundResult& _result, float _override_life_time);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_RoundResultBase">();
	}
	static class UUI_RoundResultBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_RoundResultBase>();
	}
};
static_assert(alignof(UUI_RoundResultBase) == 0x000008, "Wrong alignment on UUI_RoundResultBase");
static_assert(sizeof(UUI_RoundResultBase) == 0x000588, "Wrong size on UUI_RoundResultBase");
static_assert(offsetof(UUI_RoundResultBase, _RoundResult) == 0x000570, "Member 'UUI_RoundResultBase::_RoundResult' has a wrong offset!");
static_assert(offsetof(UUI_RoundResultBase, _LifeTime) == 0x000578, "Member 'UUI_RoundResultBase::_LifeTime' has a wrong offset!");
static_assert(offsetof(UUI_RoundResultBase, _MyTeam) == 0x000580, "Member 'UUI_RoundResultBase::_MyTeam' has a wrong offset!");

// Class Stigma.Buff_AntiSlowDown
// 0x0038 (0x0130 - 0x00F8)
class UBuff_AntiSlowDown : public UBuffBase
{
public:
	struct FBuffValue                             _SlowDownTime;                                     // 0x00F8(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Buff_AntiSlowDown">();
	}
	static class UBuff_AntiSlowDown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuff_AntiSlowDown>();
	}
};
static_assert(alignof(UBuff_AntiSlowDown) == 0x000008, "Wrong alignment on UBuff_AntiSlowDown");
static_assert(sizeof(UBuff_AntiSlowDown) == 0x000130, "Wrong size on UBuff_AntiSlowDown");
static_assert(offsetof(UBuff_AntiSlowDown, _SlowDownTime) == 0x0000F8, "Member 'UBuff_AntiSlowDown::_SlowDownTime' has a wrong offset!");

// Class Stigma.Buff_AntiStun
// 0x0038 (0x0130 - 0x00F8)
class UBuff_AntiStun : public UBuffBase
{
public:
	struct FBuffValue                             _StunTime;                                         // 0x00F8(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Buff_AntiStun">();
	}
	static class UBuff_AntiStun* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuff_AntiStun>();
	}
};
static_assert(alignof(UBuff_AntiStun) == 0x000008, "Wrong alignment on UBuff_AntiStun");
static_assert(sizeof(UBuff_AntiStun) == 0x000130, "Wrong size on UBuff_AntiStun");
static_assert(offsetof(UBuff_AntiStun, _StunTime) == 0x0000F8, "Member 'UBuff_AntiStun::_StunTime' has a wrong offset!");

// Class Stigma.EQT_TeamSide
// 0x0040 (0x0238 - 0x01F8)
class UEQT_TeamSide final : public UEnvQueryTest
{
public:
	struct FAIDataProviderTeamSideValue           TeamSide;                                          // 0x01F8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EQT_TeamSide">();
	}
	static class UEQT_TeamSide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEQT_TeamSide>();
	}
};
static_assert(alignof(UEQT_TeamSide) == 0x000008, "Wrong alignment on UEQT_TeamSide");
static_assert(sizeof(UEQT_TeamSide) == 0x000238, "Wrong size on UEQT_TeamSide");
static_assert(offsetof(UEQT_TeamSide, TeamSide) == 0x0001F8, "Member 'UEQT_TeamSide::TeamSide' has a wrong offset!");
static_assert(offsetof(UEQT_TeamSide, Context) == 0x000230, "Member 'UEQT_TeamSide::Context' has a wrong offset!");

// Class Stigma.UI_TDM_MainScore
// 0x0068 (0x0558 - 0x04F0)
class UUI_TDM_MainScore : public UPreviewableWidget
{
public:
	class UCanvasPanel*                           CP_MyTeam;                                         // 0x04F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CP_EnemyTeam;                                      // 0x04F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_MyScore;                                       // 0x0500(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_EnemyScore;                                    // 0x0508(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_TargetScore;                                   // 0x0510(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _MaxDiffScore;                                     // 0x0518(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _InterpSpeed;                                      // 0x051C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _RandomAdditiveWidth;                              // 0x0520(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _MaxDiffWidth;                                     // 0x0524(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _MaxDiffHeight;                                    // 0x0528(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _MaxDiffShear;                                     // 0x052C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _MyTeamScore;                                      // 0x0530(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _EnemyTeamScore;                                   // 0x0534(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2178[0x20];                                    // 0x0538(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void UpdateWinningTeam(bool _is_tie, bool _my_team);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_TDM_MainScore">();
	}
	static class UUI_TDM_MainScore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_TDM_MainScore>();
	}
};
static_assert(alignof(UUI_TDM_MainScore) == 0x000008, "Wrong alignment on UUI_TDM_MainScore");
static_assert(sizeof(UUI_TDM_MainScore) == 0x000558, "Wrong size on UUI_TDM_MainScore");
static_assert(offsetof(UUI_TDM_MainScore, CP_MyTeam) == 0x0004F0, "Member 'UUI_TDM_MainScore::CP_MyTeam' has a wrong offset!");
static_assert(offsetof(UUI_TDM_MainScore, CP_EnemyTeam) == 0x0004F8, "Member 'UUI_TDM_MainScore::CP_EnemyTeam' has a wrong offset!");
static_assert(offsetof(UUI_TDM_MainScore, Txt_MyScore) == 0x000500, "Member 'UUI_TDM_MainScore::Txt_MyScore' has a wrong offset!");
static_assert(offsetof(UUI_TDM_MainScore, Txt_EnemyScore) == 0x000508, "Member 'UUI_TDM_MainScore::Txt_EnemyScore' has a wrong offset!");
static_assert(offsetof(UUI_TDM_MainScore, Txt_TargetScore) == 0x000510, "Member 'UUI_TDM_MainScore::Txt_TargetScore' has a wrong offset!");
static_assert(offsetof(UUI_TDM_MainScore, _MaxDiffScore) == 0x000518, "Member 'UUI_TDM_MainScore::_MaxDiffScore' has a wrong offset!");
static_assert(offsetof(UUI_TDM_MainScore, _InterpSpeed) == 0x00051C, "Member 'UUI_TDM_MainScore::_InterpSpeed' has a wrong offset!");
static_assert(offsetof(UUI_TDM_MainScore, _RandomAdditiveWidth) == 0x000520, "Member 'UUI_TDM_MainScore::_RandomAdditiveWidth' has a wrong offset!");
static_assert(offsetof(UUI_TDM_MainScore, _MaxDiffWidth) == 0x000524, "Member 'UUI_TDM_MainScore::_MaxDiffWidth' has a wrong offset!");
static_assert(offsetof(UUI_TDM_MainScore, _MaxDiffHeight) == 0x000528, "Member 'UUI_TDM_MainScore::_MaxDiffHeight' has a wrong offset!");
static_assert(offsetof(UUI_TDM_MainScore, _MaxDiffShear) == 0x00052C, "Member 'UUI_TDM_MainScore::_MaxDiffShear' has a wrong offset!");
static_assert(offsetof(UUI_TDM_MainScore, _MyTeamScore) == 0x000530, "Member 'UUI_TDM_MainScore::_MyTeamScore' has a wrong offset!");
static_assert(offsetof(UUI_TDM_MainScore, _EnemyTeamScore) == 0x000534, "Member 'UUI_TDM_MainScore::_EnemyTeamScore' has a wrong offset!");

// Class Stigma.Buff_Berserk
// 0x0038 (0x0130 - 0x00F8)
class UBuff_Berserk : public UBuffBase
{
public:
	struct FBuffValue                             _DamageRate;                                       // 0x00F8(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Buff_Berserk">();
	}
	static class UBuff_Berserk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuff_Berserk>();
	}
};
static_assert(alignof(UBuff_Berserk) == 0x000008, "Wrong alignment on UBuff_Berserk");
static_assert(sizeof(UBuff_Berserk) == 0x000130, "Wrong size on UBuff_Berserk");
static_assert(offsetof(UBuff_Berserk, _DamageRate) == 0x0000F8, "Member 'UBuff_Berserk::_DamageRate' has a wrong offset!");

// Class Stigma.Ctrl_TextCheckBoxGroupBase
// 0x0050 (0x0540 - 0x04F0)
class UCtrl_TextCheckBoxGroupBase final : public UPreviewableWidget
{
public:
	class UHorizontalBox*                         CheckBoxContainer;                                 // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCtrl_TextCheckBoxBase>     _EntryCheckBoxSubClass;                            // 0x04F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTextCheckBoxGroupEntry>        _entries;                                          // 0x0500(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         _EntrySpaceSize;                                   // 0x0510(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2179[0x2C];                                    // 0x0514(0x002C)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ClearAllSelections(bool _invoke_callback);
	void RegisterOnStateChange(const TDelegate<void(class UCtrl_TextCheckBoxBase* _check_box, class FName& _id, bool _is_checked)>& _callback);
	void SetCheckStateByID(const class FName& _id, bool _is_check, bool _invoke_callback);
	void Setup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_TextCheckBoxGroupBase">();
	}
	static class UCtrl_TextCheckBoxGroupBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_TextCheckBoxGroupBase>();
	}
};
static_assert(alignof(UCtrl_TextCheckBoxGroupBase) == 0x000008, "Wrong alignment on UCtrl_TextCheckBoxGroupBase");
static_assert(sizeof(UCtrl_TextCheckBoxGroupBase) == 0x000540, "Wrong size on UCtrl_TextCheckBoxGroupBase");
static_assert(offsetof(UCtrl_TextCheckBoxGroupBase, CheckBoxContainer) == 0x0004F0, "Member 'UCtrl_TextCheckBoxGroupBase::CheckBoxContainer' has a wrong offset!");
static_assert(offsetof(UCtrl_TextCheckBoxGroupBase, _EntryCheckBoxSubClass) == 0x0004F8, "Member 'UCtrl_TextCheckBoxGroupBase::_EntryCheckBoxSubClass' has a wrong offset!");
static_assert(offsetof(UCtrl_TextCheckBoxGroupBase, _entries) == 0x000500, "Member 'UCtrl_TextCheckBoxGroupBase::_entries' has a wrong offset!");
static_assert(offsetof(UCtrl_TextCheckBoxGroupBase, _EntrySpaceSize) == 0x000510, "Member 'UCtrl_TextCheckBoxGroupBase::_EntrySpaceSize' has a wrong offset!");

// Class Stigma.Buff_Booster
// 0x0078 (0x0170 - 0x00F8)
class UBuff_Booster : public UBuffBase
{
public:
	struct FBuffValue                             _CooltimeDecreaseSec;                              // 0x00F8(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBuffValue                             _DurationIncreaseSec;                              // 0x0130(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_217B[0x8];                                     // 0x0168(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Buff_Booster">();
	}
	static class UBuff_Booster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuff_Booster>();
	}
};
static_assert(alignof(UBuff_Booster) == 0x000008, "Wrong alignment on UBuff_Booster");
static_assert(sizeof(UBuff_Booster) == 0x000170, "Wrong size on UBuff_Booster");
static_assert(offsetof(UBuff_Booster, _CooltimeDecreaseSec) == 0x0000F8, "Member 'UBuff_Booster::_CooltimeDecreaseSec' has a wrong offset!");
static_assert(offsetof(UBuff_Booster, _DurationIncreaseSec) == 0x000130, "Member 'UBuff_Booster::_DurationIncreaseSec' has a wrong offset!");

// Class Stigma.UI_SocialContainer
// 0x0058 (0x0318 - 0x02C0)
class UUI_SocialContainer : public UUserWidget
{
public:
	class UVerticalBox*                           FriendAskNotifyContainer;                          // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           PartyInviteNotifyContainer;                        // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           BattleInviteNotifyContainer;                       // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_FriendNotifySlot>       _FriendNotifySlotClass;                            // 0x02D8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_PartyNotifySlot>        _PartyNotifySlotClass;                             // 0x02E0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_InviteBattleNotifySlot> _BattleNotifySlotClass;                            // 0x02E8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _MaxFriendNotifyCount;                             // 0x02F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _MaxPartyNotifyCount;                              // 0x02F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _MaxBattleNotifyCount;                             // 0x02F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                _SlotPadding;                                      // 0x02FC(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_217C[0x4];                                     // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class USocialContext*                         _SocialManager;                                    // 0x0310(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPartyEntered(const class UBriefParty* _party);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_SocialContainer">();
	}
	static class UUI_SocialContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_SocialContainer>();
	}
};
static_assert(alignof(UUI_SocialContainer) == 0x000008, "Wrong alignment on UUI_SocialContainer");
static_assert(sizeof(UUI_SocialContainer) == 0x000318, "Wrong size on UUI_SocialContainer");
static_assert(offsetof(UUI_SocialContainer, FriendAskNotifyContainer) == 0x0002C0, "Member 'UUI_SocialContainer::FriendAskNotifyContainer' has a wrong offset!");
static_assert(offsetof(UUI_SocialContainer, PartyInviteNotifyContainer) == 0x0002C8, "Member 'UUI_SocialContainer::PartyInviteNotifyContainer' has a wrong offset!");
static_assert(offsetof(UUI_SocialContainer, BattleInviteNotifyContainer) == 0x0002D0, "Member 'UUI_SocialContainer::BattleInviteNotifyContainer' has a wrong offset!");
static_assert(offsetof(UUI_SocialContainer, _FriendNotifySlotClass) == 0x0002D8, "Member 'UUI_SocialContainer::_FriendNotifySlotClass' has a wrong offset!");
static_assert(offsetof(UUI_SocialContainer, _PartyNotifySlotClass) == 0x0002E0, "Member 'UUI_SocialContainer::_PartyNotifySlotClass' has a wrong offset!");
static_assert(offsetof(UUI_SocialContainer, _BattleNotifySlotClass) == 0x0002E8, "Member 'UUI_SocialContainer::_BattleNotifySlotClass' has a wrong offset!");
static_assert(offsetof(UUI_SocialContainer, _MaxFriendNotifyCount) == 0x0002F0, "Member 'UUI_SocialContainer::_MaxFriendNotifyCount' has a wrong offset!");
static_assert(offsetof(UUI_SocialContainer, _MaxPartyNotifyCount) == 0x0002F4, "Member 'UUI_SocialContainer::_MaxPartyNotifyCount' has a wrong offset!");
static_assert(offsetof(UUI_SocialContainer, _MaxBattleNotifyCount) == 0x0002F8, "Member 'UUI_SocialContainer::_MaxBattleNotifyCount' has a wrong offset!");
static_assert(offsetof(UUI_SocialContainer, _SlotPadding) == 0x0002FC, "Member 'UUI_SocialContainer::_SlotPadding' has a wrong offset!");
static_assert(offsetof(UUI_SocialContainer, _SocialManager) == 0x000310, "Member 'UUI_SocialContainer::_SocialManager' has a wrong offset!");

// Class Stigma.Buff_Deviation
// 0x0038 (0x0130 - 0x00F8)
class UBuff_Deviation final : public UBuffBase
{
public:
	struct FBuffValue                             _DeviationRate;                                    // 0x00F8(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Buff_Deviation">();
	}
	static class UBuff_Deviation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuff_Deviation>();
	}
};
static_assert(alignof(UBuff_Deviation) == 0x000008, "Wrong alignment on UBuff_Deviation");
static_assert(sizeof(UBuff_Deviation) == 0x000130, "Wrong size on UBuff_Deviation");
static_assert(offsetof(UBuff_Deviation, _DeviationRate) == 0x0000F8, "Member 'UBuff_Deviation::_DeviationRate' has a wrong offset!");

// Class Stigma.Buff_FOV
// 0x0008 (0x0100 - 0x00F8)
class UBuff_FOV : public UBuffBase
{
public:
	float                                         _FOV;                                              // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_217D[0x4];                                     // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Buff_FOV">();
	}
	static class UBuff_FOV* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuff_FOV>();
	}
};
static_assert(alignof(UBuff_FOV) == 0x000008, "Wrong alignment on UBuff_FOV");
static_assert(sizeof(UBuff_FOV) == 0x000100, "Wrong size on UBuff_FOV");
static_assert(offsetof(UBuff_FOV, _FOV) == 0x0000F8, "Member 'UBuff_FOV::_FOV' has a wrong offset!");

// Class Stigma.GoToWidget_Custom
// 0x0000 (0x0038 - 0x0038)
class UGoToWidget_Custom final : public UGoToWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GoToWidget_Custom">();
	}
	static class UGoToWidget_Custom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGoToWidget_Custom>();
	}
};
static_assert(alignof(UGoToWidget_Custom) == 0x000008, "Wrong alignment on UGoToWidget_Custom");
static_assert(sizeof(UGoToWidget_Custom) == 0x000038, "Wrong size on UGoToWidget_Custom");

// Class Stigma.UI_RewardMissionSlot
// 0x0020 (0x0510 - 0x04F0)
class UUI_RewardMissionSlot : public UPreviewableWidget
{
public:
	class UTextBlock*                             Txt_Category;                                      // 0x04F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_RewardContainer*                    RewardContainer;                                   // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_MissionRepeatContainer*           RepeatContainer;                                   // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_Status*                           Ctrl_Status;                                       // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetDesc(const class FText& _text);
	void SetTitle(const class FText& _text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_RewardMissionSlot">();
	}
	static class UUI_RewardMissionSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_RewardMissionSlot>();
	}
};
static_assert(alignof(UUI_RewardMissionSlot) == 0x000008, "Wrong alignment on UUI_RewardMissionSlot");
static_assert(sizeof(UUI_RewardMissionSlot) == 0x000510, "Wrong size on UUI_RewardMissionSlot");
static_assert(offsetof(UUI_RewardMissionSlot, Txt_Category) == 0x0004F0, "Member 'UUI_RewardMissionSlot::Txt_Category' has a wrong offset!");
static_assert(offsetof(UUI_RewardMissionSlot, RewardContainer) == 0x0004F8, "Member 'UUI_RewardMissionSlot::RewardContainer' has a wrong offset!");
static_assert(offsetof(UUI_RewardMissionSlot, RepeatContainer) == 0x000500, "Member 'UUI_RewardMissionSlot::RepeatContainer' has a wrong offset!");
static_assert(offsetof(UUI_RewardMissionSlot, Ctrl_Status) == 0x000508, "Member 'UUI_RewardMissionSlot::Ctrl_Status' has a wrong offset!");

// Class Stigma.Buff_GunSpec
// 0x0150 (0x0248 - 0x00F8)
class UBuff_GunSpec : public UBuffBase
{
public:
	struct FBuffValue                             Damage_IncRate;                                    // 0x00F8(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBuffValue                             FireDelay_DecRate;                                 // 0x0130(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBuffValue                             Range_IncRate;                                     // 0x0168(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBuffValue                             AdditionalBullet;                                  // 0x01A0(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBuffValue                             AdditionalMagazine;                                // 0x01D8(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBuffValue                             ReloadSpeed_IncRate;                               // 0x0210(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Buff_GunSpec">();
	}
	static class UBuff_GunSpec* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuff_GunSpec>();
	}
};
static_assert(alignof(UBuff_GunSpec) == 0x000008, "Wrong alignment on UBuff_GunSpec");
static_assert(sizeof(UBuff_GunSpec) == 0x000248, "Wrong size on UBuff_GunSpec");
static_assert(offsetof(UBuff_GunSpec, Damage_IncRate) == 0x0000F8, "Member 'UBuff_GunSpec::Damage_IncRate' has a wrong offset!");
static_assert(offsetof(UBuff_GunSpec, FireDelay_DecRate) == 0x000130, "Member 'UBuff_GunSpec::FireDelay_DecRate' has a wrong offset!");
static_assert(offsetof(UBuff_GunSpec, Range_IncRate) == 0x000168, "Member 'UBuff_GunSpec::Range_IncRate' has a wrong offset!");
static_assert(offsetof(UBuff_GunSpec, AdditionalBullet) == 0x0001A0, "Member 'UBuff_GunSpec::AdditionalBullet' has a wrong offset!");
static_assert(offsetof(UBuff_GunSpec, AdditionalMagazine) == 0x0001D8, "Member 'UBuff_GunSpec::AdditionalMagazine' has a wrong offset!");
static_assert(offsetof(UBuff_GunSpec, ReloadSpeed_IncRate) == 0x000210, "Member 'UBuff_GunSpec::ReloadSpeed_IncRate' has a wrong offset!");

// Class Stigma.LVData_CompetitionRankingItem
// 0x0010 (0x0038 - 0x0028)
class ULVData_CompetitionRankingItem final : public UObject
{
public:
	ECompetitionType                              _CompetitionType;                                  // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_217E[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UCompetitionPlayer*                     _RankingEntry;                                     // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Config(ECompetitionType _competition_type, class UCompetitionPlayer* _entry);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LVData_CompetitionRankingItem">();
	}
	static class ULVData_CompetitionRankingItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULVData_CompetitionRankingItem>();
	}
};
static_assert(alignof(ULVData_CompetitionRankingItem) == 0x000008, "Wrong alignment on ULVData_CompetitionRankingItem");
static_assert(sizeof(ULVData_CompetitionRankingItem) == 0x000038, "Wrong size on ULVData_CompetitionRankingItem");
static_assert(offsetof(ULVData_CompetitionRankingItem, _CompetitionType) == 0x000028, "Member 'ULVData_CompetitionRankingItem::_CompetitionType' has a wrong offset!");
static_assert(offsetof(ULVData_CompetitionRankingItem, _RankingEntry) == 0x000030, "Member 'ULVData_CompetitionRankingItem::_RankingEntry' has a wrong offset!");

// Class Stigma.Buff_Heal
// 0x0040 (0x0138 - 0x00F8)
class UBuff_Heal : public UBuffBase
{
public:
	struct FBuffValue                             _HealPerSec;                                       // 0x00F8(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2180[0x8];                                     // 0x0130(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Buff_Heal">();
	}
	static class UBuff_Heal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuff_Heal>();
	}
};
static_assert(alignof(UBuff_Heal) == 0x000008, "Wrong alignment on UBuff_Heal");
static_assert(sizeof(UBuff_Heal) == 0x000138, "Wrong size on UBuff_Heal");
static_assert(offsetof(UBuff_Heal, _HealPerSec) == 0x0000F8, "Member 'UBuff_Heal::_HealPerSec' has a wrong offset!");

// Class Stigma.Buff_InfiniteBullet
// 0x0000 (0x00F8 - 0x00F8)
class UBuff_InfiniteBullet final : public UBuffBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Buff_InfiniteBullet">();
	}
	static class UBuff_InfiniteBullet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuff_InfiniteBullet>();
	}
};
static_assert(alignof(UBuff_InfiniteBullet) == 0x000008, "Wrong alignment on UBuff_InfiniteBullet");
static_assert(sizeof(UBuff_InfiniteBullet) == 0x0000F8, "Wrong size on UBuff_InfiniteBullet");

// Class Stigma.Buff_Marksmanship
// 0x0380 (0x0478 - 0x00F8)
class UBuff_Marksmanship : public UBuffBase
{
public:
	struct FBuffValue                             _FireDelay_DecRate;                                // 0x00F8(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBuffValue                             _GunDeviation_Fire_1PV_DecRate;                    // 0x0130(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBuffValue                             _GunDeviation_Fire_3PV_DecRate;                    // 0x0168(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBuffValue                             _GunDeviation_DecRate;                             // 0x01A0(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBuffValue                             _BodyDeviation_Aiming_DecRate;                     // 0x01D8(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBuffValue                             _BodyDeviation_Moving_DecRate;                     // 0x0210(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBuffValue                             _BodyDeviation_Crouch_DecRate;                     // 0x0248(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBuffValue                             _DeviationRecovery_DecRate;                        // 0x0280(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBuffValue                             _Recoil_DecRate_Vert;                              // 0x02B8(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBuffValue                             _Recoil_DecRate_Hori;                              // 0x02F0(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBuffValue                             _Recoil_DecRate_Crosshair;                         // 0x0328(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBuffValue                             _Recoil_DecRate_Camera;                            // 0x0360(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBuffValue                             _Recoil_Recovery_1PV_DecRate;                      // 0x0398(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBuffValue                             _Recoil_Recovery_3PV_DecRate;                      // 0x03D0(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBuffValue                             _ControlPower_Inc;                                 // 0x0408(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBuffValue                             _DoubleTap_JudgeTime_IncRate;                      // 0x0440(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Buff_Marksmanship">();
	}
	static class UBuff_Marksmanship* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuff_Marksmanship>();
	}
};
static_assert(alignof(UBuff_Marksmanship) == 0x000008, "Wrong alignment on UBuff_Marksmanship");
static_assert(sizeof(UBuff_Marksmanship) == 0x000478, "Wrong size on UBuff_Marksmanship");
static_assert(offsetof(UBuff_Marksmanship, _FireDelay_DecRate) == 0x0000F8, "Member 'UBuff_Marksmanship::_FireDelay_DecRate' has a wrong offset!");
static_assert(offsetof(UBuff_Marksmanship, _GunDeviation_Fire_1PV_DecRate) == 0x000130, "Member 'UBuff_Marksmanship::_GunDeviation_Fire_1PV_DecRate' has a wrong offset!");
static_assert(offsetof(UBuff_Marksmanship, _GunDeviation_Fire_3PV_DecRate) == 0x000168, "Member 'UBuff_Marksmanship::_GunDeviation_Fire_3PV_DecRate' has a wrong offset!");
static_assert(offsetof(UBuff_Marksmanship, _GunDeviation_DecRate) == 0x0001A0, "Member 'UBuff_Marksmanship::_GunDeviation_DecRate' has a wrong offset!");
static_assert(offsetof(UBuff_Marksmanship, _BodyDeviation_Aiming_DecRate) == 0x0001D8, "Member 'UBuff_Marksmanship::_BodyDeviation_Aiming_DecRate' has a wrong offset!");
static_assert(offsetof(UBuff_Marksmanship, _BodyDeviation_Moving_DecRate) == 0x000210, "Member 'UBuff_Marksmanship::_BodyDeviation_Moving_DecRate' has a wrong offset!");
static_assert(offsetof(UBuff_Marksmanship, _BodyDeviation_Crouch_DecRate) == 0x000248, "Member 'UBuff_Marksmanship::_BodyDeviation_Crouch_DecRate' has a wrong offset!");
static_assert(offsetof(UBuff_Marksmanship, _DeviationRecovery_DecRate) == 0x000280, "Member 'UBuff_Marksmanship::_DeviationRecovery_DecRate' has a wrong offset!");
static_assert(offsetof(UBuff_Marksmanship, _Recoil_DecRate_Vert) == 0x0002B8, "Member 'UBuff_Marksmanship::_Recoil_DecRate_Vert' has a wrong offset!");
static_assert(offsetof(UBuff_Marksmanship, _Recoil_DecRate_Hori) == 0x0002F0, "Member 'UBuff_Marksmanship::_Recoil_DecRate_Hori' has a wrong offset!");
static_assert(offsetof(UBuff_Marksmanship, _Recoil_DecRate_Crosshair) == 0x000328, "Member 'UBuff_Marksmanship::_Recoil_DecRate_Crosshair' has a wrong offset!");
static_assert(offsetof(UBuff_Marksmanship, _Recoil_DecRate_Camera) == 0x000360, "Member 'UBuff_Marksmanship::_Recoil_DecRate_Camera' has a wrong offset!");
static_assert(offsetof(UBuff_Marksmanship, _Recoil_Recovery_1PV_DecRate) == 0x000398, "Member 'UBuff_Marksmanship::_Recoil_Recovery_1PV_DecRate' has a wrong offset!");
static_assert(offsetof(UBuff_Marksmanship, _Recoil_Recovery_3PV_DecRate) == 0x0003D0, "Member 'UBuff_Marksmanship::_Recoil_Recovery_3PV_DecRate' has a wrong offset!");
static_assert(offsetof(UBuff_Marksmanship, _ControlPower_Inc) == 0x000408, "Member 'UBuff_Marksmanship::_ControlPower_Inc' has a wrong offset!");
static_assert(offsetof(UBuff_Marksmanship, _DoubleTap_JudgeTime_IncRate) == 0x000440, "Member 'UBuff_Marksmanship::_DoubleTap_JudgeTime_IncRate' has a wrong offset!");

// Class Stigma.InteractionComponent
// 0x0088 (0x0128 - 0x00A0)
class UInteractionComponent final : public UActorComponent
{
public:
	bool                                          _LockInteractive;                                  // 0x00A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2181[0x7];                                     // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class AActor*                                 _InteractiveTarget;                                // 0x00A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FInteractionData                       _InteractionData;                                  // 0x00B0(0x0058)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class UUI_Interaction*                        _UI_Interaction;                                   // 0x0108(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_Interaction>            UI_Interaction_Class;                              // 0x0110(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2182[0x10];                                    // 0x0118(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	class UUI_Interaction* GetOrCreateInteractionUI();
	void Lock();
	void RPC_ALL_TryInteract(class AActor* _interactive_target, bool _key_pressed, int32 _param, EInteractionResult _result);
	void RPC_SERVER_TryInteract(class AActor* _interactive_target, bool _key_pressed, int32 _param);
	bool TryInteraction(bool _pressed);
	void Unlock();

	class AActor* GetInteractiveTarget() const;
	void GetLookAtRay(struct FVector* _out_start, struct FVector* _out_end) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionComponent">();
	}
	static class UInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionComponent>();
	}
};
static_assert(alignof(UInteractionComponent) == 0x000008, "Wrong alignment on UInteractionComponent");
static_assert(sizeof(UInteractionComponent) == 0x000128, "Wrong size on UInteractionComponent");
static_assert(offsetof(UInteractionComponent, _LockInteractive) == 0x0000A0, "Member 'UInteractionComponent::_LockInteractive' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, _InteractiveTarget) == 0x0000A8, "Member 'UInteractionComponent::_InteractiveTarget' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, _InteractionData) == 0x0000B0, "Member 'UInteractionComponent::_InteractionData' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, _UI_Interaction) == 0x000108, "Member 'UInteractionComponent::_UI_Interaction' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, UI_Interaction_Class) == 0x000110, "Member 'UInteractionComponent::UI_Interaction_Class' has a wrong offset!");

// Class Stigma.UI_ToastMessageBase
// 0x0030 (0x0520 - 0x04F0)
class UUI_ToastMessageBase : public UPreviewableWidget
{
public:
	class UScaleBox*                              RootScaleBox;                                      // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Background;                                        // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         MessageText;                                       // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _LifeTime;                                         // 0x0508(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2186[0x14];                                    // 0x050C(0x0014)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void SetActive(bool _is_show);
	void SetScale(float _scale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_ToastMessageBase">();
	}
	static class UUI_ToastMessageBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_ToastMessageBase>();
	}
};
static_assert(alignof(UUI_ToastMessageBase) == 0x000008, "Wrong alignment on UUI_ToastMessageBase");
static_assert(sizeof(UUI_ToastMessageBase) == 0x000520, "Wrong size on UUI_ToastMessageBase");
static_assert(offsetof(UUI_ToastMessageBase, RootScaleBox) == 0x0004F0, "Member 'UUI_ToastMessageBase::RootScaleBox' has a wrong offset!");
static_assert(offsetof(UUI_ToastMessageBase, Background) == 0x0004F8, "Member 'UUI_ToastMessageBase::Background' has a wrong offset!");
static_assert(offsetof(UUI_ToastMessageBase, MessageText) == 0x000500, "Member 'UUI_ToastMessageBase::MessageText' has a wrong offset!");
static_assert(offsetof(UUI_ToastMessageBase, _LifeTime) == 0x000508, "Member 'UUI_ToastMessageBase::_LifeTime' has a wrong offset!");

// Class Stigma.Buff_Player
// 0x0020 (0x0118 - 0x00F8)
class UBuff_Player : public UBuffBase
{
public:
	float                                         ExpRate;                                           // 0x00F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DiamondRate;                                       // 0x00FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PassiveSkillLevel;                                 // 0x0100(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PassiveSkillSlot;                                  // 0x0104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BoosterSlot;                                       // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BoosterUnlimit;                                    // 0x010C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          BoosterAuto;                                       // 0x010D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2187[0x2];                                     // 0x010E(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         AddBulletRate;                                     // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2188[0x4];                                     // 0x0114(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Buff_Player">();
	}
	static class UBuff_Player* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuff_Player>();
	}
};
static_assert(alignof(UBuff_Player) == 0x000008, "Wrong alignment on UBuff_Player");
static_assert(sizeof(UBuff_Player) == 0x000118, "Wrong size on UBuff_Player");
static_assert(offsetof(UBuff_Player, ExpRate) == 0x0000F8, "Member 'UBuff_Player::ExpRate' has a wrong offset!");
static_assert(offsetof(UBuff_Player, DiamondRate) == 0x0000FC, "Member 'UBuff_Player::DiamondRate' has a wrong offset!");
static_assert(offsetof(UBuff_Player, PassiveSkillLevel) == 0x000100, "Member 'UBuff_Player::PassiveSkillLevel' has a wrong offset!");
static_assert(offsetof(UBuff_Player, PassiveSkillSlot) == 0x000104, "Member 'UBuff_Player::PassiveSkillSlot' has a wrong offset!");
static_assert(offsetof(UBuff_Player, BoosterSlot) == 0x000108, "Member 'UBuff_Player::BoosterSlot' has a wrong offset!");
static_assert(offsetof(UBuff_Player, BoosterUnlimit) == 0x00010C, "Member 'UBuff_Player::BoosterUnlimit' has a wrong offset!");
static_assert(offsetof(UBuff_Player, BoosterAuto) == 0x00010D, "Member 'UBuff_Player::BoosterAuto' has a wrong offset!");
static_assert(offsetof(UBuff_Player, AddBulletRate) == 0x000110, "Member 'UBuff_Player::AddBulletRate' has a wrong offset!");

// Class Stigma.Debug_DamageViewerComponent
// 0x0000 (0x00A0 - 0x00A0)
class UDebug_DamageViewerComponent : public UActorComponent
{
public:
	void OnActivation(bool _is_activated, EDebug_DamageViewerType _type);
	void OnAddDamage(const struct FDamagedData& _damage);
	void Reset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Debug_DamageViewerComponent">();
	}
	static class UDebug_DamageViewerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebug_DamageViewerComponent>();
	}
};
static_assert(alignof(UDebug_DamageViewerComponent) == 0x000008, "Wrong alignment on UDebug_DamageViewerComponent");
static_assert(sizeof(UDebug_DamageViewerComponent) == 0x0000A0, "Wrong size on UDebug_DamageViewerComponent");

// Class Stigma.Buff_Resist
// 0x0118 (0x0210 - 0x00F8)
class UBuff_Resist : public UBuffBase
{
public:
	struct FBuffValue                             _SlowDown_DecSec;                                  // 0x00F8(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBuffValue                             _Stun_DecSec;                                      // 0x0130(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBuffValue                             _DoubleTap_DecRate;                                // 0x0168(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBuffValue                             _FlashBang_DecSec;                                 // 0x01A0(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBuffValue                             _BoneBreak_DecSec;                                 // 0x01D8(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Buff_Resist">();
	}
	static class UBuff_Resist* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuff_Resist>();
	}
};
static_assert(alignof(UBuff_Resist) == 0x000008, "Wrong alignment on UBuff_Resist");
static_assert(sizeof(UBuff_Resist) == 0x000210, "Wrong size on UBuff_Resist");
static_assert(offsetof(UBuff_Resist, _SlowDown_DecSec) == 0x0000F8, "Member 'UBuff_Resist::_SlowDown_DecSec' has a wrong offset!");
static_assert(offsetof(UBuff_Resist, _Stun_DecSec) == 0x000130, "Member 'UBuff_Resist::_Stun_DecSec' has a wrong offset!");
static_assert(offsetof(UBuff_Resist, _DoubleTap_DecRate) == 0x000168, "Member 'UBuff_Resist::_DoubleTap_DecRate' has a wrong offset!");
static_assert(offsetof(UBuff_Resist, _FlashBang_DecSec) == 0x0001A0, "Member 'UBuff_Resist::_FlashBang_DecSec' has a wrong offset!");
static_assert(offsetof(UBuff_Resist, _BoneBreak_DecSec) == 0x0001D8, "Member 'UBuff_Resist::_BoneBreak_DecSec' has a wrong offset!");

// Class Stigma.UI_TDM_SubScoreContainer
// 0x01C0 (0x06B0 - 0x04F0)
class UUI_TDM_SubScoreContainer : public UPreviewableWidget
{
public:
	class UHorizontalBox*                         HorizontalBox;                                     // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_TDM_SubScoreSlot>       _SlotClass;                                        // 0x04F8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateBrush                            _MyTeamBGBrush;                                    // 0x0500(0x00D0)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            _EnemyTeamBGBrush;                                 // 0x05D0(0x00D0)(Edit, Protected, NativeAccessSpecifierProtected)
	bool                                          _IsMyTeam;                                         // 0x06A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2189[0xF];                                     // 0x06A1(0x000F)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void SetBGBrush(const struct FSlateBrush& _brush);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_TDM_SubScoreContainer">();
	}
	static class UUI_TDM_SubScoreContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_TDM_SubScoreContainer>();
	}
};
static_assert(alignof(UUI_TDM_SubScoreContainer) == 0x000010, "Wrong alignment on UUI_TDM_SubScoreContainer");
static_assert(sizeof(UUI_TDM_SubScoreContainer) == 0x0006B0, "Wrong size on UUI_TDM_SubScoreContainer");
static_assert(offsetof(UUI_TDM_SubScoreContainer, HorizontalBox) == 0x0004F0, "Member 'UUI_TDM_SubScoreContainer::HorizontalBox' has a wrong offset!");
static_assert(offsetof(UUI_TDM_SubScoreContainer, _SlotClass) == 0x0004F8, "Member 'UUI_TDM_SubScoreContainer::_SlotClass' has a wrong offset!");
static_assert(offsetof(UUI_TDM_SubScoreContainer, _MyTeamBGBrush) == 0x000500, "Member 'UUI_TDM_SubScoreContainer::_MyTeamBGBrush' has a wrong offset!");
static_assert(offsetof(UUI_TDM_SubScoreContainer, _EnemyTeamBGBrush) == 0x0005D0, "Member 'UUI_TDM_SubScoreContainer::_EnemyTeamBGBrush' has a wrong offset!");
static_assert(offsetof(UUI_TDM_SubScoreContainer, _IsMyTeam) == 0x0006A0, "Member 'UUI_TDM_SubScoreContainer::_IsMyTeam' has a wrong offset!");

// Class Stigma.Buff_ScanRange
// 0x0038 (0x0130 - 0x00F8)
class UBuff_ScanRange : public UBuffBase
{
public:
	struct FBuffValue                             _distance;                                         // 0x00F8(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Buff_ScanRange">();
	}
	static class UBuff_ScanRange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuff_ScanRange>();
	}
};
static_assert(alignof(UBuff_ScanRange) == 0x000008, "Wrong alignment on UBuff_ScanRange");
static_assert(sizeof(UBuff_ScanRange) == 0x000130, "Wrong size on UBuff_ScanRange");
static_assert(offsetof(UBuff_ScanRange, _distance) == 0x0000F8, "Member 'UBuff_ScanRange::_distance' has a wrong offset!");

// Class Stigma.Buff_ScanRangeDistance
// 0x0038 (0x0130 - 0x00F8)
class UBuff_ScanRangeDistance : public UBuffBase
{
public:
	struct FBuffValue                             _distance;                                         // 0x00F8(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Buff_ScanRangeDistance">();
	}
	static class UBuff_ScanRangeDistance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuff_ScanRangeDistance>();
	}
};
static_assert(alignof(UBuff_ScanRangeDistance) == 0x000008, "Wrong alignment on UBuff_ScanRangeDistance");
static_assert(sizeof(UBuff_ScanRangeDistance) == 0x000130, "Wrong size on UBuff_ScanRangeDistance");
static_assert(offsetof(UBuff_ScanRangeDistance, _distance) == 0x0000F8, "Member 'UBuff_ScanRangeDistance::_distance' has a wrong offset!");

// Class Stigma.GunnerSystemComponent_Snipe
// 0x00B0 (0x0168 - 0x00B8)
class UGunnerSystemComponent_Snipe final : public UGunnerSystemComponent
{
public:
	TSubclassOf<class USpecterAnimInstance>       DefaultStanceAnimBPClass;                          // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USpecterAnimInstance>       SnipeStanceAnimBPClass;                            // 0x00C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USpecterAnimInstance>       DefaultStance1PVAnimBPClass;                       // 0x00C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USpecterAnimInstance>       SnipeStance1PVAnimBPClass;                         // 0x00D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECharaAction                                  _SnipeStanceTargetAction;                          // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_218A[0x7];                                     // 0x00D9(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FItemID                                _GunSight_Snipe;                                   // 0x00E0(0x0010)(Edit, BlueprintVisible, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGunType                                      _GunType;                                          // 0x00F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_218B[0x7];                                     // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FSnipeFXData                           _ChargingFXData;                                   // 0x00F8(0x0048)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FSnipeFXData>                   _ShotFXData;                                       // 0x0140(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      _ChargingFX;                                       // 0x0150(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _ElapsedChargingTime;                              // 0x0158(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_218C[0xC];                                     // 0x015C(0x000C)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnRep_ElapsedChargingTime();
	void Setter_ElapsedChargingTime(float _elapsed_time);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GunnerSystemComponent_Snipe">();
	}
	static class UGunnerSystemComponent_Snipe* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGunnerSystemComponent_Snipe>();
	}
};
static_assert(alignof(UGunnerSystemComponent_Snipe) == 0x000008, "Wrong alignment on UGunnerSystemComponent_Snipe");
static_assert(sizeof(UGunnerSystemComponent_Snipe) == 0x000168, "Wrong size on UGunnerSystemComponent_Snipe");
static_assert(offsetof(UGunnerSystemComponent_Snipe, DefaultStanceAnimBPClass) == 0x0000B8, "Member 'UGunnerSystemComponent_Snipe::DefaultStanceAnimBPClass' has a wrong offset!");
static_assert(offsetof(UGunnerSystemComponent_Snipe, SnipeStanceAnimBPClass) == 0x0000C0, "Member 'UGunnerSystemComponent_Snipe::SnipeStanceAnimBPClass' has a wrong offset!");
static_assert(offsetof(UGunnerSystemComponent_Snipe, DefaultStance1PVAnimBPClass) == 0x0000C8, "Member 'UGunnerSystemComponent_Snipe::DefaultStance1PVAnimBPClass' has a wrong offset!");
static_assert(offsetof(UGunnerSystemComponent_Snipe, SnipeStance1PVAnimBPClass) == 0x0000D0, "Member 'UGunnerSystemComponent_Snipe::SnipeStance1PVAnimBPClass' has a wrong offset!");
static_assert(offsetof(UGunnerSystemComponent_Snipe, _SnipeStanceTargetAction) == 0x0000D8, "Member 'UGunnerSystemComponent_Snipe::_SnipeStanceTargetAction' has a wrong offset!");
static_assert(offsetof(UGunnerSystemComponent_Snipe, _GunSight_Snipe) == 0x0000E0, "Member 'UGunnerSystemComponent_Snipe::_GunSight_Snipe' has a wrong offset!");
static_assert(offsetof(UGunnerSystemComponent_Snipe, _GunType) == 0x0000F0, "Member 'UGunnerSystemComponent_Snipe::_GunType' has a wrong offset!");
static_assert(offsetof(UGunnerSystemComponent_Snipe, _ChargingFXData) == 0x0000F8, "Member 'UGunnerSystemComponent_Snipe::_ChargingFXData' has a wrong offset!");
static_assert(offsetof(UGunnerSystemComponent_Snipe, _ShotFXData) == 0x000140, "Member 'UGunnerSystemComponent_Snipe::_ShotFXData' has a wrong offset!");
static_assert(offsetof(UGunnerSystemComponent_Snipe, _ChargingFX) == 0x000150, "Member 'UGunnerSystemComponent_Snipe::_ChargingFX' has a wrong offset!");
static_assert(offsetof(UGunnerSystemComponent_Snipe, _ElapsedChargingTime) == 0x000158, "Member 'UGunnerSystemComponent_Snipe::_ElapsedChargingTime' has a wrong offset!");

// Class Stigma.Buff_SpeedBoost
// 0x00A8 (0x01A0 - 0x00F8)
class UBuff_SpeedBoost : public UBuffBase
{
public:
	struct FBuffValue                             _SpeedBoost_Stand;                                 // 0x00F8(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBuffValue                             _SpeedBoost_Crouch;                                // 0x0130(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBuffValue                             _SpeedBoost_Aim;                                   // 0x0168(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Buff_SpeedBoost">();
	}
	static class UBuff_SpeedBoost* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuff_SpeedBoost>();
	}
};
static_assert(alignof(UBuff_SpeedBoost) == 0x000008, "Wrong alignment on UBuff_SpeedBoost");
static_assert(sizeof(UBuff_SpeedBoost) == 0x0001A0, "Wrong size on UBuff_SpeedBoost");
static_assert(offsetof(UBuff_SpeedBoost, _SpeedBoost_Stand) == 0x0000F8, "Member 'UBuff_SpeedBoost::_SpeedBoost_Stand' has a wrong offset!");
static_assert(offsetof(UBuff_SpeedBoost, _SpeedBoost_Crouch) == 0x000130, "Member 'UBuff_SpeedBoost::_SpeedBoost_Crouch' has a wrong offset!");
static_assert(offsetof(UBuff_SpeedBoost, _SpeedBoost_Aim) == 0x000168, "Member 'UBuff_SpeedBoost::_SpeedBoost_Aim' has a wrong offset!");

// Class Stigma.HitDataBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UHitDataBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FDamageDef GetDamage(const struct FHitData& _hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitDataBlueprintLibrary">();
	}
	static class UHitDataBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitDataBlueprintLibrary>();
	}
};
static_assert(alignof(UHitDataBlueprintLibrary) == 0x000008, "Wrong alignment on UHitDataBlueprintLibrary");
static_assert(sizeof(UHitDataBlueprintLibrary) == 0x000028, "Wrong size on UHitDataBlueprintLibrary");

// Class Stigma.CameraBoomComponent
// 0x01D0 (0x0570 - 0x03A0)
class UCameraBoomComponent final : public USpringArmComponent
{
public:
	uint8                                         Pad_218E[0x4];                                     // 0x03A0(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         EyeHeight;                                         // 0x03A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_218F[0x1C8];                                   // 0x03A8(0x01C8)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Reset();
	void SetCameraDirectingParams(const struct FCameraDirectingParams& Params_0);
	void SetMode(ECameraWalkMode _new_mode, bool _smoothing);
	void SetSideViewAimLocation(const struct FVector& _loc);
	void SetSideViewTargetLocation(const struct FVector& _loc);

	ECameraWalkMode GetMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraBoomComponent">();
	}
	static class UCameraBoomComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraBoomComponent>();
	}
};
static_assert(alignof(UCameraBoomComponent) == 0x000010, "Wrong alignment on UCameraBoomComponent");
static_assert(sizeof(UCameraBoomComponent) == 0x000570, "Wrong size on UCameraBoomComponent");
static_assert(offsetof(UCameraBoomComponent, EyeHeight) == 0x0003A4, "Member 'UCameraBoomComponent::EyeHeight' has a wrong offset!");

// Class Stigma.CameraModifier_Recoil
// 0x0000 (0x0048 - 0x0048)
class UCameraModifier_Recoil final : public UCameraModifier
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraModifier_Recoil">();
	}
	static class UCameraModifier_Recoil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraModifier_Recoil>();
	}
};
static_assert(alignof(UCameraModifier_Recoil) == 0x000008, "Wrong alignment on UCameraModifier_Recoil");
static_assert(sizeof(UCameraModifier_Recoil) == 0x000048, "Wrong size on UCameraModifier_Recoil");

// Class Stigma.CameraOffset
// 0x0020 (0x0050 - 0x0030)
class UCameraOffset final : public UAnimNotifyState
{
public:
	struct FVector                                Offset;                                            // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Speed;                                             // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2190[0x4];                                     // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraOffset">();
	}
	static class UCameraOffset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraOffset>();
	}
};
static_assert(alignof(UCameraOffset) == 0x000008, "Wrong alignment on UCameraOffset");
static_assert(sizeof(UCameraOffset) == 0x000050, "Wrong size on UCameraOffset");
static_assert(offsetof(UCameraOffset, Offset) == 0x000030, "Member 'UCameraOffset::Offset' has a wrong offset!");
static_assert(offsetof(UCameraOffset, Speed) == 0x000048, "Member 'UCameraOffset::Speed' has a wrong offset!");

// Class Stigma.KeyBindingSubsys
// 0x0120 (0x0150 - 0x0030)
class UKeyBindingSubsys final : public UGameInstanceSubsystem
{
public:
	TMap<ECharaType, struct FKeyMappingsMap>      _KeyBinding_Map;                                   // 0x0030(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<EIMCType, struct FInputMappingContextConfig> _IMC_Map;                                          // 0x0080(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             _KeyDisplayTextTable;                              // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2191[0x78];                                    // 0x00D8(0x0078)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ChangeInputMappingContext(class ULocalPlayer* _local_player, EIMCType _imc_type, bool _is_active);
	struct FKeyMapping FindKeyMapping(EInputAction _input_action, EInputSlotType _slot_type, ECharaType _chara_type);
	struct FKeyMappings FindKeyMappings(EInputAction _input_action, ECharaType _chara_type);
	struct FKey GetKeyByIMC(class ULocalPlayer* _local_player, EIMCType _imc_type, EInputAction _input_action);
	class FText GetKeyDisplayText(const struct FKey& _Key);
	bool HasMappingContext(class ULocalPlayer* _local_player, EIMCType _imc_type);
	bool IsCombinationKey(const struct FKey& _Key);
	bool IsUsedInterceptor();
	bool IsValidInputKey(const struct FKey& _Key);
	void RequestInputKeyInterceptor(class UCtrl_OptionKeyBindBase* _host);
	void StopInputKeyInterceptor(bool _is_roll_back, bool _is_update_key_mapping);
	void ToastDisableKey();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KeyBindingSubsys">();
	}
	static class UKeyBindingSubsys* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKeyBindingSubsys>();
	}
};
static_assert(alignof(UKeyBindingSubsys) == 0x000008, "Wrong alignment on UKeyBindingSubsys");
static_assert(sizeof(UKeyBindingSubsys) == 0x000150, "Wrong size on UKeyBindingSubsys");
static_assert(offsetof(UKeyBindingSubsys, _KeyBinding_Map) == 0x000030, "Member 'UKeyBindingSubsys::_KeyBinding_Map' has a wrong offset!");
static_assert(offsetof(UKeyBindingSubsys, _IMC_Map) == 0x000080, "Member 'UKeyBindingSubsys::_IMC_Map' has a wrong offset!");
static_assert(offsetof(UKeyBindingSubsys, _KeyDisplayTextTable) == 0x0000D0, "Member 'UKeyBindingSubsys::_KeyDisplayTextTable' has a wrong offset!");

// Class Stigma.UI_Record_KDA_Master
// 0x0040 (0x0300 - 0x02C0)
class UUI_Record_KDA_Master : public UUserWidget
{
public:
	class UImage*                                 IMG_Pose;                                          // 0x02C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_CharacterName;                                 // 0x02C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_KDA;                                           // 0x02D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              IMG_NullPose;                                      // 0x02D8(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Record_KDA_Master">();
	}
	static class UUI_Record_KDA_Master* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Record_KDA_Master>();
	}
};
static_assert(alignof(UUI_Record_KDA_Master) == 0x000008, "Wrong alignment on UUI_Record_KDA_Master");
static_assert(sizeof(UUI_Record_KDA_Master) == 0x000300, "Wrong size on UUI_Record_KDA_Master");
static_assert(offsetof(UUI_Record_KDA_Master, IMG_Pose) == 0x0002C0, "Member 'UUI_Record_KDA_Master::IMG_Pose' has a wrong offset!");
static_assert(offsetof(UUI_Record_KDA_Master, TXT_CharacterName) == 0x0002C8, "Member 'UUI_Record_KDA_Master::TXT_CharacterName' has a wrong offset!");
static_assert(offsetof(UUI_Record_KDA_Master, TXT_KDA) == 0x0002D0, "Member 'UUI_Record_KDA_Master::TXT_KDA' has a wrong offset!");
static_assert(offsetof(UUI_Record_KDA_Master, IMG_NullPose) == 0x0002D8, "Member 'UUI_Record_KDA_Master::IMG_NullPose' has a wrong offset!");

// Class Stigma.CameraWalk
// 0x0008 (0x0038 - 0x0030)
class UCameraWalk final : public UAnimNotifyState
{
public:
	ECameraWalkMode                               Mode;                                              // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESideViewSide                                 Side;                                              // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2199[0x6];                                     // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CameraWalk">();
	}
	static class UCameraWalk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCameraWalk>();
	}
};
static_assert(alignof(UCameraWalk) == 0x000008, "Wrong alignment on UCameraWalk");
static_assert(sizeof(UCameraWalk) == 0x000038, "Wrong size on UCameraWalk");
static_assert(offsetof(UCameraWalk, Mode) == 0x000030, "Member 'UCameraWalk::Mode' has a wrong offset!");
static_assert(offsetof(UCameraWalk, Side) == 0x000031, "Member 'UCameraWalk::Side' has a wrong offset!");

// Class Stigma.EnvQueryContext_GetPreemptLocation
// 0x0000 (0x0028 - 0x0028)
class UEnvQueryContext_GetPreemptLocation final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_GetPreemptLocation">();
	}
	static class UEnvQueryContext_GetPreemptLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_GetPreemptLocation>();
	}
};
static_assert(alignof(UEnvQueryContext_GetPreemptLocation) == 0x000008, "Wrong alignment on UEnvQueryContext_GetPreemptLocation");
static_assert(sizeof(UEnvQueryContext_GetPreemptLocation) == 0x000028, "Wrong size on UEnvQueryContext_GetPreemptLocation");

// Class Stigma.CamMesh
// 0x0008 (0x02A0 - 0x0298)
class ACamMesh : public AActor
{
public:
	int32                                         _CamIndex;                                         // 0x0298(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_219A[0x4];                                     // 0x029C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	int32 GetCamIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CamMesh">();
	}
	static class ACamMesh* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACamMesh>();
	}
};
static_assert(alignof(ACamMesh) == 0x000008, "Wrong alignment on ACamMesh");
static_assert(sizeof(ACamMesh) == 0x0002A0, "Wrong size on ACamMesh");
static_assert(offsetof(ACamMesh, _CamIndex) == 0x000298, "Member 'ACamMesh::_CamIndex' has a wrong offset!");

// Class Stigma.UI_Tooltip
// 0x00F0 (0x05E0 - 0x04F0)
class UUI_Tooltip : public UPreviewableWidget
{
public:
	class UWidgetSwitcher*                        WidgetSwitcher;                                    // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_CircleProgress;                                // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               SB_Main;                                           // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Ovl_Title;                                         // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_Title;                                         // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               SB_Desc;                                           // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Desc;                                          // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNamedSlot*                             Contents_1;                                        // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNamedSlot*                             Contents_2;                                        // 0x0530(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNamedSlot*                             Contents_3;                                        // 0x0538(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNamedSlot*                             Contents_4;                                        // 0x0540(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNamedSlot*                             Contents_5;                                        // 0x0548(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNamedSlot*                             Contents_6;                                        // 0x0550(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_TooltipKeyContainer*                UI_TooltipKeyContainer;                            // 0x0558(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _NoDelay;                                          // 0x0560(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_219B[0x17];                                    // 0x0561(0x0017)(Fixing Size After Last Property [ Dumper-69 ])
	class UMaterialInterface*                     _CircleProgressMateralParent;                      // 0x0578(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               _CircleProgressMaterial;                           // 0x0580(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         _TooltipWidth;                                     // 0x0588(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_219C[0x4];                                     // 0x058C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class FText                                   _TitleText;                                        // 0x0590(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          _ShowTitle;                                        // 0x05A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_219D[0x7];                                     // 0x05A9(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class FText                                   _DescText;                                         // 0x05B0(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         _DescMinHeight;                                    // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _ShowDesc;                                         // 0x05CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_219E[0x3];                                     // 0x05CD(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FTooltipKeyInfo>                _KeyInfos;                                         // 0x05D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void AddTooltipKey(const struct FTooltipKeyInfo& _key_info);
	void ClearTooltipKeys();
	void OnShowTooltip();
	void SetDesc(const class FText& _Desc);
	void SetTitle(const class FText& _Title);
	void SetWidth(float _width);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Tooltip">();
	}
	static class UUI_Tooltip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Tooltip>();
	}
};
static_assert(alignof(UUI_Tooltip) == 0x000008, "Wrong alignment on UUI_Tooltip");
static_assert(sizeof(UUI_Tooltip) == 0x0005E0, "Wrong size on UUI_Tooltip");
static_assert(offsetof(UUI_Tooltip, WidgetSwitcher) == 0x0004F0, "Member 'UUI_Tooltip::WidgetSwitcher' has a wrong offset!");
static_assert(offsetof(UUI_Tooltip, Img_CircleProgress) == 0x0004F8, "Member 'UUI_Tooltip::Img_CircleProgress' has a wrong offset!");
static_assert(offsetof(UUI_Tooltip, SB_Main) == 0x000500, "Member 'UUI_Tooltip::SB_Main' has a wrong offset!");
static_assert(offsetof(UUI_Tooltip, Ovl_Title) == 0x000508, "Member 'UUI_Tooltip::Ovl_Title' has a wrong offset!");
static_assert(offsetof(UUI_Tooltip, Txt_Title) == 0x000510, "Member 'UUI_Tooltip::Txt_Title' has a wrong offset!");
static_assert(offsetof(UUI_Tooltip, SB_Desc) == 0x000518, "Member 'UUI_Tooltip::SB_Desc' has a wrong offset!");
static_assert(offsetof(UUI_Tooltip, TXT_Desc) == 0x000520, "Member 'UUI_Tooltip::TXT_Desc' has a wrong offset!");
static_assert(offsetof(UUI_Tooltip, Contents_1) == 0x000528, "Member 'UUI_Tooltip::Contents_1' has a wrong offset!");
static_assert(offsetof(UUI_Tooltip, Contents_2) == 0x000530, "Member 'UUI_Tooltip::Contents_2' has a wrong offset!");
static_assert(offsetof(UUI_Tooltip, Contents_3) == 0x000538, "Member 'UUI_Tooltip::Contents_3' has a wrong offset!");
static_assert(offsetof(UUI_Tooltip, Contents_4) == 0x000540, "Member 'UUI_Tooltip::Contents_4' has a wrong offset!");
static_assert(offsetof(UUI_Tooltip, Contents_5) == 0x000548, "Member 'UUI_Tooltip::Contents_5' has a wrong offset!");
static_assert(offsetof(UUI_Tooltip, Contents_6) == 0x000550, "Member 'UUI_Tooltip::Contents_6' has a wrong offset!");
static_assert(offsetof(UUI_Tooltip, UI_TooltipKeyContainer) == 0x000558, "Member 'UUI_Tooltip::UI_TooltipKeyContainer' has a wrong offset!");
static_assert(offsetof(UUI_Tooltip, _NoDelay) == 0x000560, "Member 'UUI_Tooltip::_NoDelay' has a wrong offset!");
static_assert(offsetof(UUI_Tooltip, _CircleProgressMateralParent) == 0x000578, "Member 'UUI_Tooltip::_CircleProgressMateralParent' has a wrong offset!");
static_assert(offsetof(UUI_Tooltip, _CircleProgressMaterial) == 0x000580, "Member 'UUI_Tooltip::_CircleProgressMaterial' has a wrong offset!");
static_assert(offsetof(UUI_Tooltip, _TooltipWidth) == 0x000588, "Member 'UUI_Tooltip::_TooltipWidth' has a wrong offset!");
static_assert(offsetof(UUI_Tooltip, _TitleText) == 0x000590, "Member 'UUI_Tooltip::_TitleText' has a wrong offset!");
static_assert(offsetof(UUI_Tooltip, _ShowTitle) == 0x0005A8, "Member 'UUI_Tooltip::_ShowTitle' has a wrong offset!");
static_assert(offsetof(UUI_Tooltip, _DescText) == 0x0005B0, "Member 'UUI_Tooltip::_DescText' has a wrong offset!");
static_assert(offsetof(UUI_Tooltip, _DescMinHeight) == 0x0005C8, "Member 'UUI_Tooltip::_DescMinHeight' has a wrong offset!");
static_assert(offsetof(UUI_Tooltip, _ShowDesc) == 0x0005CC, "Member 'UUI_Tooltip::_ShowDesc' has a wrong offset!");
static_assert(offsetof(UUI_Tooltip, _KeyInfos) == 0x0005D0, "Member 'UUI_Tooltip::_KeyInfos' has a wrong offset!");

// Class Stigma.CanTransit
// 0x0000 (0x0030 - 0x0030)
class UCanTransit final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CanTransit">();
	}
	static class UCanTransit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCanTransit>();
	}
};
static_assert(alignof(UCanTransit) == 0x000008, "Wrong alignment on UCanTransit");
static_assert(sizeof(UCanTransit) == 0x000030, "Wrong size on UCanTransit");

// Class Stigma.CapsuleCollision
// 0x0000 (0x0030 - 0x0030)
class UCapsuleCollision final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CapsuleCollision">();
	}
	static class UCapsuleCollision* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCapsuleCollision>();
	}
};
static_assert(alignof(UCapsuleCollision) == 0x000008, "Wrong alignment on UCapsuleCollision");
static_assert(sizeof(UCapsuleCollision) == 0x000030, "Wrong size on UCapsuleCollision");

// Class Stigma.Damageable
// 0x0000 (0x0028 - 0x0028)
class IDamageable final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Damageable">();
	}
	static class IDamageable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDamageable>();
	}
};
static_assert(alignof(IDamageable) == 0x000008, "Wrong alignment on IDamageable");
static_assert(sizeof(IDamageable) == 0x000028, "Wrong size on IDamageable");

// Class Stigma.Challenge_GameMode
// 0x01C8 (0x09A0 - 0x07D8)
class AChallenge_GameMode : public ABattleGameModeBase
{
public:
	TArray<struct FConfig_ChallengeWave>          Waves;                                             // 0x07D8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FChallengeWaves                        ActivatedWaves;                                    // 0x07E8(0x0010)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FChallengeWaves                        RemainWaves;                                       // 0x07F8(0x0010)(Transient, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UChallenge_SubSystem>    ChallengeSubSystem;                                // 0x0808(0x0028)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FConfig_ChallengeRound                 CurrentRoundConfig;                                // 0x0830(0x0038)(Transient, Protected, NativeAccessSpecifierProtected)
	ETeams                                        Teams_AI;                                          // 0x0868(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeams                                        Teams_Player;                                      // 0x0869(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_219F[0xE];                                     // 0x086A(0x000E)(Fixing Size After Last Property [ Dumper-69 ])
	TMap<int32, class APlayerStart_AI*>           SpawnPoints;                                       // 0x0878(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TMap<int32, struct FConfig_Challenge_AIChara> CharaConfigs_AI;                                   // 0x08C8(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	TArray<class AAICharaBase*>                   AI_Charas;                                         // 0x0918(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AAICharaBase>               AICharaClass;                                      // 0x0928(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBehaviorTree*                          BehaviorTree;                                      // 0x0930(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CountDownTime;                                     // 0x0938(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21A0[0x64];                                    // 0x093C(0x0064)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnMissionUpdated(EMissionUpdateType _type, class UMission* _mission);

	struct FConfig_Challenge_AIChara GetCharConfig_AI(int32 _index) const;
	int32 GetCurrentWaveIndex() const;
	struct FChallengeWaves GetCurrentWaves() const;
	struct FChallengeWaves GetNextWaves() const;
	class APlayerStart_AI* GetSpawnPoint(int32 _index) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Challenge_GameMode">();
	}
	static class AChallenge_GameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChallenge_GameMode>();
	}
};
static_assert(alignof(AChallenge_GameMode) == 0x000008, "Wrong alignment on AChallenge_GameMode");
static_assert(sizeof(AChallenge_GameMode) == 0x0009A0, "Wrong size on AChallenge_GameMode");
static_assert(offsetof(AChallenge_GameMode, Waves) == 0x0007D8, "Member 'AChallenge_GameMode::Waves' has a wrong offset!");
static_assert(offsetof(AChallenge_GameMode, ActivatedWaves) == 0x0007E8, "Member 'AChallenge_GameMode::ActivatedWaves' has a wrong offset!");
static_assert(offsetof(AChallenge_GameMode, RemainWaves) == 0x0007F8, "Member 'AChallenge_GameMode::RemainWaves' has a wrong offset!");
static_assert(offsetof(AChallenge_GameMode, ChallengeSubSystem) == 0x000808, "Member 'AChallenge_GameMode::ChallengeSubSystem' has a wrong offset!");
static_assert(offsetof(AChallenge_GameMode, CurrentRoundConfig) == 0x000830, "Member 'AChallenge_GameMode::CurrentRoundConfig' has a wrong offset!");
static_assert(offsetof(AChallenge_GameMode, Teams_AI) == 0x000868, "Member 'AChallenge_GameMode::Teams_AI' has a wrong offset!");
static_assert(offsetof(AChallenge_GameMode, Teams_Player) == 0x000869, "Member 'AChallenge_GameMode::Teams_Player' has a wrong offset!");
static_assert(offsetof(AChallenge_GameMode, SpawnPoints) == 0x000878, "Member 'AChallenge_GameMode::SpawnPoints' has a wrong offset!");
static_assert(offsetof(AChallenge_GameMode, CharaConfigs_AI) == 0x0008C8, "Member 'AChallenge_GameMode::CharaConfigs_AI' has a wrong offset!");
static_assert(offsetof(AChallenge_GameMode, AI_Charas) == 0x000918, "Member 'AChallenge_GameMode::AI_Charas' has a wrong offset!");
static_assert(offsetof(AChallenge_GameMode, AICharaClass) == 0x000928, "Member 'AChallenge_GameMode::AICharaClass' has a wrong offset!");
static_assert(offsetof(AChallenge_GameMode, BehaviorTree) == 0x000930, "Member 'AChallenge_GameMode::BehaviorTree' has a wrong offset!");
static_assert(offsetof(AChallenge_GameMode, CountDownTime) == 0x000938, "Member 'AChallenge_GameMode::CountDownTime' has a wrong offset!");

// Class Stigma.DoorBase
// 0x01B8 (0x0450 - 0x0298)
class ADoorBase final : public AActor
{
public:
	bool                                          IsOpened;                                          // 0x0298(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21A4[0x3];                                     // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         Speed;                                             // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             CloseTransform;                                    // 0x02A0(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             OpenTransform;                                     // 0x0300(0x0060)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              OpenSoundCue;                                      // 0x0360(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              CloseSoundCue;                                     // 0x0368(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21A5[0xD0];                                    // 0x0370(0x00D0)(Fixing Size After Last Property [ Dumper-69 ])
	class UMeshComponent*                         _Mesh;                                             // 0x0440(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21A6[0x8];                                     // 0x0448(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Close();
	void InitDoor();
	void OnRep_IsOpened();
	void Open();
	void Setter_IsOpened(bool _is_opened);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DoorBase">();
	}
	static class ADoorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADoorBase>();
	}
};
static_assert(alignof(ADoorBase) == 0x000010, "Wrong alignment on ADoorBase");
static_assert(sizeof(ADoorBase) == 0x000450, "Wrong size on ADoorBase");
static_assert(offsetof(ADoorBase, IsOpened) == 0x000298, "Member 'ADoorBase::IsOpened' has a wrong offset!");
static_assert(offsetof(ADoorBase, Speed) == 0x00029C, "Member 'ADoorBase::Speed' has a wrong offset!");
static_assert(offsetof(ADoorBase, CloseTransform) == 0x0002A0, "Member 'ADoorBase::CloseTransform' has a wrong offset!");
static_assert(offsetof(ADoorBase, OpenTransform) == 0x000300, "Member 'ADoorBase::OpenTransform' has a wrong offset!");
static_assert(offsetof(ADoorBase, OpenSoundCue) == 0x000360, "Member 'ADoorBase::OpenSoundCue' has a wrong offset!");
static_assert(offsetof(ADoorBase, CloseSoundCue) == 0x000368, "Member 'ADoorBase::CloseSoundCue' has a wrong offset!");
static_assert(offsetof(ADoorBase, _Mesh) == 0x000440, "Member 'ADoorBase::_Mesh' has a wrong offset!");

// Class Stigma.Challenge_GameState
// 0x0040 (0x0948 - 0x0908)
class AChallenge_GameState : public ABattleGameStateBase
{
public:
	int32                                         Gold;                                              // 0x0908(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlackCoinCount;                                    // 0x090C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TicketUsed;                                        // 0x0910(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrevBestScore;                                     // 0x0914(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FChallengeResult                       _PrevResult;                                       // 0x0918(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         FreeItemCount_Challenge;                           // 0x0938(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GoldBoxValue;                                      // 0x093C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisableControlTimeOnRoundStart;                    // 0x0940(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21A7[0x4];                                     // 0x0944(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Challenge_GameState">();
	}
	static class AChallenge_GameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChallenge_GameState>();
	}
};
static_assert(alignof(AChallenge_GameState) == 0x000008, "Wrong alignment on AChallenge_GameState");
static_assert(sizeof(AChallenge_GameState) == 0x000948, "Wrong size on AChallenge_GameState");
static_assert(offsetof(AChallenge_GameState, Gold) == 0x000908, "Member 'AChallenge_GameState::Gold' has a wrong offset!");
static_assert(offsetof(AChallenge_GameState, BlackCoinCount) == 0x00090C, "Member 'AChallenge_GameState::BlackCoinCount' has a wrong offset!");
static_assert(offsetof(AChallenge_GameState, TicketUsed) == 0x000910, "Member 'AChallenge_GameState::TicketUsed' has a wrong offset!");
static_assert(offsetof(AChallenge_GameState, PrevBestScore) == 0x000914, "Member 'AChallenge_GameState::PrevBestScore' has a wrong offset!");
static_assert(offsetof(AChallenge_GameState, _PrevResult) == 0x000918, "Member 'AChallenge_GameState::_PrevResult' has a wrong offset!");
static_assert(offsetof(AChallenge_GameState, FreeItemCount_Challenge) == 0x000938, "Member 'AChallenge_GameState::FreeItemCount_Challenge' has a wrong offset!");
static_assert(offsetof(AChallenge_GameState, GoldBoxValue) == 0x00093C, "Member 'AChallenge_GameState::GoldBoxValue' has a wrong offset!");
static_assert(offsetof(AChallenge_GameState, DisableControlTimeOnRoundStart) == 0x000940, "Member 'AChallenge_GameState::DisableControlTimeOnRoundStart' has a wrong offset!");

// Class Stigma.UI_TextDialogue
// 0x0058 (0x0548 - 0x04F0)
class UUI_TextDialogue : public UPreviewableWidget
{
public:
	class URichTextBlock*                         RTxt_Message;                                      // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         RTxt_Message_Hidden;                               // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _TypeWritingSpeed;                                 // 0x0500(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21A8[0x4];                                     // 0x0504(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class FText                                   _SourceText;                                       // 0x0508(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_21A9[0x28];                                    // 0x0520(0x0028)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void SetSpeed(int32 _Speed);
	void SetText(const class FText& _text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_TextDialogue">();
	}
	static class UUI_TextDialogue* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_TextDialogue>();
	}
};
static_assert(alignof(UUI_TextDialogue) == 0x000008, "Wrong alignment on UUI_TextDialogue");
static_assert(sizeof(UUI_TextDialogue) == 0x000548, "Wrong size on UUI_TextDialogue");
static_assert(offsetof(UUI_TextDialogue, RTxt_Message) == 0x0004F0, "Member 'UUI_TextDialogue::RTxt_Message' has a wrong offset!");
static_assert(offsetof(UUI_TextDialogue, RTxt_Message_Hidden) == 0x0004F8, "Member 'UUI_TextDialogue::RTxt_Message_Hidden' has a wrong offset!");
static_assert(offsetof(UUI_TextDialogue, _TypeWritingSpeed) == 0x000500, "Member 'UUI_TextDialogue::_TypeWritingSpeed' has a wrong offset!");
static_assert(offsetof(UUI_TextDialogue, _SourceText) == 0x000508, "Member 'UUI_TextDialogue::_SourceText' has a wrong offset!");

// Class Stigma.UI_TextDialogue_Mission
// 0x0030 (0x0578 - 0x0548)
class UUI_TextDialogue_Mission : public UUI_TextDialogue
{
public:
	EMissionType                                  _MissionType;                                      // 0x0548(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21AA[0x7];                                     // 0x0549(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FItemID                                _TaskID;                                           // 0x0550(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemIDRef_Mission                     _TargetMissionID;                                  // 0x0560(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMission*                               _mission;                                          // 0x0570(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UMission* GetMission();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_TextDialogue_Mission">();
	}
	static class UUI_TextDialogue_Mission* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_TextDialogue_Mission>();
	}
};
static_assert(alignof(UUI_TextDialogue_Mission) == 0x000008, "Wrong alignment on UUI_TextDialogue_Mission");
static_assert(sizeof(UUI_TextDialogue_Mission) == 0x000578, "Wrong size on UUI_TextDialogue_Mission");
static_assert(offsetof(UUI_TextDialogue_Mission, _MissionType) == 0x000548, "Member 'UUI_TextDialogue_Mission::_MissionType' has a wrong offset!");
static_assert(offsetof(UUI_TextDialogue_Mission, _TaskID) == 0x000550, "Member 'UUI_TextDialogue_Mission::_TaskID' has a wrong offset!");
static_assert(offsetof(UUI_TextDialogue_Mission, _TargetMissionID) == 0x000560, "Member 'UUI_TextDialogue_Mission::_TargetMissionID' has a wrong offset!");
static_assert(offsetof(UUI_TextDialogue_Mission, _mission) == 0x000570, "Member 'UUI_TextDialogue_Mission::_mission' has a wrong offset!");

// Class Stigma.Challenge_PlayerController
// 0x0010 (0x0E50 - 0x0E40)
class AChallenge_PlayerController : public ABattlePlayerControllerBase
{
public:
	FMulticastInlineDelegateProperty_             OnSkipPopupPressedEvent;                           // 0x0E40(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnFinishRound(const struct FChallengeResult& _prev, const struct FChallengeResult& _result);
	void RPC_CLIENT_ChallengeResult(const TArray<struct FACK_ChallengeRead>& _top3, const TArray<struct FACK_ChallengeRead>& _rankers);
	void RPC_CLIENT_FinishRound(const struct FChallengeResult& _prev, const struct FChallengeResult& _result);
	void RPC_SERVER_DriveNextRound(bool _is_round_clear);
	void RPC_SERVER_FinishChallengeMode();
	void RPC_SERVER_StartRound();
	void ShowChallengeResult(const TArray<struct FACK_ChallengeRead>& _top3, const TArray<struct FACK_ChallengeRead>& _rankers);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Challenge_PlayerController">();
	}
	static class AChallenge_PlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChallenge_PlayerController>();
	}
};
static_assert(alignof(AChallenge_PlayerController) == 0x000008, "Wrong alignment on AChallenge_PlayerController");
static_assert(sizeof(AChallenge_PlayerController) == 0x000E50, "Wrong size on AChallenge_PlayerController");
static_assert(offsetof(AChallenge_PlayerController, OnSkipPopupPressedEvent) == 0x000E40, "Member 'AChallenge_PlayerController::OnSkipPopupPressedEvent' has a wrong offset!");

// Class Stigma.Challenge_PlayerState
// 0x0048 (0x0CD0 - 0x0C88)
class AChallenge_PlayerState : public ABattlePlayerState
{
public:
	int32                                         _ChallengeBoosterCount;                            // 0x0C88(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21AB[0x4];                                     // 0x0C8C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FBattleResult_Challenge                _BattleResult;                                     // 0x0C90(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, Net, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	const struct FBattleResult_Challenge GetBattleResult() const;
	int32 GetBounsBoosterCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Challenge_PlayerState">();
	}
	static class AChallenge_PlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AChallenge_PlayerState>();
	}
};
static_assert(alignof(AChallenge_PlayerState) == 0x000008, "Wrong alignment on AChallenge_PlayerState");
static_assert(sizeof(AChallenge_PlayerState) == 0x000CD0, "Wrong size on AChallenge_PlayerState");
static_assert(offsetof(AChallenge_PlayerState, _ChallengeBoosterCount) == 0x000C88, "Member 'AChallenge_PlayerState::_ChallengeBoosterCount' has a wrong offset!");
static_assert(offsetof(AChallenge_PlayerState, _BattleResult) == 0x000C90, "Member 'AChallenge_PlayerState::_BattleResult' has a wrong offset!");

// Class Stigma.GoodsObject
// 0x0260 (0x0288 - 0x0028)
class UGoodsObject final : public UObject
{
public:
	struct FItemID                                _ItemID;                                           // 0x0028(0x0010)(Edit, BlueprintVisible, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGoodsTag                              _tags;                                             // 0x0038(0x0005)(Edit, BlueprintVisible, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_21AC[0x3];                                     // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         _DisplaySlot;                                      // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _Discount;                                         // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _BuyCount;                                         // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _Price;                                            // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemID_Currency                       _PriceType;                                        // 0x0050(0x0010)(Edit, BlueprintVisible, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 _CurrencyCode;                                     // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 _Desc;                                             // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FConfig_Goods                          _Config;                                           // 0x0080(0x01F0)(Edit, BlueprintVisible, Transient, Protected, NativeAccessSpecifierProtected)
	struct FDateTime                              _StartAt;                                          // 0x0270(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDateTime                              _EndAt;                                            // 0x0278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _TagWeight;                                        // 0x0280(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21AD[0x4];                                     // 0x0284(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	int32 GetBuyCount() const;
	const struct FConfig_Goods GetConfig() const;
	class FString GetCurrencyCode() const;
	int32 GetDiscount() const;
	const class FText GetDisplayNameText() const;
	int32 GetDisplaySlot() const;
	class FString GetGoodsDesc() const;
	const TSoftObjectPtr<class UTexture2D> GetIcon() const;
	struct FItemID GetItemID() const;
	struct FDateTime GetLaunchingDate() const;
	float GetPrice() const;
	struct FItemID_Currency GetPriceType() const;
	const struct FGoodsTag GetTags() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GoodsObject">();
	}
	static class UGoodsObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGoodsObject>();
	}
};
static_assert(alignof(UGoodsObject) == 0x000008, "Wrong alignment on UGoodsObject");
static_assert(sizeof(UGoodsObject) == 0x000288, "Wrong size on UGoodsObject");
static_assert(offsetof(UGoodsObject, _ItemID) == 0x000028, "Member 'UGoodsObject::_ItemID' has a wrong offset!");
static_assert(offsetof(UGoodsObject, _tags) == 0x000038, "Member 'UGoodsObject::_tags' has a wrong offset!");
static_assert(offsetof(UGoodsObject, _DisplaySlot) == 0x000040, "Member 'UGoodsObject::_DisplaySlot' has a wrong offset!");
static_assert(offsetof(UGoodsObject, _Discount) == 0x000044, "Member 'UGoodsObject::_Discount' has a wrong offset!");
static_assert(offsetof(UGoodsObject, _BuyCount) == 0x000048, "Member 'UGoodsObject::_BuyCount' has a wrong offset!");
static_assert(offsetof(UGoodsObject, _Price) == 0x00004C, "Member 'UGoodsObject::_Price' has a wrong offset!");
static_assert(offsetof(UGoodsObject, _PriceType) == 0x000050, "Member 'UGoodsObject::_PriceType' has a wrong offset!");
static_assert(offsetof(UGoodsObject, _CurrencyCode) == 0x000060, "Member 'UGoodsObject::_CurrencyCode' has a wrong offset!");
static_assert(offsetof(UGoodsObject, _Desc) == 0x000070, "Member 'UGoodsObject::_Desc' has a wrong offset!");
static_assert(offsetof(UGoodsObject, _Config) == 0x000080, "Member 'UGoodsObject::_Config' has a wrong offset!");
static_assert(offsetof(UGoodsObject, _StartAt) == 0x000270, "Member 'UGoodsObject::_StartAt' has a wrong offset!");
static_assert(offsetof(UGoodsObject, _EndAt) == 0x000278, "Member 'UGoodsObject::_EndAt' has a wrong offset!");
static_assert(offsetof(UGoodsObject, _TagWeight) == 0x000280, "Member 'UGoodsObject::_TagWeight' has a wrong offset!");

// Class Stigma.OnlineAccount
// 0x0000 (0x0028 - 0x0028)
class UOnlineAccount final : public UBlueprintFunctionLibrary
{
public:
	static int32 GetHeartBit(const class UObject* WorldContextObject);
	static EPublisher GetPublisher(const class UObject* WorldContextObject);
	static class FString GetPublisherID(const class UObject* WorldContextObject);
	static class FString GetPublisherToken(const class UObject* _world_ctx);
	static class FString GetToken(const class UObject* _world_ctx);
	static bool IsAuthenticated(const class UObject* WorldContextObject);
	static bool SetAuthenticated(const class UObject* WorldContextObject, bool Flag);
	static void SetPublisher(const class UObject* WorldContextObject, EPublisher _Publisher);
	static void SetPublisherID(const class UObject* _world_ctx, const class FString& _Name);
	static void SetPublisherToken(const class UObject* _world_ctx, const class FString& _Token);
	static bool ShouldBeEnterAccountID(const class UObject* _world_ctx);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineAccount">();
	}
	static class UOnlineAccount* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineAccount>();
	}
};
static_assert(alignof(UOnlineAccount) == 0x000008, "Wrong alignment on UOnlineAccount");
static_assert(sizeof(UOnlineAccount) == 0x000028, "Wrong size on UOnlineAccount");

// Class Stigma.Challenge_SubSystem
// 0x0130 (0x0160 - 0x0030)
class UChallenge_SubSystem final : public UGameInstanceSubsystem
{
public:
	int32                                         LastRound;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         StartRound;                                        // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CurrentRound;                                      // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Gold;                                              // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BlackCointCount;                                   // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         BounsTicket;                                       // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TicketUsed;                                        // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FChallengeResult                       PrevResult;                                        // 0x004C(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	int32                                         PrevBestScore;                                     // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21B4[0x48];                                    // 0x0070(0x0048)(Fixing Size After Last Property [ Dumper-69 ])
	struct FACK_ChallengeRead                     LastChallengeACK;                                  // 0x00B8(0x0078)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FConfig_ChallengeRound>         RoundConfigs;                                      // 0x0130(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FConfig_ChallengeWave>          WaveConfigs;                                       // 0x0140(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FConfig_Challenge_AIChara>      AIConfigs;                                         // 0x0150(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	void CalcRankWithCurrentBattleResult(const class UObject* _world_ctx, const TArray<struct FACK_ChallengeRead>& _top3, const TArray<struct FACK_ChallengeRead>& _rankers, const struct FBattleResult_Challenge& _current_battle_result, TArray<struct FACK_ChallengeRead>* _out_top3, TArray<struct FACK_ChallengeRead>* _out_rankers);
	void JumpToBestRound(float _delay_before_jump);
	void ReadMyChallengeRanks(const TDelegate<void()>& _proc);
	void Reset();
	void StartChallengeMode(bool _is_first_round);

	int32 GetBounsTicket() const;
	int32 GetCurrentBlackCoin() const;
	int32 GetCurrentGold() const;
	int32 GetCurrentRound() const;
	struct FConfig_ChallengeRound GetCurrentRoundConfig() const;
	int32 GetLastRound() const;
	int32 GetPrevBestScore() const;
	struct FChallengeResult GetPrevResult() const;
	int32 GetStartRound() const;
	int32 GetTicketUsed() const;
	bool IsStartRound() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Challenge_SubSystem">();
	}
	static class UChallenge_SubSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChallenge_SubSystem>();
	}
};
static_assert(alignof(UChallenge_SubSystem) == 0x000008, "Wrong alignment on UChallenge_SubSystem");
static_assert(sizeof(UChallenge_SubSystem) == 0x000160, "Wrong size on UChallenge_SubSystem");
static_assert(offsetof(UChallenge_SubSystem, LastRound) == 0x000030, "Member 'UChallenge_SubSystem::LastRound' has a wrong offset!");
static_assert(offsetof(UChallenge_SubSystem, StartRound) == 0x000034, "Member 'UChallenge_SubSystem::StartRound' has a wrong offset!");
static_assert(offsetof(UChallenge_SubSystem, CurrentRound) == 0x000038, "Member 'UChallenge_SubSystem::CurrentRound' has a wrong offset!");
static_assert(offsetof(UChallenge_SubSystem, Gold) == 0x00003C, "Member 'UChallenge_SubSystem::Gold' has a wrong offset!");
static_assert(offsetof(UChallenge_SubSystem, BlackCointCount) == 0x000040, "Member 'UChallenge_SubSystem::BlackCointCount' has a wrong offset!");
static_assert(offsetof(UChallenge_SubSystem, BounsTicket) == 0x000044, "Member 'UChallenge_SubSystem::BounsTicket' has a wrong offset!");
static_assert(offsetof(UChallenge_SubSystem, TicketUsed) == 0x000048, "Member 'UChallenge_SubSystem::TicketUsed' has a wrong offset!");
static_assert(offsetof(UChallenge_SubSystem, PrevResult) == 0x00004C, "Member 'UChallenge_SubSystem::PrevResult' has a wrong offset!");
static_assert(offsetof(UChallenge_SubSystem, PrevBestScore) == 0x00006C, "Member 'UChallenge_SubSystem::PrevBestScore' has a wrong offset!");
static_assert(offsetof(UChallenge_SubSystem, LastChallengeACK) == 0x0000B8, "Member 'UChallenge_SubSystem::LastChallengeACK' has a wrong offset!");
static_assert(offsetof(UChallenge_SubSystem, RoundConfigs) == 0x000130, "Member 'UChallenge_SubSystem::RoundConfigs' has a wrong offset!");
static_assert(offsetof(UChallenge_SubSystem, WaveConfigs) == 0x000140, "Member 'UChallenge_SubSystem::WaveConfigs' has a wrong offset!");
static_assert(offsetof(UChallenge_SubSystem, AIConfigs) == 0x000150, "Member 'UChallenge_SubSystem::AIConfigs' has a wrong offset!");

// Class Stigma.CharacterDefineBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UCharacterDefineBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FActionGraphID GetActionGraphID(const struct FCharacterDefine& _define, ECharaAction _slot);
	static struct FCharaGraphValue GetCharaBuffedGraphValue(const struct FCharacterDefine& _define, const struct FCharaBuffEffect& _effect);
	static struct FCharaBuffEffect GetCharaBuffEffectOfBoosters(const TArray<struct FItemID_Booster>& _boosters);
	static struct FCharaBuffEffect GetCharaBuffEffectOfPassiveSkills(const TArray<struct FPassiveSkill>& _passive_skills);
	static ECharaType GetCharaType(const struct FCharacterDefine& _define);
	static struct FCharaGraphValue GetGraphValue(const struct FCharacterDefine& _define);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterDefineBlueprintLibrary">();
	}
	static class UCharacterDefineBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterDefineBlueprintLibrary>();
	}
};
static_assert(alignof(UCharacterDefineBlueprintLibrary) == 0x000008, "Wrong alignment on UCharacterDefineBlueprintLibrary");
static_assert(sizeof(UCharacterDefineBlueprintLibrary) == 0x000028, "Wrong size on UCharacterDefineBlueprintLibrary");

// Class Stigma.CharacterInfoBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UCharacterInfoBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float CalcControlPower(const class UObject* _world_ctx, const struct FCharacterInfo& _info);
	static EArmorType GetArmorType(const struct FCharacterInfo& _info);
	static bool GetBullets(const struct FCharacterInfo& _info, EBulletType* _out_bullet_type, EBulletTip* _out_bullet_tip);
	static EBulletTip GetBulletTipID(const struct FCharacterInfo& _info);
	static bool IsEquipedItemID(const struct FCharacterInfo& _info, const struct FItemID& _id);
	static struct FNetCharacter ToNetCharacter(const struct FCharacterInfo& _info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterInfoBlueprintLibrary">();
	}
	static class UCharacterInfoBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterInfoBlueprintLibrary>();
	}
};
static_assert(alignof(UCharacterInfoBlueprintLibrary) == 0x000008, "Wrong alignment on UCharacterInfoBlueprintLibrary");
static_assert(sizeof(UCharacterInfoBlueprintLibrary) == 0x000028, "Wrong size on UCharacterInfoBlueprintLibrary");

// Class Stigma.CharaShapeComponent
// 0x0010 (0x05B0 - 0x05A0)
class UCharaShapeComponent final : public UCapsuleComponent
{
public:
	TArray<struct FShape>                         _Shapes;                                           // 0x0598(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_21BF[0x8];                                     // 0x05A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharaShapeComponent">();
	}
	static class UCharaShapeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharaShapeComponent>();
	}
};
static_assert(alignof(UCharaShapeComponent) == 0x000010, "Wrong alignment on UCharaShapeComponent");
static_assert(sizeof(UCharaShapeComponent) == 0x0005B0, "Wrong size on UCharaShapeComponent");
static_assert(offsetof(UCharaShapeComponent, _Shapes) == 0x000598, "Member 'UCharaShapeComponent::_Shapes' has a wrong offset!");

// Class Stigma.UI_TeamResultItem
// 0x0078 (0x0568 - 0x04F0)
class UUI_TeamResultItem : public UPreviewableWidget
{
public:
	class UWidget*                                _owner;                                            // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGameMode                                     _mode;                                             // 0x04F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeams                                        _Team;                                             // 0x04F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21C0[0x2];                                     // 0x04FA(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         _Rank;                                             // 0x04FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _score;                                            // 0x0500(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsWonTeam;                                        // 0x0504(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21C1[0x3];                                     // 0x0505(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FUserBattleResult>              _Players;                                          // 0x0508(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_21C2[0x8];                                     // 0x0518(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UUI_PlayerResultItem>       PlayerResultItemWidgetClass;                       // 0x0520(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UTexture2D>>      RankerIcons;                                       // 0x0528(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WS_ScorePerMode;                                   // 0x0538(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_WinCount;                                      // 0x0540(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_Ranking;                                       // 0x0548(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_TeamColor;                                     // 0x0550(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_TransferScore;                                 // 0x0558(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           Container_PlayerResult;                            // 0x0560(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void UpdateUI();

	struct FBattleDecisionDetail GetResult() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_TeamResultItem">();
	}
	static class UUI_TeamResultItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_TeamResultItem>();
	}
};
static_assert(alignof(UUI_TeamResultItem) == 0x000008, "Wrong alignment on UUI_TeamResultItem");
static_assert(sizeof(UUI_TeamResultItem) == 0x000568, "Wrong size on UUI_TeamResultItem");
static_assert(offsetof(UUI_TeamResultItem, _owner) == 0x0004F0, "Member 'UUI_TeamResultItem::_owner' has a wrong offset!");
static_assert(offsetof(UUI_TeamResultItem, _mode) == 0x0004F8, "Member 'UUI_TeamResultItem::_mode' has a wrong offset!");
static_assert(offsetof(UUI_TeamResultItem, _Team) == 0x0004F9, "Member 'UUI_TeamResultItem::_Team' has a wrong offset!");
static_assert(offsetof(UUI_TeamResultItem, _Rank) == 0x0004FC, "Member 'UUI_TeamResultItem::_Rank' has a wrong offset!");
static_assert(offsetof(UUI_TeamResultItem, _score) == 0x000500, "Member 'UUI_TeamResultItem::_score' has a wrong offset!");
static_assert(offsetof(UUI_TeamResultItem, _IsWonTeam) == 0x000504, "Member 'UUI_TeamResultItem::_IsWonTeam' has a wrong offset!");
static_assert(offsetof(UUI_TeamResultItem, _Players) == 0x000508, "Member 'UUI_TeamResultItem::_Players' has a wrong offset!");
static_assert(offsetof(UUI_TeamResultItem, PlayerResultItemWidgetClass) == 0x000520, "Member 'UUI_TeamResultItem::PlayerResultItemWidgetClass' has a wrong offset!");
static_assert(offsetof(UUI_TeamResultItem, RankerIcons) == 0x000528, "Member 'UUI_TeamResultItem::RankerIcons' has a wrong offset!");
static_assert(offsetof(UUI_TeamResultItem, WS_ScorePerMode) == 0x000538, "Member 'UUI_TeamResultItem::WS_ScorePerMode' has a wrong offset!");
static_assert(offsetof(UUI_TeamResultItem, TXT_WinCount) == 0x000540, "Member 'UUI_TeamResultItem::TXT_WinCount' has a wrong offset!");
static_assert(offsetof(UUI_TeamResultItem, IMG_Ranking) == 0x000548, "Member 'UUI_TeamResultItem::IMG_Ranking' has a wrong offset!");
static_assert(offsetof(UUI_TeamResultItem, IMG_TeamColor) == 0x000550, "Member 'UUI_TeamResultItem::IMG_TeamColor' has a wrong offset!");
static_assert(offsetof(UUI_TeamResultItem, TXT_TransferScore) == 0x000558, "Member 'UUI_TeamResultItem::TXT_TransferScore' has a wrong offset!");
static_assert(offsetof(UUI_TeamResultItem, Container_PlayerResult) == 0x000560, "Member 'UUI_TeamResultItem::Container_PlayerResult' has a wrong offset!");

// Class Stigma.CharaStatsBuff
// 0x0018 (0x0110 - 0x00F8)
class UCharaStatsBuff : public UBuffBase
{
public:
	struct FBuffStats                             AdditionalBuffStats;                               // 0x00F8(0x0018)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharaStatsBuff">();
	}
	static class UCharaStatsBuff* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharaStatsBuff>();
	}
};
static_assert(alignof(UCharaStatsBuff) == 0x000008, "Wrong alignment on UCharaStatsBuff");
static_assert(sizeof(UCharaStatsBuff) == 0x000110, "Wrong size on UCharaStatsBuff");
static_assert(offsetof(UCharaStatsBuff, AdditionalBuffStats) == 0x0000F8, "Member 'UCharaStatsBuff::AdditionalBuffStats' has a wrong offset!");

// Class Stigma.EQG_GoldBox
// 0x0008 (0x0058 - 0x0050)
class UEQG_GoldBox final : public UEnvQueryGenerator
{
public:
	EGoldBoxType                                  GoldBoxType;                                       // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C3[0x7];                                     // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EQG_GoldBox">();
	}
	static class UEQG_GoldBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEQG_GoldBox>();
	}
};
static_assert(alignof(UEQG_GoldBox) == 0x000008, "Wrong alignment on UEQG_GoldBox");
static_assert(sizeof(UEQG_GoldBox) == 0x000058, "Wrong size on UEQG_GoldBox");
static_assert(offsetof(UEQG_GoldBox, GoldBoxType) == 0x000050, "Member 'UEQG_GoldBox::GoldBoxType' has a wrong offset!");

// Class Stigma.ChatManager
// 0x0058 (0x0080 - 0x0028)
class UChatManager final : public UObject
{
public:
	uint8                                         Pad_21C4[0x58];                                    // 0x0028(0x0058)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void NotifyChatStartEvent();
	void RegisterOnChatMsgAdded(const TDelegate<void(struct FChatMsg& _msg)>& _callback);
	void RegisterOnChatMsgCleared(const TDelegate<void()>& _callback);
	void RegisterOnStartChatReceived(const TDelegate<void()>& _callback);
	void UnRegisterOnChatMsgAdded(const class UObject* _bind_owner);
	void UnRegisterOnChatMsgCleared(const class UObject* _bind_owner);
	void UnRegisterOnStartChatReceived(const class UObject* _bind_owner);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChatManager">();
	}
	static class UChatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChatManager>();
	}
};
static_assert(alignof(UChatManager) == 0x000008, "Wrong alignment on UChatManager");
static_assert(sizeof(UChatManager) == 0x000080, "Wrong size on UChatManager");

// Class Stigma.UI_TutorialMissionGuide
// 0x0040 (0x0530 - 0x04F0)
class UUI_TutorialMissionGuide : public UPreviewableWidget
{
public:
	class UScaleBox*                              SB_MissionTitle;                                   // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_MissionTitle;                                  // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTutorialTarget>                _Targets;                                          // 0x0500(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              _Shear;                                            // 0x0510(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMission*                               _mission;                                          // 0x0520(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21C5[0x8];                                     // 0x0528(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ClearTargetMissions();
	class UMission* GetMission();
	void OnMissionUpdated(EMissionUpdateType _type, class UMission* _updated_mission);
	void SetTargetMission(const struct FItemID& _task_id, const TArray<struct FItemIDRef_Mission>& _mission_ids, bool _show_title);

	bool GetIsmissionChecked() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_TutorialMissionGuide">();
	}
	static class UUI_TutorialMissionGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_TutorialMissionGuide>();
	}
};
static_assert(alignof(UUI_TutorialMissionGuide) == 0x000008, "Wrong alignment on UUI_TutorialMissionGuide");
static_assert(sizeof(UUI_TutorialMissionGuide) == 0x000530, "Wrong size on UUI_TutorialMissionGuide");
static_assert(offsetof(UUI_TutorialMissionGuide, SB_MissionTitle) == 0x0004F0, "Member 'UUI_TutorialMissionGuide::SB_MissionTitle' has a wrong offset!");
static_assert(offsetof(UUI_TutorialMissionGuide, Txt_MissionTitle) == 0x0004F8, "Member 'UUI_TutorialMissionGuide::Txt_MissionTitle' has a wrong offset!");
static_assert(offsetof(UUI_TutorialMissionGuide, _Targets) == 0x000500, "Member 'UUI_TutorialMissionGuide::_Targets' has a wrong offset!");
static_assert(offsetof(UUI_TutorialMissionGuide, _Shear) == 0x000510, "Member 'UUI_TutorialMissionGuide::_Shear' has a wrong offset!");
static_assert(offsetof(UUI_TutorialMissionGuide, _mission) == 0x000520, "Member 'UUI_TutorialMissionGuide::_mission' has a wrong offset!");

// Class Stigma.ChatText
// 0x0010 (0x0520 - 0x0510)
class UChatText final : public UEditableText
{
public:
	uint8                                         Pad_21C8[0x10];                                    // 0x0510(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChatText">();
	}
	static class UChatText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChatText>();
	}
};
static_assert(alignof(UChatText) == 0x000010, "Wrong alignment on UChatText");
static_assert(sizeof(UChatText) == 0x000520, "Wrong size on UChatText");

// Class Stigma.CLB_ActuationSwitch
// 0x0038 (0x02D0 - 0x0298)
class ACLB_ActuationSwitch final : public AActor
{
public:
	float                                         SwitchActivationTime;                              // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C9[0x4];                                     // 0x029C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class AAISpawner*                             LinkedSpawner;                                     // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SwitchElapsedTime;                                 // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsActivation;                                      // 0x02AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21CA[0x3];                                     // 0x02AD(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         RemainSpawnCount;                                  // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21CB[0x4];                                     // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class ACharaBase*                             Interactor;                                        // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21CC[0x10];                                    // 0x02C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void FinishInteraction();
	bool StartInteraction(class ACharaBase* _interactor);
	void StopInteraction(class ACharaBase* _interactor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CLB_ActuationSwitch">();
	}
	static class ACLB_ActuationSwitch* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACLB_ActuationSwitch>();
	}
};
static_assert(alignof(ACLB_ActuationSwitch) == 0x000008, "Wrong alignment on ACLB_ActuationSwitch");
static_assert(sizeof(ACLB_ActuationSwitch) == 0x0002D0, "Wrong size on ACLB_ActuationSwitch");
static_assert(offsetof(ACLB_ActuationSwitch, SwitchActivationTime) == 0x000298, "Member 'ACLB_ActuationSwitch::SwitchActivationTime' has a wrong offset!");
static_assert(offsetof(ACLB_ActuationSwitch, LinkedSpawner) == 0x0002A0, "Member 'ACLB_ActuationSwitch::LinkedSpawner' has a wrong offset!");
static_assert(offsetof(ACLB_ActuationSwitch, SwitchElapsedTime) == 0x0002A8, "Member 'ACLB_ActuationSwitch::SwitchElapsedTime' has a wrong offset!");
static_assert(offsetof(ACLB_ActuationSwitch, IsActivation) == 0x0002AC, "Member 'ACLB_ActuationSwitch::IsActivation' has a wrong offset!");
static_assert(offsetof(ACLB_ActuationSwitch, RemainSpawnCount) == 0x0002B0, "Member 'ACLB_ActuationSwitch::RemainSpawnCount' has a wrong offset!");
static_assert(offsetof(ACLB_ActuationSwitch, Interactor) == 0x0002B8, "Member 'ACLB_ActuationSwitch::Interactor' has a wrong offset!");

// Class Stigma.GravityScaleInRootMotion
// 0x0008 (0x0038 - 0x0030)
class UGravityScaleInRootMotion final : public UAnimNotifyState
{
public:
	float                                         Scale;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21CE[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GravityScaleInRootMotion">();
	}
	static class UGravityScaleInRootMotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGravityScaleInRootMotion>();
	}
};
static_assert(alignof(UGravityScaleInRootMotion) == 0x000008, "Wrong alignment on UGravityScaleInRootMotion");
static_assert(sizeof(UGravityScaleInRootMotion) == 0x000038, "Wrong size on UGravityScaleInRootMotion");
static_assert(offsetof(UGravityScaleInRootMotion, Scale) == 0x000030, "Member 'UGravityScaleInRootMotion::Scale' has a wrong offset!");

// Class Stigma.PiercingObjectBase
// 0x00D0 (0x0660 - 0x0590)
class APiercingObjectBase final : public AObjectBase
{
public:
	class USphereComponent*                       _collision;                                        // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _EndPoint;                                         // 0x0590(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USplineComponent*                       _Spline;                                           // 0x05A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UArrowComponent*                        _StuckPoint;                                       // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharaBase*                             _Shooter;                                          // 0x05B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21CF[0xA0];                                    // 0x05C0(0x00A0)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PiercingObjectBase">();
	}
	static class APiercingObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<APiercingObjectBase>();
	}
};
static_assert(alignof(APiercingObjectBase) == 0x000010, "Wrong alignment on APiercingObjectBase");
static_assert(sizeof(APiercingObjectBase) == 0x000660, "Wrong size on APiercingObjectBase");
static_assert(offsetof(APiercingObjectBase, _collision) == 0x000588, "Member 'APiercingObjectBase::_collision' has a wrong offset!");
static_assert(offsetof(APiercingObjectBase, _EndPoint) == 0x000590, "Member 'APiercingObjectBase::_EndPoint' has a wrong offset!");
static_assert(offsetof(APiercingObjectBase, _Spline) == 0x0005A8, "Member 'APiercingObjectBase::_Spline' has a wrong offset!");
static_assert(offsetof(APiercingObjectBase, _StuckPoint) == 0x0005B0, "Member 'APiercingObjectBase::_StuckPoint' has a wrong offset!");
static_assert(offsetof(APiercingObjectBase, _Shooter) == 0x0005B8, "Member 'APiercingObjectBase::_Shooter' has a wrong offset!");

// Class Stigma.CLB_RewardBase
// 0x0000 (0x0028 - 0x0028)
class UCLB_RewardBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CLB_RewardBase">();
	}
	static class UCLB_RewardBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCLB_RewardBase>();
	}
};
static_assert(alignof(UCLB_RewardBase) == 0x000008, "Wrong alignment on UCLB_RewardBase");
static_assert(sizeof(UCLB_RewardBase) == 0x000028, "Wrong size on UCLB_RewardBase");

// Class Stigma.FireSystemComponent
// 0x0088 (0x0128 - 0x00A0)
class UFireSystemComponent final : public UActorComponent
{
public:
	bool                                          _UseP2PModel;                                      // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21D0[0x87];                                    // 0x00A1(0x0087)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void RPC_ALL_BeReady();
	void RPC_ALL_Fire(const struct FShot& _shot);
	void RPC_ALL_LoadMagazine();
	void RPC_SERVER_BeReady();
	void RPC_SERVER_Fire(const struct FShot& _shot);
	void RPC_SERVER_LoadMagazine();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FireSystemComponent">();
	}
	static class UFireSystemComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFireSystemComponent>();
	}
};
static_assert(alignof(UFireSystemComponent) == 0x000008, "Wrong alignment on UFireSystemComponent");
static_assert(sizeof(UFireSystemComponent) == 0x000128, "Wrong size on UFireSystemComponent");
static_assert(offsetof(UFireSystemComponent, _UseP2PModel) == 0x0000A0, "Member 'UFireSystemComponent::_UseP2PModel' has a wrong offset!");

// Class Stigma.CLB_BuffReward
// 0x0010 (0x0038 - 0x0028)
class UCLB_BuffReward : public UCLB_RewardBase
{
public:
	class FString                                 BuffName;                                          // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CLB_BuffReward">();
	}
	static class UCLB_BuffReward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCLB_BuffReward>();
	}
};
static_assert(alignof(UCLB_BuffReward) == 0x000008, "Wrong alignment on UCLB_BuffReward");
static_assert(sizeof(UCLB_BuffReward) == 0x000038, "Wrong size on UCLB_BuffReward");
static_assert(offsetof(UCLB_BuffReward, BuffName) == 0x000028, "Member 'UCLB_BuffReward::BuffName' has a wrong offset!");

// Class Stigma.CLB_Sector
// 0x0070 (0x0308 - 0x0298)
class ACLB_Sector : public AActor
{
public:
	TArray<class AAISpawner*>                     LinkedSpawner;                                     // 0x0298(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class APlayerStart*>                   SpawnPlayerStarts;                                 // 0x02A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class ACLB_InterMissionTrigger*               InterMission;                                      // 0x02B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ADoorBase*                              LinkedDoor;                                        // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ClearMoney;                                        // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21D1[0x4];                                     // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<int32>                                 SpawnProperMaxCountArray;                          // 0x02D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_21D2[0x28];                                    // 0x02E0(0x0028)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	class APlayerStart* GetPlayerStart();

	ECLB_SectorType GetSectorType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CLB_Sector">();
	}
	static class ACLB_Sector* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACLB_Sector>();
	}
};
static_assert(alignof(ACLB_Sector) == 0x000008, "Wrong alignment on ACLB_Sector");
static_assert(sizeof(ACLB_Sector) == 0x000308, "Wrong size on ACLB_Sector");
static_assert(offsetof(ACLB_Sector, LinkedSpawner) == 0x000298, "Member 'ACLB_Sector::LinkedSpawner' has a wrong offset!");
static_assert(offsetof(ACLB_Sector, SpawnPlayerStarts) == 0x0002A8, "Member 'ACLB_Sector::SpawnPlayerStarts' has a wrong offset!");
static_assert(offsetof(ACLB_Sector, InterMission) == 0x0002B8, "Member 'ACLB_Sector::InterMission' has a wrong offset!");
static_assert(offsetof(ACLB_Sector, LinkedDoor) == 0x0002C0, "Member 'ACLB_Sector::LinkedDoor' has a wrong offset!");
static_assert(offsetof(ACLB_Sector, ClearMoney) == 0x0002C8, "Member 'ACLB_Sector::ClearMoney' has a wrong offset!");
static_assert(offsetof(ACLB_Sector, SpawnProperMaxCountArray) == 0x0002D0, "Member 'ACLB_Sector::SpawnProperMaxCountArray' has a wrong offset!");

// Class Stigma.CLB_DefensionSector
// 0x0010 (0x0318 - 0x0308)
class ACLB_DefensionSector final : public ACLB_Sector
{
public:
	float                                         DefenceTime;                                       // 0x0308(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnLimitedSpawnTime;                                // 0x030C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21D3[0x8];                                     // 0x0310(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	float GetElapsedTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CLB_DefensionSector">();
	}
	static class ACLB_DefensionSector* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACLB_DefensionSector>();
	}
};
static_assert(alignof(ACLB_DefensionSector) == 0x000008, "Wrong alignment on ACLB_DefensionSector");
static_assert(sizeof(ACLB_DefensionSector) == 0x000318, "Wrong size on ACLB_DefensionSector");
static_assert(offsetof(ACLB_DefensionSector, DefenceTime) == 0x000308, "Member 'ACLB_DefensionSector::DefenceTime' has a wrong offset!");
static_assert(offsetof(ACLB_DefensionSector, UnLimitedSpawnTime) == 0x00030C, "Member 'ACLB_DefensionSector::UnLimitedSpawnTime' has a wrong offset!");

// Class Stigma.UI_TooltipKeyContainer
// 0x0020 (0x0510 - 0x04F0)
class UUI_TooltipKeyContainer : public UPreviewableWidget
{
public:
	class UVerticalBox*                           VB_Container;                                      // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_TooltipKey>             _UI_TooltipKeyClass;                               // 0x04F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTooltipKeyInfo>                _KeyInfos;                                         // 0x0500(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void AddTooltipKey(const struct FTooltipKeyInfo& _key_info);
	void ClearTooltipKey();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_TooltipKeyContainer">();
	}
	static class UUI_TooltipKeyContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_TooltipKeyContainer>();
	}
};
static_assert(alignof(UUI_TooltipKeyContainer) == 0x000008, "Wrong alignment on UUI_TooltipKeyContainer");
static_assert(sizeof(UUI_TooltipKeyContainer) == 0x000510, "Wrong size on UUI_TooltipKeyContainer");
static_assert(offsetof(UUI_TooltipKeyContainer, VB_Container) == 0x0004F0, "Member 'UUI_TooltipKeyContainer::VB_Container' has a wrong offset!");
static_assert(offsetof(UUI_TooltipKeyContainer, _UI_TooltipKeyClass) == 0x0004F8, "Member 'UUI_TooltipKeyContainer::_UI_TooltipKeyClass' has a wrong offset!");
static_assert(offsetof(UUI_TooltipKeyContainer, _KeyInfos) == 0x000500, "Member 'UUI_TooltipKeyContainer::_KeyInfos' has a wrong offset!");

// Class Stigma.CLB_GameMode
// 0x0098 (0x0870 - 0x07D8)
class ACLB_GameMode final : public ABattleGameModeBase
{
public:
	int32                                         _TimeLimit_Loading;                                // 0x07D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _TimeLimit_Intermission;                           // 0x07DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FConfig_CollaborationMode              _CollaborationModeConfig;                          // 0x07E0(0x0010)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_21D4[0x10];                                    // 0x07F0(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class ACLB_SectorManager*                     SectorManager;                                     // 0x0800(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ADoorBase*                              _LastActiveDoor;                                   // 0x0808(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21D5[0x60];                                    // 0x0810(0x0060)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnFinishLoading(int32 _uuid);
	void StartFighting();

	const struct FConfig_CollaborationMode GetCollaborationConfig() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CLB_GameMode">();
	}
	static class ACLB_GameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACLB_GameMode>();
	}
};
static_assert(alignof(ACLB_GameMode) == 0x000008, "Wrong alignment on ACLB_GameMode");
static_assert(sizeof(ACLB_GameMode) == 0x000870, "Wrong size on ACLB_GameMode");
static_assert(offsetof(ACLB_GameMode, _TimeLimit_Loading) == 0x0007D8, "Member 'ACLB_GameMode::_TimeLimit_Loading' has a wrong offset!");
static_assert(offsetof(ACLB_GameMode, _TimeLimit_Intermission) == 0x0007DC, "Member 'ACLB_GameMode::_TimeLimit_Intermission' has a wrong offset!");
static_assert(offsetof(ACLB_GameMode, _CollaborationModeConfig) == 0x0007E0, "Member 'ACLB_GameMode::_CollaborationModeConfig' has a wrong offset!");
static_assert(offsetof(ACLB_GameMode, SectorManager) == 0x000800, "Member 'ACLB_GameMode::SectorManager' has a wrong offset!");
static_assert(offsetof(ACLB_GameMode, _LastActiveDoor) == 0x000808, "Member 'ACLB_GameMode::_LastActiveDoor' has a wrong offset!");

// Class Stigma.EventCaster
// 0x0000 (0x0028 - 0x0028)
class UEventCaster final : public UBlueprintFunctionLibrary
{
public:
	static void PublishEvent(const class UObject* _world_ctx, const class FName& _event_name, class UObject* _subject, class UObject* _target, class UObject* _with, int32 _int_value, const struct FVector& _vector);
	static void SubscribeEvent(const class UObject* _world_ctx, class FName _event_name, const TDelegate<void(class FName& _event_name, struct FCastedEvent& _event)>& _handler);
	static void UnsubscribeAllEvents(const class UObject* _object);
	static void UnsubscribeEvent(class FName _event_name, const class UObject* _object);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventCaster">();
	}
	static class UEventCaster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventCaster>();
	}
};
static_assert(alignof(UEventCaster) == 0x000008, "Wrong alignment on UEventCaster");
static_assert(sizeof(UEventCaster) == 0x000028, "Wrong size on UEventCaster");

// Class Stigma.CLB_GameState
// 0x0030 (0x0938 - 0x0908)
class ACLB_GameState final : public ABattleGameStateBase
{
public:
	ECLBModePhase                                 Phase;                                             // 0x0908(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21D7[0x7];                                     // 0x0909(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class ADoorBase*                              ActiveDoor;                                        // 0x0910(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MapIndex;                                          // 0x0918(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSectorInfo                            SectorInfo;                                        // 0x091C(0x001C)(Edit, BlueprintVisible, Net, NoDestructor, NativeAccessSpecifierPublic)

public:
	void OnRep_ActiveDoor();
	void OnRep_MapIndex();
	void OnRep_Phase();
	void Setter_ActiveDoor(class ADoorBase* _door);
	void Setter_Phase(ECLBModePhase _phase);

	int32 GetSectorRemainTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CLB_GameState">();
	}
	static class ACLB_GameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACLB_GameState>();
	}
};
static_assert(alignof(ACLB_GameState) == 0x000008, "Wrong alignment on ACLB_GameState");
static_assert(sizeof(ACLB_GameState) == 0x000938, "Wrong size on ACLB_GameState");
static_assert(offsetof(ACLB_GameState, Phase) == 0x000908, "Member 'ACLB_GameState::Phase' has a wrong offset!");
static_assert(offsetof(ACLB_GameState, ActiveDoor) == 0x000910, "Member 'ACLB_GameState::ActiveDoor' has a wrong offset!");
static_assert(offsetof(ACLB_GameState, MapIndex) == 0x000918, "Member 'ACLB_GameState::MapIndex' has a wrong offset!");
static_assert(offsetof(ACLB_GameState, SectorInfo) == 0x00091C, "Member 'ACLB_GameState::SectorInfo' has a wrong offset!");

// Class Stigma.RecruitHistoryItemData
// 0x0058 (0x0080 - 0x0028)
class URecruitHistoryItemData final : public UObject
{
public:
	struct FItemID_Recruit                        _RecruitID;                                        // 0x0028(0x0010)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _RecruitCountIndex;                                // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21D8[0x4];                                     // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FItemID_Currency                       _UseCurrencyType;                                  // 0x0040(0x0010)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _UseCurrencyAmount;                                // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21D9[0x4];                                     // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FRecruitHistoryRewardTextData>  _RewardTextList;                                   // 0x0058(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FRecruitHistoryRewardTextData>  _RefundTextList;                                   // 0x0068(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FDateTime                              _BuyAt;                                            // 0x0078(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecruitHistoryItemData">();
	}
	static class URecruitHistoryItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecruitHistoryItemData>();
	}
};
static_assert(alignof(URecruitHistoryItemData) == 0x000008, "Wrong alignment on URecruitHistoryItemData");
static_assert(sizeof(URecruitHistoryItemData) == 0x000080, "Wrong size on URecruitHistoryItemData");
static_assert(offsetof(URecruitHistoryItemData, _RecruitID) == 0x000028, "Member 'URecruitHistoryItemData::_RecruitID' has a wrong offset!");
static_assert(offsetof(URecruitHistoryItemData, _RecruitCountIndex) == 0x000038, "Member 'URecruitHistoryItemData::_RecruitCountIndex' has a wrong offset!");
static_assert(offsetof(URecruitHistoryItemData, _UseCurrencyType) == 0x000040, "Member 'URecruitHistoryItemData::_UseCurrencyType' has a wrong offset!");
static_assert(offsetof(URecruitHistoryItemData, _UseCurrencyAmount) == 0x000050, "Member 'URecruitHistoryItemData::_UseCurrencyAmount' has a wrong offset!");
static_assert(offsetof(URecruitHistoryItemData, _RewardTextList) == 0x000058, "Member 'URecruitHistoryItemData::_RewardTextList' has a wrong offset!");
static_assert(offsetof(URecruitHistoryItemData, _RefundTextList) == 0x000068, "Member 'URecruitHistoryItemData::_RefundTextList' has a wrong offset!");
static_assert(offsetof(URecruitHistoryItemData, _BuyAt) == 0x000078, "Member 'URecruitHistoryItemData::_BuyAt' has a wrong offset!");

// Class Stigma.CLB_GunReward
// 0x0010 (0x0038 - 0x0028)
class UCLB_GunReward : public UCLB_RewardBase
{
public:
	struct FItemIDRef_Gun_Body                    _GunID;                                            // 0x0028(0x0010)(Edit, BlueprintVisible, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CLB_GunReward">();
	}
	static class UCLB_GunReward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCLB_GunReward>();
	}
};
static_assert(alignof(UCLB_GunReward) == 0x000008, "Wrong alignment on UCLB_GunReward");
static_assert(sizeof(UCLB_GunReward) == 0x000038, "Wrong size on UCLB_GunReward");
static_assert(offsetof(UCLB_GunReward, _GunID) == 0x000028, "Member 'UCLB_GunReward::_GunID' has a wrong offset!");

// Class Stigma.CLB_IncreaseArmorReward
// 0x0008 (0x0030 - 0x0028)
class UCLB_IncreaseArmorReward final : public UCLB_RewardBase
{
public:
	int32                                         IncreaseArmor;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21DA[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CLB_IncreaseArmorReward">();
	}
	static class UCLB_IncreaseArmorReward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCLB_IncreaseArmorReward>();
	}
};
static_assert(alignof(UCLB_IncreaseArmorReward) == 0x000008, "Wrong alignment on UCLB_IncreaseArmorReward");
static_assert(sizeof(UCLB_IncreaseArmorReward) == 0x000030, "Wrong size on UCLB_IncreaseArmorReward");
static_assert(offsetof(UCLB_IncreaseArmorReward, IncreaseArmor) == 0x000028, "Member 'UCLB_IncreaseArmorReward::IncreaseArmor' has a wrong offset!");

// Class Stigma.Ctrl_CommonTabPanel
// 0x0118 (0x0608 - 0x04F0)
class UCtrl_CommonTabPanel : public UPreviewableWidget
{
public:
	TSubclassOf<class UCtrl_CommonTab>            TabWidgetClass;                                    // 0x04F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FTabDefine>                     TabList;                                           // 0x04F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FSlateFontInfo                         FontNormal;                                        // 0x0508(0x0058)(Edit, BlueprintVisible, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateFontInfo                         FontSelected;                                      // 0x0560(0x0058)(Edit, BlueprintVisible, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                TabMargin;                                         // 0x05B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              EntrySize;                                         // 0x05C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETextJustify                                  TextJustify;                                       // 0x05D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21DB[0x7];                                     // 0x05D9(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UPanelWidget*                           TabContainer;                                      // 0x05E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21DC[0x10];                                    // 0x05E8(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             OnTabChanged;                                      // 0x05F8(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void DuplicateTab();
	struct FTabDefine GetEditableTabDefine(const class FName& _id);
	struct FTabDefine GetEditableTabDefineFromIdx(int32 _idx);
	void SetReRegisterTab(class FName _tab_id, bool _is_register);
	void SetSelectedIdx(int32 _idx, bool _call_on_tab_changed);
	void SetSelectedTabID(class FName _tab_id, bool _call_on_tab_changed);

	const TArray<struct FTabDefine> GetAllTabDefine() const;
	int32 GetIndexOfID(const class FName& _id) const;
	class FName GetSelectedID() const;
	const struct FTabDefine GetTabDefine(const class FName& _id) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_CommonTabPanel">();
	}
	static class UCtrl_CommonTabPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_CommonTabPanel>();
	}
};
static_assert(alignof(UCtrl_CommonTabPanel) == 0x000008, "Wrong alignment on UCtrl_CommonTabPanel");
static_assert(sizeof(UCtrl_CommonTabPanel) == 0x000608, "Wrong size on UCtrl_CommonTabPanel");
static_assert(offsetof(UCtrl_CommonTabPanel, TabWidgetClass) == 0x0004F0, "Member 'UCtrl_CommonTabPanel::TabWidgetClass' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonTabPanel, TabList) == 0x0004F8, "Member 'UCtrl_CommonTabPanel::TabList' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonTabPanel, FontNormal) == 0x000508, "Member 'UCtrl_CommonTabPanel::FontNormal' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonTabPanel, FontSelected) == 0x000560, "Member 'UCtrl_CommonTabPanel::FontSelected' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonTabPanel, TabMargin) == 0x0005B8, "Member 'UCtrl_CommonTabPanel::TabMargin' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonTabPanel, EntrySize) == 0x0005C8, "Member 'UCtrl_CommonTabPanel::EntrySize' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonTabPanel, TextJustify) == 0x0005D8, "Member 'UCtrl_CommonTabPanel::TextJustify' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonTabPanel, TabContainer) == 0x0005E0, "Member 'UCtrl_CommonTabPanel::TabContainer' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonTabPanel, OnTabChanged) == 0x0005F8, "Member 'UCtrl_CommonTabPanel::OnTabChanged' has a wrong offset!");

// Class Stigma.Ctrl_VerticalTabPanel
// 0x0010 (0x0618 - 0x0608)
class UCtrl_VerticalTabPanel : public UCtrl_CommonTabPanel
{
public:
	class UVerticalBox*                           VerticalTabContainer;                              // 0x0608(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EVerticalAlignment                            VertAlign;                                         // 0x0610(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21E3[0x7];                                     // 0x0611(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnTabSelected(class FName _id, int32 _idx);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_VerticalTabPanel">();
	}
	static class UCtrl_VerticalTabPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_VerticalTabPanel>();
	}
};
static_assert(alignof(UCtrl_VerticalTabPanel) == 0x000008, "Wrong alignment on UCtrl_VerticalTabPanel");
static_assert(sizeof(UCtrl_VerticalTabPanel) == 0x000618, "Wrong size on UCtrl_VerticalTabPanel");
static_assert(offsetof(UCtrl_VerticalTabPanel, VerticalTabContainer) == 0x000608, "Member 'UCtrl_VerticalTabPanel::VerticalTabContainer' has a wrong offset!");
static_assert(offsetof(UCtrl_VerticalTabPanel, VertAlign) == 0x000610, "Member 'UCtrl_VerticalTabPanel::VertAlign' has a wrong offset!");

// Class Stigma.CLB_IncreaseHPReward
// 0x0008 (0x0030 - 0x0028)
class UCLB_IncreaseHPReward final : public UCLB_RewardBase
{
public:
	int32                                         IncreaseHP;                                        // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21E4[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CLB_IncreaseHPReward">();
	}
	static class UCLB_IncreaseHPReward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCLB_IncreaseHPReward>();
	}
};
static_assert(alignof(UCLB_IncreaseHPReward) == 0x000008, "Wrong alignment on UCLB_IncreaseHPReward");
static_assert(sizeof(UCLB_IncreaseHPReward) == 0x000030, "Wrong size on UCLB_IncreaseHPReward");
static_assert(offsetof(UCLB_IncreaseHPReward, IncreaseHP) == 0x000028, "Member 'UCLB_IncreaseHPReward::IncreaseHP' has a wrong offset!");

// Class Stigma.FovNiagaraComponent
// 0x0010 (0x0820 - 0x0810)
class UFovNiagaraComponent final : public UNiagaraComponent
{
public:
	float                                         _DesiredFov;                                       // 0x0810(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _EnableFov;                                        // 0x0814(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21E5[0xB];                                     // 0x0815(0x000B)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FovNiagaraComponent">();
	}
	static class UFovNiagaraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFovNiagaraComponent>();
	}
};
static_assert(alignof(UFovNiagaraComponent) == 0x000010, "Wrong alignment on UFovNiagaraComponent");
static_assert(sizeof(UFovNiagaraComponent) == 0x000820, "Wrong size on UFovNiagaraComponent");
static_assert(offsetof(UFovNiagaraComponent, _DesiredFov) == 0x000810, "Member 'UFovNiagaraComponent::_DesiredFov' has a wrong offset!");
static_assert(offsetof(UFovNiagaraComponent, _EnableFov) == 0x000814, "Member 'UFovNiagaraComponent::_EnableFov' has a wrong offset!");

// Class Stigma.CLB_IncreasePillReward
// 0x0008 (0x0030 - 0x0028)
class UCLB_IncreasePillReward : public UCLB_RewardBase
{
public:
	int32                                         Count;                                             // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21E6[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CLB_IncreasePillReward">();
	}
	static class UCLB_IncreasePillReward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCLB_IncreasePillReward>();
	}
};
static_assert(alignof(UCLB_IncreasePillReward) == 0x000008, "Wrong alignment on UCLB_IncreasePillReward");
static_assert(sizeof(UCLB_IncreasePillReward) == 0x000030, "Wrong size on UCLB_IncreasePillReward");
static_assert(offsetof(UCLB_IncreasePillReward, Count) == 0x000028, "Member 'UCLB_IncreasePillReward::Count' has a wrong offset!");

// Class Stigma.CLB_InterMissionSector
// 0x0008 (0x0310 - 0x0308)
class ACLB_InterMissionSector final : public ACLB_Sector
{
public:
	ECLB_SectorType                               SectorType;                                        // 0x0308(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21E7[0x7];                                     // 0x0309(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CLB_InterMissionSector">();
	}
	static class ACLB_InterMissionSector* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACLB_InterMissionSector>();
	}
};
static_assert(alignof(ACLB_InterMissionSector) == 0x000008, "Wrong alignment on ACLB_InterMissionSector");
static_assert(sizeof(ACLB_InterMissionSector) == 0x000310, "Wrong size on ACLB_InterMissionSector");
static_assert(offsetof(ACLB_InterMissionSector, SectorType) == 0x000308, "Member 'ACLB_InterMissionSector::SectorType' has a wrong offset!");

// Class Stigma.CLB_InterMissionTrigger
// 0x0020 (0x02B8 - 0x0298)
class ACLB_InterMissionTrigger final : public AActor
{
public:
	TArray<class ACollaborationModeStore*>        CLB_Store;                                         // 0x0298(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         InterMissionWaitingTime;                           // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21E8[0xC];                                     // 0x02AC(0x000C)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	float GetRemainWaitingTime() const;
	bool IsFinishedInterMission() const;
	bool IsStartInterMission() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CLB_InterMissionTrigger">();
	}
	static class ACLB_InterMissionTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACLB_InterMissionTrigger>();
	}
};
static_assert(alignof(ACLB_InterMissionTrigger) == 0x000008, "Wrong alignment on ACLB_InterMissionTrigger");
static_assert(sizeof(ACLB_InterMissionTrigger) == 0x0002B8, "Wrong size on ACLB_InterMissionTrigger");
static_assert(offsetof(ACLB_InterMissionTrigger, CLB_Store) == 0x000298, "Member 'ACLB_InterMissionTrigger::CLB_Store' has a wrong offset!");
static_assert(offsetof(ACLB_InterMissionTrigger, InterMissionWaitingTime) == 0x0002A8, "Member 'ACLB_InterMissionTrigger::InterMissionWaitingTime' has a wrong offset!");

// Class Stigma.UI_RecruitBackground
// 0x0008 (0x04F8 - 0x04F0)
class UUI_RecruitBackground final : public UPreviewableWidget
{
public:
	class UTextBlock*                             TXT_Desc;                                          // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_RecruitBackground">();
	}
	static class UUI_RecruitBackground* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_RecruitBackground>();
	}
};
static_assert(alignof(UUI_RecruitBackground) == 0x000008, "Wrong alignment on UUI_RecruitBackground");
static_assert(sizeof(UUI_RecruitBackground) == 0x0004F8, "Wrong size on UUI_RecruitBackground");
static_assert(offsetof(UUI_RecruitBackground, TXT_Desc) == 0x0004F0, "Member 'UUI_RecruitBackground::TXT_Desc' has a wrong offset!");

// Class Stigma.CLB_LevelBase
// 0x0008 (0x02A8 - 0x02A0)
class ACLB_LevelBase final : public ALevelScriptActor
{
public:
	class FName                                   NextLevel;                                         // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CLB_LevelBase">();
	}
	static class ACLB_LevelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACLB_LevelBase>();
	}
};
static_assert(alignof(ACLB_LevelBase) == 0x000008, "Wrong alignment on ACLB_LevelBase");
static_assert(sizeof(ACLB_LevelBase) == 0x0002A8, "Wrong size on ACLB_LevelBase");
static_assert(offsetof(ACLB_LevelBase, NextLevel) == 0x0002A0, "Member 'ACLB_LevelBase::NextLevel' has a wrong offset!");

// Class Stigma.ItemIDsBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UItemIDsBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FItemID_Booster MakeBoosterID(const struct FItemID& _item_id);
	static struct FItemID MakeItemIDByCategories(EBoosterAcquisitionType _acq_type, int32 _serial_number);
	static struct FItemID_Announcer ToAnnouncerID(const struct FItemID& _id);
	static struct FItemID_BattlePass ToBattlePassID(const struct FItemID& _id);
	static struct FItemID_Skin_Body ToBodyID(const struct FItemID& _id);
	static struct FItemID_Booster ToBoosterID(const struct FItemID& _id);
	static struct FItemID_Buff ToBuffID(const struct FItemID& _id);
	static struct FItemID_Currency ToCurrencyID(const struct FItemID& _id);
	static struct FItemID_EventPage ToEventPageID(const struct FItemID& _id);
	static struct FGoodsID ToGoodsID(const struct FItemID& _id);
	static struct FItemID_Gun_Body ToGunBodyID(const struct FItemID& _id);
	static struct FItemID_Gun_Charm ToGunCharmID(const struct FItemID& _id);
	static struct FItemID_Gun_Front ToGunFrontID(const struct FItemID& _id);
	static struct FItemID_Gun_Magazine ToGunMagazineID(const struct FItemID& _id);
	static struct FItemID_Gun_Sight ToGunSightID(const struct FItemID& _id);
	static struct FItemID_Gun_Slide ToGunSlideID(const struct FItemID& _id);
	static struct FItemID_Gun_Sticker ToGunStickerID(const struct FItemID& _id);
	static struct FItemID_Skin_Head ToHeadID(const struct FItemID& _id);
	static struct FItemIDRef_Skin_Head ToHeadIDRef(const struct FItemID& _id);
	static struct FItemIDRef ToItemIDRef(const struct FItemID& _id);
	static struct FItemID_Mission ToMissionID(const struct FItemID& _id);
	static struct FPassiveSkillID ToPassiveSkillID(const struct FItemID& _id);
	static struct FItemID_RandomBox ToRandomBoxID(const struct FItemID& _id);
	static struct FItemID_Recruit ToRecruitID(const struct FItemID& _id);
	static struct FItemID_Stack ToStackID(const struct FItemID& _id);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemIDsBlueprintLibrary">();
	}
	static class UItemIDsBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemIDsBlueprintLibrary>();
	}
};
static_assert(alignof(UItemIDsBlueprintLibrary) == 0x000008, "Wrong alignment on UItemIDsBlueprintLibrary");
static_assert(sizeof(UItemIDsBlueprintLibrary) == 0x000028, "Wrong size on UItemIDsBlueprintLibrary");

// Class Stigma.CLB_LifeReward
// 0x0008 (0x0030 - 0x0028)
class UCLB_LifeReward final : public UCLB_RewardBase
{
public:
	int32                                         IncreasementCount;                                 // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21EA[0x4];                                     // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CLB_LifeReward">();
	}
	static class UCLB_LifeReward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCLB_LifeReward>();
	}
};
static_assert(alignof(UCLB_LifeReward) == 0x000008, "Wrong alignment on UCLB_LifeReward");
static_assert(sizeof(UCLB_LifeReward) == 0x000030, "Wrong size on UCLB_LifeReward");
static_assert(offsetof(UCLB_LifeReward, IncreasementCount) == 0x000028, "Member 'UCLB_LifeReward::IncreasementCount' has a wrong offset!");

// Class Stigma.RecruitRewardData
// 0x0058 (0x0080 - 0x0028)
class URecruitRewardData final : public UObject
{
public:
	uint8                                         Pad_21EB[0x58];                                    // 0x0028(0x0058)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecruitRewardData">();
	}
	static class URecruitRewardData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecruitRewardData>();
	}
};
static_assert(alignof(URecruitRewardData) == 0x000008, "Wrong alignment on URecruitRewardData");
static_assert(sizeof(URecruitRewardData) == 0x000080, "Wrong size on URecruitRewardData");

// Class Stigma.CLB_MagazineReward
// 0x0000 (0x0028 - 0x0028)
class UCLB_MagazineReward final : public UCLB_RewardBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CLB_MagazineReward">();
	}
	static class UCLB_MagazineReward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCLB_MagazineReward>();
	}
};
static_assert(alignof(UCLB_MagazineReward) == 0x000008, "Wrong alignment on UCLB_MagazineReward");
static_assert(sizeof(UCLB_MagazineReward) == 0x000028, "Wrong size on UCLB_MagazineReward");

// Class Stigma.CLB_PatrolPoint
// 0x0000 (0x0298 - 0x0298)
class ACLB_PatrolPoint final : public AActor
{
public:
	struct FVector GetPatrolLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CLB_PatrolPoint">();
	}
	static class ACLB_PatrolPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACLB_PatrolPoint>();
	}
};
static_assert(alignof(ACLB_PatrolPoint) == 0x000008, "Wrong alignment on ACLB_PatrolPoint");
static_assert(sizeof(ACLB_PatrolPoint) == 0x000298, "Wrong size on ACLB_PatrolPoint");

// Class Stigma.DepthSenseComponent
// 0x0580 (0x0820 - 0x02A0)
class UDepthSenseComponent final : public USceneComponent
{
public:
	uint8                                         Pad_21EC[0x580];                                   // 0x02A0(0x0580)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	class UTexture2D* GetVisualizedTexture();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DepthSenseComponent">();
	}
	static class UDepthSenseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDepthSenseComponent>();
	}
};
static_assert(alignof(UDepthSenseComponent) == 0x000010, "Wrong alignment on UDepthSenseComponent");
static_assert(sizeof(UDepthSenseComponent) == 0x000820, "Wrong size on UDepthSenseComponent");

// Class Stigma.UI_SeasonRewardPopup
// 0x0000 (0x0570 - 0x0570)
class UUI_SeasonRewardPopup : public UPopupBase
{
public:
	void SetValue(const struct FBC_SeasonReward& _packet);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_SeasonRewardPopup">();
	}
	static class UUI_SeasonRewardPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_SeasonRewardPopup>();
	}
};
static_assert(alignof(UUI_SeasonRewardPopup) == 0x000008, "Wrong alignment on UUI_SeasonRewardPopup");
static_assert(sizeof(UUI_SeasonRewardPopup) == 0x000570, "Wrong size on UUI_SeasonRewardPopup");

// Class Stigma.CLB_PatrolPoints
// 0x0010 (0x02A8 - 0x0298)
class ACLB_PatrolPoints final : public AActor
{
public:
	TArray<class ACLB_PatrolPoint*>               PatrolPoints;                                      // 0x0298(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CLB_PatrolPoints">();
	}
	static class ACLB_PatrolPoints* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACLB_PatrolPoints>();
	}
};
static_assert(alignof(ACLB_PatrolPoints) == 0x000008, "Wrong alignment on ACLB_PatrolPoints");
static_assert(sizeof(ACLB_PatrolPoints) == 0x0002A8, "Wrong size on ACLB_PatrolPoints");
static_assert(offsetof(ACLB_PatrolPoints, PatrolPoints) == 0x000298, "Member 'ACLB_PatrolPoints::PatrolPoints' has a wrong offset!");

// Class Stigma.ItemBoxBase
// 0x0060 (0x02F8 - 0x0298)
class AItemBoxBase : public AActor
{
public:
	uint8                                         Pad_21ED[0x20];                                    // 0x0298(0x0020)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          CanPickup;                                         // 0x02B8(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanInteraction;                                    // 0x02B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EObjectType                                   ObjectType;                                        // 0x02BA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21EE[0x5];                                     // 0x02BB(0x0005)(Fixing Size After Last Property [ Dumper-69 ])
	class USceneComponent*                        _SceneRootComponent;                               // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   _MeshComp;                                         // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              _Icon;                                             // 0x02D0(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPickupItem(class ACharaBase* _involver);
	void OnRep_CanPickup();
	void RPC_All_OnPickupItem(class ACharaBase* _involver);
	void SetInteraction(bool _is_interaction);
	void Setter_CanPickup(bool _can_pickup);

	class FText GetDisplayText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemBoxBase">();
	}
	static class AItemBoxBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AItemBoxBase>();
	}
};
static_assert(alignof(AItemBoxBase) == 0x000008, "Wrong alignment on AItemBoxBase");
static_assert(sizeof(AItemBoxBase) == 0x0002F8, "Wrong size on AItemBoxBase");
static_assert(offsetof(AItemBoxBase, CanPickup) == 0x0002B8, "Member 'AItemBoxBase::CanPickup' has a wrong offset!");
static_assert(offsetof(AItemBoxBase, CanInteraction) == 0x0002B9, "Member 'AItemBoxBase::CanInteraction' has a wrong offset!");
static_assert(offsetof(AItemBoxBase, ObjectType) == 0x0002BA, "Member 'AItemBoxBase::ObjectType' has a wrong offset!");
static_assert(offsetof(AItemBoxBase, _SceneRootComponent) == 0x0002C0, "Member 'AItemBoxBase::_SceneRootComponent' has a wrong offset!");
static_assert(offsetof(AItemBoxBase, _MeshComp) == 0x0002C8, "Member 'AItemBoxBase::_MeshComp' has a wrong offset!");
static_assert(offsetof(AItemBoxBase, _Icon) == 0x0002D0, "Member 'AItemBoxBase::_Icon' has a wrong offset!");

// Class Stigma.CLB_PlayerController
// 0x0008 (0x0E48 - 0x0E40)
class ACLB_PlayerController final : public ABattlePlayerControllerBase
{
public:
	uint8                                         Pad_21EF[0x8];                                     // 0x0E40(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnAddNotifyMessage(const class FString& _text, float _life_time);
	bool OnChangeActiveDoor(class ADoorBase* _door);
	bool OnChangePhase(ECLBModePhase _phase);
	void RPC_CLIENT_AddNotifyMessage(const class FString& _text, float _life_time);
	void RPC_SERVER_DEBUG_SkipNextInterMission();
	void RPC_SERVER_RequestRespawn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CLB_PlayerController">();
	}
	static class ACLB_PlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACLB_PlayerController>();
	}
};
static_assert(alignof(ACLB_PlayerController) == 0x000008, "Wrong alignment on ACLB_PlayerController");
static_assert(sizeof(ACLB_PlayerController) == 0x000E48, "Wrong size on ACLB_PlayerController");

// Class Stigma.CLB_PlayerState
// 0x0010 (0x0C98 - 0x0C88)
class ACLB_PlayerState final : public ABattlePlayerState
{
public:
	int32                                         _RemainLife;                                       // 0x0C88(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _Money;                                            // 0x0C8C(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _TotalPoints;                                      // 0x0C90(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21F3[0x4];                                     // 0x0C94(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void SetRemainLife(int32 _Life);

	int32 GetRemainLife() const;
	int32 GetTotalPoints() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CLB_PlayerState">();
	}
	static class ACLB_PlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACLB_PlayerState>();
	}
};
static_assert(alignof(ACLB_PlayerState) == 0x000008, "Wrong alignment on ACLB_PlayerState");
static_assert(sizeof(ACLB_PlayerState) == 0x000C98, "Wrong size on ACLB_PlayerState");
static_assert(offsetof(ACLB_PlayerState, _RemainLife) == 0x000C88, "Member 'ACLB_PlayerState::_RemainLife' has a wrong offset!");
static_assert(offsetof(ACLB_PlayerState, _Money) == 0x000C8C, "Member 'ACLB_PlayerState::_Money' has a wrong offset!");
static_assert(offsetof(ACLB_PlayerState, _TotalPoints) == 0x000C90, "Member 'ACLB_PlayerState::_TotalPoints' has a wrong offset!");

// Class Stigma.CLB_SectorManager
// 0x0020 (0x02B8 - 0x0298)
class ACLB_SectorManager final : public AActor
{
public:
	TArray<class ACLB_Sector*>                    SectorList;                                        // 0x0298(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_21F4[0x10];                                    // 0x02A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	class APlayerStart* GetPlayerStart();
	void OnFinishSector(class ACLB_Sector* Sector);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CLB_SectorManager">();
	}
	static class ACLB_SectorManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACLB_SectorManager>();
	}
};
static_assert(alignof(ACLB_SectorManager) == 0x000008, "Wrong alignment on ACLB_SectorManager");
static_assert(sizeof(ACLB_SectorManager) == 0x0002B8, "Wrong size on ACLB_SectorManager");
static_assert(offsetof(ACLB_SectorManager, SectorList) == 0x000298, "Member 'ACLB_SectorManager::SectorList' has a wrong offset!");

// Class Stigma.FollowingActorComponent
// 0x0098 (0x0138 - 0x00A0)
class UFollowingActorComponent final : public UActorComponent
{
public:
	class UBoxComponent*                          _BoxComponent;                                     // 0x00A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 _TargetActor;                                      // 0x00A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         _IgnoreActors;                                     // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FVector                                _TargetLocationOffset;                             // 0x00C0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _Speed;                                            // 0x00D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _AttachDistance;                                   // 0x00DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsAutoDetection;                                  // 0x00E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsAttachment;                                     // 0x00E1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21F5[0x6];                                     // 0x00E2(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	struct FVector                                _DetectionBoxExtent;                               // 0x00E8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class AActor>>             _DetectionActorTypes;                              // 0x0100(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_21F6[0x28];                                    // 0x0110(0x0028)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FollowingActorComponent">();
	}
	static class UFollowingActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFollowingActorComponent>();
	}
};
static_assert(alignof(UFollowingActorComponent) == 0x000008, "Wrong alignment on UFollowingActorComponent");
static_assert(sizeof(UFollowingActorComponent) == 0x000138, "Wrong size on UFollowingActorComponent");
static_assert(offsetof(UFollowingActorComponent, _BoxComponent) == 0x0000A0, "Member 'UFollowingActorComponent::_BoxComponent' has a wrong offset!");
static_assert(offsetof(UFollowingActorComponent, _TargetActor) == 0x0000A8, "Member 'UFollowingActorComponent::_TargetActor' has a wrong offset!");
static_assert(offsetof(UFollowingActorComponent, _IgnoreActors) == 0x0000B0, "Member 'UFollowingActorComponent::_IgnoreActors' has a wrong offset!");
static_assert(offsetof(UFollowingActorComponent, _TargetLocationOffset) == 0x0000C0, "Member 'UFollowingActorComponent::_TargetLocationOffset' has a wrong offset!");
static_assert(offsetof(UFollowingActorComponent, _Speed) == 0x0000D8, "Member 'UFollowingActorComponent::_Speed' has a wrong offset!");
static_assert(offsetof(UFollowingActorComponent, _AttachDistance) == 0x0000DC, "Member 'UFollowingActorComponent::_AttachDistance' has a wrong offset!");
static_assert(offsetof(UFollowingActorComponent, _IsAutoDetection) == 0x0000E0, "Member 'UFollowingActorComponent::_IsAutoDetection' has a wrong offset!");
static_assert(offsetof(UFollowingActorComponent, _IsAttachment) == 0x0000E1, "Member 'UFollowingActorComponent::_IsAttachment' has a wrong offset!");
static_assert(offsetof(UFollowingActorComponent, _DetectionBoxExtent) == 0x0000E8, "Member 'UFollowingActorComponent::_DetectionBoxExtent' has a wrong offset!");
static_assert(offsetof(UFollowingActorComponent, _DetectionActorTypes) == 0x000100, "Member 'UFollowingActorComponent::_DetectionActorTypes' has a wrong offset!");

// Class Stigma.UI_RecruitResultPopup
// 0x0198 (0x0708 - 0x0570)
class UUI_RecruitResultPopup : public UPopupBase
{
public:
	class UButton*                                Btn_Screen;                                        // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HB_RewardList;                                     // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_ClickMsg;                                      // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CP_Main;                                           // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CP_Result;                                         // 0x0590(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UListView*                              LV_ResultList;                                     // 0x0598(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_CommonButtonBase*                 Btn_ResultConfirm;                                 // 0x05A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPreviewableWidget*                     Btn_Skip;                                          // 0x05A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<ERecruitSequenceType, class ULevelSequence*> _SequenceMap;                                      // 0x05B0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_RecruitRewardItem>      _RewardItemClass;                                  // 0x0600(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                _RewardPadding;                                    // 0x0608(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class ULevelStreamingDynamic*                 _RecruitLevel;                                     // 0x0618(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULevelSequencePlayer*                   _SequencePlayer;                                   // 0x0620(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FNetRecruitReward>              _rewards;                                          // 0x0628(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UUI_RecruitRewardItem*>          _RewardWidgets;                                    // 0x0638(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class APreviewActor>              _GunPreviewerClass;                                // 0x0648(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGunObject*                             _PreviewGunObj;                                    // 0x0650(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APreviewActor*                          _GunPreviewer;                                     // 0x0658(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AGunBase*                               _PreviewGun;                                       // 0x0660(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharaBase*                             _PreviewChara;                                     // 0x0668(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ALevelSequenceActor*                    _LevelSequenceActor;                               // 0x0670(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, TWeakObjectPtr<class AActor>> _ActorMap;                                         // 0x0678(0x0050)(Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class AAmbientSound>>   _LobbySounds;                                      // 0x06C8(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_21F7[0x30];                                    // 0x06D8(0x0030)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void CreateGun(class UGunObject* Gun_obj);
	class AGunBase* GetGun();
	void OnClickResultConfirm(class UAnimatableWidget* _btn, bool _selected);
	void OnClickScreen();
	void OnClickSkip();
	void OnRewardWidgetShowEnd(class UAnimatableWidget* _widget);
	void OnSequenceFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_RecruitResultPopup">();
	}
	static class UUI_RecruitResultPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_RecruitResultPopup>();
	}
};
static_assert(alignof(UUI_RecruitResultPopup) == 0x000008, "Wrong alignment on UUI_RecruitResultPopup");
static_assert(sizeof(UUI_RecruitResultPopup) == 0x000708, "Wrong size on UUI_RecruitResultPopup");
static_assert(offsetof(UUI_RecruitResultPopup, Btn_Screen) == 0x000570, "Member 'UUI_RecruitResultPopup::Btn_Screen' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultPopup, HB_RewardList) == 0x000578, "Member 'UUI_RecruitResultPopup::HB_RewardList' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultPopup, Txt_ClickMsg) == 0x000580, "Member 'UUI_RecruitResultPopup::Txt_ClickMsg' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultPopup, CP_Main) == 0x000588, "Member 'UUI_RecruitResultPopup::CP_Main' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultPopup, CP_Result) == 0x000590, "Member 'UUI_RecruitResultPopup::CP_Result' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultPopup, LV_ResultList) == 0x000598, "Member 'UUI_RecruitResultPopup::LV_ResultList' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultPopup, Btn_ResultConfirm) == 0x0005A0, "Member 'UUI_RecruitResultPopup::Btn_ResultConfirm' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultPopup, Btn_Skip) == 0x0005A8, "Member 'UUI_RecruitResultPopup::Btn_Skip' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultPopup, _SequenceMap) == 0x0005B0, "Member 'UUI_RecruitResultPopup::_SequenceMap' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultPopup, _RewardItemClass) == 0x000600, "Member 'UUI_RecruitResultPopup::_RewardItemClass' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultPopup, _RewardPadding) == 0x000608, "Member 'UUI_RecruitResultPopup::_RewardPadding' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultPopup, _RecruitLevel) == 0x000618, "Member 'UUI_RecruitResultPopup::_RecruitLevel' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultPopup, _SequencePlayer) == 0x000620, "Member 'UUI_RecruitResultPopup::_SequencePlayer' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultPopup, _rewards) == 0x000628, "Member 'UUI_RecruitResultPopup::_rewards' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultPopup, _RewardWidgets) == 0x000638, "Member 'UUI_RecruitResultPopup::_RewardWidgets' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultPopup, _GunPreviewerClass) == 0x000648, "Member 'UUI_RecruitResultPopup::_GunPreviewerClass' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultPopup, _PreviewGunObj) == 0x000650, "Member 'UUI_RecruitResultPopup::_PreviewGunObj' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultPopup, _GunPreviewer) == 0x000658, "Member 'UUI_RecruitResultPopup::_GunPreviewer' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultPopup, _PreviewGun) == 0x000660, "Member 'UUI_RecruitResultPopup::_PreviewGun' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultPopup, _PreviewChara) == 0x000668, "Member 'UUI_RecruitResultPopup::_PreviewChara' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultPopup, _LevelSequenceActor) == 0x000670, "Member 'UUI_RecruitResultPopup::_LevelSequenceActor' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultPopup, _ActorMap) == 0x000678, "Member 'UUI_RecruitResultPopup::_ActorMap' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultPopup, _LobbySounds) == 0x0006C8, "Member 'UUI_RecruitResultPopup::_LobbySounds' has a wrong offset!");

// Class Stigma.CLB_SecurementSector
// 0x0038 (0x0340 - 0x0308)
class ACLB_SecurementSector final : public ACLB_Sector
{
public:
	TArray<class ACLB_SecurementZone*>            SecurementZones;                                   // 0x0308(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class ACLB_SecurementZone*                    ActivatedZone;                                     // 0x0318(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SecurementProgress;                                // 0x0320(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ClearZoneCount;                                    // 0x0324(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         GoalZoneCount;                                     // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21F9[0x4];                                     // 0x032C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class ACLB_SecurementZone*>            RemainSecurementZones;                             // 0x0330(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CLB_SecurementSector">();
	}
	static class ACLB_SecurementSector* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACLB_SecurementSector>();
	}
};
static_assert(alignof(ACLB_SecurementSector) == 0x000008, "Wrong alignment on ACLB_SecurementSector");
static_assert(sizeof(ACLB_SecurementSector) == 0x000340, "Wrong size on ACLB_SecurementSector");
static_assert(offsetof(ACLB_SecurementSector, SecurementZones) == 0x000308, "Member 'ACLB_SecurementSector::SecurementZones' has a wrong offset!");
static_assert(offsetof(ACLB_SecurementSector, ActivatedZone) == 0x000318, "Member 'ACLB_SecurementSector::ActivatedZone' has a wrong offset!");
static_assert(offsetof(ACLB_SecurementSector, SecurementProgress) == 0x000320, "Member 'ACLB_SecurementSector::SecurementProgress' has a wrong offset!");
static_assert(offsetof(ACLB_SecurementSector, ClearZoneCount) == 0x000324, "Member 'ACLB_SecurementSector::ClearZoneCount' has a wrong offset!");
static_assert(offsetof(ACLB_SecurementSector, GoalZoneCount) == 0x000328, "Member 'ACLB_SecurementSector::GoalZoneCount' has a wrong offset!");
static_assert(offsetof(ACLB_SecurementSector, RemainSecurementZones) == 0x000330, "Member 'ACLB_SecurementSector::RemainSecurementZones' has a wrong offset!");

// Class Stigma.MissionCondition_EnterArea
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_EnterArea final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_EnterArea">();
	}
	static class UMissionCondition_EnterArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_EnterArea>();
	}
};
static_assert(alignof(UMissionCondition_EnterArea) == 0x000008, "Wrong alignment on UMissionCondition_EnterArea");
static_assert(sizeof(UMissionCondition_EnterArea) == 0x000068, "Wrong size on UMissionCondition_EnterArea");

// Class Stigma.TrainingRoomGameState
// 0x0000 (0x0908 - 0x0908)
class ATrainingRoomGameState final : public ABattleGameStateBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrainingRoomGameState">();
	}
	static class ATrainingRoomGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrainingRoomGameState>();
	}
};
static_assert(alignof(ATrainingRoomGameState) == 0x000008, "Wrong alignment on ATrainingRoomGameState");
static_assert(sizeof(ATrainingRoomGameState) == 0x000908, "Wrong size on ATrainingRoomGameState");

// Class Stigma.BlueprintCollaborationSecurmentLibrary
// 0x0000 (0x0028 - 0x0028)
class UBlueprintCollaborationSecurmentLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString GetSecurmentZoneName(int32 _score);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintCollaborationSecurmentLibrary">();
	}
	static class UBlueprintCollaborationSecurmentLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintCollaborationSecurmentLibrary>();
	}
};
static_assert(alignof(UBlueprintCollaborationSecurmentLibrary) == 0x000008, "Wrong alignment on UBlueprintCollaborationSecurmentLibrary");
static_assert(sizeof(UBlueprintCollaborationSecurmentLibrary) == 0x000028, "Wrong size on UBlueprintCollaborationSecurmentLibrary");

// Class Stigma.VS_GameState
// 0x0000 (0x0998 - 0x0998)
class AVS_GameState : public AAnnihilation_GameState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VS_GameState">();
	}
	static class AVS_GameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVS_GameState>();
	}
};
static_assert(alignof(AVS_GameState) == 0x000008, "Wrong alignment on AVS_GameState");
static_assert(sizeof(AVS_GameState) == 0x000998, "Wrong size on AVS_GameState");

// Class Stigma.CLB_SecurementZone
// 0x0040 (0x02D8 - 0x0298)
class ACLB_SecurementZone final : public AActor
{
public:
	uint8                                         Pad_21FB[0x8];                                     // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class AAISpawner*>                     LinkedSpawner;                                     // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   ActivationZoneMesh;                                // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecurementTime;                                    // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnLimitedSpawnTime;                                // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             IndicatorImage;                                    // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UIndicatorBaseWidget>       IndicatorClassType;                                // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentProgress;                                   // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsActivated;                                       // 0x02D4(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21FC[0x3];                                     // 0x02D5(0x0003)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	int32 GetOverlappedPlayerCount();
	void OnRep_IsActivated();
	void Setter_IsActivated(bool _is_activated);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CLB_SecurementZone">();
	}
	static class ACLB_SecurementZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACLB_SecurementZone>();
	}
};
static_assert(alignof(ACLB_SecurementZone) == 0x000008, "Wrong alignment on ACLB_SecurementZone");
static_assert(sizeof(ACLB_SecurementZone) == 0x0002D8, "Wrong size on ACLB_SecurementZone");
static_assert(offsetof(ACLB_SecurementZone, LinkedSpawner) == 0x0002A0, "Member 'ACLB_SecurementZone::LinkedSpawner' has a wrong offset!");
static_assert(offsetof(ACLB_SecurementZone, ActivationZoneMesh) == 0x0002B0, "Member 'ACLB_SecurementZone::ActivationZoneMesh' has a wrong offset!");
static_assert(offsetof(ACLB_SecurementZone, SecurementTime) == 0x0002B8, "Member 'ACLB_SecurementZone::SecurementTime' has a wrong offset!");
static_assert(offsetof(ACLB_SecurementZone, UnLimitedSpawnTime) == 0x0002BC, "Member 'ACLB_SecurementZone::UnLimitedSpawnTime' has a wrong offset!");
static_assert(offsetof(ACLB_SecurementZone, IndicatorImage) == 0x0002C0, "Member 'ACLB_SecurementZone::IndicatorImage' has a wrong offset!");
static_assert(offsetof(ACLB_SecurementZone, IndicatorClassType) == 0x0002C8, "Member 'ACLB_SecurementZone::IndicatorClassType' has a wrong offset!");
static_assert(offsetof(ACLB_SecurementZone, CurrentProgress) == 0x0002D0, "Member 'ACLB_SecurementZone::CurrentProgress' has a wrong offset!");
static_assert(offsetof(ACLB_SecurementZone, IsActivated) == 0x0002D4, "Member 'ACLB_SecurementZone::IsActivated' has a wrong offset!");

// Class Stigma.ClientSession
// 0x0150 (0x0178 - 0x0028)
class UClientSession final : public UObject
{
public:
	uint8                                         Pad_21FD[0x150];                                   // 0x0028(0x0150)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientSession">();
	}
	static class UClientSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClientSession>();
	}
};
static_assert(alignof(UClientSession) == 0x000008, "Wrong alignment on UClientSession");
static_assert(sizeof(UClientSession) == 0x000178, "Wrong size on UClientSession");

// Class Stigma.HUD_FlyBullet
// 0x0048 (0x0538 - 0x04F0)
class UHUD_FlyBullet : public UPreviewableWidget
{
public:
	class UImage*                                 IMG_Bullet;                                        // 0x04F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21FE[0x40];                                    // 0x04F8(0x0040)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUD_FlyBullet">();
	}
	static class UHUD_FlyBullet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUD_FlyBullet>();
	}
};
static_assert(alignof(UHUD_FlyBullet) == 0x000008, "Wrong alignment on UHUD_FlyBullet");
static_assert(sizeof(UHUD_FlyBullet) == 0x000538, "Wrong size on UHUD_FlyBullet");
static_assert(offsetof(UHUD_FlyBullet, IMG_Bullet) == 0x0004F0, "Member 'UHUD_FlyBullet::IMG_Bullet' has a wrong offset!");

// Class Stigma.Coin
// 0x0060 (0x02F8 - 0x0298)
class ACoin : public AActor
{
public:
	class UStaticMeshComponent*                   Mesh;                                              // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 _TargetActor;                                      // 0x02A0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _ImpulseRangeMin;                                  // 0x02A8(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                _ImpulseRangeMax;                                  // 0x02C0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SimulatePhysicsTimer;                              // 0x02D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21FF[0x4];                                     // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         _FollowSpeed;                                      // 0x02E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _FollowEndDistance;                                // 0x02E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _RotateSpeedMin;                                   // 0x02E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _RotateSpeedMax;                                   // 0x02EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2200[0x8];                                     // 0x02F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Coin">();
	}
	static class ACoin* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACoin>();
	}
};
static_assert(alignof(ACoin) == 0x000008, "Wrong alignment on ACoin");
static_assert(sizeof(ACoin) == 0x0002F8, "Wrong size on ACoin");
static_assert(offsetof(ACoin, Mesh) == 0x000298, "Member 'ACoin::Mesh' has a wrong offset!");
static_assert(offsetof(ACoin, _TargetActor) == 0x0002A0, "Member 'ACoin::_TargetActor' has a wrong offset!");
static_assert(offsetof(ACoin, _ImpulseRangeMin) == 0x0002A8, "Member 'ACoin::_ImpulseRangeMin' has a wrong offset!");
static_assert(offsetof(ACoin, _ImpulseRangeMax) == 0x0002C0, "Member 'ACoin::_ImpulseRangeMax' has a wrong offset!");
static_assert(offsetof(ACoin, SimulatePhysicsTimer) == 0x0002D8, "Member 'ACoin::SimulatePhysicsTimer' has a wrong offset!");
static_assert(offsetof(ACoin, _FollowSpeed) == 0x0002E0, "Member 'ACoin::_FollowSpeed' has a wrong offset!");
static_assert(offsetof(ACoin, _FollowEndDistance) == 0x0002E4, "Member 'ACoin::_FollowEndDistance' has a wrong offset!");
static_assert(offsetof(ACoin, _RotateSpeedMin) == 0x0002E8, "Member 'ACoin::_RotateSpeedMin' has a wrong offset!");
static_assert(offsetof(ACoin, _RotateSpeedMax) == 0x0002EC, "Member 'ACoin::_RotateSpeedMax' has a wrong offset!");

// Class Stigma.LocalRegistry
// 0x0058 (0x0088 - 0x0030)
class ULocalRegistry final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_2201[0x58];                                    // 0x0030(0x0058)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool GetBool(const class FString& _Key, bool _default);
	float GetFloat(const class FString& _Key, float _default);
	int32 GetInt32(const class FString& _Key, int32 _default);
	class FString GetString(const class FString& _Key, const class FString& _default);
	void Load();
	void Save();
	void SetBool(const class FString& _Key, bool _value);
	void SetFloat(const class FString& _Key, float _value);
	void SetInt32(const class FString& _Key, int32 _value);
	void SetString(const class FString& _Key, const class FString& _value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalRegistry">();
	}
	static class ULocalRegistry* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalRegistry>();
	}
};
static_assert(alignof(ULocalRegistry) == 0x000008, "Wrong alignment on ULocalRegistry");
static_assert(sizeof(ULocalRegistry) == 0x000088, "Wrong size on ULocalRegistry");

// Class Stigma.CoinBase
// 0x0050 (0x02E8 - 0x0298)
class ACoinBase : public AActor
{
public:
	uint8                                         Pad_2206[0x10];                                    // 0x0298(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class USceneComponent*                        SceneRootComponent;                                // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       SphereCollision;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _PickUpDistance;                                   // 0x02B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _PickUpDelaySec;                                   // 0x02BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2207[0x4];                                     // 0x02C0(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         _Gold;                                             // 0x02C4(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ACoin>                      _CoinClass;                                        // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ACoin*>                          _Coins;                                            // 0x02D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_2208[0x8];                                     // 0x02E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnPickup(class ACharaBase* _involver);
	void OnRep_Gold();
	void RPC_All_OnPickupItem(class ACharaBase* _involver);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoinBase">();
	}
	static class ACoinBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACoinBase>();
	}
};
static_assert(alignof(ACoinBase) == 0x000008, "Wrong alignment on ACoinBase");
static_assert(sizeof(ACoinBase) == 0x0002E8, "Wrong size on ACoinBase");
static_assert(offsetof(ACoinBase, SceneRootComponent) == 0x0002A8, "Member 'ACoinBase::SceneRootComponent' has a wrong offset!");
static_assert(offsetof(ACoinBase, SphereCollision) == 0x0002B0, "Member 'ACoinBase::SphereCollision' has a wrong offset!");
static_assert(offsetof(ACoinBase, _PickUpDistance) == 0x0002B8, "Member 'ACoinBase::_PickUpDistance' has a wrong offset!");
static_assert(offsetof(ACoinBase, _PickUpDelaySec) == 0x0002BC, "Member 'ACoinBase::_PickUpDelaySec' has a wrong offset!");
static_assert(offsetof(ACoinBase, _Gold) == 0x0002C4, "Member 'ACoinBase::_Gold' has a wrong offset!");
static_assert(offsetof(ACoinBase, _CoinClass) == 0x0002C8, "Member 'ACoinBase::_CoinClass' has a wrong offset!");
static_assert(offsetof(ACoinBase, _Coins) == 0x0002D0, "Member 'ACoinBase::_Coins' has a wrong offset!");

// Class Stigma.ZipLine
// 0x0088 (0x0350 - 0x02C8)
class AZipLine final : public ASplineShapedActor
{
public:
	uint8                                         Pad_2209[0x10];                                    // 0x02C8(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class UStaticMeshComponent*                   _StartConsole;                                     // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   _EndConsole;                                       // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          _StartCollision;                                   // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          _EndCollision;                                     // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _UseConstantVelocity;                              // 0x02F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_220A[0x3];                                     // 0x02F9(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         _ZOffset;                                          // 0x02FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class ACharaBase*, struct FRider>        _Riders;                                           // 0x0300(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ZipLine">();
	}
	static class AZipLine* GetDefaultObj()
	{
		return GetDefaultObjImpl<AZipLine>();
	}
};
static_assert(alignof(AZipLine) == 0x000008, "Wrong alignment on AZipLine");
static_assert(sizeof(AZipLine) == 0x000350, "Wrong size on AZipLine");
static_assert(offsetof(AZipLine, _StartConsole) == 0x0002D8, "Member 'AZipLine::_StartConsole' has a wrong offset!");
static_assert(offsetof(AZipLine, _EndConsole) == 0x0002E0, "Member 'AZipLine::_EndConsole' has a wrong offset!");
static_assert(offsetof(AZipLine, _StartCollision) == 0x0002E8, "Member 'AZipLine::_StartCollision' has a wrong offset!");
static_assert(offsetof(AZipLine, _EndCollision) == 0x0002F0, "Member 'AZipLine::_EndCollision' has a wrong offset!");
static_assert(offsetof(AZipLine, _UseConstantVelocity) == 0x0002F8, "Member 'AZipLine::_UseConstantVelocity' has a wrong offset!");
static_assert(offsetof(AZipLine, _ZOffset) == 0x0002FC, "Member 'AZipLine::_ZOffset' has a wrong offset!");
static_assert(offsetof(AZipLine, _Riders) == 0x000300, "Member 'AZipLine::_Riders' has a wrong offset!");

// Class Stigma.Prop_StoreItem
// 0x0048 (0x0070 - 0x0028)
class UProp_StoreItem : public UObject
{
public:
	class FString                                 Title;                                             // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Category;                                          // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Price;                                             // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PanelWidth;                                        // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PanelHeight;                                       // 0x0054(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   Key;                                               // 0x0058(0x0018)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Prop_StoreItem">();
	}
	static class UProp_StoreItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProp_StoreItem>();
	}
};
static_assert(alignof(UProp_StoreItem) == 0x000008, "Wrong alignment on UProp_StoreItem");
static_assert(sizeof(UProp_StoreItem) == 0x000070, "Wrong size on UProp_StoreItem");
static_assert(offsetof(UProp_StoreItem, Title) == 0x000028, "Member 'UProp_StoreItem::Title' has a wrong offset!");
static_assert(offsetof(UProp_StoreItem, Category) == 0x000038, "Member 'UProp_StoreItem::Category' has a wrong offset!");
static_assert(offsetof(UProp_StoreItem, Price) == 0x000048, "Member 'UProp_StoreItem::Price' has a wrong offset!");
static_assert(offsetof(UProp_StoreItem, Count) == 0x00004C, "Member 'UProp_StoreItem::Count' has a wrong offset!");
static_assert(offsetof(UProp_StoreItem, PanelWidth) == 0x000050, "Member 'UProp_StoreItem::PanelWidth' has a wrong offset!");
static_assert(offsetof(UProp_StoreItem, PanelHeight) == 0x000054, "Member 'UProp_StoreItem::PanelHeight' has a wrong offset!");
static_assert(offsetof(UProp_StoreItem, Key) == 0x000058, "Member 'UProp_StoreItem::Key' has a wrong offset!");

// Class Stigma.CLB_StoreItem
// 0x0010 (0x0080 - 0x0070)
class UCLB_StoreItem final : public UProp_StoreItem
{
public:
	class UCLB_RewardBase*                        ItemReward;                                        // 0x0070(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             UI_Image;                                          // 0x0078(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CLB_StoreItem">();
	}
	static class UCLB_StoreItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCLB_StoreItem>();
	}
};
static_assert(alignof(UCLB_StoreItem) == 0x000008, "Wrong alignment on UCLB_StoreItem");
static_assert(sizeof(UCLB_StoreItem) == 0x000080, "Wrong size on UCLB_StoreItem");
static_assert(offsetof(UCLB_StoreItem, ItemReward) == 0x000070, "Member 'UCLB_StoreItem::ItemReward' has a wrong offset!");
static_assert(offsetof(UCLB_StoreItem, UI_Image) == 0x000078, "Member 'UCLB_StoreItem::UI_Image' has a wrong offset!");

// Class Stigma.LemmingsGameZone
// 0x0188 (0x0420 - 0x0298)
class ALemmingsGameZone final : public AActor
{
public:
	TArray<class UCapsuleComponent*>              _SpawnPoints;                                      // 0x0298(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UBoxComponent*                          _KillZone;                                         // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class ANPC_Lemming>               _NPCClass;                                         // 0x02B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 WaveDesign;                                        // 0x02B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_220B[0x10];                                    // 0x02C8(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         _StartingWaveIndex;                                // 0x02D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _StartingDelay;                                    // 0x02DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _IntermissionDelay;                                // 0x02E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _LifeLimit;                                        // 0x02E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_220C[0xB0];                                    // 0x02E8(0x00B0)(Fixing Size After Last Property [ Dumper-69 ])
	TSet<class ANPC_Lemming*>                     _Lemmings;                                         // 0x0398(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FLemmingsGameState                     _GameState;                                        // 0x03E8(0x001C)(Edit, BlueprintVisible, Net, Transient, EditConst, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_220D[0x4];                                     // 0x0404(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class ACharaBase*                             _Player;                                           // 0x0408(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnChangeGamePhase;                                 // 0x0410(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void FinishGame();
	void OnBeginOverlap_KillZone(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	bool OnChange_GameState(const struct FLemmingsGameState& _state);
	void OnRep_GameState();
	void RPC_ALL_LemmingDied(class ANPC_Lemming* _lemming, bool _is_killed_by_player);
	void Setter_GameState(const struct FLemmingsGameState& _new_state);
	void StartGame(class ACharaBase* _user);

	int32 GetCurrentWave() const;
	int32 GetPoint() const;
	int32 GetWaveCount() const;
	bool IsPlaying() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LemmingsGameZone">();
	}
	static class ALemmingsGameZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALemmingsGameZone>();
	}
};
static_assert(alignof(ALemmingsGameZone) == 0x000008, "Wrong alignment on ALemmingsGameZone");
static_assert(sizeof(ALemmingsGameZone) == 0x000420, "Wrong size on ALemmingsGameZone");
static_assert(offsetof(ALemmingsGameZone, _SpawnPoints) == 0x000298, "Member 'ALemmingsGameZone::_SpawnPoints' has a wrong offset!");
static_assert(offsetof(ALemmingsGameZone, _KillZone) == 0x0002A8, "Member 'ALemmingsGameZone::_KillZone' has a wrong offset!");
static_assert(offsetof(ALemmingsGameZone, _NPCClass) == 0x0002B0, "Member 'ALemmingsGameZone::_NPCClass' has a wrong offset!");
static_assert(offsetof(ALemmingsGameZone, WaveDesign) == 0x0002B8, "Member 'ALemmingsGameZone::WaveDesign' has a wrong offset!");
static_assert(offsetof(ALemmingsGameZone, _StartingWaveIndex) == 0x0002D8, "Member 'ALemmingsGameZone::_StartingWaveIndex' has a wrong offset!");
static_assert(offsetof(ALemmingsGameZone, _StartingDelay) == 0x0002DC, "Member 'ALemmingsGameZone::_StartingDelay' has a wrong offset!");
static_assert(offsetof(ALemmingsGameZone, _IntermissionDelay) == 0x0002E0, "Member 'ALemmingsGameZone::_IntermissionDelay' has a wrong offset!");
static_assert(offsetof(ALemmingsGameZone, _LifeLimit) == 0x0002E4, "Member 'ALemmingsGameZone::_LifeLimit' has a wrong offset!");
static_assert(offsetof(ALemmingsGameZone, _Lemmings) == 0x000398, "Member 'ALemmingsGameZone::_Lemmings' has a wrong offset!");
static_assert(offsetof(ALemmingsGameZone, _GameState) == 0x0003E8, "Member 'ALemmingsGameZone::_GameState' has a wrong offset!");
static_assert(offsetof(ALemmingsGameZone, _Player) == 0x000408, "Member 'ALemmingsGameZone::_Player' has a wrong offset!");
static_assert(offsetof(ALemmingsGameZone, OnChangeGamePhase) == 0x000410, "Member 'ALemmingsGameZone::OnChangeGamePhase' has a wrong offset!");

// Class Stigma.VoiceSubsystem
// 0x0118 (0x0148 - 0x0030)
class UVoiceSubsystem final : public UGameInstanceSubsystem
{
public:
	class USoundEffectSourcePresetChain*          _RadioVoiceEffectPresetChain;                      // 0x0030(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, class USoundCue*>           _AnnouncerVoiceMap;                                // 0x0038(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<ECharaType, struct FVoiceMap>            _CharacterVoiceMap;                                // 0x0088(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<struct FChannelVoiceInfo>              _RawChannelVoiceInfos;                             // 0x00D8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<class AActor*, struct FToPlayVoiceInfo>  _CurrentVoiceInfoMap;                              // 0x00E8(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2211[0x10];                                    // 0x0138(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnFinishedVoiceInfo(const struct FToPlayVoiceInfo& _finished_voice_info);
	void SetVoiceIgnored(bool _value);
	void StopAllVoices();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoiceSubsystem">();
	}
	static class UVoiceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoiceSubsystem>();
	}
};
static_assert(alignof(UVoiceSubsystem) == 0x000008, "Wrong alignment on UVoiceSubsystem");
static_assert(sizeof(UVoiceSubsystem) == 0x000148, "Wrong size on UVoiceSubsystem");
static_assert(offsetof(UVoiceSubsystem, _RadioVoiceEffectPresetChain) == 0x000030, "Member 'UVoiceSubsystem::_RadioVoiceEffectPresetChain' has a wrong offset!");
static_assert(offsetof(UVoiceSubsystem, _AnnouncerVoiceMap) == 0x000038, "Member 'UVoiceSubsystem::_AnnouncerVoiceMap' has a wrong offset!");
static_assert(offsetof(UVoiceSubsystem, _CharacterVoiceMap) == 0x000088, "Member 'UVoiceSubsystem::_CharacterVoiceMap' has a wrong offset!");
static_assert(offsetof(UVoiceSubsystem, _RawChannelVoiceInfos) == 0x0000D8, "Member 'UVoiceSubsystem::_RawChannelVoiceInfos' has a wrong offset!");
static_assert(offsetof(UVoiceSubsystem, _CurrentVoiceInfoMap) == 0x0000E8, "Member 'UVoiceSubsystem::_CurrentVoiceInfoMap' has a wrong offset!");

// Class Stigma.TrainingRoomGameMode
// 0x0000 (0x07D8 - 0x07D8)
class ATrainingRoomGameMode : public ABattleGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrainingRoomGameMode">();
	}
	static class ATrainingRoomGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrainingRoomGameMode>();
	}
};
static_assert(alignof(ATrainingRoomGameMode) == 0x000008, "Wrong alignment on ATrainingRoomGameMode");
static_assert(sizeof(ATrainingRoomGameMode) == 0x0007D8, "Wrong size on ATrainingRoomGameMode");

// Class Stigma.Prop_Store
// 0x0088 (0x0320 - 0x0298)
class AProp_Store : public AActor
{
public:
	uint8                                         Pad_2212[0x8];                                     // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UUI_StorePopup>             Store_popup_class;                                 // 0x02A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsNetworkShareItem;                                // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2213[0x7];                                     // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UUI_StorePopup*                         StorePopup;                                        // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UProp_StoreItem*>                ItemList;                                          // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<int32, class UProp_StoreItemList*>       ItemListMap;                                       // 0x02C8(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UMeshComponent*                         _Mesh;                                             // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CLIENT_RequestPurchase(int32 _item_index, class ACharaBase* _involver);
	void RPC_ALL_SuccessPurchase(int32 _item_index, class ACharaBase* _involver);

	class UProp_StoreItem* GetItem(int32 _index, class ACharaBase* _involver) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Prop_Store">();
	}
	static class AProp_Store* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProp_Store>();
	}
};
static_assert(alignof(AProp_Store) == 0x000008, "Wrong alignment on AProp_Store");
static_assert(sizeof(AProp_Store) == 0x000320, "Wrong size on AProp_Store");
static_assert(offsetof(AProp_Store, Store_popup_class) == 0x0002A0, "Member 'AProp_Store::Store_popup_class' has a wrong offset!");
static_assert(offsetof(AProp_Store, IsNetworkShareItem) == 0x0002A8, "Member 'AProp_Store::IsNetworkShareItem' has a wrong offset!");
static_assert(offsetof(AProp_Store, StorePopup) == 0x0002B0, "Member 'AProp_Store::StorePopup' has a wrong offset!");
static_assert(offsetof(AProp_Store, ItemList) == 0x0002B8, "Member 'AProp_Store::ItemList' has a wrong offset!");
static_assert(offsetof(AProp_Store, ItemListMap) == 0x0002C8, "Member 'AProp_Store::ItemListMap' has a wrong offset!");
static_assert(offsetof(AProp_Store, _Mesh) == 0x000318, "Member 'AProp_Store::_Mesh' has a wrong offset!");

// Class Stigma.MissionCondition_ChangeParts
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_ChangeParts final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_ChangeParts">();
	}
	static class UMissionCondition_ChangeParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_ChangeParts>();
	}
};
static_assert(alignof(UMissionCondition_ChangeParts) == 0x000008, "Wrong alignment on UMissionCondition_ChangeParts");
static_assert(sizeof(UMissionCondition_ChangeParts) == 0x000068, "Wrong size on UMissionCondition_ChangeParts");

// Class Stigma.UIGuide_Base
// 0x0008 (0x0038 - 0x0030)
class UUIGuide_Base : public UBlueprintAsyncActionBase
{
public:
	class UTutorial*                              _OwnerTutorial;                                    // 0x0030(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGuide_Base">();
	}
	static class UUIGuide_Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGuide_Base>();
	}
};
static_assert(alignof(UUIGuide_Base) == 0x000008, "Wrong alignment on UUIGuide_Base");
static_assert(sizeof(UUIGuide_Base) == 0x000038, "Wrong size on UUIGuide_Base");
static_assert(offsetof(UUIGuide_Base, _OwnerTutorial) == 0x000030, "Member 'UUIGuide_Base::_OwnerTutorial' has a wrong offset!");

// Class Stigma.UIGuide_PointUI
// 0x0040 (0x0078 - 0x0038)
class UUIGuide_PointUI final : public UUIGuide_Base
{
public:
	uint8                                         Pad_2217[0x30];                                    // 0x0038(0x0030)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             OnAfterDone;                                       // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UUIGuide_PointUI* Tutorial_PointUI(class UTutorial* _tutorial, class FName _id_to_point, const struct FKey& _guide_key, bool _guide_input, float _wait_time);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGuide_PointUI">();
	}
	static class UUIGuide_PointUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGuide_PointUI>();
	}
};
static_assert(alignof(UUIGuide_PointUI) == 0x000008, "Wrong alignment on UUIGuide_PointUI");
static_assert(sizeof(UUIGuide_PointUI) == 0x000078, "Wrong size on UUIGuide_PointUI");
static_assert(offsetof(UUIGuide_PointUI, OnAfterDone) == 0x000068, "Member 'UUIGuide_PointUI::OnAfterDone' has a wrong offset!");

// Class Stigma.CollaborationModeStore
// 0x0048 (0x0368 - 0x0320)
class ACollaborationModeStore final : public AProp_Store
{
public:
	uint8                                         Pad_2219[0x8];                                     // 0x0320(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class FString                                 StoreID;                                           // 0x0328(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCLB_GoodsStoreEntry                   StoreEntry;                                        // 0x0338(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          IsIndicateable;                                    // 0x0350(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsInteractable;                                    // 0x0351(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_221A[0x6];                                     // 0x0352(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	class UTexture2D*                             Store_Indicator;                                   // 0x0358(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UIndicatorBaseWidget>       IndicatorClassType;                                // 0x0360(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnRep_IsIndicateable();
	void OnRep_IsInteractable();
	void SERVER_Internal_Set_Interactable_Property(bool _value);
	void Setter_IsIndicateable(bool _is_indicateable);
	void Setter_IsInteractable(bool _is_interactable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CollaborationModeStore">();
	}
	static class ACollaborationModeStore* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACollaborationModeStore>();
	}
};
static_assert(alignof(ACollaborationModeStore) == 0x000008, "Wrong alignment on ACollaborationModeStore");
static_assert(sizeof(ACollaborationModeStore) == 0x000368, "Wrong size on ACollaborationModeStore");
static_assert(offsetof(ACollaborationModeStore, StoreID) == 0x000328, "Member 'ACollaborationModeStore::StoreID' has a wrong offset!");
static_assert(offsetof(ACollaborationModeStore, StoreEntry) == 0x000338, "Member 'ACollaborationModeStore::StoreEntry' has a wrong offset!");
static_assert(offsetof(ACollaborationModeStore, IsIndicateable) == 0x000350, "Member 'ACollaborationModeStore::IsIndicateable' has a wrong offset!");
static_assert(offsetof(ACollaborationModeStore, IsInteractable) == 0x000351, "Member 'ACollaborationModeStore::IsInteractable' has a wrong offset!");
static_assert(offsetof(ACollaborationModeStore, Store_Indicator) == 0x000358, "Member 'ACollaborationModeStore::Store_Indicator' has a wrong offset!");
static_assert(offsetof(ACollaborationModeStore, IndicatorClassType) == 0x000360, "Member 'ACollaborationModeStore::IndicatorClassType' has a wrong offset!");

// Class Stigma.WaitingRoom_AIController
// 0x0008 (0x03C8 - 0x03C0)
class AWaitingRoom_AIController final : public AAIController
{
public:
	uint8                                         Pad_221B[0x8];                                     // 0x03C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaitingRoom_AIController">();
	}
	static class AWaitingRoom_AIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWaitingRoom_AIController>();
	}
};
static_assert(alignof(AWaitingRoom_AIController) == 0x000008, "Wrong alignment on AWaitingRoom_AIController");
static_assert(sizeof(AWaitingRoom_AIController) == 0x0003C8, "Wrong size on AWaitingRoom_AIController");

// Class Stigma.CompetitionBriefPlayer
// 0x0048 (0x0070 - 0x0028)
class UCompetitionBriefPlayer final : public UObject
{
public:
	ECompetitionType                              _CompetitionType;                                  // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECompetitionState                             _CompetitionState;                                 // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_221C[0x6];                                     // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	struct FUserID                                _UserIDN;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FUserName                              _nickname;                                         // 0x0038(0x0018)(Edit, BlueprintVisible, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUserPlayingAt                                _PlayingAt;                                        // 0x0050(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_221D[0x7];                                     // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FDateTime                              _EndAt;                                            // 0x0058(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDateTime                              _BreakEndAt;                                       // 0x0060(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _Rank;                                             // 0x0068(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _RankPoint;                                        // 0x006C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	ECompetitionState GetCompetitionState();

	struct FDateTime GetBreakEndAt() const;
	ECompetitionType GetCompetitionType() const;
	struct FDateTime GetEndAt() const;
	struct FUserName GetNickname() const;
	EUserPlayingAt GetPlayingAt() const;
	int32 GetRank() const;
	float GetRankPoint() const;
	struct FUserID GetUserID() const;
	bool IsInBattle() const;
	bool IsMyBrief() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompetitionBriefPlayer">();
	}
	static class UCompetitionBriefPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCompetitionBriefPlayer>();
	}
};
static_assert(alignof(UCompetitionBriefPlayer) == 0x000008, "Wrong alignment on UCompetitionBriefPlayer");
static_assert(sizeof(UCompetitionBriefPlayer) == 0x000070, "Wrong size on UCompetitionBriefPlayer");
static_assert(offsetof(UCompetitionBriefPlayer, _CompetitionType) == 0x000028, "Member 'UCompetitionBriefPlayer::_CompetitionType' has a wrong offset!");
static_assert(offsetof(UCompetitionBriefPlayer, _CompetitionState) == 0x000029, "Member 'UCompetitionBriefPlayer::_CompetitionState' has a wrong offset!");
static_assert(offsetof(UCompetitionBriefPlayer, _UserIDN) == 0x000030, "Member 'UCompetitionBriefPlayer::_UserIDN' has a wrong offset!");
static_assert(offsetof(UCompetitionBriefPlayer, _nickname) == 0x000038, "Member 'UCompetitionBriefPlayer::_nickname' has a wrong offset!");
static_assert(offsetof(UCompetitionBriefPlayer, _PlayingAt) == 0x000050, "Member 'UCompetitionBriefPlayer::_PlayingAt' has a wrong offset!");
static_assert(offsetof(UCompetitionBriefPlayer, _EndAt) == 0x000058, "Member 'UCompetitionBriefPlayer::_EndAt' has a wrong offset!");
static_assert(offsetof(UCompetitionBriefPlayer, _BreakEndAt) == 0x000060, "Member 'UCompetitionBriefPlayer::_BreakEndAt' has a wrong offset!");
static_assert(offsetof(UCompetitionBriefPlayer, _Rank) == 0x000068, "Member 'UCompetitionBriefPlayer::_Rank' has a wrong offset!");
static_assert(offsetof(UCompetitionBriefPlayer, _RankPoint) == 0x00006C, "Member 'UCompetitionBriefPlayer::_RankPoint' has a wrong offset!");

// Class Stigma.CompetitionBriefInfo
// 0x0020 (0x0048 - 0x0028)
class UCompetitionBriefInfo final : public UObject
{
public:
	ECompetitionType                              _CompetitionType;                                  // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_221E[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class UCompetitionBriefPlayer*>        _BriefPlayers;                                     // 0x0030(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_221F[0x8];                                     // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	TArray<class UCompetitionBriefPlayer*> GetBriefPlayers();
	class UCompetitionBriefPlayer* GetMyBriefPlayer();
	ECompetitionState GetMyPlayerState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompetitionBriefInfo">();
	}
	static class UCompetitionBriefInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCompetitionBriefInfo>();
	}
};
static_assert(alignof(UCompetitionBriefInfo) == 0x000008, "Wrong alignment on UCompetitionBriefInfo");
static_assert(sizeof(UCompetitionBriefInfo) == 0x000048, "Wrong size on UCompetitionBriefInfo");
static_assert(offsetof(UCompetitionBriefInfo, _CompetitionType) == 0x000028, "Member 'UCompetitionBriefInfo::_CompetitionType' has a wrong offset!");
static_assert(offsetof(UCompetitionBriefInfo, _BriefPlayers) == 0x000030, "Member 'UCompetitionBriefInfo::_BriefPlayers' has a wrong offset!");

// Class Stigma.HUD_PlayerSlot
// 0x0088 (0x0578 - 0x04F0)
class UHUD_PlayerSlot : public UPreviewableWidget
{
public:
	class UCanvasPanel*                           Blank_Panel;                                       // 0x04F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           Player_Panel;                                      // 0x04F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           Ready_Panel;                                       // 0x0500(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           Died_Panel;                                        // 0x0508(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           Down_Panel;                                        // 0x0510(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_TeamColor;                                     // 0x0518(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_TeamColorReady;                                // 0x0520(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_CharaIcon;                                     // 0x0528(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_Spectating;                                    // 0x0530(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           PlayerHpProgress;                                  // 0x0538(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       BreakInAnimation;                                  // 0x0540(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       DiedAnimation;                                     // 0x0548(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       DownAnimation;                                     // 0x0550(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABattlePlayerState*                     _PlayerState;                                      // 0x0558(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2220[0x18];                                    // 0x0560(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void InitPlayer(class ABattlePlayerState* _player_state, int32 _zidx_chara, bool _is_blue_team, bool _is_show_hp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUD_PlayerSlot">();
	}
	static class UHUD_PlayerSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUD_PlayerSlot>();
	}
};
static_assert(alignof(UHUD_PlayerSlot) == 0x000008, "Wrong alignment on UHUD_PlayerSlot");
static_assert(sizeof(UHUD_PlayerSlot) == 0x000578, "Wrong size on UHUD_PlayerSlot");
static_assert(offsetof(UHUD_PlayerSlot, Blank_Panel) == 0x0004F0, "Member 'UHUD_PlayerSlot::Blank_Panel' has a wrong offset!");
static_assert(offsetof(UHUD_PlayerSlot, Player_Panel) == 0x0004F8, "Member 'UHUD_PlayerSlot::Player_Panel' has a wrong offset!");
static_assert(offsetof(UHUD_PlayerSlot, Ready_Panel) == 0x000500, "Member 'UHUD_PlayerSlot::Ready_Panel' has a wrong offset!");
static_assert(offsetof(UHUD_PlayerSlot, Died_Panel) == 0x000508, "Member 'UHUD_PlayerSlot::Died_Panel' has a wrong offset!");
static_assert(offsetof(UHUD_PlayerSlot, Down_Panel) == 0x000510, "Member 'UHUD_PlayerSlot::Down_Panel' has a wrong offset!");
static_assert(offsetof(UHUD_PlayerSlot, IMG_TeamColor) == 0x000518, "Member 'UHUD_PlayerSlot::IMG_TeamColor' has a wrong offset!");
static_assert(offsetof(UHUD_PlayerSlot, IMG_TeamColorReady) == 0x000520, "Member 'UHUD_PlayerSlot::IMG_TeamColorReady' has a wrong offset!");
static_assert(offsetof(UHUD_PlayerSlot, Img_CharaIcon) == 0x000528, "Member 'UHUD_PlayerSlot::Img_CharaIcon' has a wrong offset!");
static_assert(offsetof(UHUD_PlayerSlot, IMG_Spectating) == 0x000530, "Member 'UHUD_PlayerSlot::IMG_Spectating' has a wrong offset!");
static_assert(offsetof(UHUD_PlayerSlot, PlayerHpProgress) == 0x000538, "Member 'UHUD_PlayerSlot::PlayerHpProgress' has a wrong offset!");
static_assert(offsetof(UHUD_PlayerSlot, BreakInAnimation) == 0x000540, "Member 'UHUD_PlayerSlot::BreakInAnimation' has a wrong offset!");
static_assert(offsetof(UHUD_PlayerSlot, DiedAnimation) == 0x000548, "Member 'UHUD_PlayerSlot::DiedAnimation' has a wrong offset!");
static_assert(offsetof(UHUD_PlayerSlot, DownAnimation) == 0x000550, "Member 'UHUD_PlayerSlot::DownAnimation' has a wrong offset!");
static_assert(offsetof(UHUD_PlayerSlot, _PlayerState) == 0x000558, "Member 'UHUD_PlayerSlot::_PlayerState' has a wrong offset!");

// Class Stigma.CompetitionPlayer
// 0x0068 (0x0090 - 0x0028)
class UCompetitionPlayer final : public UObject
{
public:
	class UCompetitionBriefPlayer*                _BriefPlayer;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _PlayTime;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _Kill;                                             // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _Death;                                            // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _assist;                                           // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _Win1Count;                                        // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _Win2Count;                                        // 0x0044(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _CompetCount;                                      // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _RewardCount;                                      // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _TopRank;                                          // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2222[0x4];                                     // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FItemID                                _ProfileCardIDN;                                   // 0x0058(0x0010)(Edit, BlueprintVisible, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemID                                _EmblemIDN;                                        // 0x0068(0x0010)(Edit, BlueprintVisible, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemID                                _NicknameFXIDN;                                    // 0x0078(0x0010)(Edit, BlueprintVisible, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETier                                         _TierRank;                                         // 0x0088(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2223[0x3];                                     // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         _level;                                            // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	ECompetitionState GetPlayerState();

	int32 GetAssist() const;
	class UCompetitionBriefPlayer* GetBriefPlayer() const;
	int32 GetCompetCount() const;
	int32 GetDeath() const;
	struct FItemID GetEmblemID() const;
	int32 GetKill() const;
	int32 GetLevel() const;
	struct FItemID GetNicknameFXID() const;
	int32 GetPlayTime() const;
	struct FItemID GetProfileCardID() const;
	int32 GetRewardCount() const;
	ETier GetTier() const;
	int32 GetTopRank() const;
	int32 GetWin1Count() const;
	int32 GetWin2Count() const;
	bool IsMyPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompetitionPlayer">();
	}
	static class UCompetitionPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCompetitionPlayer>();
	}
};
static_assert(alignof(UCompetitionPlayer) == 0x000008, "Wrong alignment on UCompetitionPlayer");
static_assert(sizeof(UCompetitionPlayer) == 0x000090, "Wrong size on UCompetitionPlayer");
static_assert(offsetof(UCompetitionPlayer, _BriefPlayer) == 0x000028, "Member 'UCompetitionPlayer::_BriefPlayer' has a wrong offset!");
static_assert(offsetof(UCompetitionPlayer, _PlayTime) == 0x000030, "Member 'UCompetitionPlayer::_PlayTime' has a wrong offset!");
static_assert(offsetof(UCompetitionPlayer, _Kill) == 0x000034, "Member 'UCompetitionPlayer::_Kill' has a wrong offset!");
static_assert(offsetof(UCompetitionPlayer, _Death) == 0x000038, "Member 'UCompetitionPlayer::_Death' has a wrong offset!");
static_assert(offsetof(UCompetitionPlayer, _assist) == 0x00003C, "Member 'UCompetitionPlayer::_assist' has a wrong offset!");
static_assert(offsetof(UCompetitionPlayer, _Win1Count) == 0x000040, "Member 'UCompetitionPlayer::_Win1Count' has a wrong offset!");
static_assert(offsetof(UCompetitionPlayer, _Win2Count) == 0x000044, "Member 'UCompetitionPlayer::_Win2Count' has a wrong offset!");
static_assert(offsetof(UCompetitionPlayer, _CompetCount) == 0x000048, "Member 'UCompetitionPlayer::_CompetCount' has a wrong offset!");
static_assert(offsetof(UCompetitionPlayer, _RewardCount) == 0x00004C, "Member 'UCompetitionPlayer::_RewardCount' has a wrong offset!");
static_assert(offsetof(UCompetitionPlayer, _TopRank) == 0x000050, "Member 'UCompetitionPlayer::_TopRank' has a wrong offset!");
static_assert(offsetof(UCompetitionPlayer, _ProfileCardIDN) == 0x000058, "Member 'UCompetitionPlayer::_ProfileCardIDN' has a wrong offset!");
static_assert(offsetof(UCompetitionPlayer, _EmblemIDN) == 0x000068, "Member 'UCompetitionPlayer::_EmblemIDN' has a wrong offset!");
static_assert(offsetof(UCompetitionPlayer, _NicknameFXIDN) == 0x000078, "Member 'UCompetitionPlayer::_NicknameFXIDN' has a wrong offset!");
static_assert(offsetof(UCompetitionPlayer, _TierRank) == 0x000088, "Member 'UCompetitionPlayer::_TierRank' has a wrong offset!");
static_assert(offsetof(UCompetitionPlayer, _level) == 0x00008C, "Member 'UCompetitionPlayer::_level' has a wrong offset!");

// Class Stigma.GunObject
// 0x01B8 (0x01E0 - 0x0028)
class UGunObject final : public UObject
{
public:
	uint8                                         Pad_2224[0x18];                                    // 0x0028(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	struct FGunSpec                               _spec;                                             // 0x0040(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	EOwnType                                      _OwnType;                                          // 0x0110(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2225[0x7];                                     // 0x0111(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	int64                                         _OwnValue;                                         // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsTemporary;                                      // 0x0120(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2226[0x3];                                     // 0x0121(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	struct FGunAttribute_Common                   _GunMainAttributes;                                // 0x0124(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGunAttribute_Common                   _GunTotalAttributes;                               // 0x0148(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGunAttribute_Common                   _GunPartsAttributes;                               // 0x016C(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TMap<EGunPartsSlot, struct FGunAttribute_Common> _GunAttributesMap;                                 // 0x0190(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	static class UGunObject* Create(class UObject* _outer, const struct FGunSpec& _gun_spec);
	static bool IsAccessorySlot(EGunPartsSlot _slot);
	static bool IsCharmSlot(EGunPartsSlot _slot);
	static bool IsStickerSlot(EGunPartsSlot _slot);
	static EGunPartsSlot ItemCategoryToPartsSlot(EItemCategory _item_category, const struct FItemID& _item_id);
	static EItemCategory PartsSlotToItemCategory(EGunPartsSlot _slot);

	void BindUpdatedEvent(const TDelegate<void(class UGunObject* Object)>& _event);
	void D_OnUpdatedSpec__DelegateSignature(class UGunObject* Object);
	void SetAccessory(EGunPartsSlot _slot, const struct FItemID& _item_id, bool _is_shop_preview);
	void SetBody(const struct FItemID_Gun_Body& _body_id);
	void SetBulletTip(EBulletTip _bullet_tip);
	void SetCharm(EGunPartsSlot _slot, const struct FItemID_Gun_Charm& _charm_id, bool _is_shop_preview);
	void SetFront(const struct FItemID_Gun_Front& _front_id);
	void SetMagazine(const struct FItemID_Gun_Magazine& _magazine_id);
	void SetPartsID(const struct FItemID& _item_id);
	void SetPresetName(const class FString& _preset_name);
	void SetSight(const struct FItemID_Gun_Sight& _sight_id);
	void SetSlide(const struct FItemID_Gun_Slide& _slide_id);
	void SetSticker(EGunPartsSlot _slot, const struct FItemID_Gun_Sticker& _sticker_id, bool _is_shop_preview);
	void SetTopSight(const struct FItemID_Gun_Sight& _top_sight_id);
	void SetUnderSight(const struct FItemID_Gun_Sight& _under_sight_id);
	void ToggleBookmark();
	void UnBindUpdatedEvent(class UObject* _binder);
	void UpdateGunSpec(const struct FGunSpec& Param__spec);
	void UpdateOwnInfo();

	int32 CalculateEquipablePartsCnt() const;
	int32 CalculateEquippedPartsCnt() const;
	class UGunObject* DuplicatedGunObject() const;
	EGunPartsSlot FindPartsSlotByID(const struct FItemID& _item_id) const;
	struct FItemID_Gun_Body GetBody() const;
	EBulletTip GetBulletTip() const;
	struct FItemID_Gun_Charm GetCharm_Body() const;
	struct FItemID_Gun_Charm GetCharm_Magazine() const;
	struct FDateTime GetExpireAt() const;
	struct FItemID_Gun_Front GetFront() const;
	struct FItemID GetGunPartsID(EGunPartsSlot _slot) const;
	const struct FGunPreset GetGunPreset() const;
	int32 GetGunPresetSlot() const;
	const struct FGunSpec GetGunSpec() const;
	EGunType GetGunType() const;
	struct FItemID_Gun_Magazine GetMagazine() const;
	class FString GetPresetName() const;
	struct FItemID_Gun_Slide GetSlide() const;
	struct FItemID_Gun_Sticker GetSticker_Body() const;
	struct FItemID_Gun_Sticker GetSticker_Body2() const;
	struct FItemID_Gun_Sight GetTopSight() const;
	struct FItemID_Gun_Sight GetUnderSight() const;
	TArray<EGunPartsSlot> GetUnownedGunParts() const;
	bool IsActivatedSlot(EGunPartsSlot _slot) const;
	bool IsBookmarked() const;
	bool IsDefaultPartsSlot(EGunPartsSlot _slot) const;
	bool IsEqual(const class UGunObject* _gun_object) const;
	bool IsEquippedItem(const struct FItemID& _item_id) const;
	bool IsEquippedItemToSlot(EGunPartsSlot _slot, const struct FItemID& _item_id) const;
	bool IsExpiredGun() const;
	bool IsHiddenSlot(EGunPartsSlot _slot) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GunObject">();
	}
	static class UGunObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGunObject>();
	}
};
static_assert(alignof(UGunObject) == 0x000008, "Wrong alignment on UGunObject");
static_assert(sizeof(UGunObject) == 0x0001E0, "Wrong size on UGunObject");
static_assert(offsetof(UGunObject, _spec) == 0x000040, "Member 'UGunObject::_spec' has a wrong offset!");
static_assert(offsetof(UGunObject, _OwnType) == 0x000110, "Member 'UGunObject::_OwnType' has a wrong offset!");
static_assert(offsetof(UGunObject, _OwnValue) == 0x000118, "Member 'UGunObject::_OwnValue' has a wrong offset!");
static_assert(offsetof(UGunObject, _IsTemporary) == 0x000120, "Member 'UGunObject::_IsTemporary' has a wrong offset!");
static_assert(offsetof(UGunObject, _GunMainAttributes) == 0x000124, "Member 'UGunObject::_GunMainAttributes' has a wrong offset!");
static_assert(offsetof(UGunObject, _GunTotalAttributes) == 0x000148, "Member 'UGunObject::_GunTotalAttributes' has a wrong offset!");
static_assert(offsetof(UGunObject, _GunPartsAttributes) == 0x00016C, "Member 'UGunObject::_GunPartsAttributes' has a wrong offset!");
static_assert(offsetof(UGunObject, _GunAttributesMap) == 0x000190, "Member 'UGunObject::_GunAttributesMap' has a wrong offset!");

// Class Stigma.CompetitionInfo
// 0x0018 (0x0040 - 0x0028)
class UCompetitionInfo final : public UObject
{
public:
	ECompetitionType                              _CompetitionType;                                  // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2235[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class UCompetitionPlayer*>             _Players;                                          // 0x0030(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	class UCompetitionPlayer* GetMyPlayer();
	TArray<class UCompetitionPlayer*> GetPlayers();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompetitionInfo">();
	}
	static class UCompetitionInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCompetitionInfo>();
	}
};
static_assert(alignof(UCompetitionInfo) == 0x000008, "Wrong alignment on UCompetitionInfo");
static_assert(sizeof(UCompetitionInfo) == 0x000040, "Wrong size on UCompetitionInfo");
static_assert(offsetof(UCompetitionInfo, _CompetitionType) == 0x000028, "Member 'UCompetitionInfo::_CompetitionType' has a wrong offset!");
static_assert(offsetof(UCompetitionInfo, _Players) == 0x000030, "Member 'UCompetitionInfo::_Players' has a wrong offset!");

// Class Stigma.CompetitionInfoManager
// 0x00F0 (0x0118 - 0x0028)
class UCompetitionInfoManager final : public UObject
{
public:
	TMap<ECompetitionType, class UCompetitionBriefInfo*> _CompetitionBriefMap;                              // 0x0028(0x0050)(NativeAccessSpecifierPrivate)
	TMap<ECompetitionType, class UCompetitionInfo*> _CompetitionPlayerMap;                             // 0x0078(0x0050)(NativeAccessSpecifierPrivate)
	TMap<ECompetitionType, bool>                  _IsUsingFastStartMap;                              // 0x00C8(0x0050)(NativeAccessSpecifierPrivate)

public:
	class UCompetitionBriefInfo* GetCompetitionBrief(ECompetitionType _competition_type);
	class UCompetitionInfo* GetCompetitionPlayerInfo(ECompetitionType _competition_type);
	void SetUseFastStart(ECompetitionType _competition_type, bool _use);

	bool IsEnable(ECompetitionType _competition_type) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CompetitionInfoManager">();
	}
	static class UCompetitionInfoManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCompetitionInfoManager>();
	}
};
static_assert(alignof(UCompetitionInfoManager) == 0x000008, "Wrong alignment on UCompetitionInfoManager");
static_assert(sizeof(UCompetitionInfoManager) == 0x000118, "Wrong size on UCompetitionInfoManager");
static_assert(offsetof(UCompetitionInfoManager, _CompetitionBriefMap) == 0x000028, "Member 'UCompetitionInfoManager::_CompetitionBriefMap' has a wrong offset!");
static_assert(offsetof(UCompetitionInfoManager, _CompetitionPlayerMap) == 0x000078, "Member 'UCompetitionInfoManager::_CompetitionPlayerMap' has a wrong offset!");
static_assert(offsetof(UCompetitionInfoManager, _IsUsingFastStartMap) == 0x0000C8, "Member 'UCompetitionInfoManager::_IsUsingFastStartMap' has a wrong offset!");

// Class Stigma.Config
// 0x0060 (0x0088 - 0x0028)
class UConfig final : public UObject
{
public:
	uint8                                         Pad_2238[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          DEBUG_AllowAllGuns;                                // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Config, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableMovementLogPack;                             // 0x0031(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableActionGraphLogPack;                          // 0x0032(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAppBuild                                     AppBuild;                                          // 0x0033(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Config, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Version_Major;                                     // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Version_Minor;                                     // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Version_Date;                                      // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Version_Revision;                                  // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERunEnv                                       RunEnvironment;                                    // 0x0044(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2239[0x3];                                     // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         SteamAppID;                                        // 0x0048(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DediServerPingIntervalSec;                         // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Config, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 RegionCode;                                        // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_223A[0x28];                                    // 0x0060(0x0028)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static bool CheckVersion(const class FString& _Version);
	static int32 CompareVersion(const class FString& _Version1, const class FString& _Version2);
	static class FString GetAPIURL(const class UObject* _world_ctx, const class FString& _uri);
	static class FString GetMQURL(const class UObject* _world_ctx);
	static ERunEnv GetRunEnvironment();
	static class FString GetRunEnvironmentName();
	static int32 GetSteamAppID();
	static class FString GetVersionString(bool _with_revision);
	static class FString GetWebsocketURL(const class UObject* _world_ctx);
	static bool IsDevelopping();
	static bool IsRunEnvironment(ERunEnv Run_type);
	static bool IsStaging();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Config">();
	}
	static class UConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConfig>();
	}
};
static_assert(alignof(UConfig) == 0x000008, "Wrong alignment on UConfig");
static_assert(sizeof(UConfig) == 0x000088, "Wrong size on UConfig");
static_assert(offsetof(UConfig, DEBUG_AllowAllGuns) == 0x000030, "Member 'UConfig::DEBUG_AllowAllGuns' has a wrong offset!");
static_assert(offsetof(UConfig, EnableMovementLogPack) == 0x000031, "Member 'UConfig::EnableMovementLogPack' has a wrong offset!");
static_assert(offsetof(UConfig, EnableActionGraphLogPack) == 0x000032, "Member 'UConfig::EnableActionGraphLogPack' has a wrong offset!");
static_assert(offsetof(UConfig, AppBuild) == 0x000033, "Member 'UConfig::AppBuild' has a wrong offset!");
static_assert(offsetof(UConfig, Version_Major) == 0x000034, "Member 'UConfig::Version_Major' has a wrong offset!");
static_assert(offsetof(UConfig, Version_Minor) == 0x000038, "Member 'UConfig::Version_Minor' has a wrong offset!");
static_assert(offsetof(UConfig, Version_Date) == 0x00003C, "Member 'UConfig::Version_Date' has a wrong offset!");
static_assert(offsetof(UConfig, Version_Revision) == 0x000040, "Member 'UConfig::Version_Revision' has a wrong offset!");
static_assert(offsetof(UConfig, RunEnvironment) == 0x000044, "Member 'UConfig::RunEnvironment' has a wrong offset!");
static_assert(offsetof(UConfig, SteamAppID) == 0x000048, "Member 'UConfig::SteamAppID' has a wrong offset!");
static_assert(offsetof(UConfig, DediServerPingIntervalSec) == 0x00004C, "Member 'UConfig::DediServerPingIntervalSec' has a wrong offset!");
static_assert(offsetof(UConfig, RegionCode) == 0x000050, "Member 'UConfig::RegionCode' has a wrong offset!");

// Class Stigma.PlayerContext
// 0x06D8 (0x0700 - 0x0028)
class UPlayerContext : public UObject
{
public:
	uint8                                         Pad_223E[0x14C];                                   // 0x0028(0x014C)(Fixing Size After Last Property [ Dumper-69 ])
	struct FUserRole                              _role;                                             // 0x0174(0x0003)(BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_223F[0x1];                                     // 0x0177(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         _level;                                            // 0x0178(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _Exp;                                              // 0x017C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _PlayTime;                                         // 0x0180(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _PlayCount;                                        // 0x0184(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETier                                         _tier;                                             // 0x0188(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2240[0xBF];                                    // 0x0189(0x00BF)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FPassiveSkill>                  _PassiveSkills;                                    // 0x0248(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FItemID_Booster>                _boosters;                                         // 0x0258(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UGunObject*>                     _Guns;                                             // 0x0268(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2241[0x50];                                    // 0x0278(0x0050)(Fixing Size After Last Property [ Dumper-69 ])
	class UInvenItems*                            _InvenItems;                                       // 0x02C8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2242[0x1D0];                                   // 0x02D0(0x01D0)(Fixing Size After Last Property [ Dumper-69 ])
	class UUserMission*                           _Missions;                                         // 0x04A0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2243[0x258];                                   // 0x04A8(0x0258)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void AddMissionConditionReport(EMissionConditionType _type, const class FString& _sub_type, const int32 _value);
	void BindOnMissionUpdatedEvent(const TDelegate<void(EMissionUpdateType _type, class UMission* _mission)>& _proc);
	void DEBUG_SetPassiveSkillLevel(const struct FPassiveSkillID& _skill_id, int32 _skill_level);
	TArray<class UInvenItem*> GetFilteredInvenItems(bool _include_box, bool _include_currency, bool _include_function);
	class UGunObject* GetOptimalGunByControlPower(float _chara_cp, class UGunObject* _cur_gun);
	void OnMissionUpdated(EMissionUpdateType _type, class UMission* _mission);
	void RefreshCharacterOwnInfo(bool _is_in_battle);
	void RefreshGunOwnInfo(bool _is_in_battle);
	void SetEmblem(const struct FItemID& _item_id);
	void SetNicknameFX(const struct FItemID& _item_id);
	void SetProfileCard(const struct FItemID& _item_id);
	void UnBindOnMissionUpdatedEvent(const class UObject* _obj);

	bool FindFunctionByTarget(EFuncTarget _target, struct FAppliedFunction* _function) const;
	class UGunObject* FindGunObjectByPreset(const struct FGunPreset& _preset) const;
	const TArray<struct FActiveFunction> GetActiveFunctions() const;
	TArray<struct FCharacterInfo> GetAllCharacters() const;
	EArmorType GetArmor(ECharaType _type) const;
	struct FItemID GetBody(ECharaType _type) const;
	struct FItemID_Booster GetBooster(int32 _slot_index) const;
	struct FDateTime GetBoosterSlotExpiry(int32 _zidx) const;
	EUserSlotStatus GetBoosterSlotStatus(int32 _zidx) const;
	int32 GetBoosterTicketCount() const;
	const struct FCharacterInfo GetCharacter(ECharaType _chara_type) const;
	ECharaType GetCharaType() const;
	class FString GetCountry() const;
	EArmorType GetCurrentArmor() const;
	struct FItemID_Skin_Body GetCurrentBody() const;
	const struct FCharacterInfo GetCurrentCharacter() const;
	const struct FGunPreset GetCurrentGunPreset() const;
	struct FItemID_Skin_Head GetCurrentHead() const;
	struct FItemID_Emblem GetEmblem() const;
	const struct FPlayerFuncContext GetFuncContext() const;
	const TArray<struct FGMFunction> GetGMFunctions() const;
	const TMap<struct FGunPreset, class UGunObject*> GetGunMap() const;
	const struct FGunPreset GetGunPreset(ECharaType _type) const;
	const TArray<bool> GetGunPresetSlotsStatus() const;
	bool GetGunPresetSlotStatus(int32 _zidx) const;
	const TArray<class UGunObject*> GetGuns() const;
	const TMap<ECharaType, struct FCharacterInfo> GetHavingCharas() const;
	struct FItemID GetHead(ECharaType _type) const;
	class UInvenItems* GetInvenItems() const;
	TArray<class UInvenItem*> GetInvenItemsByGunParts(EGunPartsSlot _gun_parts_slot) const;
	EJoinType GetJoinType() const;
	const struct FPlayerKPI GetKPI() const;
	int32 GetLevel() const;
	const struct FUserName GetNickname() const;
	struct FItemID_NicknameFX GetNicknameFX() const;
	int32 GetPassiveSkillLevel(const struct FPassiveSkillID& _id) const;
	int32 GetPickedCharaCount() const;
	ECharaType GetPickedCharaType(int32 _zidx) const;
	const struct FCharacterInfo GetPreviewCharaInfo() const;
	const struct FPlayerPrivilege GetPrivilege() const;
	struct FItemID_ProfileCard GetProfileCard() const;
	class FString GetRegion() const;
	const struct FUserRole GetRole() const;
	ETeams GetTeam() const;
	ETier GetTier() const;
	class UInvenItem* GetTopInvenItemByID(const struct FItemID& _id) const;
	int32 GetTotalSkillPoint() const;
	struct FTutorialProgress GetTutorialProgress() const;
	bool HasCharacter(ECharaType _chara_type) const;
	bool HasItem(const struct FItemID& _item_id) const;
	bool HasUniqueItem(const struct FItemID& _item_id) const;
	bool HasValidCharacters() const;
	bool IsAI() const;
	bool IsBoosterSlotActive(int32 _zidx) const;
	bool IsEquippedItem(EItemCategory _category, const struct FItemID& _item_id) const;
	bool IsFunctionApplied(const struct FItemIDRef_Function& _item_id) const;
	bool IsReadyToFight() const;
	bool IsTutorialCompleted() const;
	bool IsTutorialPaused() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerContext">();
	}
	static class UPlayerContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerContext>();
	}
};
static_assert(alignof(UPlayerContext) == 0x000008, "Wrong alignment on UPlayerContext");
static_assert(sizeof(UPlayerContext) == 0x000700, "Wrong size on UPlayerContext");
static_assert(offsetof(UPlayerContext, _role) == 0x000174, "Member 'UPlayerContext::_role' has a wrong offset!");
static_assert(offsetof(UPlayerContext, _level) == 0x000178, "Member 'UPlayerContext::_level' has a wrong offset!");
static_assert(offsetof(UPlayerContext, _Exp) == 0x00017C, "Member 'UPlayerContext::_Exp' has a wrong offset!");
static_assert(offsetof(UPlayerContext, _PlayTime) == 0x000180, "Member 'UPlayerContext::_PlayTime' has a wrong offset!");
static_assert(offsetof(UPlayerContext, _PlayCount) == 0x000184, "Member 'UPlayerContext::_PlayCount' has a wrong offset!");
static_assert(offsetof(UPlayerContext, _tier) == 0x000188, "Member 'UPlayerContext::_tier' has a wrong offset!");
static_assert(offsetof(UPlayerContext, _PassiveSkills) == 0x000248, "Member 'UPlayerContext::_PassiveSkills' has a wrong offset!");
static_assert(offsetof(UPlayerContext, _boosters) == 0x000258, "Member 'UPlayerContext::_boosters' has a wrong offset!");
static_assert(offsetof(UPlayerContext, _Guns) == 0x000268, "Member 'UPlayerContext::_Guns' has a wrong offset!");
static_assert(offsetof(UPlayerContext, _InvenItems) == 0x0002C8, "Member 'UPlayerContext::_InvenItems' has a wrong offset!");
static_assert(offsetof(UPlayerContext, _Missions) == 0x0004A0, "Member 'UPlayerContext::_Missions' has a wrong offset!");

// Class Stigma.LocalPlayerContext
// 0x0188 (0x0888 - 0x0700)
class ULocalPlayerContext final : public UPlayerContext
{
public:
	uint8                                         Pad_225D[0x10];                                    // 0x0700(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class ULocalUserProfile*                      _UserObj;                                          // 0x0710(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FItemID_EventPage, struct FEventPageInfo> _EventPageMap;                                     // 0x0718(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<struct FItemID_BattlePass, struct FBattlePassInfo> _BattlePassMap;                                    // 0x0768(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<EGoodsCategory, struct FCategoryGoodsMap> _GoodsMap;                                         // 0x07B8(0x0050)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_225E[0x8];                                     // 0x0808(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	struct FPassiveSkillID                        _LastSelectedPassiveSkillID;                       // 0x0810(0x0010)(BlueprintVisible, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCompetitionInfoManager*                _CompetitionInfoManager;                           // 0x0820(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_225F[0x58];                                    // 0x0828(0x0058)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         _PrevPassExp;                                      // 0x0880(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2260[0x4];                                     // 0x0884(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void AddRewardItem(const struct FRewardPlain& _reward_plain);
	const TArray<class UInvenItem*> GetAllItemsOfCategory(EItemCategory _category);
	struct FCategoryGoodsMap GetCategoryGoods(EGoodsCategory _category);
	class UCompetitionInfoManager* GetCompetitionInfoManager();
	class UGunObject* GetCopiedCurrentGunObject();
	class ULocalUserProfile* GetUserObject();
	void MakeItemsSeen(EItemCategory _category);

	class UGunObject* GetCurrentGunObject() const;
	bool HasCategoryGoods(EGoodsCategory _category) const;
	bool IsReadyForPVP() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalPlayerContext">();
	}
	static class ULocalPlayerContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalPlayerContext>();
	}
};
static_assert(alignof(ULocalPlayerContext) == 0x000008, "Wrong alignment on ULocalPlayerContext");
static_assert(sizeof(ULocalPlayerContext) == 0x000888, "Wrong size on ULocalPlayerContext");
static_assert(offsetof(ULocalPlayerContext, _UserObj) == 0x000710, "Member 'ULocalPlayerContext::_UserObj' has a wrong offset!");
static_assert(offsetof(ULocalPlayerContext, _EventPageMap) == 0x000718, "Member 'ULocalPlayerContext::_EventPageMap' has a wrong offset!");
static_assert(offsetof(ULocalPlayerContext, _BattlePassMap) == 0x000768, "Member 'ULocalPlayerContext::_BattlePassMap' has a wrong offset!");
static_assert(offsetof(ULocalPlayerContext, _GoodsMap) == 0x0007B8, "Member 'ULocalPlayerContext::_GoodsMap' has a wrong offset!");
static_assert(offsetof(ULocalPlayerContext, _LastSelectedPassiveSkillID) == 0x000810, "Member 'ULocalPlayerContext::_LastSelectedPassiveSkillID' has a wrong offset!");
static_assert(offsetof(ULocalPlayerContext, _CompetitionInfoManager) == 0x000820, "Member 'ULocalPlayerContext::_CompetitionInfoManager' has a wrong offset!");
static_assert(offsetof(ULocalPlayerContext, _PrevPassExp) == 0x000880, "Member 'ULocalPlayerContext::_PrevPassExp' has a wrong offset!");

// Class Stigma.WaitingRoomPlayerState
// 0x0008 (0x05A8 - 0x05A0)
class AWaitingRoomPlayerState final : public AMatchServicedPlayerState
{
public:
	int32                                         _StartingDuration;                                 // 0x05A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2263[0x4];                                     // 0x05A4(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaitingRoomPlayerState">();
	}
	static class AWaitingRoomPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWaitingRoomPlayerState>();
	}
};
static_assert(alignof(AWaitingRoomPlayerState) == 0x000008, "Wrong alignment on AWaitingRoomPlayerState");
static_assert(sizeof(AWaitingRoomPlayerState) == 0x0005A8, "Wrong size on AWaitingRoomPlayerState");
static_assert(offsetof(AWaitingRoomPlayerState, _StartingDuration) == 0x0005A0, "Member 'AWaitingRoomPlayerState::_StartingDuration' has a wrong offset!");

// Class Stigma.UIGuide_Dialog
// 0x0038 (0x0070 - 0x0038)
class UUIGuide_Dialog final : public UUIGuide_Base
{
public:
	class UTexture2D*                             Image;                                             // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2264[0x20];                                    // 0x0040(0x0020)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             OnAfterDone;                                       // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UUIGuide_Dialog* Tutorial_Dialog(class UTutorial* _tutorial, const class FText& _msg, class UTexture2D* _tex, int32 _img_index, bool _left_side, bool _black_screen);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGuide_Dialog">();
	}
	static class UUIGuide_Dialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGuide_Dialog>();
	}
};
static_assert(alignof(UUIGuide_Dialog) == 0x000008, "Wrong alignment on UUIGuide_Dialog");
static_assert(sizeof(UUIGuide_Dialog) == 0x000070, "Wrong size on UUIGuide_Dialog");
static_assert(offsetof(UUIGuide_Dialog, Image) == 0x000038, "Member 'UUIGuide_Dialog::Image' has a wrong offset!");
static_assert(offsetof(UUIGuide_Dialog, OnAfterDone) == 0x000060, "Member 'UUIGuide_Dialog::OnAfterDone' has a wrong offset!");

// Class Stigma.FunctionHelper
// 0x0000 (0x0028 - 0x0028)
class UFunctionHelper final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class FText> GetFunctionEffectText(const struct FConfig_Function& _function_def);
	static bool IsGrantedOnceEffect(const struct FConfig_Function& _function_def);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FunctionHelper">();
	}
	static class UFunctionHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFunctionHelper>();
	}
};
static_assert(alignof(UFunctionHelper) == 0x000008, "Wrong alignment on UFunctionHelper");
static_assert(sizeof(UFunctionHelper) == 0x000028, "Wrong size on UFunctionHelper");

// Class Stigma.MissionCondition_UseCurrency
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_UseCurrency final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_UseCurrency">();
	}
	static class UMissionCondition_UseCurrency* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_UseCurrency>();
	}
};
static_assert(alignof(UMissionCondition_UseCurrency) == 0x000008, "Wrong alignment on UMissionCondition_UseCurrency");
static_assert(sizeof(UMissionCondition_UseCurrency) == 0x000068, "Wrong size on UMissionCondition_UseCurrency");

// Class Stigma.UIGuide_StopTutorial
// 0x0000 (0x0038 - 0x0038)
class UUIGuide_StopTutorial final : public UUIGuide_Base
{
public:
	static class UUIGuide_StopTutorial* Tutorial_StopTutorial(class UTutorial* _tutorial);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGuide_StopTutorial">();
	}
	static class UUIGuide_StopTutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGuide_StopTutorial>();
	}
};
static_assert(alignof(UUIGuide_StopTutorial) == 0x000008, "Wrong alignment on UUIGuide_StopTutorial");
static_assert(sizeof(UUIGuide_StopTutorial) == 0x000038, "Wrong size on UUIGuide_StopTutorial");

// Class Stigma.ControlRate
// 0x0010 (0x0040 - 0x0030)
class UControlRate final : public UAnimNotifyState
{
public:
	float                                         MovementRate;                                      // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RotationYawRate;                                   // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CallEnd;                                           // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2267[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControlRate">();
	}
	static class UControlRate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControlRate>();
	}
};
static_assert(alignof(UControlRate) == 0x000008, "Wrong alignment on UControlRate");
static_assert(sizeof(UControlRate) == 0x000040, "Wrong size on UControlRate");
static_assert(offsetof(UControlRate, MovementRate) == 0x000030, "Member 'UControlRate::MovementRate' has a wrong offset!");
static_assert(offsetof(UControlRate, RotationYawRate) == 0x000034, "Member 'UControlRate::RotationYawRate' has a wrong offset!");
static_assert(offsetof(UControlRate, CallEnd) == 0x000038, "Member 'UControlRate::CallEnd' has a wrong offset!");

// Class Stigma.CooltimeComponent
// 0x0050 (0x00F0 - 0x00A0)
class UCooltimeComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2268[0x50];                                    // 0x00A0(0x0050)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool IsExpired(const class FName Param_Name, float* Out_remain_time, float* Out_duration);
	void StartCooltime(class FName Param_Name, float Duration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CooltimeComponent">();
	}
	static class UCooltimeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCooltimeComponent>();
	}
};
static_assert(alignof(UCooltimeComponent) == 0x000008, "Wrong alignment on UCooltimeComponent");
static_assert(sizeof(UCooltimeComponent) == 0x0000F0, "Wrong size on UCooltimeComponent");

// Class Stigma.MissionCondition_Resurrect
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_Resurrect final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_Resurrect">();
	}
	static class UMissionCondition_Resurrect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_Resurrect>();
	}
};
static_assert(alignof(UMissionCondition_Resurrect) == 0x000008, "Wrong alignment on UMissionCondition_Resurrect");
static_assert(sizeof(UMissionCondition_Resurrect) == 0x000068, "Wrong size on UMissionCondition_Resurrect");

// Class Stigma.CounterAttack
// 0x0000 (0x0030 - 0x0030)
class UCounterAttack final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CounterAttack">();
	}
	static class UCounterAttack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCounterAttack>();
	}
};
static_assert(alignof(UCounterAttack) == 0x000008, "Wrong alignment on UCounterAttack");
static_assert(sizeof(UCounterAttack) == 0x000030, "Wrong size on UCounterAttack");

// Class Stigma.HUD_Armor
// 0x0030 (0x0520 - 0x04F0)
class UHUD_Armor : public UPreviewableWidget
{
public:
	class ACharaBase*                             _TargetChara;                                      // 0x04F0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_Frame;                                         // 0x04F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_ArmorValue;                                    // 0x0500(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               ArmorMaterial;                                     // 0x0508(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_226A[0x10];                                    // 0x0510(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void BindTargetChara(class ACharaBase* _chara);
	void OnRechargeArmor(float _inc_armor_rate);
	void Update();
	void UpdateMaterial();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUD_Armor">();
	}
	static class UHUD_Armor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUD_Armor>();
	}
};
static_assert(alignof(UHUD_Armor) == 0x000008, "Wrong alignment on UHUD_Armor");
static_assert(sizeof(UHUD_Armor) == 0x000520, "Wrong size on UHUD_Armor");
static_assert(offsetof(UHUD_Armor, _TargetChara) == 0x0004F0, "Member 'UHUD_Armor::_TargetChara' has a wrong offset!");
static_assert(offsetof(UHUD_Armor, IMG_Frame) == 0x0004F8, "Member 'UHUD_Armor::IMG_Frame' has a wrong offset!");
static_assert(offsetof(UHUD_Armor, TXT_ArmorValue) == 0x000500, "Member 'UHUD_Armor::TXT_ArmorValue' has a wrong offset!");
static_assert(offsetof(UHUD_Armor, ArmorMaterial) == 0x000508, "Member 'UHUD_Armor::ArmorMaterial' has a wrong offset!");

// Class Stigma.Ctrl_BattlePassLevel
// 0x0000 (0x04F0 - 0x04F0)
class UCtrl_BattlePassLevel : public UPreviewableWidget
{
public:
	void SetLevel(int32 _level, bool _set_instance);
	void SetMax(bool _is_max);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_BattlePassLevel">();
	}
	static class UCtrl_BattlePassLevel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_BattlePassLevel>();
	}
};
static_assert(alignof(UCtrl_BattlePassLevel) == 0x000008, "Wrong alignment on UCtrl_BattlePassLevel");
static_assert(sizeof(UCtrl_BattlePassLevel) == 0x0004F0, "Wrong size on UCtrl_BattlePassLevel");

// Class Stigma.Ctrl_Character_CheckBox
// 0x00B0 (0x05A0 - 0x04F0)
class UCtrl_Character_CheckBox : public UPreviewableWidget
{
public:
	class UButton*                                Btn_Main;                                          // 0x04F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_CharaIcon;                                     // 0x04F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_SmileIcon;                                     // 0x0500(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Selected;                                      // 0x0508(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_StatUpdate*                       Ctrl_StatUpdate_ControlPowerLack;                  // 0x0510(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCheckBox*                              CheckBox_Select;                                   // 0x0518(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WS_Style;                                          // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_Title;                                         // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             Img_SmileIcon_Good;                                // 0x0530(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             Img_SmileIcon_Bad;                                 // 0x0538(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _ShowTitle;                                        // 0x0540(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_226C[0x7];                                     // 0x0541(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class FText                                   _TextTitle;                                        // 0x0548(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	int32                                         _MasterIdx;                                        // 0x0560(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECharaType                                    _CharaType;                                        // 0x0564(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_226D[0x3];                                     // 0x0565(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class UGunObject*                             _GunObject;                                        // 0x0568(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_Tooltip*                            _ToolTip;                                          // 0x0570(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsSelected;                                       // 0x0578(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_226E[0x3];                                     // 0x0579(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         _ControlPowerLack;                                 // 0x057C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnSelected;                                        // 0x0580(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TDelegate<void(bool _is_select, class UCtrl_Character_CheckBox* _item)> _IsSelectedDelegate;                               // 0x0590(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Init(int32 _master_idx, ECharaType _chara_type, class UGunObject* _gun_object);
	void OnClickBtn();
	void OnClickCheckBox(bool _is_checked);
	void RegisterIsSelectedDelegate(const TDelegate<void(bool _is_select, class UCtrl_Character_CheckBox* _item)>& _event);
	void SetSelect(bool _is_select, bool _from_ctrl);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_Character_CheckBox">();
	}
	static class UCtrl_Character_CheckBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_Character_CheckBox>();
	}
};
static_assert(alignof(UCtrl_Character_CheckBox) == 0x000008, "Wrong alignment on UCtrl_Character_CheckBox");
static_assert(sizeof(UCtrl_Character_CheckBox) == 0x0005A0, "Wrong size on UCtrl_Character_CheckBox");
static_assert(offsetof(UCtrl_Character_CheckBox, Btn_Main) == 0x0004F0, "Member 'UCtrl_Character_CheckBox::Btn_Main' has a wrong offset!");
static_assert(offsetof(UCtrl_Character_CheckBox, Img_CharaIcon) == 0x0004F8, "Member 'UCtrl_Character_CheckBox::Img_CharaIcon' has a wrong offset!");
static_assert(offsetof(UCtrl_Character_CheckBox, Img_SmileIcon) == 0x000500, "Member 'UCtrl_Character_CheckBox::Img_SmileIcon' has a wrong offset!");
static_assert(offsetof(UCtrl_Character_CheckBox, Img_Selected) == 0x000508, "Member 'UCtrl_Character_CheckBox::Img_Selected' has a wrong offset!");
static_assert(offsetof(UCtrl_Character_CheckBox, Ctrl_StatUpdate_ControlPowerLack) == 0x000510, "Member 'UCtrl_Character_CheckBox::Ctrl_StatUpdate_ControlPowerLack' has a wrong offset!");
static_assert(offsetof(UCtrl_Character_CheckBox, CheckBox_Select) == 0x000518, "Member 'UCtrl_Character_CheckBox::CheckBox_Select' has a wrong offset!");
static_assert(offsetof(UCtrl_Character_CheckBox, WS_Style) == 0x000520, "Member 'UCtrl_Character_CheckBox::WS_Style' has a wrong offset!");
static_assert(offsetof(UCtrl_Character_CheckBox, Txt_Title) == 0x000528, "Member 'UCtrl_Character_CheckBox::Txt_Title' has a wrong offset!");
static_assert(offsetof(UCtrl_Character_CheckBox, Img_SmileIcon_Good) == 0x000530, "Member 'UCtrl_Character_CheckBox::Img_SmileIcon_Good' has a wrong offset!");
static_assert(offsetof(UCtrl_Character_CheckBox, Img_SmileIcon_Bad) == 0x000538, "Member 'UCtrl_Character_CheckBox::Img_SmileIcon_Bad' has a wrong offset!");
static_assert(offsetof(UCtrl_Character_CheckBox, _ShowTitle) == 0x000540, "Member 'UCtrl_Character_CheckBox::_ShowTitle' has a wrong offset!");
static_assert(offsetof(UCtrl_Character_CheckBox, _TextTitle) == 0x000548, "Member 'UCtrl_Character_CheckBox::_TextTitle' has a wrong offset!");
static_assert(offsetof(UCtrl_Character_CheckBox, _MasterIdx) == 0x000560, "Member 'UCtrl_Character_CheckBox::_MasterIdx' has a wrong offset!");
static_assert(offsetof(UCtrl_Character_CheckBox, _CharaType) == 0x000564, "Member 'UCtrl_Character_CheckBox::_CharaType' has a wrong offset!");
static_assert(offsetof(UCtrl_Character_CheckBox, _GunObject) == 0x000568, "Member 'UCtrl_Character_CheckBox::_GunObject' has a wrong offset!");
static_assert(offsetof(UCtrl_Character_CheckBox, _ToolTip) == 0x000570, "Member 'UCtrl_Character_CheckBox::_ToolTip' has a wrong offset!");
static_assert(offsetof(UCtrl_Character_CheckBox, _IsSelected) == 0x000578, "Member 'UCtrl_Character_CheckBox::_IsSelected' has a wrong offset!");
static_assert(offsetof(UCtrl_Character_CheckBox, _ControlPowerLack) == 0x00057C, "Member 'UCtrl_Character_CheckBox::_ControlPowerLack' has a wrong offset!");
static_assert(offsetof(UCtrl_Character_CheckBox, OnSelected) == 0x000580, "Member 'UCtrl_Character_CheckBox::OnSelected' has a wrong offset!");
static_assert(offsetof(UCtrl_Character_CheckBox, _IsSelectedDelegate) == 0x000590, "Member 'UCtrl_Character_CheckBox::_IsSelectedDelegate' has a wrong offset!");

// Class Stigma.Ctrl_CommonButtonBase
// 0x09B0 (0x0EA0 - 0x04F0)
class UCtrl_CommonButtonBase : public UPreviewableWidget
{
public:
	class USizeBox*                               SizeBox;                                           // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                BTN_Button;                                        // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScaleBox*                              ScaleBox;                                          // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_Background;                                    // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Highlight;                                     // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HB_Inner;                                          // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Icon;                                          // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                Spacer_Icon;                                       // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VB_Text;                                           // 0x0530(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WS_TextType;                                       // 0x0538(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_Text;                                          // 0x0540(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         RTxt_Text;                                         // 0x0548(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_SubText;                                       // 0x0550(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _UseFixedSize;                                     // 0x0558(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2270[0x7];                                     // 0x0559(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FVector2D                              _FixedSize;                                        // 0x0560(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBrushStyle                            _BackgroundImageStyle;                             // 0x0570(0x0340)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            _HighlightBrush;                                   // 0x08B0(0x00D0)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FWidgetTransform                       _RenderTransform;                                  // 0x0980(0x0038)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          _UseScaletoFit;                                    // 0x09B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2271[0x3];                                     // 0x09B9(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	struct FMargin                                _InnerPadding;                                     // 0x09BC(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          _UseIcon;                                          // 0x09CC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _ForceTextCenter;                                  // 0x09CD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2272[0x2];                                     // 0x09CE(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	struct FBrushStyle                            _IconImageStyle;                                   // 0x09D0(0x0340)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FMargin                                _TextPadding;                                      // 0x0D10(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          _UseRichText;                                      // 0x0D20(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2273[0x7];                                     // 0x0D21(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class FText                                   _text;                                             // 0x0D28(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FTextStyle                             _TextStyle;                                        // 0x0D40(0x0098)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class FText                                   _SubText;                                          // 0x0DD8(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FTextStyle                             _SubTextStyle;                                     // 0x0DF0(0x0098)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class USoundBase*                             _FocusSound;                                       // 0x0E88(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             _ClickSound;                                       // 0x0E90(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsPressed;                                        // 0x0E98(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2274[0x7];                                     // 0x0E99(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnClickButton();
	void OnPressButton();
	void SetBackground(const struct FBrushStyle& _style);
	void SetFont(const struct FSlateFontInfo& _new_font, bool _is_sub_text);
	void SetIcon(const struct FBrushStyle& _icon_style);
	void SetText(const class FText& _new_text, bool _is_sub_text);
	void ShowHighlight(bool _value);
	void UpdateFont();
	void UpdateIcon();
	void UpdateSize();
	void UpdateState();
	void UpdateText();

	const class FText GetText(bool _is_sub_text) const;
	bool IsEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_CommonButtonBase">();
	}
	static class UCtrl_CommonButtonBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_CommonButtonBase>();
	}
};
static_assert(alignof(UCtrl_CommonButtonBase) == 0x000010, "Wrong alignment on UCtrl_CommonButtonBase");
static_assert(sizeof(UCtrl_CommonButtonBase) == 0x000EA0, "Wrong size on UCtrl_CommonButtonBase");
static_assert(offsetof(UCtrl_CommonButtonBase, SizeBox) == 0x0004F0, "Member 'UCtrl_CommonButtonBase::SizeBox' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, BTN_Button) == 0x0004F8, "Member 'UCtrl_CommonButtonBase::BTN_Button' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, ScaleBox) == 0x000500, "Member 'UCtrl_CommonButtonBase::ScaleBox' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, IMG_Background) == 0x000508, "Member 'UCtrl_CommonButtonBase::IMG_Background' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, Img_Highlight) == 0x000510, "Member 'UCtrl_CommonButtonBase::Img_Highlight' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, HB_Inner) == 0x000518, "Member 'UCtrl_CommonButtonBase::HB_Inner' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, Img_Icon) == 0x000520, "Member 'UCtrl_CommonButtonBase::Img_Icon' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, Spacer_Icon) == 0x000528, "Member 'UCtrl_CommonButtonBase::Spacer_Icon' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, VB_Text) == 0x000530, "Member 'UCtrl_CommonButtonBase::VB_Text' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, WS_TextType) == 0x000538, "Member 'UCtrl_CommonButtonBase::WS_TextType' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, Txt_Text) == 0x000540, "Member 'UCtrl_CommonButtonBase::Txt_Text' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, RTxt_Text) == 0x000548, "Member 'UCtrl_CommonButtonBase::RTxt_Text' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, Txt_SubText) == 0x000550, "Member 'UCtrl_CommonButtonBase::Txt_SubText' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, _UseFixedSize) == 0x000558, "Member 'UCtrl_CommonButtonBase::_UseFixedSize' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, _FixedSize) == 0x000560, "Member 'UCtrl_CommonButtonBase::_FixedSize' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, _BackgroundImageStyle) == 0x000570, "Member 'UCtrl_CommonButtonBase::_BackgroundImageStyle' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, _HighlightBrush) == 0x0008B0, "Member 'UCtrl_CommonButtonBase::_HighlightBrush' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, _RenderTransform) == 0x000980, "Member 'UCtrl_CommonButtonBase::_RenderTransform' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, _UseScaletoFit) == 0x0009B8, "Member 'UCtrl_CommonButtonBase::_UseScaletoFit' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, _InnerPadding) == 0x0009BC, "Member 'UCtrl_CommonButtonBase::_InnerPadding' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, _UseIcon) == 0x0009CC, "Member 'UCtrl_CommonButtonBase::_UseIcon' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, _ForceTextCenter) == 0x0009CD, "Member 'UCtrl_CommonButtonBase::_ForceTextCenter' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, _IconImageStyle) == 0x0009D0, "Member 'UCtrl_CommonButtonBase::_IconImageStyle' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, _TextPadding) == 0x000D10, "Member 'UCtrl_CommonButtonBase::_TextPadding' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, _UseRichText) == 0x000D20, "Member 'UCtrl_CommonButtonBase::_UseRichText' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, _text) == 0x000D28, "Member 'UCtrl_CommonButtonBase::_text' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, _TextStyle) == 0x000D40, "Member 'UCtrl_CommonButtonBase::_TextStyle' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, _SubText) == 0x000DD8, "Member 'UCtrl_CommonButtonBase::_SubText' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, _SubTextStyle) == 0x000DF0, "Member 'UCtrl_CommonButtonBase::_SubTextStyle' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, _FocusSound) == 0x000E88, "Member 'UCtrl_CommonButtonBase::_FocusSound' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, _ClickSound) == 0x000E90, "Member 'UCtrl_CommonButtonBase::_ClickSound' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButtonBase, _IsPressed) == 0x000E98, "Member 'UCtrl_CommonButtonBase::_IsPressed' has a wrong offset!");

// Class Stigma.LVData_GunParts
// 0x0028 (0x0050 - 0x0028)
class ULVData_GunParts final : public UObject
{
public:
	class UInvenItem*                             _InvenItem;                                        // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGunObject*                             _CurGunObject;                                     // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGunPartsSlot                                 _PartsSlot;                                        // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2278[0x17];                                    // 0x0039(0x0017)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Config(EGunPartsSlot _slot, class UInvenItem* _inven_item, class UGunObject* _cur_gun_object);
	void OnUpdateListItemStates();

	class UGunObject* GetGunObject() const;
	class UInvenItem* GetInvenItem() const;
	EGunPartsSlot GetPartsSlot() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LVData_GunParts">();
	}
	static class ULVData_GunParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULVData_GunParts>();
	}
};
static_assert(alignof(ULVData_GunParts) == 0x000008, "Wrong alignment on ULVData_GunParts");
static_assert(sizeof(ULVData_GunParts) == 0x000050, "Wrong size on ULVData_GunParts");
static_assert(offsetof(ULVData_GunParts, _InvenItem) == 0x000028, "Member 'ULVData_GunParts::_InvenItem' has a wrong offset!");
static_assert(offsetof(ULVData_GunParts, _CurGunObject) == 0x000030, "Member 'ULVData_GunParts::_CurGunObject' has a wrong offset!");
static_assert(offsetof(ULVData_GunParts, _PartsSlot) == 0x000038, "Member 'ULVData_GunParts::_PartsSlot' has a wrong offset!");

// Class Stigma.UIGuide_KickOffTutorialIfAny
// 0x0000 (0x0038 - 0x0038)
class UUIGuide_KickOffTutorialIfAny final : public UUIGuide_Base
{
public:
	static class UUIGuide_KickOffTutorialIfAny* Tutorial_KickOffTutorialIfAny(class UTutorial* _tutorial);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGuide_KickOffTutorialIfAny">();
	}
	static class UUIGuide_KickOffTutorialIfAny* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGuide_KickOffTutorialIfAny>();
	}
};
static_assert(alignof(UUIGuide_KickOffTutorialIfAny) == 0x000008, "Wrong alignment on UUIGuide_KickOffTutorialIfAny");
static_assert(sizeof(UUIGuide_KickOffTutorialIfAny) == 0x000038, "Wrong size on UUIGuide_KickOffTutorialIfAny");

// Class Stigma.Ctrl_CommonButton_Currency
// 0x00A0 (0x0F40 - 0x0EA0)
class UCtrl_CommonButton_Currency : public UCtrl_CommonButtonBase
{
public:
	struct FTextColor                             _TxtColor_CantBuy;                                 // 0x0EA0(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTextColor                             _TxtColor_Default;                                 // 0x0EE0(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FItemID_Currency                       _CurrencyID;                                       // 0x0F20(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _Amount;                                           // 0x0F30(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_227A[0xC];                                     // 0x0F34(0x000C)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool GetCanPurchase();
	void InitWidget(const struct FItemID_Currency& _currency_id, int32 _currency_amount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_CommonButton_Currency">();
	}
	static class UCtrl_CommonButton_Currency* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_CommonButton_Currency>();
	}
};
static_assert(alignof(UCtrl_CommonButton_Currency) == 0x000010, "Wrong alignment on UCtrl_CommonButton_Currency");
static_assert(sizeof(UCtrl_CommonButton_Currency) == 0x000F40, "Wrong size on UCtrl_CommonButton_Currency");
static_assert(offsetof(UCtrl_CommonButton_Currency, _TxtColor_CantBuy) == 0x000EA0, "Member 'UCtrl_CommonButton_Currency::_TxtColor_CantBuy' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButton_Currency, _TxtColor_Default) == 0x000EE0, "Member 'UCtrl_CommonButton_Currency::_TxtColor_Default' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButton_Currency, _CurrencyID) == 0x000F20, "Member 'UCtrl_CommonButton_Currency::_CurrencyID' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButton_Currency, _Amount) == 0x000F30, "Member 'UCtrl_CommonButton_Currency::_Amount' has a wrong offset!");

// Class Stigma.Mannequin
// 0x0120 (0x03B8 - 0x0298)
class AMannequin final : public AActor
{
public:
	EMannequinUpdateType                          _UpdateType;                                       // 0x0298(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_227C[0x3];                                     // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         _PartyIndex;                                       // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_227D[0xF8];                                    // 0x02A0(0x00F8)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class AActor>                     _DummyActorClass;                                  // 0x0398(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UChildActorComponent*                   _ChildActorComp;                                   // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstance*                      _MI_Silhouette;                                    // 0x03A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_227E[0x8];                                     // 0x03B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ClearCharacter();
	void Reset();
	void ResetRotation();
	void RotateYaw(float _yaw);
	void SetCharacter(const struct FItemID& _body_id, const struct FItemID& _head_id);
	void SetGunByGunObject(class UGunObject* _gun_obj);
	void SetGunSpec(const struct FGunSpec& _spec);
	void SetVisible(bool _visible);
	void UpdateIfAny(class AMatchServicedPlayerState* _ps);

	struct FItemID GetBodyID() const;
	ECharaType GetCharacterType() const;
	EGunType GetGunType() const;
	struct FItemID GetHeadID() const;
	bool IsVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Mannequin">();
	}
	static class AMannequin* GetDefaultObj()
	{
		return GetDefaultObjImpl<AMannequin>();
	}
};
static_assert(alignof(AMannequin) == 0x000008, "Wrong alignment on AMannequin");
static_assert(sizeof(AMannequin) == 0x0003B8, "Wrong size on AMannequin");
static_assert(offsetof(AMannequin, _UpdateType) == 0x000298, "Member 'AMannequin::_UpdateType' has a wrong offset!");
static_assert(offsetof(AMannequin, _PartyIndex) == 0x00029C, "Member 'AMannequin::_PartyIndex' has a wrong offset!");
static_assert(offsetof(AMannequin, _DummyActorClass) == 0x000398, "Member 'AMannequin::_DummyActorClass' has a wrong offset!");
static_assert(offsetof(AMannequin, _ChildActorComp) == 0x0003A0, "Member 'AMannequin::_ChildActorComp' has a wrong offset!");
static_assert(offsetof(AMannequin, _MI_Silhouette) == 0x0003A8, "Member 'AMannequin::_MI_Silhouette' has a wrong offset!");

// Class Stigma.TutorialSubsystem
// 0x00B0 (0x00E0 - 0x0030)
class UTutorialSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_227F[0x8];                                     // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UTutorial*                              _CurTutorial;                                      // 0x0038(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2280[0x10];                                    // 0x0040(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	TMap<class FName, int32>                      _PlayedTutorialHistory;                            // 0x0050(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2281[0x20];                                    // 0x00A0(0x0020)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FConfig_TutorialMatch>          _Matches;                                          // 0x00C0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FBotCreation>                   _QueuedBotCreations;                               // 0x00D0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UTutorialSubsystem* Get(const class UObject* _world_ctx);
	static int32 GetCompletedMatchCount(const class UObject* _world_ctx);
	static ETutorialState GetTutorialState(const class UObject* _world_ctx);
	static bool IsAnyTutorialRunning(const class UObject* _world_ctx);
	static bool IsTutorialProgressing(const class UObject* _world_ctx);
	static void SetTutorialState(const class UObject* _world_ctx, ETutorialState _state);
	static void StartTutorial(const class UObject* _world_ctx, TSubclassOf<class UTutorial> _type);
	static void StartTutorialMatch(const class UObject* _world_ctx, EGameMode _game_mode, int32 _level, ECharaType _chara_type, bool _is_welcome_match, const class FString& _option);
	static void StartWelcomeMatch(const class UObject* _world_ctx, ECharaType _chara_type);
	static void StopWelcomeScenario(const class UObject* _world_ctx, bool _show_yes_no);

	bool IsProgressing() const;
	bool IsTutorialRunning() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialSubsystem">();
	}
	static class UTutorialSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialSubsystem>();
	}
};
static_assert(alignof(UTutorialSubsystem) == 0x000008, "Wrong alignment on UTutorialSubsystem");
static_assert(sizeof(UTutorialSubsystem) == 0x0000E0, "Wrong size on UTutorialSubsystem");
static_assert(offsetof(UTutorialSubsystem, _CurTutorial) == 0x000038, "Member 'UTutorialSubsystem::_CurTutorial' has a wrong offset!");
static_assert(offsetof(UTutorialSubsystem, _PlayedTutorialHistory) == 0x000050, "Member 'UTutorialSubsystem::_PlayedTutorialHistory' has a wrong offset!");
static_assert(offsetof(UTutorialSubsystem, _Matches) == 0x0000C0, "Member 'UTutorialSubsystem::_Matches' has a wrong offset!");
static_assert(offsetof(UTutorialSubsystem, _QueuedBotCreations) == 0x0000D0, "Member 'UTutorialSubsystem::_QueuedBotCreations' has a wrong offset!");

// Class Stigma.Ctrl_CommonButton_Intensity
// 0x0150 (0x0FF0 - 0x0EA0)
class UCtrl_CommonButton_Intensity : public UCtrl_CommonButtonBase
{
public:
	EButtonIntensity                              _Intensity;                                        // 0x0EA0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_228B[0x7];                                     // 0x0EA1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TMap<EButtonIntensity, struct FBrushStyle>    IntensityBackgroundImage;                          // 0x0EA8(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TMap<EButtonIntensity, struct FSlateBrush>    IntensityHighlightImage;                           // 0x0EF8(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TMap<EButtonIntensity, struct FTextStyle>     IntensityTextStyle;                                // 0x0F48(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TMap<EButtonIntensity, struct FTextStyle>     IntensitySubTextStyle;                             // 0x0F98(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_228C[0x8];                                     // 0x0FE8(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void SetIntensity(EButtonIntensity _new_intensity);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_CommonButton_Intensity">();
	}
	static class UCtrl_CommonButton_Intensity* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_CommonButton_Intensity>();
	}
};
static_assert(alignof(UCtrl_CommonButton_Intensity) == 0x000010, "Wrong alignment on UCtrl_CommonButton_Intensity");
static_assert(sizeof(UCtrl_CommonButton_Intensity) == 0x000FF0, "Wrong size on UCtrl_CommonButton_Intensity");
static_assert(offsetof(UCtrl_CommonButton_Intensity, _Intensity) == 0x000EA0, "Member 'UCtrl_CommonButton_Intensity::_Intensity' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButton_Intensity, IntensityBackgroundImage) == 0x000EA8, "Member 'UCtrl_CommonButton_Intensity::IntensityBackgroundImage' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButton_Intensity, IntensityHighlightImage) == 0x000EF8, "Member 'UCtrl_CommonButton_Intensity::IntensityHighlightImage' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButton_Intensity, IntensityTextStyle) == 0x000F48, "Member 'UCtrl_CommonButton_Intensity::IntensityTextStyle' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonButton_Intensity, IntensitySubTextStyle) == 0x000F98, "Member 'UCtrl_CommonButton_Intensity::IntensitySubTextStyle' has a wrong offset!");

// Class Stigma.Ctrl_CommonTileView
// 0x0000 (0x0CA0 - 0x0CA0)
class UCtrl_CommonTileView final : public UTileView
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_CommonTileView">();
	}
	static class UCtrl_CommonTileView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_CommonTileView>();
	}
};
static_assert(alignof(UCtrl_CommonTileView) == 0x000010, "Wrong alignment on UCtrl_CommonTileView");
static_assert(sizeof(UCtrl_CommonTileView) == 0x000CA0, "Wrong size on UCtrl_CommonTileView");

// Class Stigma.Ctrl_CommonListView
// 0x0000 (0x0C70 - 0x0C70)
class UCtrl_CommonListView final : public UListView
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_CommonListView">();
	}
	static class UCtrl_CommonListView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_CommonListView>();
	}
};
static_assert(alignof(UCtrl_CommonListView) == 0x000010, "Wrong alignment on UCtrl_CommonListView");
static_assert(sizeof(UCtrl_CommonListView) == 0x000C70, "Wrong size on UCtrl_CommonListView");

// Class Stigma.MissionCondition_OpenUI
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_OpenUI final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_OpenUI">();
	}
	static class UMissionCondition_OpenUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_OpenUI>();
	}
};
static_assert(alignof(UMissionCondition_OpenUI) == 0x000008, "Wrong alignment on UMissionCondition_OpenUI");
static_assert(sizeof(UMissionCondition_OpenUI) == 0x000068, "Wrong size on UMissionCondition_OpenUI");

// Class Stigma.Button_Ready
// 0x0000 (0x04F0 - 0x04F0)
class UButton_Ready : public UPreviewableWidget
{
public:
	void SetTitleText(const class FText& _text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Button_Ready">();
	}
	static class UButton_Ready* GetDefaultObj()
	{
		return GetDefaultObjImpl<UButton_Ready>();
	}
};
static_assert(alignof(UButton_Ready) == 0x000008, "Wrong alignment on UButton_Ready");
static_assert(sizeof(UButton_Ready) == 0x0004F0, "Wrong size on UButton_Ready");

// Class Stigma.Ctrl_CommonScrollBox
// 0x0000 (0x0CF0 - 0x0CF0)
class UCtrl_CommonScrollBox final : public UScrollBox
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_CommonScrollBox">();
	}
	static class UCtrl_CommonScrollBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_CommonScrollBox>();
	}
};
static_assert(alignof(UCtrl_CommonScrollBox) == 0x000010, "Wrong alignment on UCtrl_CommonScrollBox");
static_assert(sizeof(UCtrl_CommonScrollBox) == 0x000CF0, "Wrong size on UCtrl_CommonScrollBox");

// Class Stigma.HUD_CrossHair
// 0x0098 (0x0588 - 0x04F0)
class UHUD_CrossHair : public UPreviewableWidget
{
public:
	class UCanvasPanel*                           CrossHairArea;                                     // 0x04F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_228D[0x8];                                     // 0x04F8(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UCanvasPanel*                           CrossHair_Top_Area;                                // 0x0500(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CrossHair_Bottom_Area;                             // 0x0508(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CrossHair_Left_Area;                               // 0x0510(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CrossHair_Right_Area;                              // 0x0518(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CrossHair_Center_Area;                             // 0x0520(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CrossHair_Top;                                     // 0x0528(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CrossHair_Bottom;                                  // 0x0530(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CrossHair_Left;                                    // 0x0538(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CrossHair_Right;                                   // 0x0540(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CrossHair_Center;                                  // 0x0548(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CrossHair_Top_OutLine;                             // 0x0550(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CrossHair_Bottom_OutLine;                          // 0x0558(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CrossHair_Left_OutLine;                            // 0x0560(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CrossHair_Right_OutLine;                           // 0x0568(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 CrossHair_Center_OutLine;                          // 0x0570(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _ShowCrossHair;                                    // 0x0578(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _ShowCenterDot;                                    // 0x0579(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _ForceAllHide;                                     // 0x057A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_228E[0x1];                                     // 0x057B(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         _deviation;                                        // 0x057C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsCrossHairVisible;                               // 0x0580(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_228F[0x7];                                     // 0x0581(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	struct FVector2D GetCrossHairPos();
	void OnHit(const struct FHitData& _hit_data);
	bool OnHit_Local(const struct FHitData& _hit_data);
	void SetCrossHairPos(float _x, float _y);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUD_CrossHair">();
	}
	static class UHUD_CrossHair* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUD_CrossHair>();
	}
};
static_assert(alignof(UHUD_CrossHair) == 0x000008, "Wrong alignment on UHUD_CrossHair");
static_assert(sizeof(UHUD_CrossHair) == 0x000588, "Wrong size on UHUD_CrossHair");
static_assert(offsetof(UHUD_CrossHair, CrossHairArea) == 0x0004F0, "Member 'UHUD_CrossHair::CrossHairArea' has a wrong offset!");
static_assert(offsetof(UHUD_CrossHair, CrossHair_Top_Area) == 0x000500, "Member 'UHUD_CrossHair::CrossHair_Top_Area' has a wrong offset!");
static_assert(offsetof(UHUD_CrossHair, CrossHair_Bottom_Area) == 0x000508, "Member 'UHUD_CrossHair::CrossHair_Bottom_Area' has a wrong offset!");
static_assert(offsetof(UHUD_CrossHair, CrossHair_Left_Area) == 0x000510, "Member 'UHUD_CrossHair::CrossHair_Left_Area' has a wrong offset!");
static_assert(offsetof(UHUD_CrossHair, CrossHair_Right_Area) == 0x000518, "Member 'UHUD_CrossHair::CrossHair_Right_Area' has a wrong offset!");
static_assert(offsetof(UHUD_CrossHair, CrossHair_Center_Area) == 0x000520, "Member 'UHUD_CrossHair::CrossHair_Center_Area' has a wrong offset!");
static_assert(offsetof(UHUD_CrossHair, CrossHair_Top) == 0x000528, "Member 'UHUD_CrossHair::CrossHair_Top' has a wrong offset!");
static_assert(offsetof(UHUD_CrossHair, CrossHair_Bottom) == 0x000530, "Member 'UHUD_CrossHair::CrossHair_Bottom' has a wrong offset!");
static_assert(offsetof(UHUD_CrossHair, CrossHair_Left) == 0x000538, "Member 'UHUD_CrossHair::CrossHair_Left' has a wrong offset!");
static_assert(offsetof(UHUD_CrossHair, CrossHair_Right) == 0x000540, "Member 'UHUD_CrossHair::CrossHair_Right' has a wrong offset!");
static_assert(offsetof(UHUD_CrossHair, CrossHair_Center) == 0x000548, "Member 'UHUD_CrossHair::CrossHair_Center' has a wrong offset!");
static_assert(offsetof(UHUD_CrossHair, CrossHair_Top_OutLine) == 0x000550, "Member 'UHUD_CrossHair::CrossHair_Top_OutLine' has a wrong offset!");
static_assert(offsetof(UHUD_CrossHair, CrossHair_Bottom_OutLine) == 0x000558, "Member 'UHUD_CrossHair::CrossHair_Bottom_OutLine' has a wrong offset!");
static_assert(offsetof(UHUD_CrossHair, CrossHair_Left_OutLine) == 0x000560, "Member 'UHUD_CrossHair::CrossHair_Left_OutLine' has a wrong offset!");
static_assert(offsetof(UHUD_CrossHair, CrossHair_Right_OutLine) == 0x000568, "Member 'UHUD_CrossHair::CrossHair_Right_OutLine' has a wrong offset!");
static_assert(offsetof(UHUD_CrossHair, CrossHair_Center_OutLine) == 0x000570, "Member 'UHUD_CrossHair::CrossHair_Center_OutLine' has a wrong offset!");
static_assert(offsetof(UHUD_CrossHair, _ShowCrossHair) == 0x000578, "Member 'UHUD_CrossHair::_ShowCrossHair' has a wrong offset!");
static_assert(offsetof(UHUD_CrossHair, _ShowCenterDot) == 0x000579, "Member 'UHUD_CrossHair::_ShowCenterDot' has a wrong offset!");
static_assert(offsetof(UHUD_CrossHair, _ForceAllHide) == 0x00057A, "Member 'UHUD_CrossHair::_ForceAllHide' has a wrong offset!");
static_assert(offsetof(UHUD_CrossHair, _deviation) == 0x00057C, "Member 'UHUD_CrossHair::_deviation' has a wrong offset!");
static_assert(offsetof(UHUD_CrossHair, _IsCrossHairVisible) == 0x000580, "Member 'UHUD_CrossHair::_IsCrossHairVisible' has a wrong offset!");

// Class Stigma.Ctrl_CommonProgressBar
// 0x0030 (0x0520 - 0x04F0)
class UCtrl_CommonProgressBar : public UPreviewableWidget
{
public:
	class UProgressBar*                           CurrentBar;                                        // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WS_Text;                                           // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2291[0x11];                                    // 0x0500(0x0011)(Fixing Size After Last Property [ Dumper-69 ])
	EProgressBarTextType                          _TextType;                                         // 0x0511(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EProgressBarTextType                          _TextType_OnMax;                                   // 0x0512(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2292[0x1];                                     // 0x0513(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         _FractinoalDigits;                                 // 0x0514(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _InterpAlpha;                                      // 0x0518(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2293[0x4];                                     // 0x051C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void SetFractionalText(float _current_val, float _target_val, bool _is_max);
	void SetPercentageText(float _current_val, float _target_val, bool _is_max);
	void SetProgressPercent(float _cur_percent, bool _reset_value);
	void SetProgressValue(float _target_value, float _cur_value, bool _reset_value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_CommonProgressBar">();
	}
	static class UCtrl_CommonProgressBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_CommonProgressBar>();
	}
};
static_assert(alignof(UCtrl_CommonProgressBar) == 0x000008, "Wrong alignment on UCtrl_CommonProgressBar");
static_assert(sizeof(UCtrl_CommonProgressBar) == 0x000520, "Wrong size on UCtrl_CommonProgressBar");
static_assert(offsetof(UCtrl_CommonProgressBar, CurrentBar) == 0x0004F0, "Member 'UCtrl_CommonProgressBar::CurrentBar' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonProgressBar, WS_Text) == 0x0004F8, "Member 'UCtrl_CommonProgressBar::WS_Text' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonProgressBar, _TextType) == 0x000511, "Member 'UCtrl_CommonProgressBar::_TextType' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonProgressBar, _TextType_OnMax) == 0x000512, "Member 'UCtrl_CommonProgressBar::_TextType_OnMax' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonProgressBar, _FractinoalDigits) == 0x000514, "Member 'UCtrl_CommonProgressBar::_FractinoalDigits' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonProgressBar, _InterpAlpha) == 0x000518, "Member 'UCtrl_CommonProgressBar::_InterpAlpha' has a wrong offset!");

// Class Stigma.Ctrl_CommonTab
// 0x0580 (0x0A70 - 0x04F0)
class alignas(0x10) UCtrl_CommonTab : public UPreviewableWidget
{
public:
	class UTextBlock*                             Txt_Title;                                         // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScaleBox*                              SB_Margin;                                         // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Icon;                                          // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               SZ_Size;                                           // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URadioButton*                           BTN_Body;                                          // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinSize;                                           // 0x0518(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2298[0x4];                                     // 0x051C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TSoftObjectPtr<class USoundBase>              ClickSound;                                        // 0x0520(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              IconTexture;                                       // 0x0548(0x0028)(Transient, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2299[0x4F0];                                   // 0x0570(0x04F0)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             OnSelected;                                        // 0x0A60(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void Init(const struct FCommonTabInitializeInfo& _info);
	void OnClickBtn();
	void SetSelected();
	void SetSelectedID(const class FName& _id);
	void SetTitle(const class FText& _Title);
	void UpdateFont();
	void UpdateMargin();
	void UpdateSelected();
	void UpdateSize();
	void UpdateStyle();
	void UpdateTitle();

	class FName GetID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_CommonTab">();
	}
	static class UCtrl_CommonTab* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_CommonTab>();
	}
};
static_assert(alignof(UCtrl_CommonTab) == 0x000010, "Wrong alignment on UCtrl_CommonTab");
static_assert(sizeof(UCtrl_CommonTab) == 0x000A70, "Wrong size on UCtrl_CommonTab");
static_assert(offsetof(UCtrl_CommonTab, Txt_Title) == 0x0004F0, "Member 'UCtrl_CommonTab::Txt_Title' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonTab, SB_Margin) == 0x0004F8, "Member 'UCtrl_CommonTab::SB_Margin' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonTab, Img_Icon) == 0x000500, "Member 'UCtrl_CommonTab::Img_Icon' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonTab, SZ_Size) == 0x000508, "Member 'UCtrl_CommonTab::SZ_Size' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonTab, BTN_Body) == 0x000510, "Member 'UCtrl_CommonTab::BTN_Body' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonTab, MinSize) == 0x000518, "Member 'UCtrl_CommonTab::MinSize' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonTab, ClickSound) == 0x000520, "Member 'UCtrl_CommonTab::ClickSound' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonTab, IconTexture) == 0x000548, "Member 'UCtrl_CommonTab::IconTexture' has a wrong offset!");
static_assert(offsetof(UCtrl_CommonTab, OnSelected) == 0x000A60, "Member 'UCtrl_CommonTab::OnSelected' has a wrong offset!");

// Class Stigma.UIGuide_ShowWidget
// 0x0020 (0x0058 - 0x0038)
class UUIGuide_ShowWidget final : public UUIGuide_Base
{
public:
	FMulticastInlineDelegateProperty_             OnAfterDone;                                       // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UUserWidget*                            _widget;                                           // 0x0048(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_229A[0x8];                                     // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UUIGuide_ShowWidget* Tutorial_ShowWidget(class UTutorial* _tutorial, TSubclassOf<class UUserWidget> _widget_class, float _timeout, bool _close_at_timeout, EUIOrder _order, class UUserWidget** _out_widget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGuide_ShowWidget">();
	}
	static class UUIGuide_ShowWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGuide_ShowWidget>();
	}
};
static_assert(alignof(UUIGuide_ShowWidget) == 0x000008, "Wrong alignment on UUIGuide_ShowWidget");
static_assert(sizeof(UUIGuide_ShowWidget) == 0x000058, "Wrong size on UUIGuide_ShowWidget");
static_assert(offsetof(UUIGuide_ShowWidget, OnAfterDone) == 0x000038, "Member 'UUIGuide_ShowWidget::OnAfterDone' has a wrong offset!");
static_assert(offsetof(UUIGuide_ShowWidget, _widget) == 0x000048, "Member 'UUIGuide_ShowWidget::_widget' has a wrong offset!");

// Class Stigma.Ctrl_ControlMasterTabBase
// 0x0018 (0x0508 - 0x04F0)
class UCtrl_ControlMasterTabBase : public UPreviewableWidget
{
public:
	uint8                                         Pad_229C[0x18];                                    // 0x04F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	ECharaType GetSelectedChara();
	void InvokeOnMasterSelectionChanged(ECharaType _chara);
	void RegisterOnMasterChanged(const TDelegate<void(class UCtrl_ControlMasterTabBase* _master_tab, ECharaType _chara)>& _callback);
	void RemoveMasterProfile(ECharaType _chara_type);
	bool UpdateProfile();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_ControlMasterTabBase">();
	}
	static class UCtrl_ControlMasterTabBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_ControlMasterTabBase>();
	}
};
static_assert(alignof(UCtrl_ControlMasterTabBase) == 0x000008, "Wrong alignment on UCtrl_ControlMasterTabBase");
static_assert(sizeof(UCtrl_ControlMasterTabBase) == 0x000508, "Wrong size on UCtrl_ControlMasterTabBase");

// Class Stigma.HUD_Cartridge
// 0x0038 (0x0528 - 0x04F0)
class UHUD_Cartridge : public UPreviewableWidget
{
public:
	int32                                         _BulletCount;                                      // 0x04F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _LastBulletCount;                                  // 0x04F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _MaxBulletCount;                                   // 0x04F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_229D[0x4];                                     // 0x04FC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UMaterialInstanceDynamic*               _BulletsMaterial;                                  // 0x0500(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _TraceProgressValue;                               // 0x0508(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _TargetProgressValue;                              // 0x050C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsStartAnimation;                                 // 0x0510(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsNeedBulletIncreaseAnimation;                    // 0x0511(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_229E[0x6];                                     // 0x0512(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	class UCurveFloat*                            _BulletSpeedCurve;                                 // 0x0518(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_229F[0x8];                                     // 0x0520(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void UpdateAnimationProgress(float _delta);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUD_Cartridge">();
	}
	static class UHUD_Cartridge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUD_Cartridge>();
	}
};
static_assert(alignof(UHUD_Cartridge) == 0x000008, "Wrong alignment on UHUD_Cartridge");
static_assert(sizeof(UHUD_Cartridge) == 0x000528, "Wrong size on UHUD_Cartridge");
static_assert(offsetof(UHUD_Cartridge, _BulletCount) == 0x0004F0, "Member 'UHUD_Cartridge::_BulletCount' has a wrong offset!");
static_assert(offsetof(UHUD_Cartridge, _LastBulletCount) == 0x0004F4, "Member 'UHUD_Cartridge::_LastBulletCount' has a wrong offset!");
static_assert(offsetof(UHUD_Cartridge, _MaxBulletCount) == 0x0004F8, "Member 'UHUD_Cartridge::_MaxBulletCount' has a wrong offset!");
static_assert(offsetof(UHUD_Cartridge, _BulletsMaterial) == 0x000500, "Member 'UHUD_Cartridge::_BulletsMaterial' has a wrong offset!");
static_assert(offsetof(UHUD_Cartridge, _TraceProgressValue) == 0x000508, "Member 'UHUD_Cartridge::_TraceProgressValue' has a wrong offset!");
static_assert(offsetof(UHUD_Cartridge, _TargetProgressValue) == 0x00050C, "Member 'UHUD_Cartridge::_TargetProgressValue' has a wrong offset!");
static_assert(offsetof(UHUD_Cartridge, _IsStartAnimation) == 0x000510, "Member 'UHUD_Cartridge::_IsStartAnimation' has a wrong offset!");
static_assert(offsetof(UHUD_Cartridge, _IsNeedBulletIncreaseAnimation) == 0x000511, "Member 'UHUD_Cartridge::_IsNeedBulletIncreaseAnimation' has a wrong offset!");
static_assert(offsetof(UHUD_Cartridge, _BulletSpeedCurve) == 0x000518, "Member 'UHUD_Cartridge::_BulletSpeedCurve' has a wrong offset!");

// Class Stigma.Ctrl_EventCountBubbleBase
// 0x0070 (0x0560 - 0x04F0)
class UCtrl_EventCountBubbleBase : public UPreviewableWidget
{
public:
	struct FSlateFontInfo                         _Font;                                             // 0x04F0(0x0058)(Edit, BlueprintVisible, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _MaxDisplayableCount;                              // 0x0548(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _UseEllipsisMark;                                  // 0x054C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22A0[0x3];                                     // 0x054D(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class UTextBlock*                             TXT_Count;                                         // 0x0550(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22A1[0x8];                                     // 0x0558(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ActiveEllipsisMark(bool _flag);
	void SetEventCount(int32 _count);
	void SetMaxDisplayableCount(int32 _max_count);
	void UpdateContext();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_EventCountBubbleBase">();
	}
	static class UCtrl_EventCountBubbleBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_EventCountBubbleBase>();
	}
};
static_assert(alignof(UCtrl_EventCountBubbleBase) == 0x000008, "Wrong alignment on UCtrl_EventCountBubbleBase");
static_assert(sizeof(UCtrl_EventCountBubbleBase) == 0x000560, "Wrong size on UCtrl_EventCountBubbleBase");
static_assert(offsetof(UCtrl_EventCountBubbleBase, _Font) == 0x0004F0, "Member 'UCtrl_EventCountBubbleBase::_Font' has a wrong offset!");
static_assert(offsetof(UCtrl_EventCountBubbleBase, _MaxDisplayableCount) == 0x000548, "Member 'UCtrl_EventCountBubbleBase::_MaxDisplayableCount' has a wrong offset!");
static_assert(offsetof(UCtrl_EventCountBubbleBase, _UseEllipsisMark) == 0x00054C, "Member 'UCtrl_EventCountBubbleBase::_UseEllipsisMark' has a wrong offset!");
static_assert(offsetof(UCtrl_EventCountBubbleBase, TXT_Count) == 0x000550, "Member 'UCtrl_EventCountBubbleBase::TXT_Count' has a wrong offset!");

// Class Stigma.Ctrl_HorizontalTabPanel
// 0x0010 (0x0618 - 0x0608)
class UCtrl_HorizontalTabPanel : public UCtrl_CommonTabPanel
{
public:
	class UHorizontalBox*                         HorizontalTabContainer;                            // 0x0608(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EHorizontalAlignment                          HorzAlign;                                         // 0x0610(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22A2[0x7];                                     // 0x0611(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnTabSelected(class FName _id, int32 _idx);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_HorizontalTabPanel">();
	}
	static class UCtrl_HorizontalTabPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_HorizontalTabPanel>();
	}
};
static_assert(alignof(UCtrl_HorizontalTabPanel) == 0x000008, "Wrong alignment on UCtrl_HorizontalTabPanel");
static_assert(sizeof(UCtrl_HorizontalTabPanel) == 0x000618, "Wrong size on UCtrl_HorizontalTabPanel");
static_assert(offsetof(UCtrl_HorizontalTabPanel, HorizontalTabContainer) == 0x000608, "Member 'UCtrl_HorizontalTabPanel::HorizontalTabContainer' has a wrong offset!");
static_assert(offsetof(UCtrl_HorizontalTabPanel, HorzAlign) == 0x000610, "Member 'UCtrl_HorizontalTabPanel::HorzAlign' has a wrong offset!");

// Class Stigma.Ctrl_ItemTag
// 0x0068 (0x0558 - 0x04F0)
class UCtrl_ItemTag : public UPreviewableWidget
{
public:
	TMap<EItemUITag, struct FItemTagConfig>       _TagConfigs;                                       // 0x04F0(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<EItemUITag>                            _ItemTags;                                         // 0x0540(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_22A3[0x8];                                     // 0x0550(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void InitWidget(const TArray<EItemUITag>& _tags);
	void SetTagStyle(const struct FItemTagConfig& _style);
	void ShowNextTag();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_ItemTag">();
	}
	static class UCtrl_ItemTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_ItemTag>();
	}
};
static_assert(alignof(UCtrl_ItemTag) == 0x000008, "Wrong alignment on UCtrl_ItemTag");
static_assert(sizeof(UCtrl_ItemTag) == 0x000558, "Wrong size on UCtrl_ItemTag");
static_assert(offsetof(UCtrl_ItemTag, _TagConfigs) == 0x0004F0, "Member 'UCtrl_ItemTag::_TagConfigs' has a wrong offset!");
static_assert(offsetof(UCtrl_ItemTag, _ItemTags) == 0x000540, "Member 'UCtrl_ItemTag::_ItemTags' has a wrong offset!");

// Class Stigma.LobbyGunFollowCameraActor
// 0x0000 (0x0AF0 - 0x0AF0)
class ALobbyGunFollowCameraActor final : public AFollowCameraActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyGunFollowCameraActor">();
	}
	static class ALobbyGunFollowCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALobbyGunFollowCameraActor>();
	}
};
static_assert(alignof(ALobbyGunFollowCameraActor) == 0x000010, "Wrong alignment on ALobbyGunFollowCameraActor");
static_assert(sizeof(ALobbyGunFollowCameraActor) == 0x000AF0, "Wrong size on ALobbyGunFollowCameraActor");

// Class Stigma.UI_RecruitHistoryPopup
// 0x00A8 (0x0618 - 0x0570)
class UUI_RecruitHistoryPopup : public UPopupBase
{
public:
	class UCtrl_HorizontalTabPanel*               TabList;                                           // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WS_View;                                           // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_Empty;                                         // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_Loading;                                       // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UListView*                              LV_History;                                        // 0x0590(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                BTN_PrevPage;                                      // 0x0598(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                BTN_NextPage;                                      // 0x05A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Page;                                          // 0x05A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<ERecruitType, struct FRecruitHistoryWrapData> _HistoryMap;                                       // 0x05B0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_22A4[0x18];                                    // 0x0600(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnClickNextPage();
	void OnClickPrevPage();
	void OnHistoryTabChanged(class FName _id, int32 _idx);
	void OnReadHistoryRecruit(EResultCode _rcode, const struct FACK_ReadHistoryRecruit& _ack);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_RecruitHistoryPopup">();
	}
	static class UUI_RecruitHistoryPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_RecruitHistoryPopup>();
	}
};
static_assert(alignof(UUI_RecruitHistoryPopup) == 0x000008, "Wrong alignment on UUI_RecruitHistoryPopup");
static_assert(sizeof(UUI_RecruitHistoryPopup) == 0x000618, "Wrong size on UUI_RecruitHistoryPopup");
static_assert(offsetof(UUI_RecruitHistoryPopup, TabList) == 0x000570, "Member 'UUI_RecruitHistoryPopup::TabList' has a wrong offset!");
static_assert(offsetof(UUI_RecruitHistoryPopup, WS_View) == 0x000578, "Member 'UUI_RecruitHistoryPopup::WS_View' has a wrong offset!");
static_assert(offsetof(UUI_RecruitHistoryPopup, Txt_Empty) == 0x000580, "Member 'UUI_RecruitHistoryPopup::Txt_Empty' has a wrong offset!");
static_assert(offsetof(UUI_RecruitHistoryPopup, Txt_Loading) == 0x000588, "Member 'UUI_RecruitHistoryPopup::Txt_Loading' has a wrong offset!");
static_assert(offsetof(UUI_RecruitHistoryPopup, LV_History) == 0x000590, "Member 'UUI_RecruitHistoryPopup::LV_History' has a wrong offset!");
static_assert(offsetof(UUI_RecruitHistoryPopup, BTN_PrevPage) == 0x000598, "Member 'UUI_RecruitHistoryPopup::BTN_PrevPage' has a wrong offset!");
static_assert(offsetof(UUI_RecruitHistoryPopup, BTN_NextPage) == 0x0005A0, "Member 'UUI_RecruitHistoryPopup::BTN_NextPage' has a wrong offset!");
static_assert(offsetof(UUI_RecruitHistoryPopup, TXT_Page) == 0x0005A8, "Member 'UUI_RecruitHistoryPopup::TXT_Page' has a wrong offset!");
static_assert(offsetof(UUI_RecruitHistoryPopup, _HistoryMap) == 0x0005B0, "Member 'UUI_RecruitHistoryPopup::_HistoryMap' has a wrong offset!");

// Class Stigma.Ctrl_Lines
// 0x0028 (0x02E8 - 0x02C0)
class UCtrl_Lines final : public UUserWidget
{
public:
	uint8                                         Pad_22A6[0x28];                                    // 0x02C0(0x0028)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_Lines">();
	}
	static class UCtrl_Lines* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_Lines>();
	}
};
static_assert(alignof(UCtrl_Lines) == 0x000008, "Wrong alignment on UCtrl_Lines");
static_assert(sizeof(UCtrl_Lines) == 0x0002E8, "Wrong size on UCtrl_Lines");

// Class Stigma.EQT_Safety
// 0x0008 (0x0200 - 0x01F8)
class UEQT_Safety final : public UEnvQueryTest
{
public:
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x01F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EQT_Safety">();
	}
	static class UEQT_Safety* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEQT_Safety>();
	}
};
static_assert(alignof(UEQT_Safety) == 0x000008, "Wrong alignment on UEQT_Safety");
static_assert(sizeof(UEQT_Safety) == 0x000200, "Wrong size on UEQT_Safety");
static_assert(offsetof(UEQT_Safety, Context) == 0x0001F8, "Member 'UEQT_Safety::Context' has a wrong offset!");

// Class Stigma.Ctrl_ListItem_Border
// 0x0028 (0x0518 - 0x04F0)
class UCtrl_ListItem_Border : public UPreviewableWidget
{
public:
	bool                                          IsHoverEnabled;                                    // 0x04F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22A7[0x7];                                     // 0x04F1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UImage*                                 Border_Selected;                                   // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCheckBox*                              CheckBox;                                          // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22A8[0x10];                                    // 0x0508(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnProcCheckBoxStateChanged(bool _is_checked);

	ESlateVisibility GetHoverImageVisibility() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_ListItem_Border">();
	}
	static class UCtrl_ListItem_Border* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_ListItem_Border>();
	}
};
static_assert(alignof(UCtrl_ListItem_Border) == 0x000008, "Wrong alignment on UCtrl_ListItem_Border");
static_assert(sizeof(UCtrl_ListItem_Border) == 0x000518, "Wrong size on UCtrl_ListItem_Border");
static_assert(offsetof(UCtrl_ListItem_Border, IsHoverEnabled) == 0x0004F0, "Member 'UCtrl_ListItem_Border::IsHoverEnabled' has a wrong offset!");
static_assert(offsetof(UCtrl_ListItem_Border, Border_Selected) == 0x0004F8, "Member 'UCtrl_ListItem_Border::Border_Selected' has a wrong offset!");
static_assert(offsetof(UCtrl_ListItem_Border, CheckBox) == 0x000500, "Member 'UCtrl_ListItem_Border::CheckBox' has a wrong offset!");

// Class Stigma.UI_Record_ModeResultCount
// 0x0028 (0x02E8 - 0x02C0)
class UUI_Record_ModeResultCount : public UUserWidget
{
public:
	class UImage*                                 IMG_Mode;                                          // 0x02C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Count;                                         // 0x02C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateColor                            InactiveColor;                                     // 0x02D0(0x0014)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_22A9[0x4];                                     // 0x02E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Record_ModeResultCount">();
	}
	static class UUI_Record_ModeResultCount* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Record_ModeResultCount>();
	}
};
static_assert(alignof(UUI_Record_ModeResultCount) == 0x000008, "Wrong alignment on UUI_Record_ModeResultCount");
static_assert(sizeof(UUI_Record_ModeResultCount) == 0x0002E8, "Wrong size on UUI_Record_ModeResultCount");
static_assert(offsetof(UUI_Record_ModeResultCount, IMG_Mode) == 0x0002C0, "Member 'UUI_Record_ModeResultCount::IMG_Mode' has a wrong offset!");
static_assert(offsetof(UUI_Record_ModeResultCount, TXT_Count) == 0x0002C8, "Member 'UUI_Record_ModeResultCount::TXT_Count' has a wrong offset!");
static_assert(offsetof(UUI_Record_ModeResultCount, InactiveColor) == 0x0002D0, "Member 'UUI_Record_ModeResultCount::InactiveColor' has a wrong offset!");

// Class Stigma.Ctrl_ListView
// 0x0018 (0x0508 - 0x04F0)
class UCtrl_ListView final : public UPreviewableWidget
{
public:
	class UListView*                              ListView;                                          // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _CanScrollOnLeftMouseDrag;                         // 0x04F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22AA[0x3];                                     // 0x04F9(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         _DragMulti;                                        // 0x04FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22AB[0x8];                                     // 0x0500(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_ListView">();
	}
	static class UCtrl_ListView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_ListView>();
	}
};
static_assert(alignof(UCtrl_ListView) == 0x000008, "Wrong alignment on UCtrl_ListView");
static_assert(sizeof(UCtrl_ListView) == 0x000508, "Wrong size on UCtrl_ListView");
static_assert(offsetof(UCtrl_ListView, ListView) == 0x0004F0, "Member 'UCtrl_ListView::ListView' has a wrong offset!");
static_assert(offsetof(UCtrl_ListView, _CanScrollOnLeftMouseDrag) == 0x0004F8, "Member 'UCtrl_ListView::_CanScrollOnLeftMouseDrag' has a wrong offset!");
static_assert(offsetof(UCtrl_ListView, _DragMulti) == 0x0004FC, "Member 'UCtrl_ListView::_DragMulti' has a wrong offset!");

// Class Stigma.Ctrl_MasterMissionButton
// 0x0020 (0x0510 - 0x04F0)
class UCtrl_MasterMissionButton : public UPreviewableWidget
{
public:
	class UCtrl_CommonButtonBase*                 Button;                                            // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemID_EventPage                      _MasterEventID;                                    // 0x04F8(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22AC[0x8];                                     // 0x0508(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void SetCharaIcon(const TSoftObjectPtr<class UTexture2D>& _image);
	void SetLevel(int32 _level);
	void SetLocked(bool _locked);
	void ShowRedDot(bool _show);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_MasterMissionButton">();
	}
	static class UCtrl_MasterMissionButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_MasterMissionButton>();
	}
};
static_assert(alignof(UCtrl_MasterMissionButton) == 0x000008, "Wrong alignment on UCtrl_MasterMissionButton");
static_assert(sizeof(UCtrl_MasterMissionButton) == 0x000510, "Wrong size on UCtrl_MasterMissionButton");
static_assert(offsetof(UCtrl_MasterMissionButton, Button) == 0x0004F0, "Member 'UCtrl_MasterMissionButton::Button' has a wrong offset!");
static_assert(offsetof(UCtrl_MasterMissionButton, _MasterEventID) == 0x0004F8, "Member 'UCtrl_MasterMissionButton::_MasterEventID' has a wrong offset!");

// Class Stigma.EndPointScanner
// 0x0078 (0x00A0 - 0x0028)
class UEndPointScanner final : public UObject
{
public:
	uint8                                         Pad_22AD[0x78];                                    // 0x0028(0x0078)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndPointScanner">();
	}
	static class UEndPointScanner* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndPointScanner>();
	}
};
static_assert(alignof(UEndPointScanner) == 0x000008, "Wrong alignment on UEndPointScanner");
static_assert(sizeof(UEndPointScanner) == 0x0000A0, "Wrong size on UEndPointScanner");

// Class Stigma.Ctrl_MissionRepeatContainer
// 0x0030 (0x0520 - 0x04F0)
class UCtrl_MissionRepeatContainer : public UPreviewableWidget
{
public:
	class UHorizontalBox*                         HorizontalBox;                                     // 0x04F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCtrl_MissionRepeatSlot>    _SlotClass;                                        // 0x04F8(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                _SlotPadding;                                      // 0x0500(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              _SlotSize;                                         // 0x0510(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_MissionRepeatContainer">();
	}
	static class UCtrl_MissionRepeatContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_MissionRepeatContainer>();
	}
};
static_assert(alignof(UCtrl_MissionRepeatContainer) == 0x000008, "Wrong alignment on UCtrl_MissionRepeatContainer");
static_assert(sizeof(UCtrl_MissionRepeatContainer) == 0x000520, "Wrong size on UCtrl_MissionRepeatContainer");
static_assert(offsetof(UCtrl_MissionRepeatContainer, HorizontalBox) == 0x0004F0, "Member 'UCtrl_MissionRepeatContainer::HorizontalBox' has a wrong offset!");
static_assert(offsetof(UCtrl_MissionRepeatContainer, _SlotClass) == 0x0004F8, "Member 'UCtrl_MissionRepeatContainer::_SlotClass' has a wrong offset!");
static_assert(offsetof(UCtrl_MissionRepeatContainer, _SlotPadding) == 0x000500, "Member 'UCtrl_MissionRepeatContainer::_SlotPadding' has a wrong offset!");
static_assert(offsetof(UCtrl_MissionRepeatContainer, _SlotSize) == 0x000510, "Member 'UCtrl_MissionRepeatContainer::_SlotSize' has a wrong offset!");

// Class Stigma.HUD_HpProgress
// 0x0068 (0x0558 - 0x04F0)
class UHUD_HpProgress : public UPreviewableWidget
{
public:
	uint8                                         Pad_22AE[0x8];                                     // 0x04F0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UCanvasPanel*                           HUD_HpGaugeArea;                                   // 0x04F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           RecoveryHpBar;                                     // 0x0500(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           CurrentHpBar;                                      // 0x0508(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHUD_Armor*                             HUD_Armor;                                         // 0x0510(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_HPInc;                                         // 0x0518(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22AF[0x38];                                    // 0x0520(0x0038)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void BindTargetChara(class ACharaBase* _chara);
	void OnHit(float _damage);
	void OnRechargeArmor(float _inc_armor_rate);
	void Update(float _delta);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUD_HpProgress">();
	}
	static class UHUD_HpProgress* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUD_HpProgress>();
	}
};
static_assert(alignof(UHUD_HpProgress) == 0x000008, "Wrong alignment on UHUD_HpProgress");
static_assert(sizeof(UHUD_HpProgress) == 0x000558, "Wrong size on UHUD_HpProgress");
static_assert(offsetof(UHUD_HpProgress, HUD_HpGaugeArea) == 0x0004F8, "Member 'UHUD_HpProgress::HUD_HpGaugeArea' has a wrong offset!");
static_assert(offsetof(UHUD_HpProgress, RecoveryHpBar) == 0x000500, "Member 'UHUD_HpProgress::RecoveryHpBar' has a wrong offset!");
static_assert(offsetof(UHUD_HpProgress, CurrentHpBar) == 0x000508, "Member 'UHUD_HpProgress::CurrentHpBar' has a wrong offset!");
static_assert(offsetof(UHUD_HpProgress, HUD_Armor) == 0x000510, "Member 'UHUD_HpProgress::HUD_Armor' has a wrong offset!");
static_assert(offsetof(UHUD_HpProgress, TXT_HPInc) == 0x000518, "Member 'UHUD_HpProgress::TXT_HPInc' has a wrong offset!");

// Class Stigma.Ctrl_MissionRepeatSlot
// 0x0010 (0x0500 - 0x04F0)
class UCtrl_MissionRepeatSlot : public UPreviewableWidget
{
public:
	class USizeBox*                               SizeBox;                                           // 0x04F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsRepeated;                                       // 0x04F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22B0[0x7];                                     // 0x04F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnSetReated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_MissionRepeatSlot">();
	}
	static class UCtrl_MissionRepeatSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_MissionRepeatSlot>();
	}
};
static_assert(alignof(UCtrl_MissionRepeatSlot) == 0x000008, "Wrong alignment on UCtrl_MissionRepeatSlot");
static_assert(sizeof(UCtrl_MissionRepeatSlot) == 0x000500, "Wrong size on UCtrl_MissionRepeatSlot");
static_assert(offsetof(UCtrl_MissionRepeatSlot, SizeBox) == 0x0004F0, "Member 'UCtrl_MissionRepeatSlot::SizeBox' has a wrong offset!");
static_assert(offsetof(UCtrl_MissionRepeatSlot, _IsRepeated) == 0x0004F8, "Member 'UCtrl_MissionRepeatSlot::_IsRepeated' has a wrong offset!");

// Class Stigma.Ctrl_NavigationStepper
// 0x00D0 (0x05C0 - 0x04F0)
class UCtrl_NavigationStepper : public UPreviewableWidget
{
public:
	TArray<struct FNavigationStepperEntry>        _entries;                                          // 0x04F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UCtrl_NavigationStepperSlotBase> _SlotClass;                                        // 0x0500(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             _ArrowHoverSound;                                  // 0x0508(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             _ArrowUnhoverSound;                                // 0x0510(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             _ArrowClickSound;                                  // 0x0518(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UButton*                                LeftArrow;                                         // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                RightArrow;                                        // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         SlotContainer;                                     // 0x0530(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             CurEntryText;                                      // 0x0538(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, class UCtrl_NavigationStepperSlotBase*> _SlotEntryMap;                                     // 0x0540(0x0050)(ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_22B1[0x30];                                    // 0x0590(0x0030)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	struct FLinearColor GetNotSelectedEntrySlotBtnColor();
	bool GetSelectedEntry(struct FNavigationStepperEntry* _get_selected_entry);
	struct FLinearColor GetSelectedEntrySlotBtnColor();
	void OnArrowHover();
	void OnArrowUnhover();
	void OnLeftArrowClick();
	void OnRightArrowClick();
	void RegisterOnSelectionChanged(const TDelegate<void(class UCtrl_NavigationStepper* _navigation_stepper, struct FNavigationStepperEntry& _selected_entry, int32 _entry_index)>& _callback);
	bool SelectByIndex(int32 _index, bool _invoke_callback);
	bool SelectEntryByID(const class FName& _id, bool _invoke_callback);
	void Setup();
	void UpdateArrows();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_NavigationStepper">();
	}
	static class UCtrl_NavigationStepper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_NavigationStepper>();
	}
};
static_assert(alignof(UCtrl_NavigationStepper) == 0x000008, "Wrong alignment on UCtrl_NavigationStepper");
static_assert(sizeof(UCtrl_NavigationStepper) == 0x0005C0, "Wrong size on UCtrl_NavigationStepper");
static_assert(offsetof(UCtrl_NavigationStepper, _entries) == 0x0004F0, "Member 'UCtrl_NavigationStepper::_entries' has a wrong offset!");
static_assert(offsetof(UCtrl_NavigationStepper, _SlotClass) == 0x000500, "Member 'UCtrl_NavigationStepper::_SlotClass' has a wrong offset!");
static_assert(offsetof(UCtrl_NavigationStepper, _ArrowHoverSound) == 0x000508, "Member 'UCtrl_NavigationStepper::_ArrowHoverSound' has a wrong offset!");
static_assert(offsetof(UCtrl_NavigationStepper, _ArrowUnhoverSound) == 0x000510, "Member 'UCtrl_NavigationStepper::_ArrowUnhoverSound' has a wrong offset!");
static_assert(offsetof(UCtrl_NavigationStepper, _ArrowClickSound) == 0x000518, "Member 'UCtrl_NavigationStepper::_ArrowClickSound' has a wrong offset!");
static_assert(offsetof(UCtrl_NavigationStepper, LeftArrow) == 0x000520, "Member 'UCtrl_NavigationStepper::LeftArrow' has a wrong offset!");
static_assert(offsetof(UCtrl_NavigationStepper, RightArrow) == 0x000528, "Member 'UCtrl_NavigationStepper::RightArrow' has a wrong offset!");
static_assert(offsetof(UCtrl_NavigationStepper, SlotContainer) == 0x000530, "Member 'UCtrl_NavigationStepper::SlotContainer' has a wrong offset!");
static_assert(offsetof(UCtrl_NavigationStepper, CurEntryText) == 0x000538, "Member 'UCtrl_NavigationStepper::CurEntryText' has a wrong offset!");
static_assert(offsetof(UCtrl_NavigationStepper, _SlotEntryMap) == 0x000540, "Member 'UCtrl_NavigationStepper::_SlotEntryMap' has a wrong offset!");

// Class Stigma.Ctrl_NavigationStepperSlotBase
// 0x0000 (0x04F0 - 0x04F0)
class UCtrl_NavigationStepperSlotBase : public UPreviewableWidget
{
public:
	void SetSelectedState(bool _flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_NavigationStepperSlotBase">();
	}
	static class UCtrl_NavigationStepperSlotBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_NavigationStepperSlotBase>();
	}
};
static_assert(alignof(UCtrl_NavigationStepperSlotBase) == 0x000008, "Wrong alignment on UCtrl_NavigationStepperSlotBase");
static_assert(sizeof(UCtrl_NavigationStepperSlotBase) == 0x0004F0, "Wrong size on UCtrl_NavigationStepperSlotBase");

// Class Stigma.LogNotifyState
// 0x0030 (0x0060 - 0x0030)
class ULogNotifyState final : public UAnimNotifyState
{
public:
	class FString                                 _LogText_OnStart;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 _LogText_OnTick;                                   // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 _LogText_OnEnd;                                    // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogNotifyState">();
	}
	static class ULogNotifyState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogNotifyState>();
	}
};
static_assert(alignof(ULogNotifyState) == 0x000008, "Wrong alignment on ULogNotifyState");
static_assert(sizeof(ULogNotifyState) == 0x000060, "Wrong size on ULogNotifyState");
static_assert(offsetof(ULogNotifyState, _LogText_OnStart) == 0x000030, "Member 'ULogNotifyState::_LogText_OnStart' has a wrong offset!");
static_assert(offsetof(ULogNotifyState, _LogText_OnTick) == 0x000040, "Member 'ULogNotifyState::_LogText_OnTick' has a wrong offset!");
static_assert(offsetof(ULogNotifyState, _LogText_OnEnd) == 0x000050, "Member 'ULogNotifyState::_LogText_OnEnd' has a wrong offset!");

// Class Stigma.UI_RemainDateTimer
// 0x00D0 (0x05C0 - 0x04F0)
class UUI_RemainDateTimer : public UPreviewableWidget
{
public:
	class UTextBlock*                             Text;                                              // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   _TimeFormat;                                       // 0x04F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _DaysFormat;                                       // 0x0510(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _HoursFormat;                                      // 0x0528(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _MinutesFormat;                                    // 0x0540(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	class FText                                   _SecondsFormat;                                    // 0x0558(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	int32                                         _TimeDiget;                                        // 0x0570(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _ShowZeroValue;                                    // 0x0574(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22B5[0x3];                                     // 0x0575(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         _MaxTimeUnits;                                     // 0x0578(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22B6[0x4];                                     // 0x057C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class FText                                   _OnEndText;                                        // 0x0580(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_22B7[0x18];                                    // 0x0598(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             _OnTimeEnded;                                      // 0x05B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void InitWidget(const struct FDateTime& _end_at, int32 _alert_hour);
	void OnAlert(bool _alert);
	void Reset();

	int32 GetRemainTimerSec() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_RemainDateTimer">();
	}
	static class UUI_RemainDateTimer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_RemainDateTimer>();
	}
};
static_assert(alignof(UUI_RemainDateTimer) == 0x000008, "Wrong alignment on UUI_RemainDateTimer");
static_assert(sizeof(UUI_RemainDateTimer) == 0x0005C0, "Wrong size on UUI_RemainDateTimer");
static_assert(offsetof(UUI_RemainDateTimer, Text) == 0x0004F0, "Member 'UUI_RemainDateTimer::Text' has a wrong offset!");
static_assert(offsetof(UUI_RemainDateTimer, _TimeFormat) == 0x0004F8, "Member 'UUI_RemainDateTimer::_TimeFormat' has a wrong offset!");
static_assert(offsetof(UUI_RemainDateTimer, _DaysFormat) == 0x000510, "Member 'UUI_RemainDateTimer::_DaysFormat' has a wrong offset!");
static_assert(offsetof(UUI_RemainDateTimer, _HoursFormat) == 0x000528, "Member 'UUI_RemainDateTimer::_HoursFormat' has a wrong offset!");
static_assert(offsetof(UUI_RemainDateTimer, _MinutesFormat) == 0x000540, "Member 'UUI_RemainDateTimer::_MinutesFormat' has a wrong offset!");
static_assert(offsetof(UUI_RemainDateTimer, _SecondsFormat) == 0x000558, "Member 'UUI_RemainDateTimer::_SecondsFormat' has a wrong offset!");
static_assert(offsetof(UUI_RemainDateTimer, _TimeDiget) == 0x000570, "Member 'UUI_RemainDateTimer::_TimeDiget' has a wrong offset!");
static_assert(offsetof(UUI_RemainDateTimer, _ShowZeroValue) == 0x000574, "Member 'UUI_RemainDateTimer::_ShowZeroValue' has a wrong offset!");
static_assert(offsetof(UUI_RemainDateTimer, _MaxTimeUnits) == 0x000578, "Member 'UUI_RemainDateTimer::_MaxTimeUnits' has a wrong offset!");
static_assert(offsetof(UUI_RemainDateTimer, _OnEndText) == 0x000580, "Member 'UUI_RemainDateTimer::_OnEndText' has a wrong offset!");
static_assert(offsetof(UUI_RemainDateTimer, _OnTimeEnded) == 0x0005B0, "Member 'UUI_RemainDateTimer::_OnTimeEnded' has a wrong offset!");

// Class Stigma.Ctrl_Navigation_BorderBase
// 0x0000 (0x04F0 - 0x04F0)
class UCtrl_Navigation_BorderBase : public UPreviewableWidget
{
public:
	void OnEndFocus();
	void OnInteraction();
	void OnStartFocus();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_Navigation_BorderBase">();
	}
	static class UCtrl_Navigation_BorderBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_Navigation_BorderBase>();
	}
};
static_assert(alignof(UCtrl_Navigation_BorderBase) == 0x000008, "Wrong alignment on UCtrl_Navigation_BorderBase");
static_assert(sizeof(UCtrl_Navigation_BorderBase) == 0x0004F0, "Wrong size on UCtrl_Navigation_BorderBase");

// Class Stigma.HUD_TeamScorePanel_New
// 0x0098 (0x0588 - 0x04F0)
class UHUD_TeamScorePanel_New : public UPreviewableWidget
{
public:
	class UHorizontalBox*                         BlueTeamBoxInside;                                 // 0x04F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         RedTeamBoxInside;                                  // 0x04F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_BlueScore;                                     // 0x0500(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_RedScore;                                      // 0x0508(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Round;                                         // 0x0510(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ABattlePlayerState*                     _MyPlayerState;                                    // 0x0518(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_22B9[0x18];                                    // 0x0520(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	TMap<class ABattlePlayerState*, struct FPlayerWidgetSlots> _PlayerSlotMap;                                    // 0x0538(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void Update();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUD_TeamScorePanel_New">();
	}
	static class UHUD_TeamScorePanel_New* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUD_TeamScorePanel_New>();
	}
};
static_assert(alignof(UHUD_TeamScorePanel_New) == 0x000008, "Wrong alignment on UHUD_TeamScorePanel_New");
static_assert(sizeof(UHUD_TeamScorePanel_New) == 0x000588, "Wrong size on UHUD_TeamScorePanel_New");
static_assert(offsetof(UHUD_TeamScorePanel_New, BlueTeamBoxInside) == 0x0004F0, "Member 'UHUD_TeamScorePanel_New::BlueTeamBoxInside' has a wrong offset!");
static_assert(offsetof(UHUD_TeamScorePanel_New, RedTeamBoxInside) == 0x0004F8, "Member 'UHUD_TeamScorePanel_New::RedTeamBoxInside' has a wrong offset!");
static_assert(offsetof(UHUD_TeamScorePanel_New, TXT_BlueScore) == 0x000500, "Member 'UHUD_TeamScorePanel_New::TXT_BlueScore' has a wrong offset!");
static_assert(offsetof(UHUD_TeamScorePanel_New, TXT_RedScore) == 0x000508, "Member 'UHUD_TeamScorePanel_New::TXT_RedScore' has a wrong offset!");
static_assert(offsetof(UHUD_TeamScorePanel_New, TXT_Round) == 0x000510, "Member 'UHUD_TeamScorePanel_New::TXT_Round' has a wrong offset!");
static_assert(offsetof(UHUD_TeamScorePanel_New, _MyPlayerState) == 0x000518, "Member 'UHUD_TeamScorePanel_New::_MyPlayerState' has a wrong offset!");
static_assert(offsetof(UHUD_TeamScorePanel_New, _PlayerSlotMap) == 0x000538, "Member 'UHUD_TeamScorePanel_New::_PlayerSlotMap' has a wrong offset!");

// Class Stigma.Ctrl_OptionControlBase
// 0x0030 (0x0520 - 0x04F0)
class UCtrl_OptionControlBase : public UPreviewableWidget
{
public:
	uint8                                         Pad_22BA[0x20];                                    // 0x04F0(0x0020)(Fixing Size After Last Property [ Dumper-69 ])
	class UUI_Option_Control*                     _OwnerPage;                                        // 0x0510(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              _OwnerPanel;                                       // 0x0518(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool IsControlNowUsing();
	void RegisterOnControlUsingChanged(const TDelegate<void(class UCtrl_OptionControlBase* _control, bool _is_using)>& _callback);
	void SetIsControlNowUsing(bool _state);
	void SetOwner(class UUI_Option_Control* _owner_page, class UCtrl_OptionItemPanelBase* _owner_panel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_OptionControlBase">();
	}
	static class UCtrl_OptionControlBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_OptionControlBase>();
	}
};
static_assert(alignof(UCtrl_OptionControlBase) == 0x000008, "Wrong alignment on UCtrl_OptionControlBase");
static_assert(sizeof(UCtrl_OptionControlBase) == 0x000520, "Wrong size on UCtrl_OptionControlBase");
static_assert(offsetof(UCtrl_OptionControlBase, _OwnerPage) == 0x000510, "Member 'UCtrl_OptionControlBase::_OwnerPage' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionControlBase, _OwnerPanel) == 0x000518, "Member 'UCtrl_OptionControlBase::_OwnerPanel' has a wrong offset!");

// Class Stigma.UI_RecruitPage
// 0x00E8 (0x05F8 - 0x0510)
class UUI_RecruitPage : public UUI_LobbyPage
{
public:
	class UCtrl_HorizontalTabPanel*               RecruitTab;                                        // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Ovl_Background;                                    // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HB_BuyButtonList;                                  // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_CommonButton_Intensity*           Btn_History;                                       // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_CommonButton_Intensity*           Btn_Exchange;                                      // 0x0530(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_CommonButton_Intensity*           Btn_Detail;                                        // 0x0538(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_EndPeriod;                                     // 0x0540(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               OVL_Recruit;                                       // 0x0548(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_Empty;                                         // 0x0550(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_RemainDateTimer*                    RemainDateTimer;                                   // 0x0558(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_CancellationPolicy*                 CancellationPolicy;                                // 0x0560(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_RecruitBuyButton>       _BuyButtonClass;                                   // 0x0568(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_CurrencyBox>            _CurrencyBoxClass;                                 // 0x0570(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPopupBase>                 _HistoryPopupClass;                                // 0x0578(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPopupBase>                 _ResultPopupClass;                                 // 0x0580(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _BuyButtonPadding;                                 // 0x0588(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22BB[0x4];                                     // 0x058C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FNetRecruitInfo>                _RecruitList;                                      // 0x0590(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UUI_RecruitBuyButton*>           _BuyButtonList;                                    // 0x05A0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UUI_CurrencyBox*>                _CurrencyBoxList;                                  // 0x05B0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_22BC[0x38];                                    // 0x05C0(0x0038)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnBuyRecruit(EResultCode _rcode, const struct FACK_BuyRecruit& _ack);
	void OnClickDetail(class UAnimatableWidget* _widget, bool _select);
	void OnClickExchange(class UAnimatableWidget* _widget, bool _select);
	void OnClickHistory(class UAnimatableWidget* _widget, bool _select);
	void OnClickRecruitBuy(const struct FRecruitExcuteData& _data, int32 _index);
	void OnEndResult();
	void OnReadRecruit(EResultCode _rcode, const struct FACK_ReadRecruit& _ack);
	void OnRecruitTabChanged(class FName _id, int32 _idx);
	void OnUpdateUser(EUserEvent _event);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_RecruitPage">();
	}
	static class UUI_RecruitPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_RecruitPage>();
	}
};
static_assert(alignof(UUI_RecruitPage) == 0x000008, "Wrong alignment on UUI_RecruitPage");
static_assert(sizeof(UUI_RecruitPage) == 0x0005F8, "Wrong size on UUI_RecruitPage");
static_assert(offsetof(UUI_RecruitPage, RecruitTab) == 0x000510, "Member 'UUI_RecruitPage::RecruitTab' has a wrong offset!");
static_assert(offsetof(UUI_RecruitPage, Ovl_Background) == 0x000518, "Member 'UUI_RecruitPage::Ovl_Background' has a wrong offset!");
static_assert(offsetof(UUI_RecruitPage, HB_BuyButtonList) == 0x000520, "Member 'UUI_RecruitPage::HB_BuyButtonList' has a wrong offset!");
static_assert(offsetof(UUI_RecruitPage, Btn_History) == 0x000528, "Member 'UUI_RecruitPage::Btn_History' has a wrong offset!");
static_assert(offsetof(UUI_RecruitPage, Btn_Exchange) == 0x000530, "Member 'UUI_RecruitPage::Btn_Exchange' has a wrong offset!");
static_assert(offsetof(UUI_RecruitPage, Btn_Detail) == 0x000538, "Member 'UUI_RecruitPage::Btn_Detail' has a wrong offset!");
static_assert(offsetof(UUI_RecruitPage, Txt_EndPeriod) == 0x000540, "Member 'UUI_RecruitPage::Txt_EndPeriod' has a wrong offset!");
static_assert(offsetof(UUI_RecruitPage, OVL_Recruit) == 0x000548, "Member 'UUI_RecruitPage::OVL_Recruit' has a wrong offset!");
static_assert(offsetof(UUI_RecruitPage, Txt_Empty) == 0x000550, "Member 'UUI_RecruitPage::Txt_Empty' has a wrong offset!");
static_assert(offsetof(UUI_RecruitPage, RemainDateTimer) == 0x000558, "Member 'UUI_RecruitPage::RemainDateTimer' has a wrong offset!");
static_assert(offsetof(UUI_RecruitPage, CancellationPolicy) == 0x000560, "Member 'UUI_RecruitPage::CancellationPolicy' has a wrong offset!");
static_assert(offsetof(UUI_RecruitPage, _BuyButtonClass) == 0x000568, "Member 'UUI_RecruitPage::_BuyButtonClass' has a wrong offset!");
static_assert(offsetof(UUI_RecruitPage, _CurrencyBoxClass) == 0x000570, "Member 'UUI_RecruitPage::_CurrencyBoxClass' has a wrong offset!");
static_assert(offsetof(UUI_RecruitPage, _HistoryPopupClass) == 0x000578, "Member 'UUI_RecruitPage::_HistoryPopupClass' has a wrong offset!");
static_assert(offsetof(UUI_RecruitPage, _ResultPopupClass) == 0x000580, "Member 'UUI_RecruitPage::_ResultPopupClass' has a wrong offset!");
static_assert(offsetof(UUI_RecruitPage, _BuyButtonPadding) == 0x000588, "Member 'UUI_RecruitPage::_BuyButtonPadding' has a wrong offset!");
static_assert(offsetof(UUI_RecruitPage, _RecruitList) == 0x000590, "Member 'UUI_RecruitPage::_RecruitList' has a wrong offset!");
static_assert(offsetof(UUI_RecruitPage, _BuyButtonList) == 0x0005A0, "Member 'UUI_RecruitPage::_BuyButtonList' has a wrong offset!");
static_assert(offsetof(UUI_RecruitPage, _CurrencyBoxList) == 0x0005B0, "Member 'UUI_RecruitPage::_CurrencyBoxList' has a wrong offset!");

// Class Stigma.Ctrl_OptionDetailTabBase
// 0x0000 (0x04F0 - 0x04F0)
class UCtrl_OptionDetailTabBase final : public UPreviewableWidget
{
public:
	class UUserWidget* CreateOptionContextWidget(int32 _idx);
	int32 GetSelectedIdx();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_OptionDetailTabBase">();
	}
	static class UCtrl_OptionDetailTabBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_OptionDetailTabBase>();
	}
};
static_assert(alignof(UCtrl_OptionDetailTabBase) == 0x000008, "Wrong alignment on UCtrl_OptionDetailTabBase");
static_assert(sizeof(UCtrl_OptionDetailTabBase) == 0x0004F0, "Wrong size on UCtrl_OptionDetailTabBase");

// Class Stigma.Ctrl_OptionDropDownBase
// 0x0048 (0x0538 - 0x04F0)
class UCtrl_OptionDropDownBase : public UPreviewableWidget
{
public:
	class UCustomComboBoxString*                  CustomDropDown;                                    // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FOptionDropDownEntry>           _entries;                                          // 0x04F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_22C4[0x30];                                    // 0x0508(0x0030)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Internal_OnOpeningDropdown();
	void OnProcSelectionChange(const class FName _id, const class FString& _option, ESelectInfo _selection_info);
	void RegisterOnSelectionChanged(const TDelegate<void(class FName& _id, int32 _index)>& _callback);
	bool SelectByID(class FName _display_text);
	void SelectByIndex(int32 _index);
	void Setup();
	void SetUpByEntries(const TArray<struct FOptionDropDownEntry>& _entry_list);

	int32 GetOptionCount() const;
	int32 GetSelectedIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_OptionDropDownBase">();
	}
	static class UCtrl_OptionDropDownBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_OptionDropDownBase>();
	}
};
static_assert(alignof(UCtrl_OptionDropDownBase) == 0x000008, "Wrong alignment on UCtrl_OptionDropDownBase");
static_assert(sizeof(UCtrl_OptionDropDownBase) == 0x000538, "Wrong size on UCtrl_OptionDropDownBase");
static_assert(offsetof(UCtrl_OptionDropDownBase, CustomDropDown) == 0x0004F0, "Member 'UCtrl_OptionDropDownBase::CustomDropDown' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionDropDownBase, _entries) == 0x0004F8, "Member 'UCtrl_OptionDropDownBase::_entries' has a wrong offset!");

// Class Stigma.EQG_PerceivedActors
// 0x0050 (0x00A0 - 0x0050)
class UEQG_PerceivedActors final : public UEnvQueryGenerator
{
public:
	TSet<TSubclassOf<class AActor>>               ActorClasses;                                      // 0x0050(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EQG_PerceivedActors">();
	}
	static class UEQG_PerceivedActors* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEQG_PerceivedActors>();
	}
};
static_assert(alignof(UEQG_PerceivedActors) == 0x000008, "Wrong alignment on UEQG_PerceivedActors");
static_assert(sizeof(UEQG_PerceivedActors) == 0x0000A0, "Wrong size on UEQG_PerceivedActors");
static_assert(offsetof(UEQG_PerceivedActors, ActorClasses) == 0x000050, "Member 'UEQG_PerceivedActors::ActorClasses' has a wrong offset!");

// Class Stigma.Ctrl_OptionItemEntry
// 0x0058 (0x0548 - 0x04F0)
class UCtrl_OptionItemEntry : public UPreviewableWidget
{
public:
	struct FOptionDescEntry                       _DescEntry;                                        // 0x04F0(0x0040)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_22C7[0x18];                                    // 0x0530(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void RegisterOnHoverChanged(const TDelegate<void(class UCtrl_OptionItemEntry* _panel, bool _is_hover)>& _callback);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_OptionItemEntry">();
	}
	static class UCtrl_OptionItemEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_OptionItemEntry>();
	}
};
static_assert(alignof(UCtrl_OptionItemEntry) == 0x000008, "Wrong alignment on UCtrl_OptionItemEntry");
static_assert(sizeof(UCtrl_OptionItemEntry) == 0x000548, "Wrong size on UCtrl_OptionItemEntry");
static_assert(offsetof(UCtrl_OptionItemEntry, _DescEntry) == 0x0004F0, "Member 'UCtrl_OptionItemEntry::_DescEntry' has a wrong offset!");

// Class Stigma.HUD_ScopeWidgetBase
// 0x0068 (0x0558 - 0x04F0)
class UHUD_ScopeWidgetBase : public UPreviewableWidget
{
public:
	class UTextBlock*                             TXT_Charging;                                      // 0x04F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharaBase*                             _TargetChara;                                      // 0x04F8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       UI_OnIdle_Default;                                 // 0x0500(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       UI_Charge;                                         // 0x0508(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       UI_Charge_Idle;                                    // 0x0510(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       UI_Shoot;                                          // 0x0518(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             _ShowSound;                                        // 0x0520(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             _IdleSound;                                        // 0x0528(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             _ChargeSound;                                      // 0x0530(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             _ChargeIdleSound;                                  // 0x0538(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             _ShootSound;                                       // 0x0540(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        _IdleAudioComponent;                               // 0x0548(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        _ChargeIdleAudioComponent;                         // 0x0550(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnEndChargeAnimation();
	void OnEndShootAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUD_ScopeWidgetBase">();
	}
	static class UHUD_ScopeWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUD_ScopeWidgetBase>();
	}
};
static_assert(alignof(UHUD_ScopeWidgetBase) == 0x000008, "Wrong alignment on UHUD_ScopeWidgetBase");
static_assert(sizeof(UHUD_ScopeWidgetBase) == 0x000558, "Wrong size on UHUD_ScopeWidgetBase");
static_assert(offsetof(UHUD_ScopeWidgetBase, TXT_Charging) == 0x0004F0, "Member 'UHUD_ScopeWidgetBase::TXT_Charging' has a wrong offset!");
static_assert(offsetof(UHUD_ScopeWidgetBase, _TargetChara) == 0x0004F8, "Member 'UHUD_ScopeWidgetBase::_TargetChara' has a wrong offset!");
static_assert(offsetof(UHUD_ScopeWidgetBase, UI_OnIdle_Default) == 0x000500, "Member 'UHUD_ScopeWidgetBase::UI_OnIdle_Default' has a wrong offset!");
static_assert(offsetof(UHUD_ScopeWidgetBase, UI_Charge) == 0x000508, "Member 'UHUD_ScopeWidgetBase::UI_Charge' has a wrong offset!");
static_assert(offsetof(UHUD_ScopeWidgetBase, UI_Charge_Idle) == 0x000510, "Member 'UHUD_ScopeWidgetBase::UI_Charge_Idle' has a wrong offset!");
static_assert(offsetof(UHUD_ScopeWidgetBase, UI_Shoot) == 0x000518, "Member 'UHUD_ScopeWidgetBase::UI_Shoot' has a wrong offset!");
static_assert(offsetof(UHUD_ScopeWidgetBase, _ShowSound) == 0x000520, "Member 'UHUD_ScopeWidgetBase::_ShowSound' has a wrong offset!");
static_assert(offsetof(UHUD_ScopeWidgetBase, _IdleSound) == 0x000528, "Member 'UHUD_ScopeWidgetBase::_IdleSound' has a wrong offset!");
static_assert(offsetof(UHUD_ScopeWidgetBase, _ChargeSound) == 0x000530, "Member 'UHUD_ScopeWidgetBase::_ChargeSound' has a wrong offset!");
static_assert(offsetof(UHUD_ScopeWidgetBase, _ChargeIdleSound) == 0x000538, "Member 'UHUD_ScopeWidgetBase::_ChargeIdleSound' has a wrong offset!");
static_assert(offsetof(UHUD_ScopeWidgetBase, _ShootSound) == 0x000540, "Member 'UHUD_ScopeWidgetBase::_ShootSound' has a wrong offset!");
static_assert(offsetof(UHUD_ScopeWidgetBase, _IdleAudioComponent) == 0x000548, "Member 'UHUD_ScopeWidgetBase::_IdleAudioComponent' has a wrong offset!");
static_assert(offsetof(UHUD_ScopeWidgetBase, _ChargeIdleAudioComponent) == 0x000550, "Member 'UHUD_ScopeWidgetBase::_ChargeIdleAudioComponent' has a wrong offset!");

// Class Stigma.Ctrl_OptionItemPanelBase
// 0x0068 (0x05B0 - 0x0548)
class UCtrl_OptionItemPanelBase : public UCtrl_OptionItemEntry
{
public:
	class UTextBlock*                             PanelText;                                         // 0x0548(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         Container;                                         // 0x0550(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNamedSlot*                             Contents;                                          // 0x0558(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   _DisplayText;                                      // 0x0560(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          _IsSubPanel;                                       // 0x0578(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22C8[0x7];                                     // 0x0579(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FVector2D                              _ContentHorizontalPadding;                         // 0x0580(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionControlBase*                _ChildControl;                                     // 0x0590(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             _HoverSound;                                       // 0x0598(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             _UnhoverSound;                                     // 0x05A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22C9[0x8];                                     // 0x05A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void SetHoverSound(class USoundBase* _hover_sound);
	void SetHoverState(bool _flag);
	void SetPanelText(const class FText& _text);
	void SetUnhoverSound(class USoundBase* _unhover_sound);
	void Setup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_OptionItemPanelBase">();
	}
	static class UCtrl_OptionItemPanelBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_OptionItemPanelBase>();
	}
};
static_assert(alignof(UCtrl_OptionItemPanelBase) == 0x000008, "Wrong alignment on UCtrl_OptionItemPanelBase");
static_assert(sizeof(UCtrl_OptionItemPanelBase) == 0x0005B0, "Wrong size on UCtrl_OptionItemPanelBase");
static_assert(offsetof(UCtrl_OptionItemPanelBase, PanelText) == 0x000548, "Member 'UCtrl_OptionItemPanelBase::PanelText' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionItemPanelBase, Container) == 0x000550, "Member 'UCtrl_OptionItemPanelBase::Container' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionItemPanelBase, Contents) == 0x000558, "Member 'UCtrl_OptionItemPanelBase::Contents' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionItemPanelBase, _DisplayText) == 0x000560, "Member 'UCtrl_OptionItemPanelBase::_DisplayText' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionItemPanelBase, _IsSubPanel) == 0x000578, "Member 'UCtrl_OptionItemPanelBase::_IsSubPanel' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionItemPanelBase, _ContentHorizontalPadding) == 0x000580, "Member 'UCtrl_OptionItemPanelBase::_ContentHorizontalPadding' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionItemPanelBase, _ChildControl) == 0x000590, "Member 'UCtrl_OptionItemPanelBase::_ChildControl' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionItemPanelBase, _HoverSound) == 0x000598, "Member 'UCtrl_OptionItemPanelBase::_HoverSound' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionItemPanelBase, _UnhoverSound) == 0x0005A0, "Member 'UCtrl_OptionItemPanelBase::_UnhoverSound' has a wrong offset!");

// Class Stigma.UpperBlendStrongly
// 0x0008 (0x0038 - 0x0030)
class UUpperBlendStrongly final : public UAnimNotifyState
{
public:
	bool                                          CallEnd;                                           // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22CA[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpperBlendStrongly">();
	}
	static class UUpperBlendStrongly* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpperBlendStrongly>();
	}
};
static_assert(alignof(UUpperBlendStrongly) == 0x000008, "Wrong alignment on UUpperBlendStrongly");
static_assert(sizeof(UUpperBlendStrongly) == 0x000038, "Wrong size on UUpperBlendStrongly");
static_assert(offsetof(UUpperBlendStrongly, CallEnd) == 0x000030, "Member 'UUpperBlendStrongly::CallEnd' has a wrong offset!");

// Class Stigma.Ctrl_OptionKeyBindBase
// 0x00C8 (0x05E8 - 0x0520)
class UCtrl_OptionKeyBindBase : public UCtrl_OptionControlBase
{
public:
	struct FKeyMapping                            _KeyMapping;                                       // 0x0520(0x0030)(BlueprintVisible, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInputSlotType                                _InputSlotType;                                    // 0x0550(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsFixedKeyBind;                                   // 0x0551(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22CB[0x6];                                     // 0x0552(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	struct FKeyMapping                            _DefaultMapping;                                   // 0x0558(0x0030)(Edit, BlueprintVisible, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FKey>                           _InputKeys;                                        // 0x0588(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          UsingInterceptor;                                  // 0x0598(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsDuplicates;                                     // 0x0599(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22CC[0x6];                                     // 0x059A(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	class UMaterial*                              _Mtrl_BlinkEffect;                                 // 0x05A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               _Mtrl_Inst_BlinkEffect;                            // 0x05A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_Blink_Background;                              // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           H_BindedKeys;                                      // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22CD[0x28];                                    // 0x05C0(0x0028)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ChangeKeyMapping(bool _is_roll_back, bool _invoke_callback);
	void CheckDuplicate(const struct FKeyBindOption& Key_bind_option, const struct FKeyMappings& _mappings);
	void CheckKeyDesc();
	void Init(ECharaType _chara_type, const struct FKeyMapping& _cur_key_mapping, const struct FKeyMapping& _default_key_mapping, const struct FKeyMappings& _cur_key_mappings);
	void OnInternalKeyMappingChanged(const struct FKeyMapping& _mapping);
	void ReadyToInputKey();
	void RegisterOnMappingChange(const TDelegate<void(class UCtrl_OptionKeyBindBase* _key_binder, struct FKeyMapping& _mapping)>& _callback);
	void SetBlinking(bool _blinking, float _blinking_speed);
	void UpdateUI(class UCtrl_OptionKeyBindBase* _key_binder, const struct FKeyMapping& _mapping);
	void ValidateMtrl();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_OptionKeyBindBase">();
	}
	static class UCtrl_OptionKeyBindBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_OptionKeyBindBase>();
	}
};
static_assert(alignof(UCtrl_OptionKeyBindBase) == 0x000008, "Wrong alignment on UCtrl_OptionKeyBindBase");
static_assert(sizeof(UCtrl_OptionKeyBindBase) == 0x0005E8, "Wrong size on UCtrl_OptionKeyBindBase");
static_assert(offsetof(UCtrl_OptionKeyBindBase, _KeyMapping) == 0x000520, "Member 'UCtrl_OptionKeyBindBase::_KeyMapping' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionKeyBindBase, _InputSlotType) == 0x000550, "Member 'UCtrl_OptionKeyBindBase::_InputSlotType' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionKeyBindBase, _IsFixedKeyBind) == 0x000551, "Member 'UCtrl_OptionKeyBindBase::_IsFixedKeyBind' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionKeyBindBase, _DefaultMapping) == 0x000558, "Member 'UCtrl_OptionKeyBindBase::_DefaultMapping' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionKeyBindBase, _InputKeys) == 0x000588, "Member 'UCtrl_OptionKeyBindBase::_InputKeys' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionKeyBindBase, UsingInterceptor) == 0x000598, "Member 'UCtrl_OptionKeyBindBase::UsingInterceptor' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionKeyBindBase, _IsDuplicates) == 0x000599, "Member 'UCtrl_OptionKeyBindBase::_IsDuplicates' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionKeyBindBase, _Mtrl_BlinkEffect) == 0x0005A0, "Member 'UCtrl_OptionKeyBindBase::_Mtrl_BlinkEffect' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionKeyBindBase, _Mtrl_Inst_BlinkEffect) == 0x0005A8, "Member 'UCtrl_OptionKeyBindBase::_Mtrl_Inst_BlinkEffect' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionKeyBindBase, IMG_Blink_Background) == 0x0005B0, "Member 'UCtrl_OptionKeyBindBase::IMG_Blink_Background' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionKeyBindBase, H_BindedKeys) == 0x0005B8, "Member 'UCtrl_OptionKeyBindBase::H_BindedKeys' has a wrong offset!");

// Class Stigma.Ctrl_OptionPalette
// 0x0000 (0x04F0 - 0x04F0)
class UCtrl_OptionPalette final : public UPreviewableWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_OptionPalette">();
	}
	static class UCtrl_OptionPalette* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_OptionPalette>();
	}
};
static_assert(alignof(UCtrl_OptionPalette) == 0x000008, "Wrong alignment on UCtrl_OptionPalette");
static_assert(sizeof(UCtrl_OptionPalette) == 0x0004F0, "Wrong size on UCtrl_OptionPalette");

// Class Stigma.GunPresetBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UGunPresetBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static EGunType GetGunType(const struct FGunPreset& _gun_preset);
	static int32 GetPresetSlot(const struct FGunPreset& _gun_preset);
	static bool IsEqualGunPreset(const struct FGunPreset& _preset1, const struct FGunPreset& _preset2);
	static bool IsValidGunPreset(const struct FGunPreset& _gun_preset);
	static struct FGunPreset MakeGunPreset(EGunType _gun_type, int32 _preset_slot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GunPresetBlueprintLibrary">();
	}
	static class UGunPresetBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGunPresetBlueprintLibrary>();
	}
};
static_assert(alignof(UGunPresetBlueprintLibrary) == 0x000008, "Wrong alignment on UGunPresetBlueprintLibrary");
static_assert(sizeof(UGunPresetBlueprintLibrary) == 0x000028, "Wrong size on UGunPresetBlueprintLibrary");

// Class Stigma.UI_RewardItem
// 0x0038 (0x0528 - 0x04F0)
class UUI_RewardItem : public UPreviewableWidget
{
public:
	struct FRewardItem                            _item;                                             // 0x04F0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          _IsRankPoint;                                      // 0x0508(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERewardItemState                              _state;                                            // 0x0509(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22D5[0x1E];                                    // 0x050A(0x001E)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnClickItem();
	void SetCount(int32 _count);
	void SetFromItemEntry(const struct FItemEntry& _item_entry);
	void SetRewardItem(const struct FItemID& _reward_id, int32 _reward_count);
	void SetRewardRankPoint(int32 _reward_rank_point);
	void SetRewardState(ERewardItemState _reward_state);

	const struct FItemID GetItemID() const;
	ERewardItemState GetRewardState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_RewardItem">();
	}
	static class UUI_RewardItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_RewardItem>();
	}
};
static_assert(alignof(UUI_RewardItem) == 0x000008, "Wrong alignment on UUI_RewardItem");
static_assert(sizeof(UUI_RewardItem) == 0x000528, "Wrong size on UUI_RewardItem");
static_assert(offsetof(UUI_RewardItem, _item) == 0x0004F0, "Member 'UUI_RewardItem::_item' has a wrong offset!");
static_assert(offsetof(UUI_RewardItem, _IsRankPoint) == 0x000508, "Member 'UUI_RewardItem::_IsRankPoint' has a wrong offset!");
static_assert(offsetof(UUI_RewardItem, _state) == 0x000509, "Member 'UUI_RewardItem::_state' has a wrong offset!");

// Class Stigma.Ctrl_OptionPaletteBase
// 0x0110 (0x0658 - 0x0548)
class UCtrl_OptionPaletteBase : public UCtrl_OptionItemEntry
{
public:
	class FName                                   _id;                                               // 0x0548(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   _SubjectText;                                      // 0x0550(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	EOptionPalettePresetMode                      PresetColorMode;                                   // 0x0568(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22D7[0x7];                                     // 0x0569(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FLinearColor>                   CustomPresetColors;                                // 0x0570(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class USoundBase*                             _PanelHoverSound;                                  // 0x0580(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             _PanelUnhoverSound;                                // 0x0588(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22D8[0x48];                                    // 0x0590(0x0048)(Fixing Size After Last Property [ Dumper-69 ])
	class UCtrl_OptionPreSetColorBase*            CurColorApplied;                                   // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         PresetContainer;                                   // 0x05E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                OpenButton;                                        // 0x05E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                ApplyButton;                                       // 0x05F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              BackSensor;                                        // 0x05F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_Palette;                                     // 0x0600(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_Preset;                                      // 0x0608(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_CrossHairRed;                                // 0x0610(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_CrossHairGreen;                              // 0x0618(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_CrossHairBlue;                               // 0x0620(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_CrossHairAlpha;                              // 0x0628(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 Slider_CrossHairRed;                               // 0x0630(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 Slider_CrossHairGreen;                             // 0x0638(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 Slider_CrossHairBlue;                              // 0x0640(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 Slider_CrossHairAlpha;                             // 0x0648(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCtrl_OptionPreSetColorBase> _PreSetColorWidget;                                // 0x0650(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ApplyChangeColor(bool _invoke_callback);
	void CloseDetailColorSetter();
	void Init(const struct FLinearColor& _color);
	void InitByRGBA(int32 _r, int32 _g, int32 _b, int32 _a);
	void OpenDetailColorSetter();
	void RegisterOnValueApplied(const TDelegate<void(class UCtrl_OptionPaletteBase* _palette, struct FLinearColor& _color)>& _callback);
	void RegisterOnValueChange(const TDelegate<void(class UCtrl_OptionPaletteBase* _palette, struct FLinearColor& _color)>& _callback);
	void Setup();

	class FName GetID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_OptionPaletteBase">();
	}
	static class UCtrl_OptionPaletteBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_OptionPaletteBase>();
	}
};
static_assert(alignof(UCtrl_OptionPaletteBase) == 0x000008, "Wrong alignment on UCtrl_OptionPaletteBase");
static_assert(sizeof(UCtrl_OptionPaletteBase) == 0x000658, "Wrong size on UCtrl_OptionPaletteBase");
static_assert(offsetof(UCtrl_OptionPaletteBase, _id) == 0x000548, "Member 'UCtrl_OptionPaletteBase::_id' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionPaletteBase, _SubjectText) == 0x000550, "Member 'UCtrl_OptionPaletteBase::_SubjectText' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionPaletteBase, PresetColorMode) == 0x000568, "Member 'UCtrl_OptionPaletteBase::PresetColorMode' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionPaletteBase, CustomPresetColors) == 0x000570, "Member 'UCtrl_OptionPaletteBase::CustomPresetColors' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionPaletteBase, _PanelHoverSound) == 0x000580, "Member 'UCtrl_OptionPaletteBase::_PanelHoverSound' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionPaletteBase, _PanelUnhoverSound) == 0x000588, "Member 'UCtrl_OptionPaletteBase::_PanelUnhoverSound' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionPaletteBase, CurColorApplied) == 0x0005D8, "Member 'UCtrl_OptionPaletteBase::CurColorApplied' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionPaletteBase, PresetContainer) == 0x0005E0, "Member 'UCtrl_OptionPaletteBase::PresetContainer' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionPaletteBase, OpenButton) == 0x0005E8, "Member 'UCtrl_OptionPaletteBase::OpenButton' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionPaletteBase, ApplyButton) == 0x0005F0, "Member 'UCtrl_OptionPaletteBase::ApplyButton' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionPaletteBase, BackSensor) == 0x0005F8, "Member 'UCtrl_OptionPaletteBase::BackSensor' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionPaletteBase, Panel_Palette) == 0x000600, "Member 'UCtrl_OptionPaletteBase::Panel_Palette' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionPaletteBase, Panel_Preset) == 0x000608, "Member 'UCtrl_OptionPaletteBase::Panel_Preset' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionPaletteBase, Panel_CrossHairRed) == 0x000610, "Member 'UCtrl_OptionPaletteBase::Panel_CrossHairRed' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionPaletteBase, Panel_CrossHairGreen) == 0x000618, "Member 'UCtrl_OptionPaletteBase::Panel_CrossHairGreen' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionPaletteBase, Panel_CrossHairBlue) == 0x000620, "Member 'UCtrl_OptionPaletteBase::Panel_CrossHairBlue' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionPaletteBase, Panel_CrossHairAlpha) == 0x000628, "Member 'UCtrl_OptionPaletteBase::Panel_CrossHairAlpha' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionPaletteBase, Slider_CrossHairRed) == 0x000630, "Member 'UCtrl_OptionPaletteBase::Slider_CrossHairRed' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionPaletteBase, Slider_CrossHairGreen) == 0x000638, "Member 'UCtrl_OptionPaletteBase::Slider_CrossHairGreen' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionPaletteBase, Slider_CrossHairBlue) == 0x000640, "Member 'UCtrl_OptionPaletteBase::Slider_CrossHairBlue' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionPaletteBase, Slider_CrossHairAlpha) == 0x000648, "Member 'UCtrl_OptionPaletteBase::Slider_CrossHairAlpha' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionPaletteBase, _PreSetColorWidget) == 0x000650, "Member 'UCtrl_OptionPaletteBase::_PreSetColorWidget' has a wrong offset!");

// Class Stigma.InvenItems
// 0x00B0 (0x00D8 - 0x0028)
class UInvenItems final : public UObject
{
public:
	uint8                                         Pad_22D9[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TMap<EItemCategory, struct FInvenItemList>    _CategoryMap;                                      // 0x0030(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<struct FItemID, struct FInvenItemList>   _InvenMap;                                         // 0x0080(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_22DA[0x8];                                     // 0x00D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	TArray<class UInvenItem*> FindItemsOrAddItem(const struct FItemID& _id);
	bool HasItem(class UInvenItem* _item);
	bool IsVisibleRedDot_Category(EItemCategory _category);
	bool IsVisibleRedDot_GunParts(EGunType _gun_type, EGunPartsSlot _gun_parts_slot);
	void SetSeenAtRecently_Category(EItemCategory _category);

	TArray<class UInvenItem*> FindAttachablePartsItemsByGun(EGunType _gun_type, EGunPartsSlot _gun_parts_slot) const;
	class UInvenItem* FindItemByNetItem(const struct FNetInvenItem& _net_item) const;
	TArray<class UInvenItem*> FindItemsByGunPartsSlot(EGunPartsSlot _gun_parts_slot) const;
	TArray<class UInvenItem*> FindItemsByID(const struct FItemID& _id) const;
	class UInvenItem* FindTopItemByID(const struct FItemID& _id) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InvenItems">();
	}
	static class UInvenItems* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInvenItems>();
	}
};
static_assert(alignof(UInvenItems) == 0x000008, "Wrong alignment on UInvenItems");
static_assert(sizeof(UInvenItems) == 0x0000D8, "Wrong size on UInvenItems");
static_assert(offsetof(UInvenItems, _CategoryMap) == 0x000030, "Member 'UInvenItems::_CategoryMap' has a wrong offset!");
static_assert(offsetof(UInvenItems, _InvenMap) == 0x000080, "Member 'UInvenItems::_InvenMap' has a wrong offset!");

// Class Stigma.Ctrl_OptionPreSetColorBase
// 0x0030 (0x0520 - 0x04F0)
class UCtrl_OptionPreSetColorBase : public UPreviewableWidget
{
public:
	uint8                                         Pad_22DE[0x28];                                    // 0x04F0(0x0028)(Fixing Size After Last Property [ Dumper-69 ])
	class UImage*                                 ColorImage;                                        // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InternalOnMouseDown();
	void RegisterOnClicked(const TDelegate<void(class UCtrl_OptionPreSetColorBase* _preset_widget)>& _callback);
	void SetColor(const struct FLinearColor& _color);

	struct FLinearColor GetColor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_OptionPreSetColorBase">();
	}
	static class UCtrl_OptionPreSetColorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_OptionPreSetColorBase>();
	}
};
static_assert(alignof(UCtrl_OptionPreSetColorBase) == 0x000008, "Wrong alignment on UCtrl_OptionPreSetColorBase");
static_assert(sizeof(UCtrl_OptionPreSetColorBase) == 0x000520, "Wrong size on UCtrl_OptionPreSetColorBase");
static_assert(offsetof(UCtrl_OptionPreSetColorBase, ColorImage) == 0x000518, "Member 'UCtrl_OptionPreSetColorBase::ColorImage' has a wrong offset!");

// Class Stigma.UI_BattlePassBriefSlot
// 0x0060 (0x0550 - 0x04F0)
class UUI_BattlePassBriefSlot : public UPreviewableWidget
{
public:
	class UOverlay*                               Ovl_PassBG;                                        // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Ovl_BriefInfo_Panel;                               // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_Navigation_BorderBase*            Navigation_Border;                                 // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_Title;                                         // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_Level;                                         // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_ResultProgressBar*                UI_ExpBar;                                         // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_RedDot;                                        // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_RemainDateTimer*                    UI_RemainDateTimer;                                // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_CommonButtonBase*                 Button;                                            // 0x0530(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemID_BattlePass                     _PassID;                                           // 0x0538(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22DF[0x8];                                     // 0x0548(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void InitWidget(const struct FItemID_BattlePass& _pass_id);
	void OnClick(class UAnimatableWidget* _widget, bool _selected);

	const struct FItemID_BattlePass GetPassID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_BattlePassBriefSlot">();
	}
	static class UUI_BattlePassBriefSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_BattlePassBriefSlot>();
	}
};
static_assert(alignof(UUI_BattlePassBriefSlot) == 0x000008, "Wrong alignment on UUI_BattlePassBriefSlot");
static_assert(sizeof(UUI_BattlePassBriefSlot) == 0x000550, "Wrong size on UUI_BattlePassBriefSlot");
static_assert(offsetof(UUI_BattlePassBriefSlot, Ovl_PassBG) == 0x0004F0, "Member 'UUI_BattlePassBriefSlot::Ovl_PassBG' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassBriefSlot, Ovl_BriefInfo_Panel) == 0x0004F8, "Member 'UUI_BattlePassBriefSlot::Ovl_BriefInfo_Panel' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassBriefSlot, Navigation_Border) == 0x000500, "Member 'UUI_BattlePassBriefSlot::Navigation_Border' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassBriefSlot, Txt_Title) == 0x000508, "Member 'UUI_BattlePassBriefSlot::Txt_Title' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassBriefSlot, Txt_Level) == 0x000510, "Member 'UUI_BattlePassBriefSlot::Txt_Level' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassBriefSlot, UI_ExpBar) == 0x000518, "Member 'UUI_BattlePassBriefSlot::UI_ExpBar' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassBriefSlot, Img_RedDot) == 0x000520, "Member 'UUI_BattlePassBriefSlot::Img_RedDot' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassBriefSlot, UI_RemainDateTimer) == 0x000528, "Member 'UUI_BattlePassBriefSlot::UI_RemainDateTimer' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassBriefSlot, Button) == 0x000530, "Member 'UUI_BattlePassBriefSlot::Button' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassBriefSlot, _PassID) == 0x000538, "Member 'UUI_BattlePassBriefSlot::_PassID' has a wrong offset!");

// Class Stigma.UI_Result_BattlePassBrief
// 0x0010 (0x0560 - 0x0550)
class UUI_Result_BattlePassBrief : public UUI_BattlePassBriefSlot
{
public:
	class USizeBox*                               SB_Reward;                                         // 0x0550(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_RewardContainer*                    RewardContainer;                                   // 0x0558(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddPassExp(int32 _base_exp, int32 _buff_exp);
	void SetFunctionAddedExp(int32 _buff_exp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Result_BattlePassBrief">();
	}
	static class UUI_Result_BattlePassBrief* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Result_BattlePassBrief>();
	}
};
static_assert(alignof(UUI_Result_BattlePassBrief) == 0x000008, "Wrong alignment on UUI_Result_BattlePassBrief");
static_assert(sizeof(UUI_Result_BattlePassBrief) == 0x000560, "Wrong size on UUI_Result_BattlePassBrief");
static_assert(offsetof(UUI_Result_BattlePassBrief, SB_Reward) == 0x000550, "Member 'UUI_Result_BattlePassBrief::SB_Reward' has a wrong offset!");
static_assert(offsetof(UUI_Result_BattlePassBrief, RewardContainer) == 0x000558, "Member 'UUI_Result_BattlePassBrief::RewardContainer' has a wrong offset!");

// Class Stigma.Ctrl_OptionSliderBase
// 0x0078 (0x0598 - 0x0520)
class UCtrl_OptionSliderBase : public UCtrl_OptionControlBase
{
public:
	class FName                                   _MyID;                                             // 0x0520(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _InitValue;                                        // 0x0528(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _MinValue;                                         // 0x052C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _MaxValue;                                         // 0x0530(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _StepSize;                                         // 0x0534(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _UsePercentageText;                                // 0x0538(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _UseRealValue;                                     // 0x0539(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22E1[0x2];                                     // 0x053A(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         _RealValueMaxDecimalPointCount;                    // 0x053C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USlider*                                Slider;                                            // 0x0540(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           ProgressBar;                                       // 0x0548(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEditableText*                          ValueText;                                         // 0x0550(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PercentageText;                                    // 0x0558(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22E2[0x38];                                    // 0x0560(0x0038)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnBeginCaptureSlider();
	void OnEndCaptureSlider();
	void OnInternalSliderValueChanged();
	void OnSliderChanged(float _value);
	void OnValueTextCommitted(const class FText& _text, ETextCommit _commit_type);
	void RegisterOnValueChange(const TDelegate<void(class UCtrl_OptionSliderBase* Slider, class FName& _id, float _value)>& _callback);
	void Setup();
	void SetValue(float _value, bool _invoke_callback);

	float GetNormalizedValue() const;
	float GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_OptionSliderBase">();
	}
	static class UCtrl_OptionSliderBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_OptionSliderBase>();
	}
};
static_assert(alignof(UCtrl_OptionSliderBase) == 0x000008, "Wrong alignment on UCtrl_OptionSliderBase");
static_assert(sizeof(UCtrl_OptionSliderBase) == 0x000598, "Wrong size on UCtrl_OptionSliderBase");
static_assert(offsetof(UCtrl_OptionSliderBase, _MyID) == 0x000520, "Member 'UCtrl_OptionSliderBase::_MyID' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionSliderBase, _InitValue) == 0x000528, "Member 'UCtrl_OptionSliderBase::_InitValue' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionSliderBase, _MinValue) == 0x00052C, "Member 'UCtrl_OptionSliderBase::_MinValue' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionSliderBase, _MaxValue) == 0x000530, "Member 'UCtrl_OptionSliderBase::_MaxValue' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionSliderBase, _StepSize) == 0x000534, "Member 'UCtrl_OptionSliderBase::_StepSize' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionSliderBase, _UsePercentageText) == 0x000538, "Member 'UCtrl_OptionSliderBase::_UsePercentageText' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionSliderBase, _UseRealValue) == 0x000539, "Member 'UCtrl_OptionSliderBase::_UseRealValue' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionSliderBase, _RealValueMaxDecimalPointCount) == 0x00053C, "Member 'UCtrl_OptionSliderBase::_RealValueMaxDecimalPointCount' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionSliderBase, Slider) == 0x000540, "Member 'UCtrl_OptionSliderBase::Slider' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionSliderBase, ProgressBar) == 0x000548, "Member 'UCtrl_OptionSliderBase::ProgressBar' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionSliderBase, ValueText) == 0x000550, "Member 'UCtrl_OptionSliderBase::ValueText' has a wrong offset!");
static_assert(offsetof(UCtrl_OptionSliderBase, PercentageText) == 0x000558, "Member 'UCtrl_OptionSliderBase::PercentageText' has a wrong offset!");

// Class Stigma.Ctrl_PageNavigator
// 0x0040 (0x0530 - 0x04F0)
class UCtrl_PageNavigator final : public UPreviewableWidget
{
public:
	class USizeBox*                               SB_Width;                                          // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_CommonButtonBase*                 Btn_Left;                                          // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_CommonButtonBase*                 Btn_Right;                                         // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_Counter;                                       // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             _OnChangeCurrentPageEvent;                         // 0x0510(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         _width;                                            // 0x0520(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22E5[0xC];                                     // 0x0524(0x000C)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void InitWidget(int32 _current_idx, int32 _max_idx);
	void OnClickBtn(class UAnimatableWidget* _widget, bool _selected);
	void SetCurrentCount(int32 _current_count);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_PageNavigator">();
	}
	static class UCtrl_PageNavigator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_PageNavigator>();
	}
};
static_assert(alignof(UCtrl_PageNavigator) == 0x000008, "Wrong alignment on UCtrl_PageNavigator");
static_assert(sizeof(UCtrl_PageNavigator) == 0x000530, "Wrong size on UCtrl_PageNavigator");
static_assert(offsetof(UCtrl_PageNavigator, SB_Width) == 0x0004F0, "Member 'UCtrl_PageNavigator::SB_Width' has a wrong offset!");
static_assert(offsetof(UCtrl_PageNavigator, Btn_Left) == 0x0004F8, "Member 'UCtrl_PageNavigator::Btn_Left' has a wrong offset!");
static_assert(offsetof(UCtrl_PageNavigator, Btn_Right) == 0x000500, "Member 'UCtrl_PageNavigator::Btn_Right' has a wrong offset!");
static_assert(offsetof(UCtrl_PageNavigator, Txt_Counter) == 0x000508, "Member 'UCtrl_PageNavigator::Txt_Counter' has a wrong offset!");
static_assert(offsetof(UCtrl_PageNavigator, _OnChangeCurrentPageEvent) == 0x000510, "Member 'UCtrl_PageNavigator::_OnChangeCurrentPageEvent' has a wrong offset!");
static_assert(offsetof(UCtrl_PageNavigator, _width) == 0x000520, "Member 'UCtrl_PageNavigator::_width' has a wrong offset!");

// Class Stigma.EventPageHelper
// 0x0000 (0x0028 - 0x0028)
class UEventPageHelper final : public UBlueprintFunctionLibrary
{
public:
	static TArray<struct FItemID_EventPage> GetAllEventPageIDs(const class UObject* _world_ctx);
	static bool GetMasterLevelExp(const class UObject* _world_ctx, ECharaType _type, int32* _out_level, int32* _out_exp, int32* _out_target_exp);
	static TArray<struct FItemID_EventPage> GetTypeEventPageIDs(const class UObject* _world_ctx, EEventPageType _type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventPageHelper">();
	}
	static class UEventPageHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventPageHelper>();
	}
};
static_assert(alignof(UEventPageHelper) == 0x000008, "Wrong alignment on UEventPageHelper");
static_assert(sizeof(UEventPageHelper) == 0x000028, "Wrong size on UEventPageHelper");

// Class Stigma.UI_WeaponPage
// 0x00C8 (0x05D8 - 0x0510)
class UUI_WeaponPage : public UUI_LobbyPage
{
public:
	class UUI_GunNPartsListViews*                 _GunNPartsListViews;                               // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               OVL_GunDetail;                                     // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           Panel_Slots;                                       // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           Panel_Draw;                                        // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_GunPreview*                         GunPreview;                                        // 0x0530(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_GunPresetEditor*                    GunPresetEditor;                                   // 0x0538(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_GunPartsSlotGroup*                  Slots_Front;                                       // 0x0540(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_GunPartsSlotGroup*                  Slots_Under;                                       // 0x0548(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_GunPartsSlotGroup*                  Slots_Body;                                        // 0x0550(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_GunPartsSlotGroup*                  Slots_Top;                                         // 0x0558(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_GunPartsSlotGroup*                  Slots_Slide;                                       // 0x0560(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_GunPartsSlotGroup*                  Slots_Magazine;                                    // 0x0568(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       UI_OnShow;                                         // 0x0570(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class APreviewActor>              _LobbyGunPreviewerClass;                           // 0x0578(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                _GunPartsMarkerClass;                              // 0x0580(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUserWidget*>                    _UnusedMarkerWidgets;                              // 0x0588(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UCtrl_Lines*                            _LineWidget;                                       // 0x0598(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGunObject*                             _OriginGunObject;                                  // 0x05A0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGunObject*                             _DuplicatedGunObject;                              // 0x05A8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APreviewActor*                          _GunPreviewer;                                     // 0x05B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFollowCameraActor*                     _PreviewCam;                                       // 0x05B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGunPartsSlot                                 _SelectedPartsSlot;                                // 0x05C0(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _ShowingGunPartsList;                              // 0x05C1(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22EA[0x16];                                    // 0x05C2(0x0016)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void CloseParts();
	class FName GetPartsCamName(EGunPartsSlot _gun_parts_slot);
	void Init();
	void OnClickCloseParts();
	void OnClickPartsSlot(EGunPartsSlot _slot);
	void OnLoadCompleteLevel();
	void OnUpdateGun(bool _is_init);
	void OpenParts(EGunPartsSlot _gun_parts_slot, EGunType _gun_type);
	void RefreshPreview(class FName _cam_tag);
	void SelectGunPreset(const struct FGunPreset& _gun_preset);
	void SelectParts(class UInvenItem* _parts, class UGunObject* _gun_object);
	bool ShowGunDetailParts(bool _is_shown);

	bool HasSelectPartsOnlyOwnedParts() const;
	bool IsSelectingParts() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_WeaponPage">();
	}
	static class UUI_WeaponPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_WeaponPage>();
	}
};
static_assert(alignof(UUI_WeaponPage) == 0x000008, "Wrong alignment on UUI_WeaponPage");
static_assert(sizeof(UUI_WeaponPage) == 0x0005D8, "Wrong size on UUI_WeaponPage");
static_assert(offsetof(UUI_WeaponPage, _GunNPartsListViews) == 0x000510, "Member 'UUI_WeaponPage::_GunNPartsListViews' has a wrong offset!");
static_assert(offsetof(UUI_WeaponPage, OVL_GunDetail) == 0x000518, "Member 'UUI_WeaponPage::OVL_GunDetail' has a wrong offset!");
static_assert(offsetof(UUI_WeaponPage, Panel_Slots) == 0x000520, "Member 'UUI_WeaponPage::Panel_Slots' has a wrong offset!");
static_assert(offsetof(UUI_WeaponPage, Panel_Draw) == 0x000528, "Member 'UUI_WeaponPage::Panel_Draw' has a wrong offset!");
static_assert(offsetof(UUI_WeaponPage, GunPreview) == 0x000530, "Member 'UUI_WeaponPage::GunPreview' has a wrong offset!");
static_assert(offsetof(UUI_WeaponPage, GunPresetEditor) == 0x000538, "Member 'UUI_WeaponPage::GunPresetEditor' has a wrong offset!");
static_assert(offsetof(UUI_WeaponPage, Slots_Front) == 0x000540, "Member 'UUI_WeaponPage::Slots_Front' has a wrong offset!");
static_assert(offsetof(UUI_WeaponPage, Slots_Under) == 0x000548, "Member 'UUI_WeaponPage::Slots_Under' has a wrong offset!");
static_assert(offsetof(UUI_WeaponPage, Slots_Body) == 0x000550, "Member 'UUI_WeaponPage::Slots_Body' has a wrong offset!");
static_assert(offsetof(UUI_WeaponPage, Slots_Top) == 0x000558, "Member 'UUI_WeaponPage::Slots_Top' has a wrong offset!");
static_assert(offsetof(UUI_WeaponPage, Slots_Slide) == 0x000560, "Member 'UUI_WeaponPage::Slots_Slide' has a wrong offset!");
static_assert(offsetof(UUI_WeaponPage, Slots_Magazine) == 0x000568, "Member 'UUI_WeaponPage::Slots_Magazine' has a wrong offset!");
static_assert(offsetof(UUI_WeaponPage, UI_OnShow) == 0x000570, "Member 'UUI_WeaponPage::UI_OnShow' has a wrong offset!");
static_assert(offsetof(UUI_WeaponPage, _LobbyGunPreviewerClass) == 0x000578, "Member 'UUI_WeaponPage::_LobbyGunPreviewerClass' has a wrong offset!");
static_assert(offsetof(UUI_WeaponPage, _GunPartsMarkerClass) == 0x000580, "Member 'UUI_WeaponPage::_GunPartsMarkerClass' has a wrong offset!");
static_assert(offsetof(UUI_WeaponPage, _UnusedMarkerWidgets) == 0x000588, "Member 'UUI_WeaponPage::_UnusedMarkerWidgets' has a wrong offset!");
static_assert(offsetof(UUI_WeaponPage, _LineWidget) == 0x000598, "Member 'UUI_WeaponPage::_LineWidget' has a wrong offset!");
static_assert(offsetof(UUI_WeaponPage, _OriginGunObject) == 0x0005A0, "Member 'UUI_WeaponPage::_OriginGunObject' has a wrong offset!");
static_assert(offsetof(UUI_WeaponPage, _DuplicatedGunObject) == 0x0005A8, "Member 'UUI_WeaponPage::_DuplicatedGunObject' has a wrong offset!");
static_assert(offsetof(UUI_WeaponPage, _GunPreviewer) == 0x0005B0, "Member 'UUI_WeaponPage::_GunPreviewer' has a wrong offset!");
static_assert(offsetof(UUI_WeaponPage, _PreviewCam) == 0x0005B8, "Member 'UUI_WeaponPage::_PreviewCam' has a wrong offset!");
static_assert(offsetof(UUI_WeaponPage, _SelectedPartsSlot) == 0x0005C0, "Member 'UUI_WeaponPage::_SelectedPartsSlot' has a wrong offset!");
static_assert(offsetof(UUI_WeaponPage, _ShowingGunPartsList) == 0x0005C1, "Member 'UUI_WeaponPage::_ShowingGunPartsList' has a wrong offset!");

// Class Stigma.Ctrl_QuestionBase
// 0x0000 (0x0570 - 0x0570)
class UCtrl_QuestionBase : public UPopupBase
{
public:
	struct FSurveyAnswer OnGetAnswer();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_QuestionBase">();
	}
	static class UCtrl_QuestionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_QuestionBase>();
	}
};
static_assert(alignof(UCtrl_QuestionBase) == 0x000008, "Wrong alignment on UCtrl_QuestionBase");
static_assert(sizeof(UCtrl_QuestionBase) == 0x000570, "Wrong size on UCtrl_QuestionBase");

// Class Stigma.MissionCondition_AbilityUp
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_AbilityUp final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_AbilityUp">();
	}
	static class UMissionCondition_AbilityUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_AbilityUp>();
	}
};
static_assert(alignof(UMissionCondition_AbilityUp) == 0x000008, "Wrong alignment on UMissionCondition_AbilityUp");
static_assert(sizeof(UMissionCondition_AbilityUp) == 0x000068, "Wrong size on UMissionCondition_AbilityUp");

// Class Stigma.Ctrl_RadioButtonGroupBase
// 0x0028 (0x0518 - 0x04F0)
class UCtrl_RadioButtonGroupBase : public UPreviewableWidget
{
public:
	class USoundBase*                             _HoverSound;                                       // 0x04F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             _ClickSound;                                       // 0x04F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22EC[0x18];                                    // 0x0500(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	class FName GetSelectedID();
	void InvokeOnSelectionChanged(const class FName& _id);
	void OnClick(class FName _id);
	void OnHover();
	void RegisterOnSelectionChange(const TDelegate<void(class UCtrl_RadioButtonGroupBase* _panel, class FName& _id)>& _callback);
	void SelectOnlyMatchedID(class FName _id_selected);
	void SelectOnlyMatchedIDEx(class FName _id_selected, bool _invoke_callback);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_RadioButtonGroupBase">();
	}
	static class UCtrl_RadioButtonGroupBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_RadioButtonGroupBase>();
	}
};
static_assert(alignof(UCtrl_RadioButtonGroupBase) == 0x000008, "Wrong alignment on UCtrl_RadioButtonGroupBase");
static_assert(sizeof(UCtrl_RadioButtonGroupBase) == 0x000518, "Wrong size on UCtrl_RadioButtonGroupBase");
static_assert(offsetof(UCtrl_RadioButtonGroupBase, _HoverSound) == 0x0004F0, "Member 'UCtrl_RadioButtonGroupBase::_HoverSound' has a wrong offset!");
static_assert(offsetof(UCtrl_RadioButtonGroupBase, _ClickSound) == 0x0004F8, "Member 'UCtrl_RadioButtonGroupBase::_ClickSound' has a wrong offset!");

// Class Stigma.UserSelectable
// 0x0000 (0x0028 - 0x0028)
class IUserSelectable final : public IInterface
{
public:
	bool OnSelectGunType(EGunType _gun_types);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserSelectable">();
	}
	static class IUserSelectable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IUserSelectable>();
	}
};
static_assert(alignof(IUserSelectable) == 0x000008, "Wrong alignment on IUserSelectable");
static_assert(sizeof(IUserSelectable) == 0x000028, "Wrong size on IUserSelectable");

// Class Stigma.Ctrl_ResultProgressBar
// 0x0018 (0x0538 - 0x0520)
class UCtrl_ResultProgressBar : public UCtrl_CommonProgressBar
{
public:
	class UProgressBar*                           PrevBar;                                           // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22EE[0x10];                                    // 0x0528(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void SetAddedValueText(int32 _added_value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_ResultProgressBar">();
	}
	static class UCtrl_ResultProgressBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_ResultProgressBar>();
	}
};
static_assert(alignof(UCtrl_ResultProgressBar) == 0x000008, "Wrong alignment on UCtrl_ResultProgressBar");
static_assert(sizeof(UCtrl_ResultProgressBar) == 0x000538, "Wrong size on UCtrl_ResultProgressBar");
static_assert(offsetof(UCtrl_ResultProgressBar, PrevBar) == 0x000520, "Member 'UCtrl_ResultProgressBar::PrevBar' has a wrong offset!");

// Class Stigma.Ctrl_ScrollTextBlock
// 0x01B0 (0x06A0 - 0x04F0)
class UCtrl_ScrollTextBlock : public UPreviewableWidget
{
public:
	class UScrollBox*                             ScrollBox;                                         // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TextBlock;                                         // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOrientation                                  _Orientation;                                      // 0x0500(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22EF[0x7];                                     // 0x0501(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class FText                                   _text;                                             // 0x0508(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           _color;                                            // 0x0520(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateFontInfo                         _Font;                                             // 0x0530(0x0058)(Edit, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22F0[0x8];                                     // 0x0588(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	struct FSlateBrush                            _StrikeBrush;                                      // 0x0590(0x00D0)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              _ShadowOffset;                                     // 0x0660(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _ShadowColor;                                      // 0x0670(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETextTransformPolicy                          _TransformPolicy;                                  // 0x0680(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _AutoScroll;                                       // 0x0681(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22F1[0x2];                                     // 0x0682(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         _AutoScrollDelayTime;                              // 0x0684(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22F2[0x4];                                     // 0x0688(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         _ScrollSpeed;                                      // 0x068C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22F3[0x10];                                    // 0x0690(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void DoScroll(bool _do_scorll);
	void SetText(const class FText& _new_text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_ScrollTextBlock">();
	}
	static class UCtrl_ScrollTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_ScrollTextBlock>();
	}
};
static_assert(alignof(UCtrl_ScrollTextBlock) == 0x000010, "Wrong alignment on UCtrl_ScrollTextBlock");
static_assert(sizeof(UCtrl_ScrollTextBlock) == 0x0006A0, "Wrong size on UCtrl_ScrollTextBlock");
static_assert(offsetof(UCtrl_ScrollTextBlock, ScrollBox) == 0x0004F0, "Member 'UCtrl_ScrollTextBlock::ScrollBox' has a wrong offset!");
static_assert(offsetof(UCtrl_ScrollTextBlock, TextBlock) == 0x0004F8, "Member 'UCtrl_ScrollTextBlock::TextBlock' has a wrong offset!");
static_assert(offsetof(UCtrl_ScrollTextBlock, _Orientation) == 0x000500, "Member 'UCtrl_ScrollTextBlock::_Orientation' has a wrong offset!");
static_assert(offsetof(UCtrl_ScrollTextBlock, _text) == 0x000508, "Member 'UCtrl_ScrollTextBlock::_text' has a wrong offset!");
static_assert(offsetof(UCtrl_ScrollTextBlock, _color) == 0x000520, "Member 'UCtrl_ScrollTextBlock::_color' has a wrong offset!");
static_assert(offsetof(UCtrl_ScrollTextBlock, _Font) == 0x000530, "Member 'UCtrl_ScrollTextBlock::_Font' has a wrong offset!");
static_assert(offsetof(UCtrl_ScrollTextBlock, _StrikeBrush) == 0x000590, "Member 'UCtrl_ScrollTextBlock::_StrikeBrush' has a wrong offset!");
static_assert(offsetof(UCtrl_ScrollTextBlock, _ShadowOffset) == 0x000660, "Member 'UCtrl_ScrollTextBlock::_ShadowOffset' has a wrong offset!");
static_assert(offsetof(UCtrl_ScrollTextBlock, _ShadowColor) == 0x000670, "Member 'UCtrl_ScrollTextBlock::_ShadowColor' has a wrong offset!");
static_assert(offsetof(UCtrl_ScrollTextBlock, _TransformPolicy) == 0x000680, "Member 'UCtrl_ScrollTextBlock::_TransformPolicy' has a wrong offset!");
static_assert(offsetof(UCtrl_ScrollTextBlock, _AutoScroll) == 0x000681, "Member 'UCtrl_ScrollTextBlock::_AutoScroll' has a wrong offset!");
static_assert(offsetof(UCtrl_ScrollTextBlock, _AutoScrollDelayTime) == 0x000684, "Member 'UCtrl_ScrollTextBlock::_AutoScrollDelayTime' has a wrong offset!");
static_assert(offsetof(UCtrl_ScrollTextBlock, _ScrollSpeed) == 0x00068C, "Member 'UCtrl_ScrollTextBlock::_ScrollSpeed' has a wrong offset!");

// Class Stigma.HUD_CooldownBaseSlot
// 0x00B8 (0x05A8 - 0x04F0)
class UHUD_CooldownBaseSlot : public UPreviewableWidget
{
public:
	class UTextBlock*                             TXT_Key;                                           // 0x04F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Icon;                                          // 0x04F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_Gauge;                                         // 0x0500(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FKey                                   _UseKey;                                           // 0x0508(0x0018)(Edit, BlueprintVisible, ExportObject, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EInputAction                                  _KeyInputAction;                                   // 0x0520(0x0001)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22F4[0x7];                                     // 0x0521(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UMaterialInterface*                     _IconMaterial;                                     // 0x0528(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     _CooltimeGaugeMaterial;                            // 0x0530(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _CoolTimeColor;                                    // 0x0538(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _ActivateDelayTimeColor;                           // 0x0548(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               _IconMaterialInst;                                 // 0x0558(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               _CooltimeGaugeMaterialInst;                        // 0x0560(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharaBase*                             _TargetChara;                                      // 0x0568(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22F5[0x38];                                    // 0x0570(0x0038)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUD_CooldownBaseSlot">();
	}
	static class UHUD_CooldownBaseSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUD_CooldownBaseSlot>();
	}
};
static_assert(alignof(UHUD_CooldownBaseSlot) == 0x000008, "Wrong alignment on UHUD_CooldownBaseSlot");
static_assert(sizeof(UHUD_CooldownBaseSlot) == 0x0005A8, "Wrong size on UHUD_CooldownBaseSlot");
static_assert(offsetof(UHUD_CooldownBaseSlot, TXT_Key) == 0x0004F0, "Member 'UHUD_CooldownBaseSlot::TXT_Key' has a wrong offset!");
static_assert(offsetof(UHUD_CooldownBaseSlot, Img_Icon) == 0x0004F8, "Member 'UHUD_CooldownBaseSlot::Img_Icon' has a wrong offset!");
static_assert(offsetof(UHUD_CooldownBaseSlot, IMG_Gauge) == 0x000500, "Member 'UHUD_CooldownBaseSlot::IMG_Gauge' has a wrong offset!");
static_assert(offsetof(UHUD_CooldownBaseSlot, _UseKey) == 0x000508, "Member 'UHUD_CooldownBaseSlot::_UseKey' has a wrong offset!");
static_assert(offsetof(UHUD_CooldownBaseSlot, _KeyInputAction) == 0x000520, "Member 'UHUD_CooldownBaseSlot::_KeyInputAction' has a wrong offset!");
static_assert(offsetof(UHUD_CooldownBaseSlot, _IconMaterial) == 0x000528, "Member 'UHUD_CooldownBaseSlot::_IconMaterial' has a wrong offset!");
static_assert(offsetof(UHUD_CooldownBaseSlot, _CooltimeGaugeMaterial) == 0x000530, "Member 'UHUD_CooldownBaseSlot::_CooltimeGaugeMaterial' has a wrong offset!");
static_assert(offsetof(UHUD_CooldownBaseSlot, _CoolTimeColor) == 0x000538, "Member 'UHUD_CooldownBaseSlot::_CoolTimeColor' has a wrong offset!");
static_assert(offsetof(UHUD_CooldownBaseSlot, _ActivateDelayTimeColor) == 0x000548, "Member 'UHUD_CooldownBaseSlot::_ActivateDelayTimeColor' has a wrong offset!");
static_assert(offsetof(UHUD_CooldownBaseSlot, _IconMaterialInst) == 0x000558, "Member 'UHUD_CooldownBaseSlot::_IconMaterialInst' has a wrong offset!");
static_assert(offsetof(UHUD_CooldownBaseSlot, _CooltimeGaugeMaterialInst) == 0x000560, "Member 'UHUD_CooldownBaseSlot::_CooltimeGaugeMaterialInst' has a wrong offset!");
static_assert(offsetof(UHUD_CooldownBaseSlot, _TargetChara) == 0x000568, "Member 'UHUD_CooldownBaseSlot::_TargetChara' has a wrong offset!");

// Class Stigma.WIDGET_TutorialDialog
// 0x0068 (0x05D8 - 0x0570)
class UWIDGET_TutorialDialog : public UPopupBase
{
public:
	class URichTextBlock*                         TXT_Message_R;                                     // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         TXT_Message_L;                                     // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        Switcher_L;                                        // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        Switcher_R;                                        // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TypewritingSpeed;                                  // 0x0590(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _LeftSide;                                         // 0x0594(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _BlackScreen;                                      // 0x0595(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22F6[0x2];                                     // 0x0596(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	class UTexture2D*                             _image;                                            // 0x0598(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         TXT_Message;                                       // 0x05A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22F7[0x30];                                    // 0x05A8(0x0030)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnEndShowMessage();
	void OnStartShowMessage();

	bool IsShowing() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WIDGET_TutorialDialog">();
	}
	static class UWIDGET_TutorialDialog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWIDGET_TutorialDialog>();
	}
};
static_assert(alignof(UWIDGET_TutorialDialog) == 0x000008, "Wrong alignment on UWIDGET_TutorialDialog");
static_assert(sizeof(UWIDGET_TutorialDialog) == 0x0005D8, "Wrong size on UWIDGET_TutorialDialog");
static_assert(offsetof(UWIDGET_TutorialDialog, TXT_Message_R) == 0x000570, "Member 'UWIDGET_TutorialDialog::TXT_Message_R' has a wrong offset!");
static_assert(offsetof(UWIDGET_TutorialDialog, TXT_Message_L) == 0x000578, "Member 'UWIDGET_TutorialDialog::TXT_Message_L' has a wrong offset!");
static_assert(offsetof(UWIDGET_TutorialDialog, Switcher_L) == 0x000580, "Member 'UWIDGET_TutorialDialog::Switcher_L' has a wrong offset!");
static_assert(offsetof(UWIDGET_TutorialDialog, Switcher_R) == 0x000588, "Member 'UWIDGET_TutorialDialog::Switcher_R' has a wrong offset!");
static_assert(offsetof(UWIDGET_TutorialDialog, TypewritingSpeed) == 0x000590, "Member 'UWIDGET_TutorialDialog::TypewritingSpeed' has a wrong offset!");
static_assert(offsetof(UWIDGET_TutorialDialog, _LeftSide) == 0x000594, "Member 'UWIDGET_TutorialDialog::_LeftSide' has a wrong offset!");
static_assert(offsetof(UWIDGET_TutorialDialog, _BlackScreen) == 0x000595, "Member 'UWIDGET_TutorialDialog::_BlackScreen' has a wrong offset!");
static_assert(offsetof(UWIDGET_TutorialDialog, _image) == 0x000598, "Member 'UWIDGET_TutorialDialog::_image' has a wrong offset!");
static_assert(offsetof(UWIDGET_TutorialDialog, TXT_Message) == 0x0005A0, "Member 'UWIDGET_TutorialDialog::TXT_Message' has a wrong offset!");

// Class Stigma.Ctrl_SkinSlot
// 0x0068 (0x0558 - 0x04F0)
class UCtrl_SkinSlot : public UPreviewableWidget
{
public:
	class UImage*                                 Img_Icon;                                          // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Grade;                                         // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Ovl_Armor;                                         // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Armor;                                         // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Expired;                                       // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              _DefaultIcon;                                      // 0x0518(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemID                                _SkinID;                                           // 0x0540(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECharaType                                    _CharaType;                                        // 0x0550(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22F8[0x7];                                     // 0x0551(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void InitWidget(const struct FItemID& _skin_id);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_SkinSlot">();
	}
	static class UCtrl_SkinSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_SkinSlot>();
	}
};
static_assert(alignof(UCtrl_SkinSlot) == 0x000008, "Wrong alignment on UCtrl_SkinSlot");
static_assert(sizeof(UCtrl_SkinSlot) == 0x000558, "Wrong size on UCtrl_SkinSlot");
static_assert(offsetof(UCtrl_SkinSlot, Img_Icon) == 0x0004F0, "Member 'UCtrl_SkinSlot::Img_Icon' has a wrong offset!");
static_assert(offsetof(UCtrl_SkinSlot, Img_Grade) == 0x0004F8, "Member 'UCtrl_SkinSlot::Img_Grade' has a wrong offset!");
static_assert(offsetof(UCtrl_SkinSlot, Ovl_Armor) == 0x000500, "Member 'UCtrl_SkinSlot::Ovl_Armor' has a wrong offset!");
static_assert(offsetof(UCtrl_SkinSlot, Img_Armor) == 0x000508, "Member 'UCtrl_SkinSlot::Img_Armor' has a wrong offset!");
static_assert(offsetof(UCtrl_SkinSlot, Img_Expired) == 0x000510, "Member 'UCtrl_SkinSlot::Img_Expired' has a wrong offset!");
static_assert(offsetof(UCtrl_SkinSlot, _DefaultIcon) == 0x000518, "Member 'UCtrl_SkinSlot::_DefaultIcon' has a wrong offset!");
static_assert(offsetof(UCtrl_SkinSlot, _SkinID) == 0x000540, "Member 'UCtrl_SkinSlot::_SkinID' has a wrong offset!");
static_assert(offsetof(UCtrl_SkinSlot, _CharaType) == 0x000550, "Member 'UCtrl_SkinSlot::_CharaType' has a wrong offset!");

// Class Stigma.LobbyControllerBase
// 0x0198 (0x0B28 - 0x0990)
class ALobbyControllerBase : public AStigmaPlayerController
{
public:
	TSubclassOf<class UUI_Lobby>                  _UI_Class;                                         // 0x0990(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_Lobby*                              _UI_Lobby;                                         // 0x0998(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_Survey>                 _SurveyUIClass;                                    // 0x09A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_SurveyWeb>              _SurveyWebClass;                                   // 0x09A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_SurveyWeb*                          _SurveyWeb;                                        // 0x09B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_SocialContainer>        _SocialContainerUIClass;                           // 0x09B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_LevelUp>                _LevelUpUIClass;                                   // 0x09C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_HelpPopup>              _HelpUIClass;                                      // 0x09C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_NoticePopup>            _NoticeUIClass;                                    // 0x09D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_TierPromotionPopup>     _TierPromotionUIClass;                             // 0x09D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_SeasonRewardPopup>      _SeasonRewardUIClass;                              // 0x09E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_CompetitionRewardPopup> _CompetitionRewardUIClass;                         // 0x09E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_RewardMissionPopup>     _RewardMissionPopupClass;                          // 0x09F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_EventPagePopup>         _EventPageUIClass;                                 // 0x09F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_BattlePassLevelUpPopup> _BattlePassLevelUpUIClass;                         // 0x0A00(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_PlayerProfilePopup>     _PlayerProfileUIClass;                             // 0x0A08(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UStringTable*>                   _StringTables;                                     // 0x0A10(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  WeaponMapFile;                                     // 0x0A20(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22F9[0x10];                                    // 0x0A48(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class AActor*                                 _PreviewActor;                                     // 0x0A58(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               _PreviewActorInitialRot;                           // 0x0A60(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          _AllowPreviewerRotationMode;                       // 0x0A78(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22FA[0x7];                                     // 0x0A79(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class ULevelStreamingDynamic*                 _Level_Weapon;                                     // 0x0A80(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22FB[0x8];                                     // 0x0A88(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UKeepConnectEventDriver*                _KeepConnectEventDriver;                           // 0x0A90(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULevelSequencePlayer*                   _CutScenePlayer;                                   // 0x0A98(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULevelStreamingDynamic*                 _LobbySelectionLevel;                              // 0x0AA0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UWorld>                  _LobbySelectionMapFile;                            // 0x0AA8(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharaBase*                             _Clone;                                            // 0x0AD0(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACamMesh*                               _CamMesh;                                          // 0x0AD8(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ALevelSequenceActor*                    _LobbySelection_Sequencer;                         // 0x0AE0(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_22FC[0x10];                                    // 0x0AE8(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	TSoftObjectPtr<class UWorld>                  _RecruitLevelAsset;                                // 0x0AF8(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULevelStreamingDynamic*                 _RecruitLevel;                                     // 0x0B20(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AllowPreviewerRotationMode(bool _allow_rot);
	void CloseHelpPopup();
	EMouseCursor GetCursor();
	class ULevelSequencePlayer* GetCutScenePlayer();
	class ALevelSequenceActor* GetSequenceByTag(class FName _tag);
	void LoadSelectionCutScene();
	void OnBeginGamePlay();
	void OnFinishSelectionCutScene();
	void OnMatchChanged();
	void SetPreviewActor(class AActor* _Actor);
	void ShowBattlePassLevelUpPopup(const class FText& _Title, int32 _level);
	void ShowCompetitionRewardPopup(const struct FBC_CompetitionEnd& _competition_end);
	void ShowEventPagePopup(bool _on_bc);
	void ShowHelpPopup(const class FString& _contents_key);
	void ShowLevelUpPopup(int32 _level, const struct FRewardPlain& _reward);
	void ShowMissionRewardPopup(const TArray<struct FNetMission>& _rewarded_net_missions);
	void ShowNoticePopup(const struct FLoginNotice& _packet, bool _is_auto_open);
	void ShowPlayerProfilePopup(const struct FUserID& _user_id, const struct FItemID& _emblem_id, const struct FItemID& _profilecard_id, ETier _tier, const struct FUserName& _nickname, int32 _level);
	void ShowRewardedPopup(const struct FRewardPlain& _reward_plain, bool _on_queue);
	void ShowSeasonRewardPopup(const struct FBC_SeasonReward& _season_result);
	void ShowTierUpdatePopup(const struct FBC_TierUpdate& _tier_update);
	void StopSelectionCutScene(class AFollowCameraActor* _cam);

	bool IsPlayingCutScene() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyControllerBase">();
	}
	static class ALobbyControllerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALobbyControllerBase>();
	}
};
static_assert(alignof(ALobbyControllerBase) == 0x000008, "Wrong alignment on ALobbyControllerBase");
static_assert(sizeof(ALobbyControllerBase) == 0x000B28, "Wrong size on ALobbyControllerBase");
static_assert(offsetof(ALobbyControllerBase, _UI_Class) == 0x000990, "Member 'ALobbyControllerBase::_UI_Class' has a wrong offset!");
static_assert(offsetof(ALobbyControllerBase, _UI_Lobby) == 0x000998, "Member 'ALobbyControllerBase::_UI_Lobby' has a wrong offset!");
static_assert(offsetof(ALobbyControllerBase, _SurveyUIClass) == 0x0009A0, "Member 'ALobbyControllerBase::_SurveyUIClass' has a wrong offset!");
static_assert(offsetof(ALobbyControllerBase, _SurveyWebClass) == 0x0009A8, "Member 'ALobbyControllerBase::_SurveyWebClass' has a wrong offset!");
static_assert(offsetof(ALobbyControllerBase, _SurveyWeb) == 0x0009B0, "Member 'ALobbyControllerBase::_SurveyWeb' has a wrong offset!");
static_assert(offsetof(ALobbyControllerBase, _SocialContainerUIClass) == 0x0009B8, "Member 'ALobbyControllerBase::_SocialContainerUIClass' has a wrong offset!");
static_assert(offsetof(ALobbyControllerBase, _LevelUpUIClass) == 0x0009C0, "Member 'ALobbyControllerBase::_LevelUpUIClass' has a wrong offset!");
static_assert(offsetof(ALobbyControllerBase, _HelpUIClass) == 0x0009C8, "Member 'ALobbyControllerBase::_HelpUIClass' has a wrong offset!");
static_assert(offsetof(ALobbyControllerBase, _NoticeUIClass) == 0x0009D0, "Member 'ALobbyControllerBase::_NoticeUIClass' has a wrong offset!");
static_assert(offsetof(ALobbyControllerBase, _TierPromotionUIClass) == 0x0009D8, "Member 'ALobbyControllerBase::_TierPromotionUIClass' has a wrong offset!");
static_assert(offsetof(ALobbyControllerBase, _SeasonRewardUIClass) == 0x0009E0, "Member 'ALobbyControllerBase::_SeasonRewardUIClass' has a wrong offset!");
static_assert(offsetof(ALobbyControllerBase, _CompetitionRewardUIClass) == 0x0009E8, "Member 'ALobbyControllerBase::_CompetitionRewardUIClass' has a wrong offset!");
static_assert(offsetof(ALobbyControllerBase, _RewardMissionPopupClass) == 0x0009F0, "Member 'ALobbyControllerBase::_RewardMissionPopupClass' has a wrong offset!");
static_assert(offsetof(ALobbyControllerBase, _EventPageUIClass) == 0x0009F8, "Member 'ALobbyControllerBase::_EventPageUIClass' has a wrong offset!");
static_assert(offsetof(ALobbyControllerBase, _BattlePassLevelUpUIClass) == 0x000A00, "Member 'ALobbyControllerBase::_BattlePassLevelUpUIClass' has a wrong offset!");
static_assert(offsetof(ALobbyControllerBase, _PlayerProfileUIClass) == 0x000A08, "Member 'ALobbyControllerBase::_PlayerProfileUIClass' has a wrong offset!");
static_assert(offsetof(ALobbyControllerBase, _StringTables) == 0x000A10, "Member 'ALobbyControllerBase::_StringTables' has a wrong offset!");
static_assert(offsetof(ALobbyControllerBase, WeaponMapFile) == 0x000A20, "Member 'ALobbyControllerBase::WeaponMapFile' has a wrong offset!");
static_assert(offsetof(ALobbyControllerBase, _PreviewActor) == 0x000A58, "Member 'ALobbyControllerBase::_PreviewActor' has a wrong offset!");
static_assert(offsetof(ALobbyControllerBase, _PreviewActorInitialRot) == 0x000A60, "Member 'ALobbyControllerBase::_PreviewActorInitialRot' has a wrong offset!");
static_assert(offsetof(ALobbyControllerBase, _AllowPreviewerRotationMode) == 0x000A78, "Member 'ALobbyControllerBase::_AllowPreviewerRotationMode' has a wrong offset!");
static_assert(offsetof(ALobbyControllerBase, _Level_Weapon) == 0x000A80, "Member 'ALobbyControllerBase::_Level_Weapon' has a wrong offset!");
static_assert(offsetof(ALobbyControllerBase, _KeepConnectEventDriver) == 0x000A90, "Member 'ALobbyControllerBase::_KeepConnectEventDriver' has a wrong offset!");
static_assert(offsetof(ALobbyControllerBase, _CutScenePlayer) == 0x000A98, "Member 'ALobbyControllerBase::_CutScenePlayer' has a wrong offset!");
static_assert(offsetof(ALobbyControllerBase, _LobbySelectionLevel) == 0x000AA0, "Member 'ALobbyControllerBase::_LobbySelectionLevel' has a wrong offset!");
static_assert(offsetof(ALobbyControllerBase, _LobbySelectionMapFile) == 0x000AA8, "Member 'ALobbyControllerBase::_LobbySelectionMapFile' has a wrong offset!");
static_assert(offsetof(ALobbyControllerBase, _Clone) == 0x000AD0, "Member 'ALobbyControllerBase::_Clone' has a wrong offset!");
static_assert(offsetof(ALobbyControllerBase, _CamMesh) == 0x000AD8, "Member 'ALobbyControllerBase::_CamMesh' has a wrong offset!");
static_assert(offsetof(ALobbyControllerBase, _LobbySelection_Sequencer) == 0x000AE0, "Member 'ALobbyControllerBase::_LobbySelection_Sequencer' has a wrong offset!");
static_assert(offsetof(ALobbyControllerBase, _RecruitLevelAsset) == 0x000AF8, "Member 'ALobbyControllerBase::_RecruitLevelAsset' has a wrong offset!");
static_assert(offsetof(ALobbyControllerBase, _RecruitLevel) == 0x000B20, "Member 'ALobbyControllerBase::_RecruitLevel' has a wrong offset!");

// Class Stigma.Ctrl_SocialTabEntryBase
// 0x0010 (0x0500 - 0x04F0)
class UCtrl_SocialTabEntryBase : public UPreviewableWidget
{
public:
	class USizeBox*                               EventBubbleContainer;                              // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_EventCountBubbleBase*             EventCountBubble;                                  // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool DoSelect(ESocialPopupTabType _tab_type);
	int32 GetState();
	void SetEventCount(int32 _count);
	void SetState(int32 _state);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_SocialTabEntryBase">();
	}
	static class UCtrl_SocialTabEntryBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_SocialTabEntryBase>();
	}
};
static_assert(alignof(UCtrl_SocialTabEntryBase) == 0x000008, "Wrong alignment on UCtrl_SocialTabEntryBase");
static_assert(sizeof(UCtrl_SocialTabEntryBase) == 0x000500, "Wrong size on UCtrl_SocialTabEntryBase");
static_assert(offsetof(UCtrl_SocialTabEntryBase, EventBubbleContainer) == 0x0004F0, "Member 'UCtrl_SocialTabEntryBase::EventBubbleContainer' has a wrong offset!");
static_assert(offsetof(UCtrl_SocialTabEntryBase, EventCountBubble) == 0x0004F8, "Member 'UCtrl_SocialTabEntryBase::EventCountBubble' has a wrong offset!");

// Class Stigma.UI_ListViewRewardItem
// 0x0010 (0x0500 - 0x04F0)
class UUI_ListViewRewardItem : public UPreviewableWidget
{
public:
	uint8                                         Pad_2303[0x8];                                     // 0x04F0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UUI_RewardItem*                         RewardItem;                                        // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_ListViewRewardItem">();
	}
	static class UUI_ListViewRewardItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_ListViewRewardItem>();
	}
};
static_assert(alignof(UUI_ListViewRewardItem) == 0x000008, "Wrong alignment on UUI_ListViewRewardItem");
static_assert(sizeof(UUI_ListViewRewardItem) == 0x000500, "Wrong size on UUI_ListViewRewardItem");
static_assert(offsetof(UUI_ListViewRewardItem, RewardItem) == 0x0004F8, "Member 'UUI_ListViewRewardItem::RewardItem' has a wrong offset!");

// Class Stigma.Ctrl_SocialUserSlotBase
// 0x0000 (0x04F0 - 0x04F0)
class UCtrl_SocialUserSlotBase final : public UPreviewableWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_SocialUserSlotBase">();
	}
	static class UCtrl_SocialUserSlotBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_SocialUserSlotBase>();
	}
};
static_assert(alignof(UCtrl_SocialUserSlotBase) == 0x000008, "Wrong alignment on UCtrl_SocialUserSlotBase");
static_assert(sizeof(UCtrl_SocialUserSlotBase) == 0x0004F0, "Wrong size on UCtrl_SocialUserSlotBase");

// Class Stigma.Ctrl_StatUpdate
// 0x0000 (0x04F0 - 0x04F0)
class UCtrl_StatUpdate : public UPreviewableWidget
{
public:
	void SetControlPower(int32 _cp);
	void SetControlPowerLack(int32 _cp_lack);
	void SetCustomStatValue(float _val, class UTexture2D* _Icon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_StatUpdate">();
	}
	static class UCtrl_StatUpdate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_StatUpdate>();
	}
};
static_assert(alignof(UCtrl_StatUpdate) == 0x000008, "Wrong alignment on UCtrl_StatUpdate");
static_assert(sizeof(UCtrl_StatUpdate) == 0x0004F0, "Wrong size on UCtrl_StatUpdate");

// Class Stigma.InvenItem
// 0x0168 (0x0190 - 0x0028)
class UInvenItem : public UObject
{
public:
	uint8                                         Pad_2305[0x168];                                   // 0x0028(0x0168)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UInvenItem* Create(class UObject* _outer, const struct FItemEntry& _item);

	void CopyFromItem(const class UInvenItem* _item);
	void SetSeenAtRecently();

	const TSoftObjectPtr<class UTexture2D> GetBigIcon() const;
	const struct FLinearColor GetColor() const;
	int64 GetCount() const;
	const class FText GetDescShortText() const;
	const class FText GetDescText() const;
	const class FText GetDisplayName() const;
	struct FDateTime GetExpiry() const;
	EItemGrade GetGrade() const;
	const TSoftObjectPtr<class UTexture2D> GetIcon() const;
	struct FItemID GetItemID() const;
	struct FDateTime GetLaunchingDate() const;
	struct FTimespan GetLeftOwnershipTime() const;
	EOwnType GetOwnType() const;
	bool IsOwned() const;
	bool IsPossessed() const;
	bool IsVisibleRedDot() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InvenItem">();
	}
	static class UInvenItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInvenItem>();
	}
};
static_assert(alignof(UInvenItem) == 0x000008, "Wrong alignment on UInvenItem");
static_assert(sizeof(UInvenItem) == 0x000190, "Wrong size on UInvenItem");

// Class Stigma.UserProfileRef
// 0x0010 (0x0038 - 0x0028)
class UUserProfileRef final : public UObject
{
public:
	class UUserProfile*                           _UserProfile;                                      // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUserProfileType                              _RefAs;                                            // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2306[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	class UUserProfile* GetProfile();

	EUserProfileType GetRefAs() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserProfileRef">();
	}
	static class UUserProfileRef* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserProfileRef>();
	}
};
static_assert(alignof(UUserProfileRef) == 0x000008, "Wrong alignment on UUserProfileRef");
static_assert(sizeof(UUserProfileRef) == 0x000038, "Wrong size on UUserProfileRef");
static_assert(offsetof(UUserProfileRef, _UserProfile) == 0x000028, "Member 'UUserProfileRef::_UserProfile' has a wrong offset!");
static_assert(offsetof(UUserProfileRef, _RefAs) == 0x000030, "Member 'UUserProfileRef::_RefAs' has a wrong offset!");

// Class Stigma.Ctrl_Status
// 0x04B0 (0x09A0 - 0x04F0)
class UCtrl_Status : public UPreviewableWidget
{
public:
	class UTextBlock*                             Txt_Title;                                         // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_SubTitle;                                      // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_Background;                                    // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_UV1;                                           // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_UV2;                                           // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Icon;                                          // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                Spacer_Icon;                                       // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   _Title;                                            // 0x0528(0x0018)(Edit, BlueprintVisible, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	struct FLinearColor                           _TitleColor;                                       // 0x0540(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateFontInfo                         _TitleFont;                                        // 0x0550(0x0058)(Edit, BlueprintVisible, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              _TitleShadowOffset;                                // 0x05A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _TitleShadowColor;                                 // 0x05B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _TitleIconPadding;                                 // 0x05C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2307[0x4];                                     // 0x05CC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class FText                                   _SubTitle;                                         // 0x05D0(0x0018)(Edit, BlueprintVisible, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	struct FSlateFontInfo                         _SubTitleFont;                                     // 0x05E8(0x0058)(Edit, BlueprintVisible, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _SubTitleColor;                                    // 0x0640(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _ShowBackground;                                   // 0x0650(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2308[0xF];                                     // 0x0651(0x000F)(Fixing Size After Last Property [ Dumper-69 ])
	struct FSlateBrush                            _BGBrush;                                          // 0x0660(0x00D0)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            _UV1Brush;                                         // 0x0730(0x00D0)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            _UV2Brush;                                         // 0x0800(0x00D0)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            _IconBrush;                                        // 0x08D0(0x00D0)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	void SetSubTitle(const class FText& _text);
	void SetTitle(const class FText& _text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_Status">();
	}
	static class UCtrl_Status* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_Status>();
	}
};
static_assert(alignof(UCtrl_Status) == 0x000010, "Wrong alignment on UCtrl_Status");
static_assert(sizeof(UCtrl_Status) == 0x0009A0, "Wrong size on UCtrl_Status");
static_assert(offsetof(UCtrl_Status, Txt_Title) == 0x0004F0, "Member 'UCtrl_Status::Txt_Title' has a wrong offset!");
static_assert(offsetof(UCtrl_Status, Txt_SubTitle) == 0x0004F8, "Member 'UCtrl_Status::Txt_SubTitle' has a wrong offset!");
static_assert(offsetof(UCtrl_Status, IMG_Background) == 0x000500, "Member 'UCtrl_Status::IMG_Background' has a wrong offset!");
static_assert(offsetof(UCtrl_Status, Img_UV1) == 0x000508, "Member 'UCtrl_Status::Img_UV1' has a wrong offset!");
static_assert(offsetof(UCtrl_Status, Img_UV2) == 0x000510, "Member 'UCtrl_Status::Img_UV2' has a wrong offset!");
static_assert(offsetof(UCtrl_Status, Img_Icon) == 0x000518, "Member 'UCtrl_Status::Img_Icon' has a wrong offset!");
static_assert(offsetof(UCtrl_Status, Spacer_Icon) == 0x000520, "Member 'UCtrl_Status::Spacer_Icon' has a wrong offset!");
static_assert(offsetof(UCtrl_Status, _Title) == 0x000528, "Member 'UCtrl_Status::_Title' has a wrong offset!");
static_assert(offsetof(UCtrl_Status, _TitleColor) == 0x000540, "Member 'UCtrl_Status::_TitleColor' has a wrong offset!");
static_assert(offsetof(UCtrl_Status, _TitleFont) == 0x000550, "Member 'UCtrl_Status::_TitleFont' has a wrong offset!");
static_assert(offsetof(UCtrl_Status, _TitleShadowOffset) == 0x0005A8, "Member 'UCtrl_Status::_TitleShadowOffset' has a wrong offset!");
static_assert(offsetof(UCtrl_Status, _TitleShadowColor) == 0x0005B8, "Member 'UCtrl_Status::_TitleShadowColor' has a wrong offset!");
static_assert(offsetof(UCtrl_Status, _TitleIconPadding) == 0x0005C8, "Member 'UCtrl_Status::_TitleIconPadding' has a wrong offset!");
static_assert(offsetof(UCtrl_Status, _SubTitle) == 0x0005D0, "Member 'UCtrl_Status::_SubTitle' has a wrong offset!");
static_assert(offsetof(UCtrl_Status, _SubTitleFont) == 0x0005E8, "Member 'UCtrl_Status::_SubTitleFont' has a wrong offset!");
static_assert(offsetof(UCtrl_Status, _SubTitleColor) == 0x000640, "Member 'UCtrl_Status::_SubTitleColor' has a wrong offset!");
static_assert(offsetof(UCtrl_Status, _ShowBackground) == 0x000650, "Member 'UCtrl_Status::_ShowBackground' has a wrong offset!");
static_assert(offsetof(UCtrl_Status, _BGBrush) == 0x000660, "Member 'UCtrl_Status::_BGBrush' has a wrong offset!");
static_assert(offsetof(UCtrl_Status, _UV1Brush) == 0x000730, "Member 'UCtrl_Status::_UV1Brush' has a wrong offset!");
static_assert(offsetof(UCtrl_Status, _UV2Brush) == 0x000800, "Member 'UCtrl_Status::_UV2Brush' has a wrong offset!");
static_assert(offsetof(UCtrl_Status, _IconBrush) == 0x0008D0, "Member 'UCtrl_Status::_IconBrush' has a wrong offset!");

// Class Stigma.Ctrl_TextCheckBoxBase
// 0x0068 (0x0558 - 0x04F0)
class UCtrl_TextCheckBoxBase : public UPreviewableWidget
{
public:
	class UCheckBox*                              CheckBox;                                          // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Text;                                              // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _id;                                               // 0x0500(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   _text;                                             // 0x0508(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          _IsFirstChecked;                                   // 0x0520(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2309[0x3];                                     // 0x0521(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	struct FSlateColor                            _TextColor;                                        // 0x0524(0x0014)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_230A[0x20];                                    // 0x0538(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Init(const class FName& _ctrl_id, const class FText& _ctrl_text, bool _is_checked);
	bool IsChecked();
	void OnProcCheckBoxStateChanged(bool _is_checked);
	void RegisterOnStateChange(const TDelegate<void(class UCtrl_TextCheckBoxBase* _check_box, class FName& _id, bool _is_checked)>& _callback);
	void SetCheck(bool _flag, bool _invoke_callback);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_TextCheckBoxBase">();
	}
	static class UCtrl_TextCheckBoxBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_TextCheckBoxBase>();
	}
};
static_assert(alignof(UCtrl_TextCheckBoxBase) == 0x000008, "Wrong alignment on UCtrl_TextCheckBoxBase");
static_assert(sizeof(UCtrl_TextCheckBoxBase) == 0x000558, "Wrong size on UCtrl_TextCheckBoxBase");
static_assert(offsetof(UCtrl_TextCheckBoxBase, CheckBox) == 0x0004F0, "Member 'UCtrl_TextCheckBoxBase::CheckBox' has a wrong offset!");
static_assert(offsetof(UCtrl_TextCheckBoxBase, Text) == 0x0004F8, "Member 'UCtrl_TextCheckBoxBase::Text' has a wrong offset!");
static_assert(offsetof(UCtrl_TextCheckBoxBase, _id) == 0x000500, "Member 'UCtrl_TextCheckBoxBase::_id' has a wrong offset!");
static_assert(offsetof(UCtrl_TextCheckBoxBase, _text) == 0x000508, "Member 'UCtrl_TextCheckBoxBase::_text' has a wrong offset!");
static_assert(offsetof(UCtrl_TextCheckBoxBase, _IsFirstChecked) == 0x000520, "Member 'UCtrl_TextCheckBoxBase::_IsFirstChecked' has a wrong offset!");
static_assert(offsetof(UCtrl_TextCheckBoxBase, _TextColor) == 0x000524, "Member 'UCtrl_TextCheckBoxBase::_TextColor' has a wrong offset!");

// Class Stigma.Ctrl_ToggleButton
// 0x0180 (0x0670 - 0x04F0)
class UCtrl_ToggleButton final : public UPreviewableWidget
{
public:
	class UBorder*                                Border;                                            // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               SizeBox;                                           // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_True;                                          // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_False;                                         // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Handle;                                        // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_CommonButtonBase*                 Button;                                            // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             _OnToggleChangedEvent;                             // 0x0520(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FSlateBrush                            _Brush_BG;                                         // 0x0530(0x00D0)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FMargin                                _SizeBox_Padding;                                  // 0x0600(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class FText                                   _Text_True;                                        // 0x0610(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	class FText                                   _Text_False;                                       // 0x0628(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             _HandleImage_True;                                 // 0x0640(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             _HandleImage_False;                                // 0x0648(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              _HandleImageSize;                                  // 0x0650(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _HandleSpeed;                                      // 0x0660(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _Initial_Value;                                    // 0x0664(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_230C[0xB];                                     // 0x0665(0x000B)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnButtonClicked(class UAnimatableWidget* _button_widget, bool _selected);
	void OnValueChanged(bool _value, bool _is_init);
	void SetValue(bool _value, bool _is_init);

	bool GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Ctrl_ToggleButton">();
	}
	static class UCtrl_ToggleButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCtrl_ToggleButton>();
	}
};
static_assert(alignof(UCtrl_ToggleButton) == 0x000010, "Wrong alignment on UCtrl_ToggleButton");
static_assert(sizeof(UCtrl_ToggleButton) == 0x000670, "Wrong size on UCtrl_ToggleButton");
static_assert(offsetof(UCtrl_ToggleButton, Border) == 0x0004F0, "Member 'UCtrl_ToggleButton::Border' has a wrong offset!");
static_assert(offsetof(UCtrl_ToggleButton, SizeBox) == 0x0004F8, "Member 'UCtrl_ToggleButton::SizeBox' has a wrong offset!");
static_assert(offsetof(UCtrl_ToggleButton, Txt_True) == 0x000500, "Member 'UCtrl_ToggleButton::Txt_True' has a wrong offset!");
static_assert(offsetof(UCtrl_ToggleButton, Txt_False) == 0x000508, "Member 'UCtrl_ToggleButton::Txt_False' has a wrong offset!");
static_assert(offsetof(UCtrl_ToggleButton, Img_Handle) == 0x000510, "Member 'UCtrl_ToggleButton::Img_Handle' has a wrong offset!");
static_assert(offsetof(UCtrl_ToggleButton, Button) == 0x000518, "Member 'UCtrl_ToggleButton::Button' has a wrong offset!");
static_assert(offsetof(UCtrl_ToggleButton, _OnToggleChangedEvent) == 0x000520, "Member 'UCtrl_ToggleButton::_OnToggleChangedEvent' has a wrong offset!");
static_assert(offsetof(UCtrl_ToggleButton, _Brush_BG) == 0x000530, "Member 'UCtrl_ToggleButton::_Brush_BG' has a wrong offset!");
static_assert(offsetof(UCtrl_ToggleButton, _SizeBox_Padding) == 0x000600, "Member 'UCtrl_ToggleButton::_SizeBox_Padding' has a wrong offset!");
static_assert(offsetof(UCtrl_ToggleButton, _Text_True) == 0x000610, "Member 'UCtrl_ToggleButton::_Text_True' has a wrong offset!");
static_assert(offsetof(UCtrl_ToggleButton, _Text_False) == 0x000628, "Member 'UCtrl_ToggleButton::_Text_False' has a wrong offset!");
static_assert(offsetof(UCtrl_ToggleButton, _HandleImage_True) == 0x000640, "Member 'UCtrl_ToggleButton::_HandleImage_True' has a wrong offset!");
static_assert(offsetof(UCtrl_ToggleButton, _HandleImage_False) == 0x000648, "Member 'UCtrl_ToggleButton::_HandleImage_False' has a wrong offset!");
static_assert(offsetof(UCtrl_ToggleButton, _HandleImageSize) == 0x000650, "Member 'UCtrl_ToggleButton::_HandleImageSize' has a wrong offset!");
static_assert(offsetof(UCtrl_ToggleButton, _HandleSpeed) == 0x000660, "Member 'UCtrl_ToggleButton::_HandleSpeed' has a wrong offset!");
static_assert(offsetof(UCtrl_ToggleButton, _Initial_Value) == 0x000664, "Member 'UCtrl_ToggleButton::_Initial_Value' has a wrong offset!");

// Class Stigma.CustomComboBoxString
// 0x14F0 (0x1670 - 0x0180)
class UCustomComboBoxString final : public UWidget
{
public:
	TArray<struct FOptionCustomBoxEntry>          DefaultOptions;                                    // 0x0180(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FOptionCustomBoxEntry                  SelectedOption;                                    // 0x0190(0x0018)(Edit, NativeAccessSpecifierPrivate)
	uint8                                         Pad_230E[0x8];                                     // 0x01A8(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	struct FComboBoxStyle                         WidgetStyle;                                       // 0x01B0(0x0660)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FTableRowStyle                         ItemStyle;                                         // 0x0810(0x0D50)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FMargin                                ContentPadding;                                    // 0x1560(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MaxListHeight;                                     // 0x1570(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasDownArrow;                                      // 0x1574(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnableGamepadNavigationMode;                       // 0x1575(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_230F[0x2];                                     // 0x1576(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	struct FSlateFontInfo                         Font;                                              // 0x1578(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            ForegroundColor;                                   // 0x15D0(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bIsFocusable;                                      // 0x15E4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2310[0x3];                                     // 0x15E5(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	TDelegate<void(const class FString& Item)>    OnGenerateWidgetEvent;                             // 0x15E8(0x0010)(Edit, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSelectionChanged;                                // 0x15F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOpening;                                         // 0x1608(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2311[0x58];                                    // 0x1618(0x0058)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void AddOption(const class FName _id, const class FString& _option);
	void ClearOptions();
	void ClearSelection();
	void ForceOpen();
	void OnOpeningEvent__DelegateSignature();
	void OnSelectionChangedEvent__DelegateSignature(class FName SelectedID, const class FString& SelectedItem, ESelectInfo SelectionType);
	void RefreshOptions();
	bool RemoveOption(const class FName& _id);
	void SetSelectedIndex(const int32 _index);
	void SetSelectedOption(class FName _id);

	int32 FindOptionIndex(const class FName& _id) const;
	struct FOptionCustomBoxEntry GetOptionAtIndex(int32 _index) const;
	int32 GetOptionCount() const;
	int32 GetSelectedIndex() const;
	struct FOptionCustomBoxEntry GetSelectedOption() const;
	bool IsOpen() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomComboBoxString">();
	}
	static class UCustomComboBoxString* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomComboBoxString>();
	}
};
static_assert(alignof(UCustomComboBoxString) == 0x000010, "Wrong alignment on UCustomComboBoxString");
static_assert(sizeof(UCustomComboBoxString) == 0x001670, "Wrong size on UCustomComboBoxString");
static_assert(offsetof(UCustomComboBoxString, DefaultOptions) == 0x000180, "Member 'UCustomComboBoxString::DefaultOptions' has a wrong offset!");
static_assert(offsetof(UCustomComboBoxString, SelectedOption) == 0x000190, "Member 'UCustomComboBoxString::SelectedOption' has a wrong offset!");
static_assert(offsetof(UCustomComboBoxString, WidgetStyle) == 0x0001B0, "Member 'UCustomComboBoxString::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UCustomComboBoxString, ItemStyle) == 0x000810, "Member 'UCustomComboBoxString::ItemStyle' has a wrong offset!");
static_assert(offsetof(UCustomComboBoxString, ContentPadding) == 0x001560, "Member 'UCustomComboBoxString::ContentPadding' has a wrong offset!");
static_assert(offsetof(UCustomComboBoxString, MaxListHeight) == 0x001570, "Member 'UCustomComboBoxString::MaxListHeight' has a wrong offset!");
static_assert(offsetof(UCustomComboBoxString, HasDownArrow) == 0x001574, "Member 'UCustomComboBoxString::HasDownArrow' has a wrong offset!");
static_assert(offsetof(UCustomComboBoxString, EnableGamepadNavigationMode) == 0x001575, "Member 'UCustomComboBoxString::EnableGamepadNavigationMode' has a wrong offset!");
static_assert(offsetof(UCustomComboBoxString, Font) == 0x001578, "Member 'UCustomComboBoxString::Font' has a wrong offset!");
static_assert(offsetof(UCustomComboBoxString, ForegroundColor) == 0x0015D0, "Member 'UCustomComboBoxString::ForegroundColor' has a wrong offset!");
static_assert(offsetof(UCustomComboBoxString, bIsFocusable) == 0x0015E4, "Member 'UCustomComboBoxString::bIsFocusable' has a wrong offset!");
static_assert(offsetof(UCustomComboBoxString, OnGenerateWidgetEvent) == 0x0015E8, "Member 'UCustomComboBoxString::OnGenerateWidgetEvent' has a wrong offset!");
static_assert(offsetof(UCustomComboBoxString, OnSelectionChanged) == 0x0015F8, "Member 'UCustomComboBoxString::OnSelectionChanged' has a wrong offset!");
static_assert(offsetof(UCustomComboBoxString, OnOpening) == 0x001608, "Member 'UCustomComboBoxString::OnOpening' has a wrong offset!");

// Class Stigma.Damage
// 0x0008 (0x0038 - 0x0030)
class UDamage final : public UAnimNotifyState
{
public:
	int32                                         DamageIndex;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2315[0x4];                                     // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Damage">();
	}
	static class UDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDamage>();
	}
};
static_assert(alignof(UDamage) == 0x000008, "Wrong alignment on UDamage");
static_assert(sizeof(UDamage) == 0x000038, "Wrong size on UDamage");
static_assert(offsetof(UDamage, DamageIndex) == 0x000030, "Member 'UDamage::DamageIndex' has a wrong offset!");

// Class Stigma.DeactivateLeftHandIK
// 0x0008 (0x0038 - 0x0030)
class UDeactivateLeftHandIK final : public UAnimNotifyState
{
public:
	bool                                          _ResetOnEnd;                                       // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2316[0x7];                                     // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeactivateLeftHandIK">();
	}
	static class UDeactivateLeftHandIK* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeactivateLeftHandIK>();
	}
};
static_assert(alignof(UDeactivateLeftHandIK) == 0x000008, "Wrong alignment on UDeactivateLeftHandIK");
static_assert(sizeof(UDeactivateLeftHandIK) == 0x000038, "Wrong size on UDeactivateLeftHandIK");
static_assert(offsetof(UDeactivateLeftHandIK, _ResetOnEnd) == 0x000030, "Member 'UDeactivateLeftHandIK::_ResetOnEnd' has a wrong offset!");

// Class Stigma.DecSkillCoolTimeBuff
// 0x0058 (0x0150 - 0x00F8)
class UDecSkillCoolTimeBuff : public UBuffBase
{
public:
	TArray<ECharaAction>                          ActionTypes;                                       // 0x00F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FBuffValue                             DecreasePercentage;                                // 0x0108(0x0038)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_2317[0x10];                                    // 0x0140(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DecSkillCoolTimeBuff">();
	}
	static class UDecSkillCoolTimeBuff* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDecSkillCoolTimeBuff>();
	}
};
static_assert(alignof(UDecSkillCoolTimeBuff) == 0x000008, "Wrong alignment on UDecSkillCoolTimeBuff");
static_assert(sizeof(UDecSkillCoolTimeBuff) == 0x000150, "Wrong size on UDecSkillCoolTimeBuff");
static_assert(offsetof(UDecSkillCoolTimeBuff, ActionTypes) == 0x0000F8, "Member 'UDecSkillCoolTimeBuff::ActionTypes' has a wrong offset!");
static_assert(offsetof(UDecSkillCoolTimeBuff, DecreasePercentage) == 0x000108, "Member 'UDecSkillCoolTimeBuff::DecreasePercentage' has a wrong offset!");

// Class Stigma.DLG_JoinCustomGameBase
// 0x0018 (0x0588 - 0x0570)
class UDLG_JoinCustomGameBase : public UPopupBase
{
public:
	uint8                                         Pad_2318[0x18];                                    // 0x0570(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void InvokeOnJoinCustomGameCallback(const class FString& _battle_ids);
	void RegisterOnJoinCustomGame(const TDelegate<void(const class FString& _battle_ids)>& _callback);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DLG_JoinCustomGameBase">();
	}
	static class UDLG_JoinCustomGameBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDLG_JoinCustomGameBase>();
	}
};
static_assert(alignof(UDLG_JoinCustomGameBase) == 0x000008, "Wrong alignment on UDLG_JoinCustomGameBase");
static_assert(sizeof(UDLG_JoinCustomGameBase) == 0x000588, "Wrong size on UDLG_JoinCustomGameBase");

// Class Stigma.Elevator
// 0x0118 (0x03B0 - 0x0298)
class AElevator final : public AActor
{
public:
	uint8                                         Pad_2319[0x8];                                     // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	struct FElevatorState                         State;                                             // 0x02A0(0x0002)(Edit, BlueprintVisible, Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_231A[0x2];                                     // 0x02A2(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         FloorHeight;                                       // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FloorSpeed;                                        // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DoorSpeed;                                         // 0x02AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          SupportDoor;                                       // 0x02B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DoorIsOpenedAtStarting;                            // 0x02B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          FloorIsHighAtStarting;                             // 0x02B2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_231B[0x5];                                     // 0x02B3(0x0005)(Fixing Size After Last Property [ Dumper-69 ])
	class UCurveFloat*                            FloorMoveCurve;                                    // 0x02B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            DoorMoveCurve;                                     // 0x02C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EElevatorStatus, class USoundBase*>      Sounds;                                            // 0x02C8(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UAudioComponent*                        PlayingSoundComponent;                             // 0x0318(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_231C[0x90];                                    // 0x0320(0x0090)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool OnMovingDoor(float _t);
	bool OnMovingFloor(float _height, float _t);
	void OnRep_State();
	void Operate();
	void Reset();
	void Setter_State(const struct FElevatorState& _state);

	bool IsHighFloor() const;
	bool IsLowFloor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Elevator">();
	}
	static class AElevator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AElevator>();
	}
};
static_assert(alignof(AElevator) == 0x000008, "Wrong alignment on AElevator");
static_assert(sizeof(AElevator) == 0x0003B0, "Wrong size on AElevator");
static_assert(offsetof(AElevator, State) == 0x0002A0, "Member 'AElevator::State' has a wrong offset!");
static_assert(offsetof(AElevator, FloorHeight) == 0x0002A4, "Member 'AElevator::FloorHeight' has a wrong offset!");
static_assert(offsetof(AElevator, FloorSpeed) == 0x0002A8, "Member 'AElevator::FloorSpeed' has a wrong offset!");
static_assert(offsetof(AElevator, DoorSpeed) == 0x0002AC, "Member 'AElevator::DoorSpeed' has a wrong offset!");
static_assert(offsetof(AElevator, SupportDoor) == 0x0002B0, "Member 'AElevator::SupportDoor' has a wrong offset!");
static_assert(offsetof(AElevator, DoorIsOpenedAtStarting) == 0x0002B1, "Member 'AElevator::DoorIsOpenedAtStarting' has a wrong offset!");
static_assert(offsetof(AElevator, FloorIsHighAtStarting) == 0x0002B2, "Member 'AElevator::FloorIsHighAtStarting' has a wrong offset!");
static_assert(offsetof(AElevator, FloorMoveCurve) == 0x0002B8, "Member 'AElevator::FloorMoveCurve' has a wrong offset!");
static_assert(offsetof(AElevator, DoorMoveCurve) == 0x0002C0, "Member 'AElevator::DoorMoveCurve' has a wrong offset!");
static_assert(offsetof(AElevator, Sounds) == 0x0002C8, "Member 'AElevator::Sounds' has a wrong offset!");
static_assert(offsetof(AElevator, PlayingSoundComponent) == 0x000318, "Member 'AElevator::PlayingSoundComponent' has a wrong offset!");

// Class Stigma.EnvQueryContext_GetAllPlayer
// 0x0000 (0x0028 - 0x0028)
class UEnvQueryContext_GetAllPlayer final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_GetAllPlayer">();
	}
	static class UEnvQueryContext_GetAllPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_GetAllPlayer>();
	}
};
static_assert(alignof(UEnvQueryContext_GetAllPlayer) == 0x000008, "Wrong alignment on UEnvQueryContext_GetAllPlayer");
static_assert(sizeof(UEnvQueryContext_GetAllPlayer) == 0x000028, "Wrong size on UEnvQueryContext_GetAllPlayer");

// Class Stigma.EnvQueryContext_GetTargetEnemy
// 0x0000 (0x0028 - 0x0028)
class UEnvQueryContext_GetTargetEnemy final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvQueryContext_GetTargetEnemy">();
	}
	static class UEnvQueryContext_GetTargetEnemy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvQueryContext_GetTargetEnemy>();
	}
};
static_assert(alignof(UEnvQueryContext_GetTargetEnemy) == 0x000008, "Wrong alignment on UEnvQueryContext_GetTargetEnemy");
static_assert(sizeof(UEnvQueryContext_GetTargetEnemy) == 0x000028, "Wrong size on UEnvQueryContext_GetTargetEnemy");

// Class Stigma.EQC_Target
// 0x0000 (0x0028 - 0x0028)
class UEQC_Target final : public UEnvQueryContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EQC_Target">();
	}
	static class UEQC_Target* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEQC_Target>();
	}
};
static_assert(alignof(UEQC_Target) == 0x000008, "Wrong alignment on UEQC_Target");
static_assert(sizeof(UEQC_Target) == 0x000028, "Wrong size on UEQC_Target");

// Class Stigma.EQG_Pawns
// 0x0008 (0x0058 - 0x0050)
class UEQG_Pawns final : public UEnvQueryGenerator
{
public:
	EEQG_PawnType                                 PawnType;                                          // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IncludeAIPawn;                                     // 0x0051(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_231F[0x6];                                     // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EQG_Pawns">();
	}
	static class UEQG_Pawns* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEQG_Pawns>();
	}
};
static_assert(alignof(UEQG_Pawns) == 0x000008, "Wrong alignment on UEQG_Pawns");
static_assert(sizeof(UEQG_Pawns) == 0x000058, "Wrong size on UEQG_Pawns");
static_assert(offsetof(UEQG_Pawns, PawnType) == 0x000050, "Member 'UEQG_Pawns::PawnType' has a wrong offset!");
static_assert(offsetof(UEQG_Pawns, IncludeAIPawn) == 0x000051, "Member 'UEQG_Pawns::IncludeAIPawn' has a wrong offset!");

// Class Stigma.EQG_Safes
// 0x0008 (0x0058 - 0x0050)
class UEQG_Safes final : public UEnvQueryGenerator
{
public:
	ESafeType                                     SafeType;                                          // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2320[0x7];                                     // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EQG_Safes">();
	}
	static class UEQG_Safes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEQG_Safes>();
	}
};
static_assert(alignof(UEQG_Safes) == 0x000008, "Wrong alignment on UEQG_Safes");
static_assert(sizeof(UEQG_Safes) == 0x000058, "Wrong size on UEQG_Safes");
static_assert(offsetof(UEQG_Safes, SafeType) == 0x000050, "Member 'UEQG_Safes::SafeType' has a wrong offset!");

// Class Stigma.EQT_Side
// 0x0040 (0x0238 - 0x01F8)
class UEQT_Side final : public UEnvQueryTest
{
public:
	struct FAIDataProviderIntValue                Side;                                              // 0x01F8(0x0038)(Edit, DisableEditOnInstance, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UEnvQueryContext>           Context;                                           // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EQT_Side">();
	}
	static class UEQT_Side* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEQT_Side>();
	}
};
static_assert(alignof(UEQT_Side) == 0x000008, "Wrong alignment on UEQT_Side");
static_assert(sizeof(UEQT_Side) == 0x000238, "Wrong size on UEQT_Side");
static_assert(offsetof(UEQT_Side, Side) == 0x0001F8, "Member 'UEQT_Side::Side' has a wrong offset!");
static_assert(offsetof(UEQT_Side, Context) == 0x000230, "Member 'UEQT_Side::Context' has a wrong offset!");

// Class Stigma.EventCasterSubsystem
// 0x0058 (0x0088 - 0x0030)
class UEventCasterSubsystem final : public UGameInstanceSubsystem
{
public:
	TMap<class FName, struct FEventReceivers>     _SubsMap;                                          // 0x0030(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2321[0x8];                                     // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventCasterSubsystem">();
	}
	static class UEventCasterSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventCasterSubsystem>();
	}
};
static_assert(alignof(UEventCasterSubsystem) == 0x000008, "Wrong alignment on UEventCasterSubsystem");
static_assert(sizeof(UEventCasterSubsystem) == 0x000088, "Wrong size on UEventCasterSubsystem");
static_assert(offsetof(UEventCasterSubsystem, _SubsMap) == 0x000030, "Member 'UEventCasterSubsystem::_SubsMap' has a wrong offset!");

// Class Stigma.EventCounterSubsystem
// 0x00A0 (0x00D0 - 0x0030)
class UEventCounterSubsystem final : public UGameInstanceSubsystem
{
public:
	TMap<EEventCounter, struct FEventCountEntry>  _EventCountMap;                                    // 0x0030(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2322[0x50];                                    // 0x0080(0x0050)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Subscribe(const TSet<EEventCounter>& _events, const TDelegate<void(EEventCounter _event, int32 _count)>& _proc);
	void Unsubscribe(const class UObject* _obj);

	int32 GetTotalCount(const TSet<EEventCounter>& _events) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventCounterSubsystem">();
	}
	static class UEventCounterSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEventCounterSubsystem>();
	}
};
static_assert(alignof(UEventCounterSubsystem) == 0x000008, "Wrong alignment on UEventCounterSubsystem");
static_assert(sizeof(UEventCounterSubsystem) == 0x0000D0, "Wrong size on UEventCounterSubsystem");
static_assert(offsetof(UEventCounterSubsystem, _EventCountMap) == 0x000030, "Member 'UEventCounterSubsystem::_EventCountMap' has a wrong offset!");

// Class Stigma.Gunner
// 0x0000 (0x0028 - 0x0028)
class IGunner final : public IInterface
{
public:
	struct FGunnerState GetGunnerState(bool _sub_gun);
	struct FVector GetTargetingPoint(bool _for_aiming_shot, EBodyParts _part);
	bool OnBeReady(bool _sub_gun);
	bool OnExtraJob(bool _sub_gun, int32 _extra_job_id);
	bool OnFireOneShot(bool _sub_gun, const struct FShot& _shot);
	bool OnLoadBullet(bool _sub_gun);
	bool OnLoadMagazine(bool _sub_gun);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Gunner">();
	}
	static class IGunner* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGunner>();
	}
};
static_assert(alignof(IGunner) == 0x000008, "Wrong alignment on IGunner");
static_assert(sizeof(IGunner) == 0x000028, "Wrong size on IGunner");

// Class Stigma.FlashBang
// 0x0020 (0x0880 - 0x0860)
class AFlashBang final : public ABombBase
{
public:
	uint8                                         Pad_232A[0x28];                                    // 0x0858(0x0028)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlashBang">();
	}
	static class AFlashBang* GetDefaultObj()
	{
		return GetDefaultObjImpl<AFlashBang>();
	}
};
static_assert(alignof(AFlashBang) == 0x000010, "Wrong alignment on AFlashBang");
static_assert(sizeof(AFlashBang) == 0x000880, "Wrong size on AFlashBang");

// Class Stigma.Footstep
// 0x0008 (0x0040 - 0x0038)
class UFootstep final : public UAnimNotify
{
public:
	EFootstepSide                                 Side;                                              // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_232B[0x7];                                     // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Footstep">();
	}
	static class UFootstep* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFootstep>();
	}
};
static_assert(alignof(UFootstep) == 0x000008, "Wrong alignment on UFootstep");
static_assert(sizeof(UFootstep) == 0x000040, "Wrong size on UFootstep");
static_assert(offsetof(UFootstep, Side) == 0x000038, "Member 'UFootstep::Side' has a wrong offset!");

// Class Stigma.FovSkeletalMeshComponent
// 0x0030 (0x0FD0 - 0x0FA0)
class UFovSkeletalMeshComponent final : public USkeletalMeshComponent
{
public:
	float                                         _DesiredFov;                                       // 0x0FA0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _EnableFov;                                        // 0x0FA4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_232C[0x2B];                                    // 0x0FA5(0x002B)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FovSkeletalMeshComponent">();
	}
	static class UFovSkeletalMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFovSkeletalMeshComponent>();
	}
};
static_assert(alignof(UFovSkeletalMeshComponent) == 0x000010, "Wrong alignment on UFovSkeletalMeshComponent");
static_assert(sizeof(UFovSkeletalMeshComponent) == 0x000FD0, "Wrong size on UFovSkeletalMeshComponent");
static_assert(offsetof(UFovSkeletalMeshComponent, _DesiredFov) == 0x000FA0, "Member 'UFovSkeletalMeshComponent::_DesiredFov' has a wrong offset!");
static_assert(offsetof(UFovSkeletalMeshComponent, _EnableFov) == 0x000FA4, "Member 'UFovSkeletalMeshComponent::_EnableFov' has a wrong offset!");

// Class Stigma.GhostTrailsComponent
// 0x0040 (0x00E0 - 0x00A0)
class UGhostTrailsComponent final : public UActorComponent
{
public:
	TArray<class UPoseableMeshComponent*>         _GhostPoseableMeshComponents;                      // 0x00A0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_232D[0x18];                                    // 0x00B0(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	class UMaterialInterface*                     _MaterialInterfaceGhost;                           // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGhostBody>                     _Ghosts;                                           // 0x00D0(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GhostTrailsComponent">();
	}
	static class UGhostTrailsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGhostTrailsComponent>();
	}
};
static_assert(alignof(UGhostTrailsComponent) == 0x000008, "Wrong alignment on UGhostTrailsComponent");
static_assert(sizeof(UGhostTrailsComponent) == 0x0000E0, "Wrong size on UGhostTrailsComponent");
static_assert(offsetof(UGhostTrailsComponent, _GhostPoseableMeshComponents) == 0x0000A0, "Member 'UGhostTrailsComponent::_GhostPoseableMeshComponents' has a wrong offset!");
static_assert(offsetof(UGhostTrailsComponent, _MaterialInterfaceGhost) == 0x0000C8, "Member 'UGhostTrailsComponent::_MaterialInterfaceGhost' has a wrong offset!");
static_assert(offsetof(UGhostTrailsComponent, _Ghosts) == 0x0000D0, "Member 'UGhostTrailsComponent::_Ghosts' has a wrong offset!");

// Class Stigma.GoldBox
// 0x00A8 (0x03A0 - 0x02F8)
class AGoldBox final : public AItemBoxBase
{
public:
	uint8                                         Pad_232E[0x8];                                     // 0x02F8(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UWidgetComponent*                       _WidgetComp;                                       // 0x0300(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       _MirrorWidgetComp;                                 // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _ReadyToShowLargeBoxEventName;                     // 0x0310(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGoldBoxType                                  GoldBoxType;                                       // 0x0318(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_232F[0x3];                                     // 0x0319(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         AdditionalRandomGold;                              // 0x031C(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGoldBoxConfig                         _Config;                                           // 0x0320(0x0078)(Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          _OnDelay;                                          // 0x0398(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2330[0x7];                                     // 0x0399(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void DriveWidget(float _delta);
	void OnRep_BoxType();
	void RPC_ALL_LoadConfig();
	void Setter_BoxType(EGoldBoxType _type);
	void ShowDelayParticle(bool _show);

	float GetDelayProgressRate() const;
	const struct FGoldBoxConfig GetGoldBoxConfig() const;
	EGoldBoxType GetGoldBoxType() const;
	int32 GetGoldValue() const;
	bool IsOnDelay() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GoldBox">();
	}
	static class AGoldBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGoldBox>();
	}
};
static_assert(alignof(AGoldBox) == 0x000008, "Wrong alignment on AGoldBox");
static_assert(sizeof(AGoldBox) == 0x0003A0, "Wrong size on AGoldBox");
static_assert(offsetof(AGoldBox, _WidgetComp) == 0x000300, "Member 'AGoldBox::_WidgetComp' has a wrong offset!");
static_assert(offsetof(AGoldBox, _MirrorWidgetComp) == 0x000308, "Member 'AGoldBox::_MirrorWidgetComp' has a wrong offset!");
static_assert(offsetof(AGoldBox, _ReadyToShowLargeBoxEventName) == 0x000310, "Member 'AGoldBox::_ReadyToShowLargeBoxEventName' has a wrong offset!");
static_assert(offsetof(AGoldBox, GoldBoxType) == 0x000318, "Member 'AGoldBox::GoldBoxType' has a wrong offset!");
static_assert(offsetof(AGoldBox, AdditionalRandomGold) == 0x00031C, "Member 'AGoldBox::AdditionalRandomGold' has a wrong offset!");
static_assert(offsetof(AGoldBox, _Config) == 0x000320, "Member 'AGoldBox::_Config' has a wrong offset!");
static_assert(offsetof(AGoldBox, _OnDelay) == 0x000398, "Member 'AGoldBox::_OnDelay' has a wrong offset!");

// Class Stigma.GoToWidgetDetailer
// 0x0028 (0x0050 - 0x0028)
class UGoToWidgetDetailer : public UObject
{
public:
	class UGoToWidget*                            _GoToWidget;                                       // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2331[0x10];                                    // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class FString>                         _params;                                           // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void Init(class UGoToWidget* _goto_widget, const TArray<class FString>& _detailer_params);
	void PlayDetailer(class UPreviewableWidget* _target_widget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GoToWidgetDetailer">();
	}
	static class UGoToWidgetDetailer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGoToWidgetDetailer>();
	}
};
static_assert(alignof(UGoToWidgetDetailer) == 0x000008, "Wrong alignment on UGoToWidgetDetailer");
static_assert(sizeof(UGoToWidgetDetailer) == 0x000050, "Wrong size on UGoToWidgetDetailer");
static_assert(offsetof(UGoToWidgetDetailer, _GoToWidget) == 0x000028, "Member 'UGoToWidgetDetailer::_GoToWidget' has a wrong offset!");
static_assert(offsetof(UGoToWidgetDetailer, _params) == 0x000040, "Member 'UGoToWidgetDetailer::_params' has a wrong offset!");

// Class Stigma.GravityOff
// 0x0000 (0x0030 - 0x0030)
class UGravityOff final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GravityOff">();
	}
	static class UGravityOff* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGravityOff>();
	}
};
static_assert(alignof(UGravityOff) == 0x000008, "Wrong alignment on UGravityOff");
static_assert(sizeof(UGravityOff) == 0x000030, "Wrong size on UGravityOff");

// Class Stigma.GunBase
// 0x1610 (0x1DF0 - 0x07E0)
class AGunBase : public AThrowBase
{
public:
	uint8                                         Pad_2332[0x8];                                     // 0x07E0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	struct FGunAttribute_Common                   _GunAttribute;                                     // 0x07E8(0x0024)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2333[0x4];                                     // 0x080C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FBulletTipDefine                       Config_BulletTip;                                  // 0x0810(0x0098)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	float                                         FireDelay;                                         // 0x08A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2334[0x4];                                     // 0x08AC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FGunSpec                               _GunSpec;                                          // 0x08B0(0x00D0)(Edit, BlueprintVisible, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	TMap<EGunPartsSlot, struct FGunPartsMeshes>   _GunPartsMeshStorage;                              // 0x0980(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class USceneComponent*>                _DuplicatedMeshComponents;                         // 0x09D0(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	EGunState                                     _GunState;                                         // 0x09E0(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsOwnGun;                                         // 0x09E1(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsSubGun;                                         // 0x09E2(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMagazine                              Magazine;                                          // 0x09E3(0x0001)(Edit, BlueprintVisible, Net, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2335[0x4];                                     // 0x09E4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         FireCount;                                         // 0x09E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2336[0x4];                                     // 0x09EC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FVector16>                      PoissonDistributionVectors;                        // 0x09F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UBoxComponent*                          _PickupBox;                                        // 0x0A00(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        _PlayingFireSound;                                 // 0x0A08(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2337[0x10];                                    // 0x0A10(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class UFovSkeletalMeshComponent*              _FovGunMeshPointer;                                // 0x0A20(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FConfig_GunZoom                        _Config_Zoom;                                      // 0x0A28(0x0028)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FGunEntry_Main                         _GunMainEntry;                                     // 0x0A50(0x0350)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FGunEntry_Body                         _GunBodyEntry;                                     // 0x0DA0(0x0368)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FGunEntry_Slide                        _GunSlideEntry;                                    // 0x1108(0x01E0)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FGunEntry_Magazine                     _GunMagazineEntry;                                 // 0x12E8(0x01E8)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FGunEntry_Sight                        _GunTopSightEntry;                                 // 0x14D0(0x0280)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FGunEntry_Sight                        _GunUnderSightEntry;                               // 0x1750(0x0280)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FGunEntry_Front                        _GunFrontEntry;                                    // 0x19D0(0x0280)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2338[0x8];                                     // 0x1C50(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          EnableLaserSight;                                  // 0x1C58(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2339[0x137];                                   // 0x1C59(0x0137)(Fixing Size After Last Property [ Dumper-69 ])
	class UMaterialInstanceDynamic*               _ScopeMaterial;                                    // 0x1D90(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 _ScopeRenderTarget;                                // 0x1D98(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneCaptureComponent2D*               _ScopeSceneCaptureComponent;                       // 0x1DA0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      _LaserSightLine;                                   // 0x1DA8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      _LaserSightRedDot;                                 // 0x1DB0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      _FireFX_Muzzle;                                    // 0x1DB8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      _FireFX_Muzzle_3PV;                                // 0x1DC0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      _FireFX_Ejection;                                  // 0x1DC8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      _FireFX_Ejection_3PV;                              // 0x1DD0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      _FireFX_BulletTrail;                               // 0x1DD8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      _FovLaserSightLine;                                // 0x1DE0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_233A[0x8];                                     // 0x1DE8(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	EGunFeedback ALL_FireAShot();
	void BeginFire();
	void EndFire();
	struct FMagazine GetDefaultMagazineValue();
	void MakeForUI();
	void MergeMeshes();
	bool OnFire();
	bool OnLoadBullet();
	bool OnLoadMagazine();
	void OnLoadSettings();
	void OnRep_EnableLaserSight();
	void OnRep_GunSpec();
	void OnRep_GunState();
	void RPC_SERVER_DEBUG_ChangeGunPart(const struct FItemID& _item_id, EGunPartsSlot _slot);
	struct FDamageDef SERVER_CalcDamage(ECharaAction _involving_action, float _distance_in_cm, float _apply_damage_rate);
	void SERVER_CancelLoadBullet();
	struct FMagazine SERVER_CancelLoadMagazine();
	void SERVER_EndLoadBullet();
	void SERVER_EndLoadMagazine();
	void SERVER_Reset();
	void SERVER_SetBulletTip(EBulletTip _tip_type);
	void SERVER_SetGunParts(const struct FItemID& _id, EGunPartsSlot _slot);
	void SERVER_SetGunSpec(const struct FGunSpec& _gun_spec);
	void SERVER_StartLoadBullet();
	struct FMagazine SERVER_StartLoadMagazine(const struct FMagazine& _new_mag);
	void Setter_EnableLaserSight(bool _enable);
	void Setter_GunSpec(const struct FGunSpec& _gun_spec);
	void Setter_GunState(EGunState _state);
	void SpawnBulletEjection();
	void UpdateScope();

	const struct FGunEntry_Body GetBodyConfig() const;
	EBulletEffectScaleType GetBulletEffectType() const;
	EBulletType GetBulletType() const;
	int32 GetCalculatedMagazineCapacity() const;
	int32 GetConfig_AutoFireCount() const;
	int32 GetConfig_BulletPerShot() const;
	const struct FBulletTipDefine GetConfig_BulletTip() const;
	float GetConfig_FireDelay() const;
	int32 GetConfig_MagazineCapacity() const;
	int32 GetConfig_MaxMagazine() const;
	int32 GetConfig_ProjectileCountPerBullet() const;
	float GetConfig_Range() const;
	struct FMagazine GetCurrentReloadingMagaine() const;
	EGunFeedback GetFeedback(float _tolerant_delay) const;
	int32 GetFireCount() const;
	struct FVector GetFireDirection() const;
	struct FVector GetFireLocation() const;
	const struct FGunAttribute_FireSystem GetGunAttributeFireSys() const;
	const struct FGunAttribute_Common GetGunAttributes() const;
	float GetGunControlPower() const;
	const struct FGunEntry_Main GetGunMainEntry() const;
	const struct FGunEntry_Sight GetGunSightEntry() const;
	const struct FGunEntry_Slide GetGunSlideEntry() const;
	const struct FGunSpec GetGunSpec() const;
	int32 GetLoadedBulletCount() const;
	int32 GetRemainAutoFireCount() const;
	struct FVector GetScopeLocation(bool _for_1pv, bool _with_offset) const;
	EGunState GetState() const;
	bool IsBulletLoaded() const;
	bool IsBurstFire() const;
	bool IsFullAutoFire() const;
	bool IsLoadingBullet() const;
	bool IsLoadingMagazine() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GunBase">();
	}
	static class AGunBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGunBase>();
	}
};
static_assert(alignof(AGunBase) == 0x000010, "Wrong alignment on AGunBase");
static_assert(sizeof(AGunBase) == 0x001DF0, "Wrong size on AGunBase");
static_assert(offsetof(AGunBase, _GunAttribute) == 0x0007E8, "Member 'AGunBase::_GunAttribute' has a wrong offset!");
static_assert(offsetof(AGunBase, Config_BulletTip) == 0x000810, "Member 'AGunBase::Config_BulletTip' has a wrong offset!");
static_assert(offsetof(AGunBase, FireDelay) == 0x0008A8, "Member 'AGunBase::FireDelay' has a wrong offset!");
static_assert(offsetof(AGunBase, _GunSpec) == 0x0008B0, "Member 'AGunBase::_GunSpec' has a wrong offset!");
static_assert(offsetof(AGunBase, _GunPartsMeshStorage) == 0x000980, "Member 'AGunBase::_GunPartsMeshStorage' has a wrong offset!");
static_assert(offsetof(AGunBase, _DuplicatedMeshComponents) == 0x0009D0, "Member 'AGunBase::_DuplicatedMeshComponents' has a wrong offset!");
static_assert(offsetof(AGunBase, _GunState) == 0x0009E0, "Member 'AGunBase::_GunState' has a wrong offset!");
static_assert(offsetof(AGunBase, _IsOwnGun) == 0x0009E1, "Member 'AGunBase::_IsOwnGun' has a wrong offset!");
static_assert(offsetof(AGunBase, _IsSubGun) == 0x0009E2, "Member 'AGunBase::_IsSubGun' has a wrong offset!");
static_assert(offsetof(AGunBase, Magazine) == 0x0009E3, "Member 'AGunBase::Magazine' has a wrong offset!");
static_assert(offsetof(AGunBase, FireCount) == 0x0009E8, "Member 'AGunBase::FireCount' has a wrong offset!");
static_assert(offsetof(AGunBase, PoissonDistributionVectors) == 0x0009F0, "Member 'AGunBase::PoissonDistributionVectors' has a wrong offset!");
static_assert(offsetof(AGunBase, _PickupBox) == 0x000A00, "Member 'AGunBase::_PickupBox' has a wrong offset!");
static_assert(offsetof(AGunBase, _PlayingFireSound) == 0x000A08, "Member 'AGunBase::_PlayingFireSound' has a wrong offset!");
static_assert(offsetof(AGunBase, _FovGunMeshPointer) == 0x000A20, "Member 'AGunBase::_FovGunMeshPointer' has a wrong offset!");
static_assert(offsetof(AGunBase, _Config_Zoom) == 0x000A28, "Member 'AGunBase::_Config_Zoom' has a wrong offset!");
static_assert(offsetof(AGunBase, _GunMainEntry) == 0x000A50, "Member 'AGunBase::_GunMainEntry' has a wrong offset!");
static_assert(offsetof(AGunBase, _GunBodyEntry) == 0x000DA0, "Member 'AGunBase::_GunBodyEntry' has a wrong offset!");
static_assert(offsetof(AGunBase, _GunSlideEntry) == 0x001108, "Member 'AGunBase::_GunSlideEntry' has a wrong offset!");
static_assert(offsetof(AGunBase, _GunMagazineEntry) == 0x0012E8, "Member 'AGunBase::_GunMagazineEntry' has a wrong offset!");
static_assert(offsetof(AGunBase, _GunTopSightEntry) == 0x0014D0, "Member 'AGunBase::_GunTopSightEntry' has a wrong offset!");
static_assert(offsetof(AGunBase, _GunUnderSightEntry) == 0x001750, "Member 'AGunBase::_GunUnderSightEntry' has a wrong offset!");
static_assert(offsetof(AGunBase, _GunFrontEntry) == 0x0019D0, "Member 'AGunBase::_GunFrontEntry' has a wrong offset!");
static_assert(offsetof(AGunBase, EnableLaserSight) == 0x001C58, "Member 'AGunBase::EnableLaserSight' has a wrong offset!");
static_assert(offsetof(AGunBase, _ScopeMaterial) == 0x001D90, "Member 'AGunBase::_ScopeMaterial' has a wrong offset!");
static_assert(offsetof(AGunBase, _ScopeRenderTarget) == 0x001D98, "Member 'AGunBase::_ScopeRenderTarget' has a wrong offset!");
static_assert(offsetof(AGunBase, _ScopeSceneCaptureComponent) == 0x001DA0, "Member 'AGunBase::_ScopeSceneCaptureComponent' has a wrong offset!");
static_assert(offsetof(AGunBase, _LaserSightLine) == 0x001DA8, "Member 'AGunBase::_LaserSightLine' has a wrong offset!");
static_assert(offsetof(AGunBase, _LaserSightRedDot) == 0x001DB0, "Member 'AGunBase::_LaserSightRedDot' has a wrong offset!");
static_assert(offsetof(AGunBase, _FireFX_Muzzle) == 0x001DB8, "Member 'AGunBase::_FireFX_Muzzle' has a wrong offset!");
static_assert(offsetof(AGunBase, _FireFX_Muzzle_3PV) == 0x001DC0, "Member 'AGunBase::_FireFX_Muzzle_3PV' has a wrong offset!");
static_assert(offsetof(AGunBase, _FireFX_Ejection) == 0x001DC8, "Member 'AGunBase::_FireFX_Ejection' has a wrong offset!");
static_assert(offsetof(AGunBase, _FireFX_Ejection_3PV) == 0x001DD0, "Member 'AGunBase::_FireFX_Ejection_3PV' has a wrong offset!");
static_assert(offsetof(AGunBase, _FireFX_BulletTrail) == 0x001DD8, "Member 'AGunBase::_FireFX_BulletTrail' has a wrong offset!");
static_assert(offsetof(AGunBase, _FovLaserSightLine) == 0x001DE0, "Member 'AGunBase::_FovLaserSightLine' has a wrong offset!");

// Class Stigma.UtilGunBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UUtilGunBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString GetPresetName(const struct FGunSpec& _gun_spec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilGunBlueprintLibrary">();
	}
	static class UUtilGunBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilGunBlueprintLibrary>();
	}
};
static_assert(alignof(UUtilGunBlueprintLibrary) == 0x000008, "Wrong alignment on UUtilGunBlueprintLibrary");
static_assert(sizeof(UUtilGunBlueprintLibrary) == 0x000028, "Wrong size on UUtilGunBlueprintLibrary");

// Class Stigma.HelpMenuItemData
// 0x0078 (0x00A0 - 0x0028)
class UHelpMenuItemData final : public UObject
{
public:
	class FText                                   _TitleText;                                        // 0x0028(0x0018)(Transient, Protected, NativeAccessSpecifierProtected)
	class FText                                   _OriginalTitleText;                                // 0x0040(0x0018)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2340[0x48];                                    // 0x0058(0x0048)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HelpMenuItemData">();
	}
	static class UHelpMenuItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHelpMenuItemData>();
	}
};
static_assert(alignof(UHelpMenuItemData) == 0x000008, "Wrong alignment on UHelpMenuItemData");
static_assert(sizeof(UHelpMenuItemData) == 0x0000A0, "Wrong size on UHelpMenuItemData");
static_assert(offsetof(UHelpMenuItemData, _TitleText) == 0x000028, "Member 'UHelpMenuItemData::_TitleText' has a wrong offset!");
static_assert(offsetof(UHelpMenuItemData, _OriginalTitleText) == 0x000040, "Member 'UHelpMenuItemData::_OriginalTitleText' has a wrong offset!");

// Class Stigma.HitRadar
// 0x0068 (0x0300 - 0x0298)
class AHitRadar final : public AActor
{
public:
	class USceneComponent*                        _Root;                                             // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 _SkelMesh;                                         // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneCaptureComponent2D*               _Capture;                                          // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EBones, class FName>                     _BoneMap;                                          // 0x02B0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitRadar">();
	}
	static class AHitRadar* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHitRadar>();
	}
};
static_assert(alignof(AHitRadar) == 0x000008, "Wrong alignment on AHitRadar");
static_assert(sizeof(AHitRadar) == 0x000300, "Wrong size on AHitRadar");
static_assert(offsetof(AHitRadar, _Root) == 0x000298, "Member 'AHitRadar::_Root' has a wrong offset!");
static_assert(offsetof(AHitRadar, _SkelMesh) == 0x0002A0, "Member 'AHitRadar::_SkelMesh' has a wrong offset!");
static_assert(offsetof(AHitRadar, _Capture) == 0x0002A8, "Member 'AHitRadar::_Capture' has a wrong offset!");
static_assert(offsetof(AHitRadar, _BoneMap) == 0x0002B0, "Member 'AHitRadar::_BoneMap' has a wrong offset!");

// Class Stigma.HUD_Blood
// 0x00E8 (0x05D8 - 0x04F0)
class UHUD_Blood : public UPreviewableWidget
{
public:
	class UCanvasPanel*                           CanvasPanel;                                       // 0x04F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPreviewableWidget*                     Ctrl_LowHpBlood;                                   // 0x04F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharaBase*                             _TargetChara;                                      // 0x0500(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPreviewableWidget>         _BloodWidgetClass;                                 // 0x0508(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FBloodPositionOption>           _BloodSpawnOptions;                                // 0x0510(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TMap<float, struct FBloodDesignOption>        _BloodDesignesPerHpPercent;                        // 0x0520(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2341[0x5C];                                    // 0x0570(0x005C)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         _LowHpAlertPercent;                                // 0x05CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2342[0x8];                                     // 0x05D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUD_Blood">();
	}
	static class UHUD_Blood* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUD_Blood>();
	}
};
static_assert(alignof(UHUD_Blood) == 0x000008, "Wrong alignment on UHUD_Blood");
static_assert(sizeof(UHUD_Blood) == 0x0005D8, "Wrong size on UHUD_Blood");
static_assert(offsetof(UHUD_Blood, CanvasPanel) == 0x0004F0, "Member 'UHUD_Blood::CanvasPanel' has a wrong offset!");
static_assert(offsetof(UHUD_Blood, Ctrl_LowHpBlood) == 0x0004F8, "Member 'UHUD_Blood::Ctrl_LowHpBlood' has a wrong offset!");
static_assert(offsetof(UHUD_Blood, _TargetChara) == 0x000500, "Member 'UHUD_Blood::_TargetChara' has a wrong offset!");
static_assert(offsetof(UHUD_Blood, _BloodWidgetClass) == 0x000508, "Member 'UHUD_Blood::_BloodWidgetClass' has a wrong offset!");
static_assert(offsetof(UHUD_Blood, _BloodSpawnOptions) == 0x000510, "Member 'UHUD_Blood::_BloodSpawnOptions' has a wrong offset!");
static_assert(offsetof(UHUD_Blood, _BloodDesignesPerHpPercent) == 0x000520, "Member 'UHUD_Blood::_BloodDesignesPerHpPercent' has a wrong offset!");
static_assert(offsetof(UHUD_Blood, _LowHpAlertPercent) == 0x0005CC, "Member 'UHUD_Blood::_LowHpAlertPercent' has a wrong offset!");

// Class Stigma.HUD_BoosterSlot
// 0x0088 (0x0630 - 0x05A8)
class UHUD_BoosterSlot : public UHUD_CooldownBaseSlot
{
public:
	class USizeBox*                               SB_BoosterBox;                                     // 0x05A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                Border_Key;                                        // 0x05B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           IMG_ApplyProgress;                                 // 0x05B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_Complete;                                      // 0x05C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_Lock;                                          // 0x05C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       CompleteAnimation;                                 // 0x05D0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanelSlot*                       SB_BoosterCanvasSlot;                              // 0x05D8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     _ActiveCoverMaterial;                              // 0x05E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               _ActiveCoverMaterialInst;                          // 0x05E8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _BoosterSlotIdx;                                   // 0x05F0(0x0004)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2343[0x4];                                     // 0x05F4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UBuffBase*                              _CurrentActiveBuff;                                // 0x05F8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2344[0x30];                                    // 0x0600(0x0030)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUD_BoosterSlot">();
	}
	static class UHUD_BoosterSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUD_BoosterSlot>();
	}
};
static_assert(alignof(UHUD_BoosterSlot) == 0x000008, "Wrong alignment on UHUD_BoosterSlot");
static_assert(sizeof(UHUD_BoosterSlot) == 0x000630, "Wrong size on UHUD_BoosterSlot");
static_assert(offsetof(UHUD_BoosterSlot, SB_BoosterBox) == 0x0005A8, "Member 'UHUD_BoosterSlot::SB_BoosterBox' has a wrong offset!");
static_assert(offsetof(UHUD_BoosterSlot, Border_Key) == 0x0005B0, "Member 'UHUD_BoosterSlot::Border_Key' has a wrong offset!");
static_assert(offsetof(UHUD_BoosterSlot, IMG_ApplyProgress) == 0x0005B8, "Member 'UHUD_BoosterSlot::IMG_ApplyProgress' has a wrong offset!");
static_assert(offsetof(UHUD_BoosterSlot, IMG_Complete) == 0x0005C0, "Member 'UHUD_BoosterSlot::IMG_Complete' has a wrong offset!");
static_assert(offsetof(UHUD_BoosterSlot, IMG_Lock) == 0x0005C8, "Member 'UHUD_BoosterSlot::IMG_Lock' has a wrong offset!");
static_assert(offsetof(UHUD_BoosterSlot, CompleteAnimation) == 0x0005D0, "Member 'UHUD_BoosterSlot::CompleteAnimation' has a wrong offset!");
static_assert(offsetof(UHUD_BoosterSlot, SB_BoosterCanvasSlot) == 0x0005D8, "Member 'UHUD_BoosterSlot::SB_BoosterCanvasSlot' has a wrong offset!");
static_assert(offsetof(UHUD_BoosterSlot, _ActiveCoverMaterial) == 0x0005E0, "Member 'UHUD_BoosterSlot::_ActiveCoverMaterial' has a wrong offset!");
static_assert(offsetof(UHUD_BoosterSlot, _ActiveCoverMaterialInst) == 0x0005E8, "Member 'UHUD_BoosterSlot::_ActiveCoverMaterialInst' has a wrong offset!");
static_assert(offsetof(UHUD_BoosterSlot, _BoosterSlotIdx) == 0x0005F0, "Member 'UHUD_BoosterSlot::_BoosterSlotIdx' has a wrong offset!");
static_assert(offsetof(UHUD_BoosterSlot, _CurrentActiveBuff) == 0x0005F8, "Member 'UHUD_BoosterSlot::_CurrentActiveBuff' has a wrong offset!");

// Class Stigma.HUD_CartridgeSlot
// 0x0048 (0x0538 - 0x04F0)
class UHUD_CartridgeSlot : public UPreviewableWidget
{
public:
	class ACharaBase*                             _TargetChara;                                      // 0x04F0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CartridgePanel;                                    // 0x04F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_Frame;                                         // 0x0500(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               _BulletsMaterial;                                  // 0x0508(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _BulletSpeedCurve;                                 // 0x0510(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2345[0x20];                                    // 0x0518(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void BindTargetChara(class ACharaBase* _chara);
	TSubclassOf<class UHUD_FlyBullet> GetFlyBulletClassType();
	void SetBulletCount(int32 _count, int32 _max_count);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUD_CartridgeSlot">();
	}
	static class UHUD_CartridgeSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUD_CartridgeSlot>();
	}
};
static_assert(alignof(UHUD_CartridgeSlot) == 0x000008, "Wrong alignment on UHUD_CartridgeSlot");
static_assert(sizeof(UHUD_CartridgeSlot) == 0x000538, "Wrong size on UHUD_CartridgeSlot");
static_assert(offsetof(UHUD_CartridgeSlot, _TargetChara) == 0x0004F0, "Member 'UHUD_CartridgeSlot::_TargetChara' has a wrong offset!");
static_assert(offsetof(UHUD_CartridgeSlot, CartridgePanel) == 0x0004F8, "Member 'UHUD_CartridgeSlot::CartridgePanel' has a wrong offset!");
static_assert(offsetof(UHUD_CartridgeSlot, IMG_Frame) == 0x000500, "Member 'UHUD_CartridgeSlot::IMG_Frame' has a wrong offset!");
static_assert(offsetof(UHUD_CartridgeSlot, _BulletsMaterial) == 0x000508, "Member 'UHUD_CartridgeSlot::_BulletsMaterial' has a wrong offset!");
static_assert(offsetof(UHUD_CartridgeSlot, _BulletSpeedCurve) == 0x000510, "Member 'UHUD_CartridgeSlot::_BulletSpeedCurve' has a wrong offset!");

// Class Stigma.HUD_CommonBase
// 0x0008 (0x04F8 - 0x04F0)
class UHUD_CommonBase : public UPreviewableWidget
{
public:
	class UUI_HUDMode*                            _HUDMode;                                          // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool OnBind();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUD_CommonBase">();
	}
	static class UHUD_CommonBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUD_CommonBase>();
	}
};
static_assert(alignof(UHUD_CommonBase) == 0x000008, "Wrong alignment on UHUD_CommonBase");
static_assert(sizeof(UHUD_CommonBase) == 0x0004F8, "Wrong size on UHUD_CommonBase");
static_assert(offsetof(UHUD_CommonBase, _HUDMode) == 0x0004F0, "Member 'UHUD_CommonBase::_HUDMode' has a wrong offset!");

// Class Stigma.HUD_GunPanel
// 0x0160 (0x0650 - 0x04F0)
class UHUD_GunPanel : public UPreviewableWidget
{
public:
	class ACharaBase*                             _TargetChara;                                      // 0x04F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           Gun_Left_Panel;                                    // 0x04F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           Gun_Right_Panel;                                   // 0x0500(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           GunName_Left_Panel;                                // 0x0508(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           GunName_Right_Panel;                               // 0x0510(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_GunNameLine;                                   // 0x0518(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_GunNameBg_Frame;                               // 0x0520(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_GunNameBg_Sub;                                 // 0x0528(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_GunNameBg_Sub_Right;                           // 0x0530(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEditableTextBox*                       TB_GunName_Left;                                   // 0x0538(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_GunNameBg_Main;                                // 0x0540(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_GunNameBg_Main_Right;                          // 0x0548(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEditableTextBox*                       TB_GunName_Right;                                  // 0x0550(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_TotalBulletCount;                              // 0x0558(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Bullet_Loaded_Left;                            // 0x0560(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Bullet_Max_Left;                               // 0x0568(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Bullet_Loaded_Right;                           // 0x0570(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Bullet_Max_Right;                              // 0x0578(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_LackControlPower*                   WIDGET_LackCP_Left;                                // 0x0580(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_LackControlPower*                   WIDGET_LackCP_Right;                               // 0x0588(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHUD_CartridgeSlot*                     HUD_Cartridge_Left;                                // 0x0590(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHUD_CartridgeSlot*                     HUD_Cartridge_Right;                               // 0x0598(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2346[0x20];                                    // 0x05A0(0x0020)(Fixing Size After Last Property [ Dumper-69 ])
	class UHUD_CartridgeSlot*                     _CartridgeMain;                                    // 0x05C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UHUD_CartridgeSlot*                     _CartridgeSub;                                     // 0x05C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _TXT_LoadedBulletCountMain;                        // 0x05D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _TXT_LoadedBulletCountSub;                         // 0x05D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _TXT_MaxBulletCountMain;                           // 0x05E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UTextBlock*                             _TXT_MaxBulletCountSub;                            // 0x05E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEditableTextBox*                       _TB_GunNameMain;                                   // 0x05F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEditableTextBox*                       _TB_GunNameSub;                                    // 0x05F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUI_LackControlPower*                   _LackControlPowerMain;                             // 0x0600(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUI_LackControlPower*                   _LackControlPowerSub;                              // 0x0608(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2347[0x28];                                    // 0x0610(0x0028)(Fixing Size After Last Property [ Dumper-69 ])
	struct FLinearColor                           _NotOwnedColor;                                    // 0x0638(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2348[0x8];                                     // 0x0648(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUD_GunPanel">();
	}
	static class UHUD_GunPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUD_GunPanel>();
	}
};
static_assert(alignof(UHUD_GunPanel) == 0x000008, "Wrong alignment on UHUD_GunPanel");
static_assert(sizeof(UHUD_GunPanel) == 0x000650, "Wrong size on UHUD_GunPanel");
static_assert(offsetof(UHUD_GunPanel, _TargetChara) == 0x0004F0, "Member 'UHUD_GunPanel::_TargetChara' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, Gun_Left_Panel) == 0x0004F8, "Member 'UHUD_GunPanel::Gun_Left_Panel' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, Gun_Right_Panel) == 0x000500, "Member 'UHUD_GunPanel::Gun_Right_Panel' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, GunName_Left_Panel) == 0x000508, "Member 'UHUD_GunPanel::GunName_Left_Panel' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, GunName_Right_Panel) == 0x000510, "Member 'UHUD_GunPanel::GunName_Right_Panel' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, IMG_GunNameLine) == 0x000518, "Member 'UHUD_GunPanel::IMG_GunNameLine' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, IMG_GunNameBg_Frame) == 0x000520, "Member 'UHUD_GunPanel::IMG_GunNameBg_Frame' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, IMG_GunNameBg_Sub) == 0x000528, "Member 'UHUD_GunPanel::IMG_GunNameBg_Sub' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, IMG_GunNameBg_Sub_Right) == 0x000530, "Member 'UHUD_GunPanel::IMG_GunNameBg_Sub_Right' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, TB_GunName_Left) == 0x000538, "Member 'UHUD_GunPanel::TB_GunName_Left' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, IMG_GunNameBg_Main) == 0x000540, "Member 'UHUD_GunPanel::IMG_GunNameBg_Main' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, IMG_GunNameBg_Main_Right) == 0x000548, "Member 'UHUD_GunPanel::IMG_GunNameBg_Main_Right' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, TB_GunName_Right) == 0x000550, "Member 'UHUD_GunPanel::TB_GunName_Right' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, TXT_TotalBulletCount) == 0x000558, "Member 'UHUD_GunPanel::TXT_TotalBulletCount' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, TXT_Bullet_Loaded_Left) == 0x000560, "Member 'UHUD_GunPanel::TXT_Bullet_Loaded_Left' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, TXT_Bullet_Max_Left) == 0x000568, "Member 'UHUD_GunPanel::TXT_Bullet_Max_Left' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, TXT_Bullet_Loaded_Right) == 0x000570, "Member 'UHUD_GunPanel::TXT_Bullet_Loaded_Right' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, TXT_Bullet_Max_Right) == 0x000578, "Member 'UHUD_GunPanel::TXT_Bullet_Max_Right' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, WIDGET_LackCP_Left) == 0x000580, "Member 'UHUD_GunPanel::WIDGET_LackCP_Left' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, WIDGET_LackCP_Right) == 0x000588, "Member 'UHUD_GunPanel::WIDGET_LackCP_Right' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, HUD_Cartridge_Left) == 0x000590, "Member 'UHUD_GunPanel::HUD_Cartridge_Left' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, HUD_Cartridge_Right) == 0x000598, "Member 'UHUD_GunPanel::HUD_Cartridge_Right' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, _CartridgeMain) == 0x0005C0, "Member 'UHUD_GunPanel::_CartridgeMain' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, _CartridgeSub) == 0x0005C8, "Member 'UHUD_GunPanel::_CartridgeSub' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, _TXT_LoadedBulletCountMain) == 0x0005D0, "Member 'UHUD_GunPanel::_TXT_LoadedBulletCountMain' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, _TXT_LoadedBulletCountSub) == 0x0005D8, "Member 'UHUD_GunPanel::_TXT_LoadedBulletCountSub' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, _TXT_MaxBulletCountMain) == 0x0005E0, "Member 'UHUD_GunPanel::_TXT_MaxBulletCountMain' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, _TXT_MaxBulletCountSub) == 0x0005E8, "Member 'UHUD_GunPanel::_TXT_MaxBulletCountSub' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, _TB_GunNameMain) == 0x0005F0, "Member 'UHUD_GunPanel::_TB_GunNameMain' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, _TB_GunNameSub) == 0x0005F8, "Member 'UHUD_GunPanel::_TB_GunNameSub' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, _LackControlPowerMain) == 0x000600, "Member 'UHUD_GunPanel::_LackControlPowerMain' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, _LackControlPowerSub) == 0x000608, "Member 'UHUD_GunPanel::_LackControlPowerSub' has a wrong offset!");
static_assert(offsetof(UHUD_GunPanel, _NotOwnedColor) == 0x000638, "Member 'UHUD_GunPanel::_NotOwnedColor' has a wrong offset!");

// Class Stigma.HUD_KillAssistTag
// 0x0010 (0x0500 - 0x04F0)
class UHUD_KillAssistTag : public UPreviewableWidget
{
public:
	uint8                                         Pad_2349[0x4];                                     // 0x04F0(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         _LifeTime;                                         // 0x04F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_234A[0x8];                                     // 0x04F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void UpdateTagCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUD_KillAssistTag">();
	}
	static class UHUD_KillAssistTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUD_KillAssistTag>();
	}
};
static_assert(alignof(UHUD_KillAssistTag) == 0x000008, "Wrong alignment on UHUD_KillAssistTag");
static_assert(sizeof(UHUD_KillAssistTag) == 0x000500, "Wrong size on UHUD_KillAssistTag");
static_assert(offsetof(UHUD_KillAssistTag, _LifeTime) == 0x0004F4, "Member 'UHUD_KillAssistTag::_LifeTime' has a wrong offset!");

// Class Stigma.HUD_KillerInfoCard
// 0x0040 (0x0530 - 0x04F0)
class UHUD_KillerInfoCard : public UPreviewableWidget
{
public:
	class UImage*                                 IMG_Chara;                                         // 0x04F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_TierIcon;                                      // 0x04F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_TierText;                                      // 0x0500(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_KillerName;                                    // 0x0508(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_MyKillCount;                                   // 0x0510(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_KillerKillCount;                               // 0x0518(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _ExposureTime;                                     // 0x0520(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_234B[0xC];                                     // 0x0524(0x000C)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUD_KillerInfoCard">();
	}
	static class UHUD_KillerInfoCard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUD_KillerInfoCard>();
	}
};
static_assert(alignof(UHUD_KillerInfoCard) == 0x000008, "Wrong alignment on UHUD_KillerInfoCard");
static_assert(sizeof(UHUD_KillerInfoCard) == 0x000530, "Wrong size on UHUD_KillerInfoCard");
static_assert(offsetof(UHUD_KillerInfoCard, IMG_Chara) == 0x0004F0, "Member 'UHUD_KillerInfoCard::IMG_Chara' has a wrong offset!");
static_assert(offsetof(UHUD_KillerInfoCard, IMG_TierIcon) == 0x0004F8, "Member 'UHUD_KillerInfoCard::IMG_TierIcon' has a wrong offset!");
static_assert(offsetof(UHUD_KillerInfoCard, IMG_TierText) == 0x000500, "Member 'UHUD_KillerInfoCard::IMG_TierText' has a wrong offset!");
static_assert(offsetof(UHUD_KillerInfoCard, TXT_KillerName) == 0x000508, "Member 'UHUD_KillerInfoCard::TXT_KillerName' has a wrong offset!");
static_assert(offsetof(UHUD_KillerInfoCard, TXT_MyKillCount) == 0x000510, "Member 'UHUD_KillerInfoCard::TXT_MyKillCount' has a wrong offset!");
static_assert(offsetof(UHUD_KillerInfoCard, TXT_KillerKillCount) == 0x000518, "Member 'UHUD_KillerInfoCard::TXT_KillerKillCount' has a wrong offset!");
static_assert(offsetof(UHUD_KillerInfoCard, _ExposureTime) == 0x000520, "Member 'UHUD_KillerInfoCard::_ExposureTime' has a wrong offset!");

// Class Stigma.HUD_KillLogSlot
// 0x00F8 (0x05E8 - 0x04F0)
class UHUD_KillLogSlot : public UPreviewableWidget
{
public:
	class UCanvasPanel*                           AssisterPanel;                                     // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           KillerPanel;                                       // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           VictimPanel;                                       // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           HeadShotPanel;                                     // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 AssisterImage;                                     // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 KillerImage;                                       // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 KillerImageFrame;                                  // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 VictimImageFrame;                                  // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 AssisterImageFrame;                                // 0x0530(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 VictimImage;                                       // 0x0538(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 WeaponImage;                                       // 0x0540(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 KillerBackGroundImage;                             // 0x0548(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 VictimBackGroundImage;                             // 0x0550(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 AssistBackGroundImage;                             // 0x0558(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             VictimNickName;                                    // 0x0560(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             KillerNickName;                                    // 0x0568(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       StartAnimation;                                    // 0x0570(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       EndAnimation;                                      // 0x0578(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EKillLogType                                  KillLogType;                                       // 0x0580(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_234C[0x7];                                     // 0x0581(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UTexture2D*                             ReviveIcon;                                        // 0x0588(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EBountyActionType, struct FBountyActionLogAsset> BountyActionAssets;                                // 0x0590(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_234D[0x8];                                     // 0x05E0(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnEndRemoveAnimation();
	void SetActionLog_Bounty(const struct FActionLog_Bounty& _bounty_action_log);
	void SetKillLog(const struct FKillLog& _kill_log);
	void SetKillLog_Revive(const struct FKillLog_ForRevive& _kill_log_revive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUD_KillLogSlot">();
	}
	static class UHUD_KillLogSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUD_KillLogSlot>();
	}
};
static_assert(alignof(UHUD_KillLogSlot) == 0x000008, "Wrong alignment on UHUD_KillLogSlot");
static_assert(sizeof(UHUD_KillLogSlot) == 0x0005E8, "Wrong size on UHUD_KillLogSlot");
static_assert(offsetof(UHUD_KillLogSlot, AssisterPanel) == 0x0004F0, "Member 'UHUD_KillLogSlot::AssisterPanel' has a wrong offset!");
static_assert(offsetof(UHUD_KillLogSlot, KillerPanel) == 0x0004F8, "Member 'UHUD_KillLogSlot::KillerPanel' has a wrong offset!");
static_assert(offsetof(UHUD_KillLogSlot, VictimPanel) == 0x000500, "Member 'UHUD_KillLogSlot::VictimPanel' has a wrong offset!");
static_assert(offsetof(UHUD_KillLogSlot, HeadShotPanel) == 0x000508, "Member 'UHUD_KillLogSlot::HeadShotPanel' has a wrong offset!");
static_assert(offsetof(UHUD_KillLogSlot, AssisterImage) == 0x000510, "Member 'UHUD_KillLogSlot::AssisterImage' has a wrong offset!");
static_assert(offsetof(UHUD_KillLogSlot, KillerImage) == 0x000518, "Member 'UHUD_KillLogSlot::KillerImage' has a wrong offset!");
static_assert(offsetof(UHUD_KillLogSlot, KillerImageFrame) == 0x000520, "Member 'UHUD_KillLogSlot::KillerImageFrame' has a wrong offset!");
static_assert(offsetof(UHUD_KillLogSlot, VictimImageFrame) == 0x000528, "Member 'UHUD_KillLogSlot::VictimImageFrame' has a wrong offset!");
static_assert(offsetof(UHUD_KillLogSlot, AssisterImageFrame) == 0x000530, "Member 'UHUD_KillLogSlot::AssisterImageFrame' has a wrong offset!");
static_assert(offsetof(UHUD_KillLogSlot, VictimImage) == 0x000538, "Member 'UHUD_KillLogSlot::VictimImage' has a wrong offset!");
static_assert(offsetof(UHUD_KillLogSlot, WeaponImage) == 0x000540, "Member 'UHUD_KillLogSlot::WeaponImage' has a wrong offset!");
static_assert(offsetof(UHUD_KillLogSlot, KillerBackGroundImage) == 0x000548, "Member 'UHUD_KillLogSlot::KillerBackGroundImage' has a wrong offset!");
static_assert(offsetof(UHUD_KillLogSlot, VictimBackGroundImage) == 0x000550, "Member 'UHUD_KillLogSlot::VictimBackGroundImage' has a wrong offset!");
static_assert(offsetof(UHUD_KillLogSlot, AssistBackGroundImage) == 0x000558, "Member 'UHUD_KillLogSlot::AssistBackGroundImage' has a wrong offset!");
static_assert(offsetof(UHUD_KillLogSlot, VictimNickName) == 0x000560, "Member 'UHUD_KillLogSlot::VictimNickName' has a wrong offset!");
static_assert(offsetof(UHUD_KillLogSlot, KillerNickName) == 0x000568, "Member 'UHUD_KillLogSlot::KillerNickName' has a wrong offset!");
static_assert(offsetof(UHUD_KillLogSlot, StartAnimation) == 0x000570, "Member 'UHUD_KillLogSlot::StartAnimation' has a wrong offset!");
static_assert(offsetof(UHUD_KillLogSlot, EndAnimation) == 0x000578, "Member 'UHUD_KillLogSlot::EndAnimation' has a wrong offset!");
static_assert(offsetof(UHUD_KillLogSlot, KillLogType) == 0x000580, "Member 'UHUD_KillLogSlot::KillLogType' has a wrong offset!");
static_assert(offsetof(UHUD_KillLogSlot, ReviveIcon) == 0x000588, "Member 'UHUD_KillLogSlot::ReviveIcon' has a wrong offset!");
static_assert(offsetof(UHUD_KillLogSlot, BountyActionAssets) == 0x000590, "Member 'UHUD_KillLogSlot::BountyActionAssets' has a wrong offset!");

// Class Stigma.HUD_ScopePanel
// 0x0020 (0x0510 - 0x04F0)
class UHUD_ScopePanel : public UPreviewableWidget
{
public:
	class UCanvasPanel*                           CP_Scope;                                          // 0x04F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharaBase*                             _TargetChara;                                      // 0x04F8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHUD_ScopeWidgetBase*                   _ScopeWidget;                                      // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_234E[0x8];                                     // 0x0508(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUD_ScopePanel">();
	}
	static class UHUD_ScopePanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUD_ScopePanel>();
	}
};
static_assert(alignof(UHUD_ScopePanel) == 0x000008, "Wrong alignment on UHUD_ScopePanel");
static_assert(sizeof(UHUD_ScopePanel) == 0x000510, "Wrong size on UHUD_ScopePanel");
static_assert(offsetof(UHUD_ScopePanel, CP_Scope) == 0x0004F0, "Member 'UHUD_ScopePanel::CP_Scope' has a wrong offset!");
static_assert(offsetof(UHUD_ScopePanel, _TargetChara) == 0x0004F8, "Member 'UHUD_ScopePanel::_TargetChara' has a wrong offset!");
static_assert(offsetof(UHUD_ScopePanel, _ScopeWidget) == 0x000500, "Member 'UHUD_ScopePanel::_ScopeWidget' has a wrong offset!");

// Class Stigma.HUD_SkillSlot
// 0x0048 (0x05F0 - 0x05A8)
class UHUD_SkillSlot : public UHUD_CooldownBaseSlot
{
public:
	class UCanvasPanel*                           MainPanel;                                         // 0x05A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                IMG_KeyBackground;                                 // 0x05B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_FullGauge;                                     // 0x05B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_StockCount;                                    // 0x05C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECharaAction                                  _SkillSlot;                                        // 0x05C8(0x0001)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_234F[0x7];                                     // 0x05C9(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UActionGraph*                           _ActionGraph;                                      // 0x05D0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2350[0x18];                                    // 0x05D8(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUD_SkillSlot">();
	}
	static class UHUD_SkillSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUD_SkillSlot>();
	}
};
static_assert(alignof(UHUD_SkillSlot) == 0x000008, "Wrong alignment on UHUD_SkillSlot");
static_assert(sizeof(UHUD_SkillSlot) == 0x0005F0, "Wrong size on UHUD_SkillSlot");
static_assert(offsetof(UHUD_SkillSlot, MainPanel) == 0x0005A8, "Member 'UHUD_SkillSlot::MainPanel' has a wrong offset!");
static_assert(offsetof(UHUD_SkillSlot, IMG_KeyBackground) == 0x0005B0, "Member 'UHUD_SkillSlot::IMG_KeyBackground' has a wrong offset!");
static_assert(offsetof(UHUD_SkillSlot, IMG_FullGauge) == 0x0005B8, "Member 'UHUD_SkillSlot::IMG_FullGauge' has a wrong offset!");
static_assert(offsetof(UHUD_SkillSlot, TXT_StockCount) == 0x0005C0, "Member 'UHUD_SkillSlot::TXT_StockCount' has a wrong offset!");
static_assert(offsetof(UHUD_SkillSlot, _SkillSlot) == 0x0005C8, "Member 'UHUD_SkillSlot::_SkillSlot' has a wrong offset!");
static_assert(offsetof(UHUD_SkillSlot, _ActionGraph) == 0x0005D0, "Member 'UHUD_SkillSlot::_ActionGraph' has a wrong offset!");

// Class Stigma.HUD_TeamMembers
// 0x0070 (0x0560 - 0x04F0)
class UHUD_TeamMembers : public UPreviewableWidget
{
public:
	ETeams                                        _Team;                                             // 0x04F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2351[0x7];                                     // 0x04F1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class ABattlePlayerState*                     _MyPlayerState;                                    // 0x04F8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class ABattlePlayerState*, class UHUD_PlayerSlot*> _PlayerSlotMap;                                    // 0x0500(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UHUD_PlayerSlot*>                _FreeWidgets;                                      // 0x0550(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void AssignTeamByOffset(int32 _offset, int32 _max_team);
	void OnChangeTeam(ETeams _new_team);
	void OnGetAllPlayerWidgets(TArray<class UHUD_PlayerSlot*>* _out_widgets);
	void SetTeam(ETeams _new_team);

	ETeams GetTeam() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUD_TeamMembers">();
	}
	static class UHUD_TeamMembers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUD_TeamMembers>();
	}
};
static_assert(alignof(UHUD_TeamMembers) == 0x000008, "Wrong alignment on UHUD_TeamMembers");
static_assert(sizeof(UHUD_TeamMembers) == 0x000560, "Wrong size on UHUD_TeamMembers");
static_assert(offsetof(UHUD_TeamMembers, _Team) == 0x0004F0, "Member 'UHUD_TeamMembers::_Team' has a wrong offset!");
static_assert(offsetof(UHUD_TeamMembers, _MyPlayerState) == 0x0004F8, "Member 'UHUD_TeamMembers::_MyPlayerState' has a wrong offset!");
static_assert(offsetof(UHUD_TeamMembers, _PlayerSlotMap) == 0x000500, "Member 'UHUD_TeamMembers::_PlayerSlotMap' has a wrong offset!");
static_assert(offsetof(UHUD_TeamMembers, _FreeWidgets) == 0x000550, "Member 'UHUD_TeamMembers::_FreeWidgets' has a wrong offset!");

// Class Stigma.HUD_TeamScorePanel
// 0x0010 (0x0508 - 0x04F8)
class UHUD_TeamScorePanel : public UHUD_CommonBase
{
public:
	TArray<class APlayerState*>                   _LastPlayerArray;                                  // 0x04F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void OnChangedPlayers();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HUD_TeamScorePanel">();
	}
	static class UHUD_TeamScorePanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHUD_TeamScorePanel>();
	}
};
static_assert(alignof(UHUD_TeamScorePanel) == 0x000008, "Wrong alignment on UHUD_TeamScorePanel");
static_assert(sizeof(UHUD_TeamScorePanel) == 0x000508, "Wrong size on UHUD_TeamScorePanel");
static_assert(offsetof(UHUD_TeamScorePanel, _LastPlayerArray) == 0x0004F8, "Member 'UHUD_TeamScorePanel::_LastPlayerArray' has a wrong offset!");

// Class Stigma.Interactable
// 0x0000 (0x0028 - 0x0028)
class IInteractable final : public IInterface
{
public:
	bool OnALL_Interact(class ACharaBase* _involver, bool _key_pressed, bool Success, int32 _param);
	bool OnFocus(class ACharaBase* _involver, bool _focus, int32 _param);
	bool OnQueryInteractable(class ACharaBase* _involver, const struct FHitResult& _hit, struct FInteractionData* _out_data);
	bool OnQueryInteractionDetail(class ACharaBase* _involver, int32 _param, struct FInteractionDetail* _out_detail);
	struct FInteractionPoint OnQueryInteractionPoint(class ACharaBase* _involver);
	int32 OnQueryPriority(class ACharaBase* _involver);
	bool OnSERVER_Interact(class ACharaBase* _involver, bool _key_pressed, int32 _param);

	class ACharaBase* GetInteractingChara() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Interactable">();
	}
	static class IInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInteractable>();
	}
};
static_assert(alignof(IInteractable) == 0x000008, "Wrong alignment on IInteractable");
static_assert(sizeof(IInteractable) == 0x000028, "Wrong size on IInteractable");

// Class Stigma.ItemIDBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UItemIDBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static int32 Conv_ItemIdToInteger(const struct FItemID& _id);
	static EItemCategory GetCategory(const struct FItemID& _id);
	static EItemCategory GetCategoryByItemID(const struct FItemID& _id);
	static int32 GetSerialNumber(const struct FItemID& _id);
	static int32 GetSubCategoryByItemID(const struct FItemID& _id);
	static bool IsEqualItemID(const struct FItemID& _id1, const struct FItemID& _id2);
	static bool IsValidItemCategories(EItemCategory _category, int32 _sub_category);
	static bool IsValidItemID(const struct FItemID& _id);
	static struct FItemID MakeItemID(int32 _id);
	static struct FItemID MakeItemIDByCategories(EItemCategory _main_category, int32 _sub_category, int32 _serial_number);
	static int32 ToInt(const struct FItemID& _id);
	static class FString ToString(const struct FItemID& _id);
	static class FText ToText(const struct FItemID& _id);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemIDBlueprintLibrary">();
	}
	static class UItemIDBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemIDBlueprintLibrary>();
	}
};
static_assert(alignof(UItemIDBlueprintLibrary) == 0x000008, "Wrong alignment on UItemIDBlueprintLibrary");
static_assert(sizeof(UItemIDBlueprintLibrary) == 0x000028, "Wrong size on UItemIDBlueprintLibrary");

// Class Stigma.ItemObject
// 0x0140 (0x0168 - 0x0028)
class UItemObject final : public UObject
{
public:
	struct FItemID                                ItemID;                                            // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemEntry                             Define;                                            // 0x0038(0x0130)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)

public:
	int32 GetLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemObject">();
	}
	static class UItemObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemObject>();
	}
};
static_assert(alignof(UItemObject) == 0x000008, "Wrong alignment on UItemObject");
static_assert(sizeof(UItemObject) == 0x000168, "Wrong size on UItemObject");
static_assert(offsetof(UItemObject, ItemID) == 0x000028, "Member 'UItemObject::ItemID' has a wrong offset!");
static_assert(offsetof(UItemObject, Define) == 0x000038, "Member 'UItemObject::Define' has a wrong offset!");

// Class Stigma.InvenItem_Currency
// 0x0000 (0x0190 - 0x0190)
class UInvenItem_Currency final : public UInvenItem
{
public:
	ECurrencyTypes GetCurrencyType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InvenItem_Currency">();
	}
	static class UInvenItem_Currency* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInvenItem_Currency>();
	}
};
static_assert(alignof(UInvenItem_Currency) == 0x000008, "Wrong alignment on UInvenItem_Currency");
static_assert(sizeof(UInvenItem_Currency) == 0x000190, "Wrong size on UInvenItem_Currency");

// Class Stigma.KeepConnectEventDriver
// 0x0008 (0x00A8 - 0x00A0)
class UKeepConnectEventDriver final : public UActorComponent
{
public:
	uint8                                         Pad_2368[0x8];                                     // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KeepConnectEventDriver">();
	}
	static class UKeepConnectEventDriver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKeepConnectEventDriver>();
	}
};
static_assert(alignof(UKeepConnectEventDriver) == 0x000008, "Wrong alignment on UKeepConnectEventDriver");
static_assert(sizeof(UKeepConnectEventDriver) == 0x0000A8, "Wrong size on UKeepConnectEventDriver");

// Class Stigma.KeyInputBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UKeyInputBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FName GetKeyFName(const struct FKey& _Key);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KeyInputBlueprintLibrary">();
	}
	static class UKeyInputBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKeyInputBlueprintLibrary>();
	}
};
static_assert(alignof(UKeyInputBlueprintLibrary) == 0x000008, "Wrong alignment on UKeyInputBlueprintLibrary");
static_assert(sizeof(UKeyInputBlueprintLibrary) == 0x000028, "Wrong size on UKeyInputBlueprintLibrary");

// Class Stigma.KnifeBase
// 0x0000 (0x07E0 - 0x07E0)
class AKnifeBase final : public AThrowBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KnifeBase">();
	}
	static class AKnifeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AKnifeBase>();
	}
};
static_assert(alignof(AKnifeBase) == 0x000010, "Wrong alignment on AKnifeBase");
static_assert(sizeof(AKnifeBase) == 0x0007E0, "Wrong size on AKnifeBase");

// Class Stigma.LobbyCamera
// 0x0048 (0x02E0 - 0x0298)
class ALobbyCamera final : public AActor
{
public:
	class UCameraComponent*                       _Camera;                                           // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELobbyCameraFit                               FitType;                                           // 0x02A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2369[0x3];                                     // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         DefaultDistance;                                   // 0x02A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              ScreenOffset;                                      // 0x02A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                BoundScale;                                        // 0x02B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LookAtTargetBone;                                  // 0x02D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_236A[0x8];                                     // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Adjust(class AActor* _target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyCamera">();
	}
	static class ALobbyCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALobbyCamera>();
	}
};
static_assert(alignof(ALobbyCamera) == 0x000008, "Wrong alignment on ALobbyCamera");
static_assert(sizeof(ALobbyCamera) == 0x0002E0, "Wrong size on ALobbyCamera");
static_assert(offsetof(ALobbyCamera, _Camera) == 0x000298, "Member 'ALobbyCamera::_Camera' has a wrong offset!");
static_assert(offsetof(ALobbyCamera, FitType) == 0x0002A0, "Member 'ALobbyCamera::FitType' has a wrong offset!");
static_assert(offsetof(ALobbyCamera, DefaultDistance) == 0x0002A4, "Member 'ALobbyCamera::DefaultDistance' has a wrong offset!");
static_assert(offsetof(ALobbyCamera, ScreenOffset) == 0x0002A8, "Member 'ALobbyCamera::ScreenOffset' has a wrong offset!");
static_assert(offsetof(ALobbyCamera, BoundScale) == 0x0002B8, "Member 'ALobbyCamera::BoundScale' has a wrong offset!");
static_assert(offsetof(ALobbyCamera, LookAtTargetBone) == 0x0002D0, "Member 'ALobbyCamera::LookAtTargetBone' has a wrong offset!");

// Class Stigma.LobbyGameMode
// 0x0000 (0x0338 - 0x0338)
class ALobbyGameMode : public AGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyGameMode">();
	}
	static class ALobbyGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALobbyGameMode>();
	}
};
static_assert(alignof(ALobbyGameMode) == 0x000008, "Wrong alignment on ALobbyGameMode");
static_assert(sizeof(ALobbyGameMode) == 0x000338, "Wrong size on ALobbyGameMode");

// Class Stigma.LobbyInventoryPageBase
// 0x0008 (0x04F8 - 0x04F0)
class ULobbyInventoryPageBase final : public UPreviewableWidget
{
public:
	class UTileView*                              InventoryView;                                     // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void UpdateInventoryContext();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyInventoryPageBase">();
	}
	static class ULobbyInventoryPageBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyInventoryPageBase>();
	}
};
static_assert(alignof(ULobbyInventoryPageBase) == 0x000008, "Wrong alignment on ULobbyInventoryPageBase");
static_assert(sizeof(ULobbyInventoryPageBase) == 0x0004F8, "Wrong size on ULobbyInventoryPageBase");
static_assert(offsetof(ULobbyInventoryPageBase, InventoryView) == 0x0004F0, "Member 'ULobbyInventoryPageBase::InventoryView' has a wrong offset!");

// Class Stigma.LogNotify
// 0x0010 (0x0048 - 0x0038)
class ULogNotify final : public UAnimNotify
{
public:
	class FString                                 _LogText;                                          // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LogNotify">();
	}
	static class ULogNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULogNotify>();
	}
};
static_assert(alignof(ULogNotify) == 0x000008, "Wrong alignment on ULogNotify");
static_assert(sizeof(ULogNotify) == 0x000048, "Wrong size on ULogNotify");
static_assert(offsetof(ULogNotify, _LogText) == 0x000038, "Member 'ULogNotify::_LogText' has a wrong offset!");

// Class Stigma.LowerState
// 0x0008 (0x0038 - 0x0030)
class ULowerState final : public UAnimNotifyState
{
public:
	EBodyLowerState                               BeginState;                                        // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBodyLowerState                               EndState;                                          // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CallEndState;                                      // 0x0032(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_236B[0x5];                                     // 0x0033(0x0005)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LowerState">();
	}
	static class ULowerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULowerState>();
	}
};
static_assert(alignof(ULowerState) == 0x000008, "Wrong alignment on ULowerState");
static_assert(sizeof(ULowerState) == 0x000038, "Wrong size on ULowerState");
static_assert(offsetof(ULowerState, BeginState) == 0x000030, "Member 'ULowerState::BeginState' has a wrong offset!");
static_assert(offsetof(ULowerState, EndState) == 0x000031, "Member 'ULowerState::EndState' has a wrong offset!");
static_assert(offsetof(ULowerState, CallEndState) == 0x000032, "Member 'ULowerState::CallEndState' has a wrong offset!");

// Class Stigma.LVData_Gun
// 0x0008 (0x0030 - 0x0028)
class ULVData_Gun final : public UObject
{
public:
	EGunType                                      _GunType;                                          // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _UseRedDot;                                        // 0x0029(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_236C[0x6];                                     // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Config(EGunType _gun_type, bool _use_reddot);
	EGunType GetGunType();

	bool IsOwned() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LVData_Gun">();
	}
	static class ULVData_Gun* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULVData_Gun>();
	}
};
static_assert(alignof(ULVData_Gun) == 0x000008, "Wrong alignment on ULVData_Gun");
static_assert(sizeof(ULVData_Gun) == 0x000030, "Wrong size on ULVData_Gun");
static_assert(offsetof(ULVData_Gun, _GunType) == 0x000028, "Member 'ULVData_Gun::_GunType' has a wrong offset!");
static_assert(offsetof(ULVData_Gun, _UseRedDot) == 0x000029, "Member 'ULVData_Gun::_UseRedDot' has a wrong offset!");

// Class Stigma.LVData_Item
// 0x0148 (0x0170 - 0x0028)
class ULVData_Item final : public UObject
{
public:
	struct FItemEntry                             _define;                                           // 0x0028(0x0130)(Edit, BlueprintVisible, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          _IsPossessed;                                      // 0x0158(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_236D[0x7];                                     // 0x0159(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FItemID                                _CurrentItemID;                                    // 0x0160(0x0010)(Edit, BlueprintVisible, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Config(const struct FItemID& _item_id, bool _is_possessed);
	void SetCurrentSelectedItemID(const struct FItemID& _selected_item_id);

	class FText GetDisplayName() const;
	EItemGrade GetGrade() const;
	TSoftObjectPtr<class UTexture2D> GetIcon() const;
	struct FItemID GetItemID() const;
	bool IsSelected() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LVData_Item">();
	}
	static class ULVData_Item* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULVData_Item>();
	}
};
static_assert(alignof(ULVData_Item) == 0x000008, "Wrong alignment on ULVData_Item");
static_assert(sizeof(ULVData_Item) == 0x000170, "Wrong size on ULVData_Item");
static_assert(offsetof(ULVData_Item, _define) == 0x000028, "Member 'ULVData_Item::_define' has a wrong offset!");
static_assert(offsetof(ULVData_Item, _IsPossessed) == 0x000158, "Member 'ULVData_Item::_IsPossessed' has a wrong offset!");
static_assert(offsetof(ULVData_Item, _CurrentItemID) == 0x000160, "Member 'ULVData_Item::_CurrentItemID' has a wrong offset!");

// Class Stigma.LVData_RankingItem
// 0x0110 (0x0138 - 0x0028)
class ULVData_RankingItem final : public UObject
{
public:
	ERankingType                                  _RankingType;                                      // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_236F[0x7];                                     // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UUI_RankingListView*                    _ParentListView;                                   // 0x0030(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FNetRankingEntry                       _RankingEntry;                                     // 0x0038(0x0080)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	struct FACK_ChallengeRead                     _RankingEntryForChallenge;                         // 0x00B8(0x0078)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          _IsSearchedUser;                                   // 0x0130(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2370[0x7];                                     // 0x0131(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Config(ERankingType _ranking_type, const struct FNetRankingEntry& _entry, class UUI_RankingListView* _parent, bool _is_searced_user);
	void ConfigChallenge(ERankingType _ranking_type, const struct FACK_ChallengeRead& _entry, class UUI_RankingListView* _parent);

	const int32 GetArmor() const;
	const int32 GetAssist() const;
	const int32 GetBlackCoin() const;
	const int32 GetDeath() const;
	const int32 GetDraw() const;
	const struct FItemID GetEmblemID() const;
	const int32 GetFinalRound() const;
	const int32 GetGold() const;
	const int32 GetKill() const;
	const int32 GetLevel() const;
	const int32 GetLose() const;
	const struct FUserName GetNickname() const;
	const struct FItemID GetNicknameFXID() const;
	const int32 GetPlayTime() const;
	const int32 GetPrevRank() const;
	const int32 GetPrevRanking() const;
	const struct FItemID GetProfileCardID() const;
	const int32 GetRanking() const;
	const float GetScore() const;
	const ETier GetTier() const;
	const struct FUserID GetUserID() const;
	const int32 GetWin() const;
	const bool IsMyRanking() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LVData_RankingItem">();
	}
	static class ULVData_RankingItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULVData_RankingItem>();
	}
};
static_assert(alignof(ULVData_RankingItem) == 0x000008, "Wrong alignment on ULVData_RankingItem");
static_assert(sizeof(ULVData_RankingItem) == 0x000138, "Wrong size on ULVData_RankingItem");
static_assert(offsetof(ULVData_RankingItem, _RankingType) == 0x000028, "Member 'ULVData_RankingItem::_RankingType' has a wrong offset!");
static_assert(offsetof(ULVData_RankingItem, _ParentListView) == 0x000030, "Member 'ULVData_RankingItem::_ParentListView' has a wrong offset!");
static_assert(offsetof(ULVData_RankingItem, _RankingEntry) == 0x000038, "Member 'ULVData_RankingItem::_RankingEntry' has a wrong offset!");
static_assert(offsetof(ULVData_RankingItem, _RankingEntryForChallenge) == 0x0000B8, "Member 'ULVData_RankingItem::_RankingEntryForChallenge' has a wrong offset!");
static_assert(offsetof(ULVData_RankingItem, _IsSearchedUser) == 0x000130, "Member 'ULVData_RankingItem::_IsSearchedUser' has a wrong offset!");

// Class Stigma.MapEntryBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UMapEntryBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString GetMapName(const struct FMapEntry& _map_entry);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MapEntryBlueprintLibrary">();
	}
	static class UMapEntryBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMapEntryBlueprintLibrary>();
	}
};
static_assert(alignof(UMapEntryBlueprintLibrary) == 0x000008, "Wrong alignment on UMapEntryBlueprintLibrary");
static_assert(sizeof(UMapEntryBlueprintLibrary) == 0x000028, "Wrong size on UMapEntryBlueprintLibrary");

// Class Stigma.MaterialDecalComponent
// 0x0040 (0x02E0 - 0x02A0)
class UMaterialDecalComponent final : public USceneComponent
{
public:
	TArray<struct FMaterialDecalEntry>            DecalEntries;                                      // 0x02A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                DecalSize;                                         // 0x02B0(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USkeletalMeshComponent*                 _AttachMeshComp;                                   // 0x02C8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsMainDecal;                                      // 0x02D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2374[0xF];                                     // 0x02D1(0x000F)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialDecalComponent">();
	}
	static class UMaterialDecalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialDecalComponent>();
	}
};
static_assert(alignof(UMaterialDecalComponent) == 0x000010, "Wrong alignment on UMaterialDecalComponent");
static_assert(sizeof(UMaterialDecalComponent) == 0x0002E0, "Wrong size on UMaterialDecalComponent");
static_assert(offsetof(UMaterialDecalComponent, DecalEntries) == 0x0002A0, "Member 'UMaterialDecalComponent::DecalEntries' has a wrong offset!");
static_assert(offsetof(UMaterialDecalComponent, DecalSize) == 0x0002B0, "Member 'UMaterialDecalComponent::DecalSize' has a wrong offset!");
static_assert(offsetof(UMaterialDecalComponent, _AttachMeshComp) == 0x0002C8, "Member 'UMaterialDecalComponent::_AttachMeshComp' has a wrong offset!");
static_assert(offsetof(UMaterialDecalComponent, _IsMainDecal) == 0x0002D0, "Member 'UMaterialDecalComponent::_IsMainDecal' has a wrong offset!");

// Class Stigma.Mission
// 0x0230 (0x0258 - 0x0028)
class UMission final : public UObject
{
public:
	uint8                                         Pad_2375[0x1B0];                                   // 0x0028(0x01B0)(Fixing Size After Last Property [ Dumper-69 ])
	struct FItemID                                _TaskID;                                           // 0x01D8(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _idx;                                              // 0x01E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _Bookmarked;                                       // 0x01EC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2376[0x3];                                     // 0x01ED(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	TMap<class UMissionCondition*, bool>          _ConditionDriveMap;                                // 0x01F0(0x0050)(Protected, NativeAccessSpecifierProtected)
	int32                                         _InitCount;                                        // 0x0240(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _count;                                            // 0x0244(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _RepeatCount;                                      // 0x0248(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _RewardCount;                                      // 0x024C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMissionProgressType                          _ProgressType;                                     // 0x0250(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2377[0x7];                                     // 0x0251(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnConditionDrivedSuccess(class UMissionCondition* _condition, const bool _fail_on_called);

	TArray<class UMissionCondition*> GetAllConditions() const;
	int32 GetCount() const;
	int32 GetCurrentCount() const;
	int32 GetDefaultRepeatCount() const;
	int32 GetDefaultTargetCount() const;
	int32 GetIdx() const;
	int32 GetInitCount() const;
	struct FItemID_Mission GetMissionID() const;
	float GetProgressRate() const;
	EMissionProgressType GetProgressType() const;
	int32 GetRepeatCount() const;
	int32 GetRewardCount() const;
	const struct FItemID GetTaskID() const;
	bool IsBookmarked() const;
	bool IsCompleted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Mission">();
	}
	static class UMission* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMission>();
	}
};
static_assert(alignof(UMission) == 0x000008, "Wrong alignment on UMission");
static_assert(sizeof(UMission) == 0x000258, "Wrong size on UMission");
static_assert(offsetof(UMission, _TaskID) == 0x0001D8, "Member 'UMission::_TaskID' has a wrong offset!");
static_assert(offsetof(UMission, _idx) == 0x0001E8, "Member 'UMission::_idx' has a wrong offset!");
static_assert(offsetof(UMission, _Bookmarked) == 0x0001EC, "Member 'UMission::_Bookmarked' has a wrong offset!");
static_assert(offsetof(UMission, _ConditionDriveMap) == 0x0001F0, "Member 'UMission::_ConditionDriveMap' has a wrong offset!");
static_assert(offsetof(UMission, _InitCount) == 0x000240, "Member 'UMission::_InitCount' has a wrong offset!");
static_assert(offsetof(UMission, _count) == 0x000244, "Member 'UMission::_count' has a wrong offset!");
static_assert(offsetof(UMission, _RepeatCount) == 0x000248, "Member 'UMission::_RepeatCount' has a wrong offset!");
static_assert(offsetof(UMission, _RewardCount) == 0x00024C, "Member 'UMission::_RewardCount' has a wrong offset!");
static_assert(offsetof(UMission, _ProgressType) == 0x000250, "Member 'UMission::_ProgressType' has a wrong offset!");

// Class Stigma.MissionCondition_MissionClear
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_MissionClear final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_MissionClear">();
	}
	static class UMissionCondition_MissionClear* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_MissionClear>();
	}
};
static_assert(alignof(UMissionCondition_MissionClear) == 0x000008, "Wrong alignment on UMissionCondition_MissionClear");
static_assert(sizeof(UMissionCondition_MissionClear) == 0x000068, "Wrong size on UMissionCondition_MissionClear");

// Class Stigma.MissionCondition_FightingStyle
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_FightingStyle final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_FightingStyle">();
	}
	static class UMissionCondition_FightingStyle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_FightingStyle>();
	}
};
static_assert(alignof(UMissionCondition_FightingStyle) == 0x000008, "Wrong alignment on UMissionCondition_FightingStyle");
static_assert(sizeof(UMissionCondition_FightingStyle) == 0x000068, "Wrong size on UMissionCondition_FightingStyle");

// Class Stigma.MissionCondition_ModeCategory
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_ModeCategory final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_ModeCategory">();
	}
	static class UMissionCondition_ModeCategory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_ModeCategory>();
	}
};
static_assert(alignof(UMissionCondition_ModeCategory) == 0x000008, "Wrong alignment on UMissionCondition_ModeCategory");
static_assert(sizeof(UMissionCondition_ModeCategory) == 0x000068, "Wrong size on UMissionCondition_ModeCategory");

// Class Stigma.MissionCondition_CharacterIndex
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_CharacterIndex final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_CharacterIndex">();
	}
	static class UMissionCondition_CharacterIndex* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_CharacterIndex>();
	}
};
static_assert(alignof(UMissionCondition_CharacterIndex) == 0x000008, "Wrong alignment on UMissionCondition_CharacterIndex");
static_assert(sizeof(UMissionCondition_CharacterIndex) == 0x000068, "Wrong size on UMissionCondition_CharacterIndex");

// Class Stigma.MissionCondition_DamageSkill
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_DamageSkill final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_DamageSkill">();
	}
	static class UMissionCondition_DamageSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_DamageSkill>();
	}
};
static_assert(alignof(UMissionCondition_DamageSkill) == 0x000008, "Wrong alignment on UMissionCondition_DamageSkill");
static_assert(sizeof(UMissionCondition_DamageSkill) == 0x000068, "Wrong size on UMissionCondition_DamageSkill");

// Class Stigma.MissionCondition_HitRangeUnder
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_HitRangeUnder final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_HitRangeUnder">();
	}
	static class UMissionCondition_HitRangeUnder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_HitRangeUnder>();
	}
};
static_assert(alignof(UMissionCondition_HitRangeUnder) == 0x000008, "Wrong alignment on UMissionCondition_HitRangeUnder");
static_assert(sizeof(UMissionCondition_HitRangeUnder) == 0x000068, "Wrong size on UMissionCondition_HitRangeUnder");

// Class Stigma.MissionCondition_FloatingHit
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_FloatingHit final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_FloatingHit">();
	}
	static class UMissionCondition_FloatingHit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_FloatingHit>();
	}
};
static_assert(alignof(UMissionCondition_FloatingHit) == 0x000008, "Wrong alignment on UMissionCondition_FloatingHit");
static_assert(sizeof(UMissionCondition_FloatingHit) == 0x000068, "Wrong size on UMissionCondition_FloatingHit");

// Class Stigma.MissionCondition_Kill
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_Kill final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_Kill">();
	}
	static class UMissionCondition_Kill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_Kill>();
	}
};
static_assert(alignof(UMissionCondition_Kill) == 0x000008, "Wrong alignment on UMissionCondition_Kill");
static_assert(sizeof(UMissionCondition_Kill) == 0x000068, "Wrong size on UMissionCondition_Kill");

// Class Stigma.MissionCondition_KillSkill
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_KillSkill final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_KillSkill">();
	}
	static class UMissionCondition_KillSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_KillSkill>();
	}
};
static_assert(alignof(UMissionCondition_KillSkill) == 0x000008, "Wrong alignment on UMissionCondition_KillSkill");
static_assert(sizeof(UMissionCondition_KillSkill) == 0x000068, "Wrong size on UMissionCondition_KillSkill");

// Class Stigma.MissionCondition_KillRangeOver
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_KillRangeOver final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_KillRangeOver">();
	}
	static class UMissionCondition_KillRangeOver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_KillRangeOver>();
	}
};
static_assert(alignof(UMissionCondition_KillRangeOver) == 0x000008, "Wrong alignment on UMissionCondition_KillRangeOver");
static_assert(sizeof(UMissionCondition_KillRangeOver) == 0x000068, "Wrong size on UMissionCondition_KillRangeOver");

// Class Stigma.MissionCondition_UseBooster
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_UseBooster final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_UseBooster">();
	}
	static class UMissionCondition_UseBooster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_UseBooster>();
	}
};
static_assert(alignof(UMissionCondition_UseBooster) == 0x000008, "Wrong alignment on UMissionCondition_UseBooster");
static_assert(sizeof(UMissionCondition_UseBooster) == 0x000068, "Wrong size on UMissionCondition_UseBooster");

// Class Stigma.MissionCondition_ArmorReplace
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_ArmorReplace final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_ArmorReplace">();
	}
	static class UMissionCondition_ArmorReplace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_ArmorReplace>();
	}
};
static_assert(alignof(UMissionCondition_ArmorReplace) == 0x000008, "Wrong alignment on UMissionCondition_ArmorReplace");
static_assert(sizeof(UMissionCondition_ArmorReplace) == 0x000068, "Wrong size on UMissionCondition_ArmorReplace");

// Class Stigma.MissionCondition_GetObject
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_GetObject final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_GetObject">();
	}
	static class UMissionCondition_GetObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_GetObject>();
	}
};
static_assert(alignof(UMissionCondition_GetObject) == 0x000008, "Wrong alignment on UMissionCondition_GetObject");
static_assert(sizeof(UMissionCondition_GetObject) == 0x000068, "Wrong size on UMissionCondition_GetObject");

// Class Stigma.MissionCondition_WithParty
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_WithParty final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_WithParty">();
	}
	static class UMissionCondition_WithParty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_WithParty>();
	}
};
static_assert(alignof(UMissionCondition_WithParty) == 0x000008, "Wrong alignment on UMissionCondition_WithParty");
static_assert(sizeof(UMissionCondition_WithParty) == 0x000068, "Wrong size on UMissionCondition_WithParty");

// Class Stigma.MissionCondition_ChangeMaster
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_ChangeMaster final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_ChangeMaster">();
	}
	static class UMissionCondition_ChangeMaster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_ChangeMaster>();
	}
};
static_assert(alignof(UMissionCondition_ChangeMaster) == 0x000008, "Wrong alignment on UMissionCondition_ChangeMaster");
static_assert(sizeof(UMissionCondition_ChangeMaster) == 0x000068, "Wrong size on UMissionCondition_ChangeMaster");

// Class Stigma.MissionCondition_ChangeWeapon
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_ChangeWeapon final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_ChangeWeapon">();
	}
	static class UMissionCondition_ChangeWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_ChangeWeapon>();
	}
};
static_assert(alignof(UMissionCondition_ChangeWeapon) == 0x000008, "Wrong alignment on UMissionCondition_ChangeWeapon");
static_assert(sizeof(UMissionCondition_ChangeWeapon) == 0x000068, "Wrong size on UMissionCondition_ChangeWeapon");

// Class Stigma.MissionCondition_Death
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_Death final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_Death">();
	}
	static class UMissionCondition_Death* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_Death>();
	}
};
static_assert(alignof(UMissionCondition_Death) == 0x000008, "Wrong alignment on UMissionCondition_Death");
static_assert(sizeof(UMissionCondition_Death) == 0x000068, "Wrong size on UMissionCondition_Death");

// Class Stigma.MissionCondition_UseInvenItem
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_UseInvenItem final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_UseInvenItem">();
	}
	static class UMissionCondition_UseInvenItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_UseInvenItem>();
	}
};
static_assert(alignof(UMissionCondition_UseInvenItem) == 0x000008, "Wrong alignment on UMissionCondition_UseInvenItem");
static_assert(sizeof(UMissionCondition_UseInvenItem) == 0x000068, "Wrong size on UMissionCondition_UseInvenItem");

// Class Stigma.MissionCondition_ChangeGunParts
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_ChangeGunParts final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_ChangeGunParts">();
	}
	static class UMissionCondition_ChangeGunParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_ChangeGunParts>();
	}
};
static_assert(alignof(UMissionCondition_ChangeGunParts) == 0x000008, "Wrong alignment on UMissionCondition_ChangeGunParts");
static_assert(sizeof(UMissionCondition_ChangeGunParts) == 0x000068, "Wrong size on UMissionCondition_ChangeGunParts");

// Class Stigma.MissionCondition_ChangeGunCharm
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_ChangeGunCharm final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_ChangeGunCharm">();
	}
	static class UMissionCondition_ChangeGunCharm* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_ChangeGunCharm>();
	}
};
static_assert(alignof(UMissionCondition_ChangeGunCharm) == 0x000008, "Wrong alignment on UMissionCondition_ChangeGunCharm");
static_assert(sizeof(UMissionCondition_ChangeGunCharm) == 0x000068, "Wrong size on UMissionCondition_ChangeGunCharm");

// Class Stigma.MissionCondition_LevelUpPassiveSkill
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_LevelUpPassiveSkill final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_LevelUpPassiveSkill">();
	}
	static class UMissionCondition_LevelUpPassiveSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_LevelUpPassiveSkill>();
	}
};
static_assert(alignof(UMissionCondition_LevelUpPassiveSkill) == 0x000008, "Wrong alignment on UMissionCondition_LevelUpPassiveSkill");
static_assert(sizeof(UMissionCondition_LevelUpPassiveSkill) == 0x000068, "Wrong size on UMissionCondition_LevelUpPassiveSkill");

// Class Stigma.MissionCondition_GetItem
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_GetItem final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_GetItem">();
	}
	static class UMissionCondition_GetItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_GetItem>();
	}
};
static_assert(alignof(UMissionCondition_GetItem) == 0x000008, "Wrong alignment on UMissionCondition_GetItem");
static_assert(sizeof(UMissionCondition_GetItem) == 0x000068, "Wrong size on UMissionCondition_GetItem");

// Class Stigma.MissionCondition_Win
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_Win final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_Win">();
	}
	static class UMissionCondition_Win* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_Win>();
	}
};
static_assert(alignof(UMissionCondition_Win) == 0x000008, "Wrong alignment on UMissionCondition_Win");
static_assert(sizeof(UMissionCondition_Win) == 0x000068, "Wrong size on UMissionCondition_Win");

// Class Stigma.MissionCondition_MVP
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_MVP final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_MVP">();
	}
	static class UMissionCondition_MVP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_MVP>();
	}
};
static_assert(alignof(UMissionCondition_MVP) == 0x000008, "Wrong alignment on UMissionCondition_MVP");
static_assert(sizeof(UMissionCondition_MVP) == 0x000068, "Wrong size on UMissionCondition_MVP");

// Class Stigma.MissionCondition_GameCount
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_GameCount final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_GameCount">();
	}
	static class UMissionCondition_GameCount* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_GameCount>();
	}
};
static_assert(alignof(UMissionCondition_GameCount) == 0x000008, "Wrong alignment on UMissionCondition_GameCount");
static_assert(sizeof(UMissionCondition_GameCount) == 0x000068, "Wrong size on UMissionCondition_GameCount");

// Class Stigma.MissionCondition_Challenge_ClearRound
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_Challenge_ClearRound final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_Challenge_ClearRound">();
	}
	static class UMissionCondition_Challenge_ClearRound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_Challenge_ClearRound>();
	}
};
static_assert(alignof(UMissionCondition_Challenge_ClearRound) == 0x000008, "Wrong alignment on UMissionCondition_Challenge_ClearRound");
static_assert(sizeof(UMissionCondition_Challenge_ClearRound) == 0x000068, "Wrong size on UMissionCondition_Challenge_ClearRound");

// Class Stigma.MissionCondition_TrackCount
// 0x0000 (0x0068 - 0x0068)
class UMissionCondition_TrackCount final : public UMissionCondition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionCondition_TrackCount">();
	}
	static class UMissionCondition_TrackCount* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionCondition_TrackCount>();
	}
};
static_assert(alignof(UMissionCondition_TrackCount) == 0x000008, "Wrong alignment on UMissionCondition_TrackCount");
static_assert(sizeof(UMissionCondition_TrackCount) == 0x000068, "Wrong size on UMissionCondition_TrackCount");

// Class Stigma.MissionHelper
// 0x0000 (0x0028 - 0x0028)
class UMissionHelper final : public UBlueprintFunctionLibrary
{
public:
	static class UMissionCondition* CreateMissionCondition(class UObject* _outer, const struct FMissionConditionInfo& _mission_condition_info);
	static class FText GetDisplayMission(const class UMission* _mission, const class FText& _format);
	static class FText GetDisplayMissionDefine(class UObject* _outer, const struct FMissionDefine& _mission_define, const class FText& _format);
	static TSubclassOf<class UMissionCondition> GetMissionConditionClassByConditionType(const EMissionConditionType _condition_type);
	static EMissionConditionSubTypeCategory GetMissionConditionSubTypeCategory(const EMissionConditionType _condition_type);
	static void GoToMission(class UObject* _outer, const struct FItemID_Mission& _mission_id);
	static bool IsPremiumMission(const struct FItemID_Mission& _mission_id);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MissionHelper">();
	}
	static class UMissionHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMissionHelper>();
	}
};
static_assert(alignof(UMissionHelper) == 0x000008, "Wrong alignment on UMissionHelper");
static_assert(sizeof(UMissionHelper) == 0x000028, "Wrong size on UMissionHelper");

// Class Stigma.MotionSource
// 0x0008 (0x0038 - 0x0030)
class UMotionSource final : public UAnimNotifyState
{
public:
	EMotionSource                                 Source;                                            // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERootMotionFrom                               RootMotionMode;                                    // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_237B[0x6];                                     // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MotionSource">();
	}
	static class UMotionSource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMotionSource>();
	}
};
static_assert(alignof(UMotionSource) == 0x000008, "Wrong alignment on UMotionSource");
static_assert(sizeof(UMotionSource) == 0x000038, "Wrong size on UMotionSource");
static_assert(offsetof(UMotionSource, Source) == 0x000030, "Member 'UMotionSource::Source' has a wrong offset!");
static_assert(offsetof(UMotionSource, RootMotionMode) == 0x000031, "Member 'UMotionSource::RootMotionMode' has a wrong offset!");

// Class Stigma.MoveMode
// 0x0008 (0x0038 - 0x0030)
class UMoveMode final : public UAnimNotifyState
{
public:
	EMoveMode                                     MoveMode;                                          // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_237C[0x3];                                     // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         RotationYawRate;                                   // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveMode">();
	}
	static class UMoveMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveMode>();
	}
};
static_assert(alignof(UMoveMode) == 0x000008, "Wrong alignment on UMoveMode");
static_assert(sizeof(UMoveMode) == 0x000038, "Wrong size on UMoveMode");
static_assert(offsetof(UMoveMode, MoveMode) == 0x000030, "Member 'UMoveMode::MoveMode' has a wrong offset!");
static_assert(offsetof(UMoveMode, RotationYawRate) == 0x000034, "Member 'UMoveMode::RotationYawRate' has a wrong offset!");

// Class Stigma.MQConnection
// 0x0020 (0x0048 - 0x0028)
class UMQConnection final : public UConnectionBase
{
public:
	class UNATSClient*                            _Client;                                           // 0x0028(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_237D[0x18];                                    // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MQConnection">();
	}
	static class UMQConnection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMQConnection>();
	}
};
static_assert(alignof(UMQConnection) == 0x000008, "Wrong alignment on UMQConnection");
static_assert(sizeof(UMQConnection) == 0x000048, "Wrong size on UMQConnection");
static_assert(offsetof(UMQConnection, _Client) == 0x000028, "Member 'UMQConnection::_Client' has a wrong offset!");

// Class Stigma.NPC_Lemming
// 0x0070 (0x38B0 - 0x3840)
class ANPC_Lemming final : public AAICharaBase
{
public:
	float                                         Explosion_OuterRange;                              // 0x3840(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Explosion_InnerRange;                              // 0x3844(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDamageDef                             Explosion_Damage;                                  // 0x3848(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_237E[0x3C];                                    // 0x385C(0x003C)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          _IsExploded;                                       // 0x3898(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_237F[0x17];                                    // 0x3899(0x0017)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool OnALL_Explode();
	void OnRep_IsExploded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NPC_Lemming">();
	}
	static class ANPC_Lemming* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANPC_Lemming>();
	}
};
static_assert(alignof(ANPC_Lemming) == 0x000010, "Wrong alignment on ANPC_Lemming");
static_assert(sizeof(ANPC_Lemming) == 0x0038B0, "Wrong size on ANPC_Lemming");
static_assert(offsetof(ANPC_Lemming, Explosion_OuterRange) == 0x003840, "Member 'ANPC_Lemming::Explosion_OuterRange' has a wrong offset!");
static_assert(offsetof(ANPC_Lemming, Explosion_InnerRange) == 0x003844, "Member 'ANPC_Lemming::Explosion_InnerRange' has a wrong offset!");
static_assert(offsetof(ANPC_Lemming, Explosion_Damage) == 0x003848, "Member 'ANPC_Lemming::Explosion_Damage' has a wrong offset!");
static_assert(offsetof(ANPC_Lemming, _IsExploded) == 0x003898, "Member 'ANPC_Lemming::_IsExploded' has a wrong offset!");

// Class Stigma.ObjectPool
// 0x0030 (0x00D0 - 0x00A0)
class UObjectPool final : public UActorComponent
{
public:
	int32                                         PoolSize;                                          // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PooledBulletholeLifeSpan;                          // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2380[0x28];                                    // 0x00A8(0x0028)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnPooledBulletholeDespawn(class APooledBullethole* PoolActor);
	class APooledBullethole* SpawnPooledBullethole();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectPool">();
	}
	static class UObjectPool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectPool>();
	}
};
static_assert(alignof(UObjectPool) == 0x000008, "Wrong alignment on UObjectPool");
static_assert(sizeof(UObjectPool) == 0x0000D0, "Wrong size on UObjectPool");
static_assert(offsetof(UObjectPool, PoolSize) == 0x0000A0, "Member 'UObjectPool::PoolSize' has a wrong offset!");
static_assert(offsetof(UObjectPool, PooledBulletholeLifeSpan) == 0x0000A4, "Member 'UObjectPool::PooledBulletholeLifeSpan' has a wrong offset!");

// Class Stigma.OccupationArea
// 0x0080 (0x0318 - 0x0298)
class AOccupationArea final : public AActor
{
public:
	uint8                                         Pad_2381[0x10];                                    // 0x0298(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         OccupyTime;                                        // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddScoreIntervalTime;                              // 0x02AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IncreasingScore;                                   // 0x02B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2382[0x4];                                     // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class FString                                 OccpuyBuffName;                                    // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UIndicatorBaseWidget>       IndicatorWidgetClass;                              // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeams                                        OwnedTeam;                                         // 0x02D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2383[0x7];                                     // 0x02D1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class ACharaBase*                             InteractingActor;                                  // 0x02D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsActivated;                                       // 0x02E0(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2384[0x7];                                     // 0x02E1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UMeshComponent*                         _Mesh;                                             // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2385[0x28];                                    // 0x02F0(0x0028)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnRep_IsActivated();
	void Setter_IsActivated(bool _is_activated);

	class UMeshComponent* GetMeshComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OccupationArea">();
	}
	static class AOccupationArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOccupationArea>();
	}
};
static_assert(alignof(AOccupationArea) == 0x000008, "Wrong alignment on AOccupationArea");
static_assert(sizeof(AOccupationArea) == 0x000318, "Wrong size on AOccupationArea");
static_assert(offsetof(AOccupationArea, OccupyTime) == 0x0002A8, "Member 'AOccupationArea::OccupyTime' has a wrong offset!");
static_assert(offsetof(AOccupationArea, AddScoreIntervalTime) == 0x0002AC, "Member 'AOccupationArea::AddScoreIntervalTime' has a wrong offset!");
static_assert(offsetof(AOccupationArea, IncreasingScore) == 0x0002B0, "Member 'AOccupationArea::IncreasingScore' has a wrong offset!");
static_assert(offsetof(AOccupationArea, OccpuyBuffName) == 0x0002B8, "Member 'AOccupationArea::OccpuyBuffName' has a wrong offset!");
static_assert(offsetof(AOccupationArea, IndicatorWidgetClass) == 0x0002C8, "Member 'AOccupationArea::IndicatorWidgetClass' has a wrong offset!");
static_assert(offsetof(AOccupationArea, OwnedTeam) == 0x0002D0, "Member 'AOccupationArea::OwnedTeam' has a wrong offset!");
static_assert(offsetof(AOccupationArea, InteractingActor) == 0x0002D8, "Member 'AOccupationArea::InteractingActor' has a wrong offset!");
static_assert(offsetof(AOccupationArea, IsActivated) == 0x0002E0, "Member 'AOccupationArea::IsActivated' has a wrong offset!");
static_assert(offsetof(AOccupationArea, _Mesh) == 0x0002E8, "Member 'AOccupationArea::_Mesh' has a wrong offset!");

// Class Stigma.Occupation_GameState
// 0x0010 (0x0918 - 0x0908)
class AOccupation_GameState final : public ABattleGameStateBase
{
public:
	TArray<struct FOccupationTeamData>            _OccupationTeamData;                               // 0x0908(0x0010)(Edit, BlueprintVisible, Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Occupation_GameState">();
	}
	static class AOccupation_GameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOccupation_GameState>();
	}
};
static_assert(alignof(AOccupation_GameState) == 0x000008, "Wrong alignment on AOccupation_GameState");
static_assert(sizeof(AOccupation_GameState) == 0x000918, "Wrong size on AOccupation_GameState");
static_assert(offsetof(AOccupation_GameState, _OccupationTeamData) == 0x000908, "Member 'AOccupation_GameState::_OccupationTeamData' has a wrong offset!");

// Class Stigma.Occupation_PlayerController
// 0x0000 (0x0E40 - 0x0E40)
class AOccupation_PlayerController final : public ABattlePlayerControllerBase
{
public:
	void CLIENT_RequestRespawn(const class FString& _area_name);
	void RPC_ALL_OccupyArea(class ACharaBase* _occupant, ETeams Prev_team, class AOccupationArea* _area);
	void RPC_CLIENT_SelectRespawn();
	void RPC_SERVER_RequestRespawnArea(class AOccupationArea* _area);
	void ShowRespawnSelector();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Occupation_PlayerController">();
	}
	static class AOccupation_PlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOccupation_PlayerController>();
	}
};
static_assert(alignof(AOccupation_PlayerController) == 0x000008, "Wrong alignment on AOccupation_PlayerController");
static_assert(sizeof(AOccupation_PlayerController) == 0x000E40, "Wrong size on AOccupation_PlayerController");

// Class Stigma.Occupation_PlayerState
// 0x0000 (0x0C88 - 0x0C88)
class AOccupation_PlayerState final : public ABattlePlayerState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Occupation_PlayerState">();
	}
	static class AOccupation_PlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOccupation_PlayerState>();
	}
};
static_assert(alignof(AOccupation_PlayerState) == 0x000008, "Wrong alignment on AOccupation_PlayerState");
static_assert(sizeof(AOccupation_PlayerState) == 0x000C88, "Wrong size on AOccupation_PlayerState");

// Class Stigma.OnlineMatch
// 0x0000 (0x0028 - 0x0028)
class UOnlineMatch final : public UBlueprintFunctionLibrary
{
public:
	static void DestroyServerSession(const class UObject* _world_ctx);
	static class FString GetJoinedSessionMapName(const class UObject* _world_ctx);
	static EServerSessionStatus GetServerSessionStatus(const class UObject* _world_ctx);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineMatch">();
	}
	static class UOnlineMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineMatch>();
	}
};
static_assert(alignof(UOnlineMatch) == 0x000008, "Wrong alignment on UOnlineMatch");
static_assert(sizeof(UOnlineMatch) == 0x000028, "Wrong size on UOnlineMatch");

// Class Stigma.OpeningPlayerController
// 0x0038 (0x08F0 - 0x08B8)
class AOpeningPlayerController final : public ABPGPlayerController
{
public:
	TArray<struct FOpeningEntry>                  _Sequences;                                        // 0x08B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2388[0x20];                                    // 0x08C8(0x0020)(Fixing Size After Last Property [ Dumper-69 ])
	class UUserWidget*                            _widget;                                           // 0x08E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void FinishSequence();
	bool StartSequence();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OpeningPlayerController">();
	}
	static class AOpeningPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOpeningPlayerController>();
	}
};
static_assert(alignof(AOpeningPlayerController) == 0x000008, "Wrong alignment on AOpeningPlayerController");
static_assert(sizeof(AOpeningPlayerController) == 0x0008F0, "Wrong size on AOpeningPlayerController");
static_assert(offsetof(AOpeningPlayerController, _Sequences) == 0x0008B8, "Member 'AOpeningPlayerController::_Sequences' has a wrong offset!");
static_assert(offsetof(AOpeningPlayerController, _widget) == 0x0008E8, "Member 'AOpeningPlayerController::_widget' has a wrong offset!");

// Class Stigma.BriefParty
// 0x0028 (0x0050 - 0x0028)
class UBriefParty final : public UObject
{
public:
	struct FPartyID                               PartyIDN;                                          // 0x0028(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FUserID                                LeaderIDN;                                         // 0x0030(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameMode                                     PartyFirstGameMode;                                // 0x0038(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EUserPlayingAt                                LeaderFirstStatus;                                 // 0x0039(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2389[0x6];                                     // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class UUserProfile*>                   MemberList;                                        // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	bool AddMember(class UUserProfile* _user);
	class UUserProfile* RemoveMember(const struct FUserID& _user_id);

	class UUserProfile* FindMember(const struct FUserID& _user_id) const;
	class UUserProfile* GetMember(int32 _zidx) const;
	class UUserProfile* GetMemberAt(int32 _zidx, const struct FUserID& _exception) const;
	int32 GetMemberCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BriefParty">();
	}
	static class UBriefParty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBriefParty>();
	}
};
static_assert(alignof(UBriefParty) == 0x000008, "Wrong alignment on UBriefParty");
static_assert(sizeof(UBriefParty) == 0x000050, "Wrong size on UBriefParty");
static_assert(offsetof(UBriefParty, PartyIDN) == 0x000028, "Member 'UBriefParty::PartyIDN' has a wrong offset!");
static_assert(offsetof(UBriefParty, LeaderIDN) == 0x000030, "Member 'UBriefParty::LeaderIDN' has a wrong offset!");
static_assert(offsetof(UBriefParty, PartyFirstGameMode) == 0x000038, "Member 'UBriefParty::PartyFirstGameMode' has a wrong offset!");
static_assert(offsetof(UBriefParty, LeaderFirstStatus) == 0x000039, "Member 'UBriefParty::LeaderFirstStatus' has a wrong offset!");
static_assert(offsetof(UBriefParty, MemberList) == 0x000040, "Member 'UBriefParty::MemberList' has a wrong offset!");

// Class Stigma.PartyIDBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UPartyIDBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool IsEqualPartyID(const struct FPartyID& _id1, const struct FPartyID& _id2);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PartyIDBlueprintLibrary">();
	}
	static class UPartyIDBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPartyIDBlueprintLibrary>();
	}
};
static_assert(alignof(UPartyIDBlueprintLibrary) == 0x000008, "Wrong alignment on UPartyIDBlueprintLibrary");
static_assert(sizeof(UPartyIDBlueprintLibrary) == 0x000028, "Wrong size on UPartyIDBlueprintLibrary");

// Class Stigma.Pickup
// 0x0000 (0x0030 - 0x0030)
class UPickup final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Pickup">();
	}
	static class UPickup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPickup>();
	}
};
static_assert(alignof(UPickup) == 0x000008, "Wrong alignment on UPickup");
static_assert(sizeof(UPickup) == 0x000030, "Wrong size on UPickup");

// Class Stigma.PingMarker
// 0x0028 (0x02C0 - 0x0298)
class APingMarker : public AActor
{
public:
	uint8                                         Pad_238E[0x8];                                     // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	struct FVector                                Normal;                                            // 0x02A0(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBattlePingType                               PingType;                                          // 0x02B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_238F[0x7];                                     // 0x02B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool OnSetPing();
	void SetPing(EBattlePingType _ping_type, const struct FVector& _normal);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PingMarker">();
	}
	static class APingMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<APingMarker>();
	}
};
static_assert(alignof(APingMarker) == 0x000008, "Wrong alignment on APingMarker");
static_assert(sizeof(APingMarker) == 0x0002C0, "Wrong size on APingMarker");
static_assert(offsetof(APingMarker, Normal) == 0x0002A0, "Member 'APingMarker::Normal' has a wrong offset!");
static_assert(offsetof(APingMarker, PingType) == 0x0002B8, "Member 'APingMarker::PingType' has a wrong offset!");

// Class Stigma.PlayerStart_AI
// 0x0008 (0x02D0 - 0x02C8)
class APlayerStart_AI final : public APlayerStart
{
public:
	int32                                         SpawnIndex;                                        // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2391[0x4];                                     // 0x02CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	int32 GetSpawnIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStart_AI">();
	}
	static class APlayerStart_AI* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerStart_AI>();
	}
};
static_assert(alignof(APlayerStart_AI) == 0x000008, "Wrong alignment on APlayerStart_AI");
static_assert(sizeof(APlayerStart_AI) == 0x0002D0, "Wrong size on APlayerStart_AI");
static_assert(offsetof(APlayerStart_AI, SpawnIndex) == 0x0002C8, "Member 'APlayerStart_AI::SpawnIndex' has a wrong offset!");

// Class Stigma.PlayNiagaraEffectStigma
// 0x0060 (0x0130 - 0x00D0)
class UPlayNiagaraEffectStigma final : public UAnimNotify_PlayNiagaraEffect
{
public:
	TMap<struct FItemID, class UNiagaraSystem*>   _BodyID_With_NiagaraSystem;                        // 0x00D0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         _resultTemplate;                                   // 0x0120(0x0008)(BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2392[0x8];                                     // 0x0128(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayNiagaraEffectStigma">();
	}
	static class UPlayNiagaraEffectStigma* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayNiagaraEffectStigma>();
	}
};
static_assert(alignof(UPlayNiagaraEffectStigma) == 0x000010, "Wrong alignment on UPlayNiagaraEffectStigma");
static_assert(sizeof(UPlayNiagaraEffectStigma) == 0x000130, "Wrong size on UPlayNiagaraEffectStigma");
static_assert(offsetof(UPlayNiagaraEffectStigma, _BodyID_With_NiagaraSystem) == 0x0000D0, "Member 'UPlayNiagaraEffectStigma::_BodyID_With_NiagaraSystem' has a wrong offset!");
static_assert(offsetof(UPlayNiagaraEffectStigma, _resultTemplate) == 0x000120, "Member 'UPlayNiagaraEffectStigma::_resultTemplate' has a wrong offset!");

// Class Stigma.PlaySoundWithTerrain
// 0x0008 (0x0040 - 0x0038)
class UPlaySoundWithTerrain final : public UAnimNotify
{
public:
	class USoundBase*                             Sound;                                             // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlaySoundWithTerrain">();
	}
	static class UPlaySoundWithTerrain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlaySoundWithTerrain>();
	}
};
static_assert(alignof(UPlaySoundWithTerrain) == 0x000008, "Wrong alignment on UPlaySoundWithTerrain");
static_assert(sizeof(UPlaySoundWithTerrain) == 0x000040, "Wrong size on UPlaySoundWithTerrain");
static_assert(offsetof(UPlaySoundWithTerrain, Sound) == 0x000038, "Member 'UPlaySoundWithTerrain::Sound' has a wrong offset!");

// Class Stigma.PoisonArea
// 0x0110 (0x06A0 - 0x0590)
class APoisonArea final : public AObjectBase
{
public:
	struct FConfig_PoisonArea                     _Config_PoisonArea;                                // 0x0588(0x0070)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class USphereComponent*                       _collision;                                        // 0x05F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharaBase*                             _Spawner;                                          // 0x0600(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AObjectBase*                            _Weapon;                                           // 0x0608(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2393[0x8];                                     // 0x0610(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UNiagaraSystem*                         _FX_Gas_Template;                                  // 0x0618(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNiagaraComponent*                      _FX_Gas;                                           // 0x0620(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class ACharaBase*, float>                _EnteredActors;                                    // 0x0628(0x0050)(Protected, NativeAccessSpecifierProtected)
	class AAntidoteArea*                          _CollidedAntidote;                                 // 0x0678(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2394[0x20];                                    // 0x0680(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnLoadSettings(struct FConfig_PoisonArea* _settings);
	bool SetUniqueEffect(class ACharaBase* _chara, bool _is_effected);
	void Start(class ACharaBase* _thrower, class AObjectBase* _weapon_obj, const struct FActionGraphOperatorID& _op_id);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoisonArea">();
	}
	static class APoisonArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<APoisonArea>();
	}
};
static_assert(alignof(APoisonArea) == 0x000010, "Wrong alignment on APoisonArea");
static_assert(sizeof(APoisonArea) == 0x0006A0, "Wrong size on APoisonArea");
static_assert(offsetof(APoisonArea, _Config_PoisonArea) == 0x000588, "Member 'APoisonArea::_Config_PoisonArea' has a wrong offset!");
static_assert(offsetof(APoisonArea, _collision) == 0x0005F8, "Member 'APoisonArea::_collision' has a wrong offset!");
static_assert(offsetof(APoisonArea, _Spawner) == 0x000600, "Member 'APoisonArea::_Spawner' has a wrong offset!");
static_assert(offsetof(APoisonArea, _Weapon) == 0x000608, "Member 'APoisonArea::_Weapon' has a wrong offset!");
static_assert(offsetof(APoisonArea, _FX_Gas_Template) == 0x000618, "Member 'APoisonArea::_FX_Gas_Template' has a wrong offset!");
static_assert(offsetof(APoisonArea, _FX_Gas) == 0x000620, "Member 'APoisonArea::_FX_Gas' has a wrong offset!");
static_assert(offsetof(APoisonArea, _EnteredActors) == 0x000628, "Member 'APoisonArea::_EnteredActors' has a wrong offset!");
static_assert(offsetof(APoisonArea, _CollidedAntidote) == 0x000678, "Member 'APoisonArea::_CollidedAntidote' has a wrong offset!");

// Class Stigma.PoolActor
// 0x0080 (0x0318 - 0x0298)
class APoolActor final : public AActor
{
public:
	class UTextureRenderTarget2D*                 _Height0;                                          // 0x0298(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 _Height1;                                          // 0x02A0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 _Height2;                                          // 0x02A8(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextureRenderTarget2D*                 _HeightfieldNormal;                                // 0x02B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   _PoolMeshCom;                                      // 0x02B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               _PoolMID;                                          // 0x02C0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterial*                              _HeigthSimMaterial;                                // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               _HeigthSimMID;                                     // 0x02D0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterial*                              _ForceMaterial;                                    // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               _ForceMID;                                         // 0x02E0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterial*                              _ComputeNormal;                                    // 0x02E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               _ComputeNormalMID;                                 // 0x02F0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _HeightState;                                      // 0x02F8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _TimeAccumulator;                                  // 0x02FC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _UpdateRate;                                       // 0x0300(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2399[0x4];                                     // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FPooledChara>                   _TouchingActors;                                   // 0x0308(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)

public:
	void AddWave(const struct FVector& _ws_pos);
	void BeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void EndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	class UTextureRenderTarget2D* GetHeightRT(int32 _RT_idx);
	class UTextureRenderTarget2D* GetLastHeight(int32 _current_height_idx, int32 _num_frames_old);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PoolActor">();
	}
	static class APoolActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APoolActor>();
	}
};
static_assert(alignof(APoolActor) == 0x000008, "Wrong alignment on APoolActor");
static_assert(sizeof(APoolActor) == 0x000318, "Wrong size on APoolActor");
static_assert(offsetof(APoolActor, _Height0) == 0x000298, "Member 'APoolActor::_Height0' has a wrong offset!");
static_assert(offsetof(APoolActor, _Height1) == 0x0002A0, "Member 'APoolActor::_Height1' has a wrong offset!");
static_assert(offsetof(APoolActor, _Height2) == 0x0002A8, "Member 'APoolActor::_Height2' has a wrong offset!");
static_assert(offsetof(APoolActor, _HeightfieldNormal) == 0x0002B0, "Member 'APoolActor::_HeightfieldNormal' has a wrong offset!");
static_assert(offsetof(APoolActor, _PoolMeshCom) == 0x0002B8, "Member 'APoolActor::_PoolMeshCom' has a wrong offset!");
static_assert(offsetof(APoolActor, _PoolMID) == 0x0002C0, "Member 'APoolActor::_PoolMID' has a wrong offset!");
static_assert(offsetof(APoolActor, _HeigthSimMaterial) == 0x0002C8, "Member 'APoolActor::_HeigthSimMaterial' has a wrong offset!");
static_assert(offsetof(APoolActor, _HeigthSimMID) == 0x0002D0, "Member 'APoolActor::_HeigthSimMID' has a wrong offset!");
static_assert(offsetof(APoolActor, _ForceMaterial) == 0x0002D8, "Member 'APoolActor::_ForceMaterial' has a wrong offset!");
static_assert(offsetof(APoolActor, _ForceMID) == 0x0002E0, "Member 'APoolActor::_ForceMID' has a wrong offset!");
static_assert(offsetof(APoolActor, _ComputeNormal) == 0x0002E8, "Member 'APoolActor::_ComputeNormal' has a wrong offset!");
static_assert(offsetof(APoolActor, _ComputeNormalMID) == 0x0002F0, "Member 'APoolActor::_ComputeNormalMID' has a wrong offset!");
static_assert(offsetof(APoolActor, _HeightState) == 0x0002F8, "Member 'APoolActor::_HeightState' has a wrong offset!");
static_assert(offsetof(APoolActor, _TimeAccumulator) == 0x0002FC, "Member 'APoolActor::_TimeAccumulator' has a wrong offset!");
static_assert(offsetof(APoolActor, _UpdateRate) == 0x000300, "Member 'APoolActor::_UpdateRate' has a wrong offset!");
static_assert(offsetof(APoolActor, _TouchingActors) == 0x000308, "Member 'APoolActor::_TouchingActors' has a wrong offset!");

// Class Stigma.Popup_Competition
// 0x0020 (0x0590 - 0x0570)
class UPopup_Competition : public UPopupBase
{
public:
	class UListView*                              RankingListView;                                   // 0x0570(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECompetitionType                              _CurCompetitionType;                               // 0x0578(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_239D[0x7];                                     // 0x0579(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UCompetitionInfo*                       _CompetitionInfo;                                  // 0x0580(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCompetitionPlayer*                     _MyPlayer;                                         // 0x0588(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitWidget();
	struct FNetReply OnACK_GetCompetitionPlayers(EResultCode _rcode, const struct FACK_ReadCompetitionPlayers& _ack);
	void Setter_CurCompetitionType(ECompetitionType _competition_type);
	void UpdateRankingContext();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Popup_Competition">();
	}
	static class UPopup_Competition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPopup_Competition>();
	}
};
static_assert(alignof(UPopup_Competition) == 0x000008, "Wrong alignment on UPopup_Competition");
static_assert(sizeof(UPopup_Competition) == 0x000590, "Wrong size on UPopup_Competition");
static_assert(offsetof(UPopup_Competition, RankingListView) == 0x000570, "Member 'UPopup_Competition::RankingListView' has a wrong offset!");
static_assert(offsetof(UPopup_Competition, _CurCompetitionType) == 0x000578, "Member 'UPopup_Competition::_CurCompetitionType' has a wrong offset!");
static_assert(offsetof(UPopup_Competition, _CompetitionInfo) == 0x000580, "Member 'UPopup_Competition::_CompetitionInfo' has a wrong offset!");
static_assert(offsetof(UPopup_Competition, _MyPlayer) == 0x000588, "Member 'UPopup_Competition::_MyPlayer' has a wrong offset!");

// Class Stigma.Popup_EnterAccount
// 0x0040 (0x05B0 - 0x0570)
class UPopup_EnterAccount : public UPopupBase
{
public:
	class FString                                 _AccountID;                                        // 0x0570(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 _Password;                                         // 0x0580(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   Title;                                             // 0x0590(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_239F[0x8];                                     // 0x05A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void SetAccount(const class FString& _account_id, const class FString& _pw);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Popup_EnterAccount">();
	}
	static class UPopup_EnterAccount* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPopup_EnterAccount>();
	}
};
static_assert(alignof(UPopup_EnterAccount) == 0x000008, "Wrong alignment on UPopup_EnterAccount");
static_assert(sizeof(UPopup_EnterAccount) == 0x0005B0, "Wrong size on UPopup_EnterAccount");
static_assert(offsetof(UPopup_EnterAccount, _AccountID) == 0x000570, "Member 'UPopup_EnterAccount::_AccountID' has a wrong offset!");
static_assert(offsetof(UPopup_EnterAccount, _Password) == 0x000580, "Member 'UPopup_EnterAccount::_Password' has a wrong offset!");
static_assert(offsetof(UPopup_EnterAccount, Title) == 0x000590, "Member 'UPopup_EnterAccount::Title' has a wrong offset!");

// Class Stigma.Popup_EnterNickname
// 0x0018 (0x0588 - 0x0570)
class UPopup_EnterNickname : public UPopupBase
{
public:
	class FString                                 _nickname;                                         // 0x0570(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23A0[0x8];                                     // 0x0580(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool OnError(EResultCode _code);
	void SetNickname(const class FString& _nick);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Popup_EnterNickname">();
	}
	static class UPopup_EnterNickname* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPopup_EnterNickname>();
	}
};
static_assert(alignof(UPopup_EnterNickname) == 0x000008, "Wrong alignment on UPopup_EnterNickname");
static_assert(sizeof(UPopup_EnterNickname) == 0x000588, "Wrong size on UPopup_EnterNickname");
static_assert(offsetof(UPopup_EnterNickname, _nickname) == 0x000570, "Member 'UPopup_EnterNickname::_nickname' has a wrong offset!");

// Class Stigma.PropJointComponent
// 0x0080 (0x0120 - 0x00A0)
class alignas(0x10) UPropJointComponent final : public UActorComponent
{
public:
	class USceneComponent*                        BodyMesh;                                          // 0x00A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23A1[0x8];                                     // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class APropBase*                              Prop;                                              // 0x00B0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23A2[0x68];                                    // 0x00B8(0x0068)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PropJointComponent">();
	}
	static class UPropJointComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropJointComponent>();
	}
};
static_assert(alignof(UPropJointComponent) == 0x000010, "Wrong alignment on UPropJointComponent");
static_assert(sizeof(UPropJointComponent) == 0x000120, "Wrong size on UPropJointComponent");
static_assert(offsetof(UPropJointComponent, BodyMesh) == 0x0000A0, "Member 'UPropJointComponent::BodyMesh' has a wrong offset!");
static_assert(offsetof(UPropJointComponent, Prop) == 0x0000B0, "Member 'UPropJointComponent::Prop' has a wrong offset!");

// Class Stigma.Prop_Concealable
// 0x0000 (0x07F0 - 0x07F0)
class AProp_Concealable final : public APropBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Prop_Concealable">();
	}
	static class AProp_Concealable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProp_Concealable>();
	}
};
static_assert(alignof(AProp_Concealable) == 0x000010, "Wrong alignment on AProp_Concealable");
static_assert(sizeof(AProp_Concealable) == 0x0007F0, "Wrong size on AProp_Concealable");

// Class Stigma.Prop_StoreItemList
// 0x0010 (0x0038 - 0x0028)
class UProp_StoreItemList final : public UObject
{
public:
	TArray<class UProp_StoreItem*>                ItemList;                                          // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Prop_StoreItemList">();
	}
	static class UProp_StoreItemList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProp_StoreItemList>();
	}
};
static_assert(alignof(UProp_StoreItemList) == 0x000008, "Wrong alignment on UProp_StoreItemList");
static_assert(sizeof(UProp_StoreItemList) == 0x000038, "Wrong size on UProp_StoreItemList");
static_assert(offsetof(UProp_StoreItemList, ItemList) == 0x000028, "Member 'UProp_StoreItemList::ItemList' has a wrong offset!");

// Class Stigma.Prop_Throwable
// 0x0000 (0x07F0 - 0x07F0)
class AProp_Throwable final : public APropBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Prop_Throwable">();
	}
	static class AProp_Throwable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AProp_Throwable>();
	}
};
static_assert(alignof(AProp_Throwable) == 0x000010, "Wrong alignment on AProp_Throwable");
static_assert(sizeof(AProp_Throwable) == 0x0007F0, "Wrong size on AProp_Throwable");

// Class Stigma.Record_KillStreak_ListItemData
// 0x0058 (0x0080 - 0x0028)
class URecord_KillStreak_ListItemData final : public UObject
{
public:
	uint8                                         Pad_23A3[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TMap<EGameMode, int32>                        _ModeCountMap;                                     // 0x0030(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	int32 GetCount();
	class FText GetTooltipModeCountText();

	EKillStreak GetKillStreak() const;
	const TMap<EGameMode, int32> GetModeCounts() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Record_KillStreak_ListItemData">();
	}
	static class URecord_KillStreak_ListItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecord_KillStreak_ListItemData>();
	}
};
static_assert(alignof(URecord_KillStreak_ListItemData) == 0x000008, "Wrong alignment on URecord_KillStreak_ListItemData");
static_assert(sizeof(URecord_KillStreak_ListItemData) == 0x000080, "Wrong size on URecord_KillStreak_ListItemData");
static_assert(offsetof(URecord_KillStreak_ListItemData, _ModeCountMap) == 0x000030, "Member 'URecord_KillStreak_ListItemData::_ModeCountMap' has a wrong offset!");

// Class Stigma.ReferenceHolder
// 0x0058 (0x0080 - 0x0028)
class UReferenceHolder final : public UObject
{
public:
	uint8                                         Pad_23A4[0x8];                                     // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TSet<class UObject*>                          _Objects;                                          // 0x0030(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReferenceHolder">();
	}
	static class UReferenceHolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReferenceHolder>();
	}
};
static_assert(alignof(UReferenceHolder) == 0x000008, "Wrong alignment on UReferenceHolder");
static_assert(sizeof(UReferenceHolder) == 0x000080, "Wrong size on UReferenceHolder");
static_assert(offsetof(UReferenceHolder, _Objects) == 0x000030, "Member 'UReferenceHolder::_Objects' has a wrong offset!");

// Class Stigma.RegistryDataTable
// 0x0050 (0x0100 - 0x00B0)
class URegistryDataTable final : public UDataTable
{
public:
	TMap<class FString, struct FRegistryStructMap> _RegistryDatas;                                    // 0x00B0(0x0050)(Edit, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RegistryDataTable">();
	}
	static class URegistryDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<URegistryDataTable>();
	}
};
static_assert(alignof(URegistryDataTable) == 0x000008, "Wrong alignment on URegistryDataTable");
static_assert(sizeof(URegistryDataTable) == 0x000100, "Wrong size on URegistryDataTable");
static_assert(offsetof(URegistryDataTable, _RegistryDatas) == 0x0000B0, "Member 'URegistryDataTable::_RegistryDatas' has a wrong offset!");

// Class Stigma.ReleaseProp
// 0x0000 (0x0030 - 0x0030)
class UReleaseProp final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReleaseProp">();
	}
	static class UReleaseProp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReleaseProp>();
	}
};
static_assert(alignof(UReleaseProp) == 0x000008, "Wrong alignment on UReleaseProp");
static_assert(sizeof(UReleaseProp) == 0x000030, "Wrong size on UReleaseProp");

// Class Stigma.RewardHelper
// 0x0000 (0x0028 - 0x0028)
class URewardHelper final : public UBlueprintFunctionLibrary
{
public:
	static bool GetAllAccessoryID(const TArray<struct FRewardItem>& _reward_items, TArray<struct FItemID>* _out_accessory_id);
	static bool GetAllGunPartsID(const TArray<struct FRewardItem>& _reward_items, TArray<struct FItemID>* _out_parts_id);
	static bool IsRewardItemHasDuration(const struct FRewardItem& _reward_item, bool* _out_is_permanent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RewardHelper">();
	}
	static class URewardHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<URewardHelper>();
	}
};
static_assert(alignof(URewardHelper) == 0x000008, "Wrong alignment on URewardHelper");
static_assert(sizeof(URewardHelper) == 0x000028, "Wrong size on URewardHelper");

// Class Stigma.RichTextBlockKeyDecorator
// 0x0008 (0x0030 - 0x0028)
class URichTextBlockKeyDecorator final : public URichTextBlockDecorator
{
public:
	class UDataTable*                             ImageTextSet;                                      // 0x0028(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichTextBlockKeyDecorator">();
	}
	static class URichTextBlockKeyDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<URichTextBlockKeyDecorator>();
	}
};
static_assert(alignof(URichTextBlockKeyDecorator) == 0x000008, "Wrong alignment on URichTextBlockKeyDecorator");
static_assert(sizeof(URichTextBlockKeyDecorator) == 0x000030, "Wrong size on URichTextBlockKeyDecorator");
static_assert(offsetof(URichTextBlockKeyDecorator, ImageTextSet) == 0x000028, "Member 'URichTextBlockKeyDecorator::ImageTextSet' has a wrong offset!");

// Class Stigma.RollingBase
// 0x0070 (0x0850 - 0x07E0)
class ARollingBase final : public AThrowBase
{
public:
	uint8                                         Pad_23A8[0x30];                                    // 0x07E0(0x0030)(Fixing Size After Last Property [ Dumper-69 ])
	struct FRollingParams                         _RollingParams;                                    // 0x0810(0x0040)(NoDestructor, NativeAccessSpecifierPublic)

public:
	void RPC_ALL_Hit_Rolling(const struct FHitData& _hit);
	void RPC_ALL_StartRolling(const struct FRollingParams& _rolling_params);
	void SERVER_RequestRolling(class AActor* _Actor, EAttackType _attack_type, const struct FVector& _target_point, float _max_dist, float _Speed, float _radius, float _gravity_scale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RollingBase">();
	}
	static class ARollingBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARollingBase>();
	}
};
static_assert(alignof(ARollingBase) == 0x000010, "Wrong alignment on ARollingBase");
static_assert(sizeof(ARollingBase) == 0x000850, "Wrong size on ARollingBase");
static_assert(offsetof(ARollingBase, _RollingParams) == 0x000810, "Member 'ARollingBase::_RollingParams' has a wrong offset!");

// Class Stigma.SanctumArea
// 0x0070 (0x0308 - 0x0298)
class ASanctumArea final : public AActor
{
public:
	class USceneComponent*                        _Root;                                             // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          _Box;                                              // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeams                                        Team;                                              // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23AA[0x7];                                     // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TSet<class ACharaBase*>                       _EnteredCharas;                                    // 0x02B0(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_23AB[0x8];                                     // 0x0300(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Activate();
	void Deactivate();
	void OnBeginOverlap(class UPrimitiveComponent* _comp, class AActor* _other_actor, class UPrimitiveComponent* _other_comp, int32 _idx_body, bool _from_sweep, const struct FHitResult& _hit);
	void OnEndOverlap(class UPrimitiveComponent* _comp, class AActor* _other_actor, class UPrimitiveComponent* _other_comp, int32 _idx_body);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SanctumArea">();
	}
	static class ASanctumArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASanctumArea>();
	}
};
static_assert(alignof(ASanctumArea) == 0x000008, "Wrong alignment on ASanctumArea");
static_assert(sizeof(ASanctumArea) == 0x000308, "Wrong size on ASanctumArea");
static_assert(offsetof(ASanctumArea, _Root) == 0x000298, "Member 'ASanctumArea::_Root' has a wrong offset!");
static_assert(offsetof(ASanctumArea, _Box) == 0x0002A0, "Member 'ASanctumArea::_Box' has a wrong offset!");
static_assert(offsetof(ASanctumArea, Team) == 0x0002A8, "Member 'ASanctumArea::Team' has a wrong offset!");
static_assert(offsetof(ASanctumArea, _EnteredCharas) == 0x0002B0, "Member 'ASanctumArea::_EnteredCharas' has a wrong offset!");

// Class Stigma.ServerSession
// 0x0020 (0x0048 - 0x0028)
class UServerSession final : public UObject
{
public:
	uint8                                         Pad_23AE[0x20];                                    // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerSession">();
	}
	static class UServerSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServerSession>();
	}
};
static_assert(alignof(UServerSession) == 0x000008, "Wrong alignment on UServerSession");
static_assert(sizeof(UServerSession) == 0x000048, "Wrong size on UServerSession");

// Class Stigma.Service
// 0x0000 (0x0028 - 0x0028)
class UService final : public UBlueprintFunctionLibrary
{
public:
	static void ActivateBattlePass(const class UObject* _world_ctx, const struct FItemID_BattlePass& _pass_id, TDelegate<void(EResultCode _rcode, struct FACK_BattlePassActivate& _ack)> _proc);
	static void ActivateCoupon(const class UObject* _world_ctx, const class FString& _coupon_code, const TDelegate<void(EResultCode _rcode, struct FACK_ActivateCoupon& _ack)>& _proc);
	static void ActivateFunction(const class UObject* _world_ctx, class UInvenItem* _item, const TDelegate<void(EResultCode _code, struct FACK_ActivateFunction& _ack)>& _proc);
	static void AddWishedGameMode(const class UObject* _world_ctx, EGameMode _game_mode);
	static void ApplyPreviewCharacterSettings(const class UObject* _world_ctx, const struct FUserID& _user_id, const TDelegate<void(EResultCode _rcode, struct FApiResult& _ack)>& _proc);
	static void AskFriend(const class UObject* _world_ctx, const struct FUserID& _target_user_id, const struct FUserName& _nickname, TDelegate<void(EResultCode _rcode, struct FACK_Friend& _ack)> _proc);
	static void AutoRewardMission(const class UObject* _world_ctx);
	static void BookmarkPassMission(const class UObject* _world_ctx, const struct FItemID_BattlePass& _pass_id, int32 _idx, const struct FItemID_Mission& _mission_id, TDelegate<void(EResultCode _rcode, struct FACK_MissionBookmark& _ack)> _proc);
	static void BuyGoods(const class UObject* _world_ctx, const struct FItemIDPlain& _goods_item, const struct FCurrencyPlain& _using_currency, TDelegate<void(EResultCode _rcode, struct FACK_BuyGoods& _ack)> _proc);
	static void BuyRecruit(const class UObject* _world_ctx, const struct FItemID_Recruit& _recruit_id, int32 _recruit_count_index, const struct FItemID_Currency& _use_currency_id, int32 _use_currency_amount, const TDelegate<void(EResultCode _rcode, struct FACK_BuyRecruit& _ack)>& _proc);
	static void CancelMatchMaking(const class UObject* _world_ctx, const struct FUserID& _user_id, TDelegate<void(EResultCode _rcode, struct FApiResult& _ack)> _proc);
	static bool CanStartMatchMaking(const class UObject* _world_ctx);
	static void ChangeMission(const class UObject* _world_ctx, const struct FItemID& _task_id, int32 _idx, const struct FItemID_Mission& _mission_id, TDelegate<void(EResultCode _rcode, struct FACK_MissionChange& _ack)> _proc);
	static void ChangeNickname(const class UObject* _world_ctx, class UInvenItem* _item, const class FString& _nickname, const TDelegate<void(EResultCode _rcode)>& _proc);
	static void DeleteFriend(const class UObject* _world_ctx, const struct FUserID& _target_user_id, TDelegate<void(EResultCode _rcode, const struct FUserID& _user_id)> _proc);
	static void DISCORD_StartBattle(const class UObject* _world_ctx);
	static void DISCORD_StartLobby(const class UObject* _world_ctx);
	static bool ExitParty(const class UObject* _world_ctx, TDelegate<void(EResultCode _rcode, struct FACK_PartyDelete& _ack)> _proc);
	static void FastStartCompetition(const class UObject* _world_ctx, const struct FCurrencyPlain& _currency, const ECompetitionType _competition_type, TDelegate<void(EResultCode _rcode, struct FACK_FastStartCompetition& _ack)> _proc);
	static void GetChallengeRankingList(const class UObject* _world_ctx, int64 _start, int64 _count, TDelegate<void(EResultCode _rcode, struct FACK_ReadChallengeRanking& _ack)> _proc);
	static void GetCompetitionPlayers(const class UObject* _world_ctx, TDelegate<void(EResultCode _rcode, struct FACK_ReadCompetitionPlayers& _ack)> _proc);
	static EFindMatchStatus GetCurrentMatchMakingStatus(const class UObject* _world_ctx);
	static void GetFriendRankingList(const class UObject* _world_ctx, int64 _start, int64 _count, const struct FSeasonID& _season_id, ERankingType _ranking_type, TDelegate<void(EResultCode _rcode, struct FACK_ReadFriendRanking& _ack)> _proc);
	static void GetLoginNotice(const class UObject* _world_ctx, const TDelegate<void(EResultCode _rcode, struct FACK_LoginNotice& _ack)>& _proc);
	static const struct FMatchContext GetMatchMakingContext(const class UObject* _world_ctx);
	static struct FTimespan GetMatchMakingElapsedTime(const class UObject* _world_ctx);
	static class FText GetMatchMakingErrorMessage(const class UObject* _world_ctx);
	static const struct FMatchOption GetMatchOption(const class UObject* _world_ctx);
	static void GetRankingList(const class UObject* _world_ctx, int64 _start, int64 _count, const struct FSeasonID& _season_id, ERankingType _ranking_type, TDelegate<void(EResultCode _rcode, struct FACK_ReadRanking& _ack)> _proc);
	static void GetSearchedUserRankingList(const class UObject* _world_ctx, const struct FUserID& _user_id, int64 _count, const struct FSeasonID& _season_id, ERankingType _ranking_type, TDelegate<void(EResultCode _rcode, struct FACK_ReadSearchedUserRanking& _ack)> _proc);
	static void GetSurvey(const class UObject* _world_ctx, int32 _survey_id);
	static void GetUserReportJWT(const class UObject* _world_ctx, const struct FUserName& _user_nickname, const struct FUserID& _user_id, const class FString& _dedi_id, const class FString& _battle_id, TDelegate<void(EResultCode _rcode, struct FACK_GetUserReportJWT& _ack)> _proc);
	static void GetUserTierInfo(const class UObject* _world_ctx, const struct FUserID& _user_id, const struct FSeasonID& _season_id, TDelegate<void(EResultCode _rcode, struct FACK_ReadUserTierInfo& _ack)> _proc);
	static void GetWeeklyBestRank(const class UObject* _world_ctx, const struct FSeasonID& _season_id, ERankingType _ranking_type, TDelegate<void(EResultCode _rcode, struct FACK_ReadWeeklyBestRank& _ack)> _proc);
	static const TArray<EGameMode> GetWishedGameModes(const class UObject* _world_ctx);
	static void GM_StalkRoom(const class UObject* _world_ctx, const struct FUserID& _target_user_id);
	static void InviteToBattle(const class UObject* _world_ctx, const struct FUserID& _to, const class FString& _to_nick);
	static bool IsInWishedGameMode(const class UObject* _world_ctx, EGameMode _game_mode);
	static bool IsMatchMaking(const class UObject* _world_ctx);
	static bool IsMatchMakingCompleted(const class UObject* _world_ctx);
	static void LoadUser(const class UObject* _world_ctx);
	static void LoadUserCurrency(const class UObject* _world_ctx);
	static void OpenInvenItem(const class UObject* _world_ctx, const TArray<class UInvenItem*>& _items, const TDelegate<void(EResultCode _code, struct FACK_OpenInvenItems& _ack)>& _proc);
	static void PickInitialCharacters(const class UObject* _world_ctx, const struct FUserID& _user_id, const TArray<ECharaType>& _picked_types);
	static void PlayBattleOnClientSide(const class UObject* _world_ctx, EGameMode _mode, class FName _map_name, bool _allow_all_chara, bool _is_tutorial_match);
	static void ReadGoods(const class UObject* _world_ctx, EGoodsCategory _category);
	static void ReadHistoryRecruit(const class UObject* _world_ctx, ERecruitType _recruit_type, int32 _cursor, int32 _req_count, const TDelegate<void(EResultCode _rcode, struct FACK_ReadHistoryRecruit& _ack)>& _proc);
	static void ReadMissions(const class UObject* _world_ctx, const TArray<struct FItemID>& _task_ids, TDelegate<void(EResultCode _rcode, struct FACK_MissionRead& _ack)> _proc);
	static void ReadProfileStatistic(const class UObject* _world_ctx, const struct FUserID& _user_id, const TDelegate<void(EResultCode _rcode, struct FACK_ProfileStatisticRead& _ack)>& _proc);
	static void ReadRecruit(const class UObject* _world_ctx, const TDelegate<void(EResultCode _rcode, struct FACK_ReadRecruit& _ack)>& _proc);
	static void RegisterNotify_OnMatchChanged(const class UObject* _world_ctx, const TDelegate<void()>& _callback);
	static void RemoveWishedGameMode(const class UObject* _world_ctx, EGameMode _game_mode);
	static void ReplyFriendAsk(const class UObject* _world_ctx, const struct FUserID& _target_user_id, const struct FUserName& _nick, bool _accept, TDelegate<void(EResultCode _rcode, struct FACK_FriendUpdate& _ack)> _proc);
	static void ReplyInviteToBattle(const class UObject* _world_ctx, const struct FREQ_InviteToBattle& _invite, EInviteReply _Reply);
	static void ResetSkillPoint(const class UObject* _world_ctx, class UInvenItem* _item, const TDelegate<void(EResultCode _code, struct FACK_ResetSkillPoint& _ack)>& _proc);
	static void RevertPreviewCharacterSettings(const class UObject* _world_ctx);
	static void RewardBattlePass(const class UObject* _world_ctx, const struct FItemID_BattlePass& _pass_id, int32 _level, TDelegate<void(EResultCode _rcode, struct FACK_BattlePassReward& _ack)> _proc);
	static void RewardEventPage(const class UObject* _world_ctx, const struct FItemID_EventPage& _event_page_id, bool _is_option, TDelegate<void(EResultCode _rcode, struct FACK_EventPageReward& _ack)> _proc);
	static void RewardMission(const class UObject* _world_ctx, const struct FItemID& _task_id, int32 _idx, const struct FItemID_Mission& _mission_id, TDelegate<void(EResultCode _rcode, struct FACK_MissionReward& _ack)> _proc);
	static void SearchUser(const class UObject* _world_ctx, const class FString& _search_nickname, TDelegate<void(EResultCode _rcode, struct FACK_SearchUser& _ack)> _proc);
	static void SetCharacterSetting(const class UObject* _world_ctx, const struct FUserID& _user_id, ECharaType _chara_type, const struct FItemID& _item_id, int32 _slot_zidx, TDelegate<void(EResultCode _rcode, struct FApiResult& _ack)> _proc);
	static void SetCharacterSetting_NoAck(const class UObject* _world_ctx, const struct FUserID& _user_id, ECharaType _chara_type, const struct FItemID& _item_id, int32 _slot_zidx);
	static void SetCharacterSettings(const class UObject* _world_ctx, const struct FUserID& _user_id, ECharaType _chara_type, const TArray<struct FItemSetting>& _settings, TDelegate<void(EResultCode _rcode, struct FApiResult& _ack)> _proc);
	static void SetCharacterSettings_NoAck(const class UObject* _world_ctx, const struct FUserID& _user_id, ECharaType _chara_type, const TArray<struct FItemSetting>& _settings);
	static void SetCurrentCharacter(const class UObject* _world_ctx, const struct FUserID& _user_id, ECharaType _chara_type, TDelegate<void(EResultCode _rcode, struct FApiResult& _ack)> _proc);
	static void SetGunSetting(const class UObject* _world_ctx, const class UGunObject* _gun_object, const TDelegate<void(EResultCode _rcode, struct FACK_UpdateGunSpec& _ack)>& _proc);
	static void SetGunType(const class UObject* _world_ctx, const struct FUserID& _user_id, ECharaType _chara_type, const struct FGunPreset& _gun_preset, TDelegate<void(EResultCode _rcode, struct FApiResult& _ack)> _proc);
	static void SetUserPlayingAt(const class UObject* _world_ctx, EUserPlayingAt _playing_at);
	static void SetWishedGameMode(const class UObject* _world_ctx, EGameMode _game_mode);
	static void StartMatchMaking(const class UObject* _world_ctx, const struct FUserID& _user_id, EGameMode _game_mode, const struct FMatchOption& _option, TDelegate<void(EResultCode _rcode, struct FACK_FindMatch& _ack)> _proc);
	static void Subscribe_OnUpdateUser(const class UObject* _world_ctx, const TSet<EUserEvent>& _events, const TDelegate<void(EUserEvent _event)>& _proc);
	static void UnregisterNotify_OnMatchChanged(const class UObject* _world_ctx, const class UObject* _obj);
	static void Unsubscribe_OnUpdateUser(const class UObject* _world_ctx, const class UObject* _obj);
	static void UpdateBooster(const class UObject* _world_ctx, const int32 _slot_index, const struct FItemID& _item_id);
	static void UpdateEmblem(const class UObject* _world_ctx, const struct FItemID& _item_id, const TDelegate<void(EResultCode _rcode, struct FACK_EmblemUpdate& _ack)>& _proc);
	static void UpdateNicknameFX(const class UObject* _world_ctx, const struct FItemID& _item_id, const TDelegate<void(EResultCode _rcode, struct FACK_SingleItemUpdate& _ack)>& _proc);
	static bool UpdatePartyGameMode(const class UObject* _world_ctx, const EGameMode& _game_mode);
	static void UpdateProfileCard(const class UObject* _world_ctx, const struct FItemID& _item_id, const TDelegate<void(EResultCode _rcode, struct FACK_ProfileCardUpdate& _ack)>& _proc);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Service">();
	}
	static class UService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UService>();
	}
};
static_assert(alignof(UService) == 0x000008, "Wrong alignment on UService");
static_assert(sizeof(UService) == 0x000028, "Wrong size on UService");

// Class Stigma.SharedPlayerStateBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class USharedPlayerStateBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool IsRoomLeader(const struct FUserInBattle& _user);
	static bool IsRoomManager(const struct FUserInBattle& _user);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SharedPlayerStateBlueprintLibrary">();
	}
	static class USharedPlayerStateBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USharedPlayerStateBlueprintLibrary>();
	}
};
static_assert(alignof(USharedPlayerStateBlueprintLibrary) == 0x000008, "Wrong alignment on USharedPlayerStateBlueprintLibrary");
static_assert(sizeof(USharedPlayerStateBlueprintLibrary) == 0x000028, "Wrong size on USharedPlayerStateBlueprintLibrary");

// Class Stigma.ShopGoodsHelper
// 0x0000 (0x0028 - 0x0028)
class UShopGoodsHelper final : public UBlueprintFunctionLibrary
{
public:
	static EGoodsCategory GetGoodsCategoryFromItemCategory(EItemCategory _category);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShopGoodsHelper">();
	}
	static class UShopGoodsHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShopGoodsHelper>();
	}
};
static_assert(alignof(UShopGoodsHelper) == 0x000008, "Wrong alignment on UShopGoodsHelper");
static_assert(sizeof(UShopGoodsHelper) == 0x000028, "Wrong size on UShopGoodsHelper");

// Class Stigma.ShopSubsys
// 0x0000 (0x0030 - 0x0030)
class UShopSubsys final : public UGameInstanceSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShopSubsys">();
	}
	static class UShopSubsys* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShopSubsys>();
	}
};
static_assert(alignof(UShopSubsys) == 0x000008, "Wrong alignment on UShopSubsys");
static_assert(sizeof(UShopSubsys) == 0x000030, "Wrong size on UShopSubsys");

// Class Stigma.SkinBaseActor
// 0x0010 (0x02A8 - 0x0298)
class ASkinBaseActor : public AActor
{
public:
	class USkeletalMeshComponent*                 _RootMeshComponent;                                // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _For1PV;                                           // 0x02A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23DF[0x7];                                     // 0x02A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkinBaseActor">();
	}
	static class ASkinBaseActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASkinBaseActor>();
	}
};
static_assert(alignof(ASkinBaseActor) == 0x000008, "Wrong alignment on ASkinBaseActor");
static_assert(sizeof(ASkinBaseActor) == 0x0002A8, "Wrong size on ASkinBaseActor");
static_assert(offsetof(ASkinBaseActor, _RootMeshComponent) == 0x000298, "Member 'ASkinBaseActor::_RootMeshComponent' has a wrong offset!");
static_assert(offsetof(ASkinBaseActor, _For1PV) == 0x0002A0, "Member 'ASkinBaseActor::_For1PV' has a wrong offset!");

// Class Stigma.SocialContext
// 0x03A0 (0x03D0 - 0x0030)
class USocialContext final : public UGameInstanceSubsystem
{
public:
	TMap<struct FUserID, class UUserProfile*>     _UserProfileMap;                                   // 0x0030(0x0050)(NativeAccessSpecifierPrivate)
	TArray<class UUserProfile*>                   _MyFriendList;                                     // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UUserProfile*>                   _RecentUserList;                                   // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UUserProfile*>                   _SteamFriendList;                                  // 0x00A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UUserProfile*>                   _FriendAskedList;                                  // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UUserProfile*>                   _SearchedUserList;                                 // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<struct FUserID, struct FDateTime>        _FriendReqTimeMap;                                 // 0x00D0(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_23E0[0x8];                                     // 0x0120(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class UUserProfile*>                   _FriendAskNotifyList;                              // 0x0128(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23E1[0xE0];                                    // 0x0138(0x00E0)(Fixing Size After Last Property [ Dumper-69 ])
	class UBriefParty*                            _MyParty;                                          // 0x0218(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FUserID, struct FDateTime>        _PartyReqTimeMap;                                  // 0x0220(0x0050)(NativeAccessSpecifierPrivate)
	TArray<struct FPartyInviteNotify>             _PartyInviteNotifyList;                            // 0x0270(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_23E2[0xE8];                                    // 0x0280(0x00E8)(Fixing Size After Last Property [ Dumper-69 ])
	TMap<struct FUserID, struct FDateTime>        _InviteBattleReqTimeMap;                           // 0x0368(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_23E3[0x18];                                    // 0x03B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool CheckCanInvitePartyTarget(const struct FUserID& _target_user_id);
	bool CheckImPartyLeader();
	bool CheckIsPartyLeader(const struct FUserID& _user_id);
	class UUserProfile* DequeueAskFriendNotify();
	const class UUserProfile* FindMyFriend(const struct FUserID& _user_id);
	class UUserProfile* FindPartyMember(const struct FUserID& _user_id);
	const TMap<struct FUserID, struct FDateTime> GetPartyReqTimeMap();
	int32 GetRemainAskFriendNotifyCount();
	int32 GetRemainFriendAskNotifyCount();
	int32 GetRemainPartyInviteNotifyCount();
	bool IsInAskFriendReqCoolTime(const struct FUserID& _user_id, const struct FUserName& _nickname);
	bool IsInInviteBattleCoolTime(const struct FUserID& _user_id, const struct FUserName& _nickname);
	bool IsInPartyReqCoolTime(const struct FUserID& _user_id);
	void NotifyPartyInviteCReq(const struct FPartyID& _party_id, const struct FUserID& _user_id, const struct FUserName& _nick);
	void NotifyUpdateMyFriends(const struct FUserID& _friend_id, const struct FUserName& _user_name, bool _is_accepted);
	void RecordAskFriendReq(const struct FUserID& _user_id);
	void RecordInviteBattleReq(const struct FUserID& _user_id);
	void RecordUserPartyReq(const struct FUserID& _user_id);
	void RegisterOnAskedFriendListUpdated(const TDelegate<void(TArray<class UUserProfile*>& _steam_friends)>& _callback);
	void RegisterOnFriendAskCreateBCRecv(const TDelegate<void(class UUserProfile* _message)>& _callback);
	void RegisterOnFriendAskUpdateBCRecv(const TDelegate<void(class UUserProfile* _user, bool _is_accept)>& _callback);
	void RegisterOnFriendAskUpdated(const TDelegate<void(TArray<class UUserProfile*>& _asked_users)>& _callback);
	void RegisterOnFriendDeleted(const TDelegate<void(class UUserProfile* _removed)>& _callback);
	void RegisterOnFriendReqCoolTime(const TDelegate<void(struct FUserID& _target_user_id, struct FUserName& _target_nickname)>& _callback);
	void RegisterOnMyFriendListUpdated(const TDelegate<void(TArray<class UUserProfile*>& _steam_friends)>& _callback);
	void RegisterOnMyPartyEntered(const TDelegate<void(class UBriefParty* _party)>& _callback);
	void RegisterOnMyPartyExited(const TDelegate<void()>& _callback);
	void RegisterOnPartyCharaUpdated(const TDelegate<void(struct FUserID& _user_id, struct FCharSpec& _chara_info)>& _callback);
	void RegisterOnPartyInviteCReqRecv(const TDelegate<void(struct FPartyID& _party_id, class UUserProfile* _from_user)>& _callback);
	void RegisterOnPartyInviteReq(const TDelegate<void(struct FUserID& _user_id)>& _callback);
	void RegisterOnPartyLeaderUpdated(const TDelegate<void(struct FUserID& _leader_id)>& _callback);
	void RegisterOnPartyMemberAdded(const TDelegate<void(class UBriefParty* _party, class UUserProfile* _member)>& _callback);
	void RegisterOnPartyMemberDeleted(const TDelegate<void(class UBriefParty* _party, struct FUserID& _user_id)>& _callback);
	void RegisterOnRecentPlayerListUpdated(const TDelegate<void(TArray<class UUserProfile*>& _steam_friends)>& _callback);
	void RegisterOnSteamFriendListUpdated(const TDelegate<void(TArray<class UUserProfile*>& _steam_friends)>& _callback);
	void RemoveAskFriendReqRecord(const struct FUserID& _user_id);
	void RemoveInviteBattleRecord(const struct FUserID& _user_id);
	bool RemoveMyFriend(const struct FUserID& _user_id);
	void RemoveMyParty(const struct FPartyID& _party_id, const struct FUserID& _remove_user_id);
	bool RemovePartyMember(const struct FPartyID& _party_id, const struct FUserID& _user_id, const struct FUserID& _next_party_leader);
	void RemoveUserPartyReqRecord(const struct FUserID& _user_id);
	bool SetMyParty(const struct FPartyID& _party_id, const struct FUserID& _leader_id, const EGameMode _game_mode, const TArray<struct FUserID>& _members);
	bool SetPartyLeader(const struct FPartyID& _party_id, const struct FUserID& _leader_id);
	void SubscribeInviteToBattle(const TDelegate<void(struct FREQ_InviteToBattle& _invite)>& _proc);
	void UnregisterAllCallbacks(const class UObject* _obj);
	void UnsubscribeInviteToBattle(const class UObject* _obj);
	bool UpdatePartyCharacter(const struct FPartyID& _party_id, const struct FUserID& _user_info, const struct FCharSpec& _chara_info, bool _invoke_callback);

	bool CheckCanAskFriendTarget(const struct FUserID& _target_user_id) const;
	bool CheckCanJoinPartyTarget(const struct FUserID& _target_user_id) const;
	bool CheckHasRestPartySlot() const;
	bool CheckIsAskedFriend(const struct FUserID& _user_id) const;
	bool CheckIsMyFriend(const struct FUserID& _user_id) const;
	bool CheckIsMyFriendNickname(const struct FUserName& _nickname) const;
	int32 GetMaxPartyMemberCount() const;
	class UBriefParty* GetMyParty() const;
	class UUserProfile* GetUser(const struct FUserID& _user_id) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialContext">();
	}
	static class USocialContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<USocialContext>();
	}
};
static_assert(alignof(USocialContext) == 0x000008, "Wrong alignment on USocialContext");
static_assert(sizeof(USocialContext) == 0x0003D0, "Wrong size on USocialContext");
static_assert(offsetof(USocialContext, _UserProfileMap) == 0x000030, "Member 'USocialContext::_UserProfileMap' has a wrong offset!");
static_assert(offsetof(USocialContext, _MyFriendList) == 0x000080, "Member 'USocialContext::_MyFriendList' has a wrong offset!");
static_assert(offsetof(USocialContext, _RecentUserList) == 0x000090, "Member 'USocialContext::_RecentUserList' has a wrong offset!");
static_assert(offsetof(USocialContext, _SteamFriendList) == 0x0000A0, "Member 'USocialContext::_SteamFriendList' has a wrong offset!");
static_assert(offsetof(USocialContext, _FriendAskedList) == 0x0000B0, "Member 'USocialContext::_FriendAskedList' has a wrong offset!");
static_assert(offsetof(USocialContext, _SearchedUserList) == 0x0000C0, "Member 'USocialContext::_SearchedUserList' has a wrong offset!");
static_assert(offsetof(USocialContext, _FriendReqTimeMap) == 0x0000D0, "Member 'USocialContext::_FriendReqTimeMap' has a wrong offset!");
static_assert(offsetof(USocialContext, _FriendAskNotifyList) == 0x000128, "Member 'USocialContext::_FriendAskNotifyList' has a wrong offset!");
static_assert(offsetof(USocialContext, _MyParty) == 0x000218, "Member 'USocialContext::_MyParty' has a wrong offset!");
static_assert(offsetof(USocialContext, _PartyReqTimeMap) == 0x000220, "Member 'USocialContext::_PartyReqTimeMap' has a wrong offset!");
static_assert(offsetof(USocialContext, _PartyInviteNotifyList) == 0x000270, "Member 'USocialContext::_PartyInviteNotifyList' has a wrong offset!");
static_assert(offsetof(USocialContext, _InviteBattleReqTimeMap) == 0x000368, "Member 'USocialContext::_InviteBattleReqTimeMap' has a wrong offset!");

// Class Stigma.SpawnActor
// 0x0098 (0x00C8 - 0x0030)
class USpawnActor final : public UAnimNotifyState
{
public:
	TSubclassOf<class AActor>                     ActorType;                                         // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LocationOffset;                                    // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               RotationOffset;                                    // 0x0050(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          AttachToCharacter;                                 // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23F5[0x3];                                     // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class FName                                   AttachSocket;                                      // 0x006C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DestroyAtEnd;                                      // 0x0074(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          SpawnOnServerOnly;                                 // 0x0075(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_23F6[0x2];                                     // 0x0076(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	TMap<class USkeletalMeshComponent*, class AActor*> _SpawnedActors;                                    // 0x0078(0x0050)(BlueprintReadOnly, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnActor">();
	}
	static class USpawnActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpawnActor>();
	}
};
static_assert(alignof(USpawnActor) == 0x000008, "Wrong alignment on USpawnActor");
static_assert(sizeof(USpawnActor) == 0x0000C8, "Wrong size on USpawnActor");
static_assert(offsetof(USpawnActor, ActorType) == 0x000030, "Member 'USpawnActor::ActorType' has a wrong offset!");
static_assert(offsetof(USpawnActor, LocationOffset) == 0x000038, "Member 'USpawnActor::LocationOffset' has a wrong offset!");
static_assert(offsetof(USpawnActor, RotationOffset) == 0x000050, "Member 'USpawnActor::RotationOffset' has a wrong offset!");
static_assert(offsetof(USpawnActor, AttachToCharacter) == 0x000068, "Member 'USpawnActor::AttachToCharacter' has a wrong offset!");
static_assert(offsetof(USpawnActor, AttachSocket) == 0x00006C, "Member 'USpawnActor::AttachSocket' has a wrong offset!");
static_assert(offsetof(USpawnActor, DestroyAtEnd) == 0x000074, "Member 'USpawnActor::DestroyAtEnd' has a wrong offset!");
static_assert(offsetof(USpawnActor, SpawnOnServerOnly) == 0x000075, "Member 'USpawnActor::SpawnOnServerOnly' has a wrong offset!");
static_assert(offsetof(USpawnActor, _SpawnedActors) == 0x000078, "Member 'USpawnActor::_SpawnedActors' has a wrong offset!");

// Class Stigma.SpectatorBase
// 0x0000 (0x0348 - 0x0348)
class ASpectatorBase : public ASpectatorPawn
{
public:
	void ViewNext();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpectatorBase">();
	}
	static class ASpectatorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASpectatorBase>();
	}
};
static_assert(alignof(ASpectatorBase) == 0x000008, "Wrong alignment on ASpectatorBase");
static_assert(sizeof(ASpectatorBase) == 0x000348, "Wrong size on ASpectatorBase");

// Class Stigma.SpecterAnimInstance
// 0x04D0 (0x0820 - 0x0350)
class USpecterAnimInstance : public UAnimInstance
{
public:
	bool                                          _IsDediServer;                                     // 0x0348(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23F7[0x7];                                     // 0x0349(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FCharaMovementAnimation                CharaMovementAnim;                                 // 0x0350(0x0138)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FCharaOutroAnimation                   CharaOutroAnim;                                    // 0x0488(0x0020)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UBlendSpace*                            CurrentLowerBlendSpace;                            // 0x04A8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      CurrentIdleAnim;                                   // 0x04B0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      CurrentOptionalPose;                               // 0x04B8(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      LoadMagazineAnim_1PV;                              // 0x04C0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOptionalPose;                                    // 0x04C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAimming;                                         // 0x04C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23F8[0x6];                                     // 0x04CA(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	class ACharaBase*                             _OwnerChara;                                       // 0x04D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _IsFire;                                           // 0x04D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23F9[0x3];                                     // 0x04D9(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         _Speed;                                            // 0x04DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _Speed_Forward;                                    // 0x04E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _Speed_Right;                                      // 0x04E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _BlendSpace_Speed_Forward;                         // 0x04E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _BlendSpace_Speed_Right;                           // 0x04EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _BlendSpace_Stand_PlayRate;                        // 0x04F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _BlendSpace_Crouch_PlayRate;                       // 0x04F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _Distance_Match_PlayRate;                          // 0x04F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _IsEquippedDotSight;                               // 0x04FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _HasAccel;                                         // 0x04FD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23FA[0x2];                                     // 0x04FE(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         _Acceleration;                                     // 0x0500(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23FB[0x4];                                     // 0x0504(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FVector                                _Velocity;                                         // 0x0508(0x0018)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _IsFalling;                                        // 0x0520(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _IsJumping;                                        // 0x0521(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _IsMaintanFirePosture;                             // 0x0522(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _IsUnfireable;                                     // 0x0523(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESprintState                                  _SprintState;                                      // 0x0524(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _PostponedDeath;                                   // 0x0525(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _IsAlreadyLiedDeathPose;                           // 0x0526(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBodyLowerState                               _LowerState;                                       // 0x0527(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBodyLowerAction                              _LowerAction;                                      // 0x0528(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBodyUpperState                               _UpperState;                                       // 0x0529(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharaAction                                  _ActionSlot;                                       // 0x052A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23FC[0x5];                                     // 0x052B(0x0005)(Fixing Size After Last Property [ Dumper-69 ])
	struct FRotator                               _TargettingRotator;                                // 0x0530(0x0018)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                _OwnerForwardVector;                               // 0x0548(0x0018)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _OwnerRightVector;                                 // 0x0560(0x0018)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                _RollDirection;                                    // 0x0578(0x0018)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBodyParts                                    _LegInjuryParts;                                   // 0x0590(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23FD[0x3];                                     // 0x0591(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	struct FInterpFloat                           _LegInjury_LRate;                                  // 0x0594(0x000C)(Edit, BlueprintVisible, Transient, NoDestructor, NativeAccessSpecifierPublic)
	struct FInterpFloat                           _LegInjury_RRate;                                  // 0x05A0(0x000C)(Edit, BlueprintVisible, Transient, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          _IsPlayingAction;                                  // 0x05AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAbnormals                             _Abnormals;                                        // 0x05AD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          _IsAnyAbnormal;                                    // 0x05AE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _EnableFireBlend;                                  // 0x05AF(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _FireLight_Weight;                                 // 0x05B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _FireMiddle_Weight;                                // 0x05B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _FireHeavy_Weight;                                 // 0x05B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _FireZero_Weight;                                  // 0x05BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _1PV_Idle_BlendWeight;                             // 0x05C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _1PV_LeftHand_FireDecoupling;                      // 0x05C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _EnableLeftHandIK;                                 // 0x05C8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _ActivateLeftHandIK;                               // 0x05C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23FE[0x2];                                     // 0x05CA(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         _LeftHandIKActivateBlendTime;                      // 0x05CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _LeftHandIKDeactivateBlendTime;                    // 0x05D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _AimOffsetAlpha;                                   // 0x05D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAimOffsetBlendSpace*                   _TransientAimOffset;                               // 0x05D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _EnabledTransientAimOffset;                        // 0x05E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23FF[0x7];                                     // 0x05E1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UObject*                                _BlendUpperStrongly_Changer;                       // 0x05E8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _BlendUpperStrongly;                               // 0x05F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2400[0x3];                                     // 0x05F1(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         _AttackID;                                         // 0x05F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _LastBegun_AttackID;                               // 0x05F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _DamagedElapsed;                                   // 0x05FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _LastDamaged_AttackID;                             // 0x0600(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _PlayingDamaged_AttackID;                          // 0x0604(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _DamageImpactAngle;                                // 0x0608(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _DamageImpactHeight;                               // 0x060C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _LastKnockBack_AttackID;                           // 0x0610(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _PlayingKnockBack_AttackID;                        // 0x0614(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _DamagedPlayRate;                                  // 0x0618(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2401[0x4];                                     // 0x061C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UObject*                                _MotionSource_Changer;                             // 0x0620(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMotionSource                                 _MotionSource;                                     // 0x0628(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2402[0x3];                                     // 0x0629(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         _FullMotion_Alpha;                                 // 0x062C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2403[0x18];                                    // 0x0630(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	class UCurveFloat*                            _HitStopPose_Alpha_Curve;                          // 0x0648(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _HitStopPose_Alpha;                                // 0x0650(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2404[0x4];                                     // 0x0654(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          _IsSupportedAimOffsetInMontage;                    // 0x0658(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _AimOffsetEnabled;                                 // 0x0659(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2405[0x2];                                     // 0x065A(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         _DamageBlockRate;                                  // 0x065C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _DamageMotionBlendingRate;                         // 0x0660(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _HasOnlyOneGun;                                    // 0x0664(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EHoldingPropMode                              _HoldingPropMode;                                  // 0x0665(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2406[0x2];                                     // 0x0666(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	struct FVector                                _PickupTargetOffset;                               // 0x0668(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _PickupBlendRate_High;                             // 0x0680(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _PickupBlendRate_Middle;                           // 0x0684(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _PickupBlendRate_Low;                              // 0x0688(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _DoPickup;                                         // 0x068C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2407[0x3];                                     // 0x068D(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         _LowerActionElapsed;                               // 0x0690(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _LyingDownAlpha;                                   // 0x0694(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2408[0x1C];                                    // 0x0698(0x001C)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          _EnableMotionMatching;                             // 0x06B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAnimMoveMode                                 _AnimMoveMode;                                     // 0x06B5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2409[0x2];                                     // 0x06B6(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         WalkUpperLimitSpeed;                               // 0x06B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_240A[0x4];                                     // 0x06BC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FPoseSnapshot                          _DeathPose;                                        // 0x06C0(0x0038)(Edit, BlueprintVisible, Transient, NativeAccessSpecifierPublic)
	bool                                          _IsRagdolling;                                     // 0x06F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _EnableTurnInPlace;                                // 0x06F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_240B[0x2];                                     // 0x06FA(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         _RootYawOffset;                                    // 0x06FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _LowerYaw;                                         // 0x0700(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_240C[0x44];                                    // 0x0704(0x0044)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         HitDirection;                                      // 0x0748(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitHeight;                                         // 0x074C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _ForwardYaw;                                       // 0x0750(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _Foot_IK_Weight_L;                                 // 0x0754(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _Foot_IK_Weight_R;                                 // 0x0758(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _Pelvis_Additive_Height;                           // 0x075C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               _Foot_Rotation_L;                                  // 0x0760(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               _Foot_Rotation_R;                                  // 0x0778(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FRandomAnimation>               _UIAnims;                                          // 0x0790(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      _1PV_Idle_CurrentAnim;                             // 0x07A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      _1PV_Idle_IdleAnim;                                // 0x07A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UAnimSequenceBase*>              _1PV_Idle_LoopAnims;                               // 0x07B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      _1PV_MoveAnim;                                     // 0x07C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _1PV_Idle_Idle_MaxPlayCount;                       // 0x07C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _1PV_Idle_Loop_MaxAnimIndex;                       // 0x07CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _1PV_Idle_Idle_PlayCount;                          // 0x07D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _1PV_Idle_Loop_AnimIndex;                          // 0x07D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_240D[0x8];                                     // 0x07D8(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UAnimSequenceBase*                      _3PV_Idle_CurrentAnim;                             // 0x07E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _3PV_Idle_Idle_MaxPlayCount;                       // 0x07E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _3PV_Idle_Loop_MaxAnimIndex;                       // 0x07EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _3PV_Idle_Idle_PlayCount;                          // 0x07F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         _3PV_Idle_Loop_AnimIndex;                          // 0x07F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_240E[0x8];                                     // 0x07F8(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UAnimMontage*                           _Bot_Agent_StartAnim;                              // 0x0800(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           _Bot_Agent_EndAnim;                                // 0x0808(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _IsPlayingInstantAnimMontage;                      // 0x0810(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_240F[0xF];                                     // 0x0811(0x000F)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void BindChara(class ACharaBase* _owner);
	bool CheckCanTransit1PVIdle(bool _from_idle_state, bool _can_check);
	bool CheckCanTransit3PVIdle(bool _from_idle_state, bool _can_check);
	void CopyAnimationFrom(TSubclassOf<class USpecterAnimInstance> Type);
	class UAnimSequenceBase* GetCutSceneOutroAnim(int32 _Pos);
	class UAnimSequenceBase* GetCutSceneOutroCameraAnim();
	void OnAnimNotify_EnterLowerAction(EBodyLowerAction _new_action);
	void OnAnimNotify_MotionSource(bool _begin, EMotionSource _source, ERootMotionFrom _root_motion_mode, class UObject* _changer);
	void OnAnimNotify_UpperBlendStrongly(bool _begin, class UObject* _changer);
	void OnDamaged(const struct FHitData& _hit);
	void OnMontageFinished(class UAnimMontage* Montage, bool bInterrupted);
	void OnMontageStart(class UAnimMontage* Montage);
	void SetAimOffsetRotator(const struct FRotator& _Rot);
	void SetDamagedMotionPlayRate(float _rate);
	void SetFireBlendEnable(bool _is_enabled);
	void SetFireBlendWeight(const float& _zero, const float& _light, const float& _middle, const float& _heavy);
	void SetMotionSource(EMotionSource _source, class UObject* _changer, const class FString& _ctx);
	void SetSupportedAimOffsetInMontage(bool _enable);

	EMotionSource GetMotionSource() const;
	float GetPickupBlendRate() const;
	float GetZoomInBlendRate() const;
	bool IsPlayingDamagedMotion() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecterAnimInstance">();
	}
	static class USpecterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecterAnimInstance>();
	}
};
static_assert(alignof(USpecterAnimInstance) == 0x000010, "Wrong alignment on USpecterAnimInstance");
static_assert(sizeof(USpecterAnimInstance) == 0x000820, "Wrong size on USpecterAnimInstance");
static_assert(offsetof(USpecterAnimInstance, _IsDediServer) == 0x000348, "Member 'USpecterAnimInstance::_IsDediServer' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, CharaMovementAnim) == 0x000350, "Member 'USpecterAnimInstance::CharaMovementAnim' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, CharaOutroAnim) == 0x000488, "Member 'USpecterAnimInstance::CharaOutroAnim' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, CurrentLowerBlendSpace) == 0x0004A8, "Member 'USpecterAnimInstance::CurrentLowerBlendSpace' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, CurrentIdleAnim) == 0x0004B0, "Member 'USpecterAnimInstance::CurrentIdleAnim' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, CurrentOptionalPose) == 0x0004B8, "Member 'USpecterAnimInstance::CurrentOptionalPose' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, LoadMagazineAnim_1PV) == 0x0004C0, "Member 'USpecterAnimInstance::LoadMagazineAnim_1PV' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, IsOptionalPose) == 0x0004C8, "Member 'USpecterAnimInstance::IsOptionalPose' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, IsAimming) == 0x0004C9, "Member 'USpecterAnimInstance::IsAimming' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _OwnerChara) == 0x0004D0, "Member 'USpecterAnimInstance::_OwnerChara' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _IsFire) == 0x0004D8, "Member 'USpecterAnimInstance::_IsFire' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _Speed) == 0x0004DC, "Member 'USpecterAnimInstance::_Speed' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _Speed_Forward) == 0x0004E0, "Member 'USpecterAnimInstance::_Speed_Forward' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _Speed_Right) == 0x0004E4, "Member 'USpecterAnimInstance::_Speed_Right' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _BlendSpace_Speed_Forward) == 0x0004E8, "Member 'USpecterAnimInstance::_BlendSpace_Speed_Forward' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _BlendSpace_Speed_Right) == 0x0004EC, "Member 'USpecterAnimInstance::_BlendSpace_Speed_Right' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _BlendSpace_Stand_PlayRate) == 0x0004F0, "Member 'USpecterAnimInstance::_BlendSpace_Stand_PlayRate' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _BlendSpace_Crouch_PlayRate) == 0x0004F4, "Member 'USpecterAnimInstance::_BlendSpace_Crouch_PlayRate' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _Distance_Match_PlayRate) == 0x0004F8, "Member 'USpecterAnimInstance::_Distance_Match_PlayRate' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _IsEquippedDotSight) == 0x0004FC, "Member 'USpecterAnimInstance::_IsEquippedDotSight' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _HasAccel) == 0x0004FD, "Member 'USpecterAnimInstance::_HasAccel' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _Acceleration) == 0x000500, "Member 'USpecterAnimInstance::_Acceleration' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _Velocity) == 0x000508, "Member 'USpecterAnimInstance::_Velocity' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _IsFalling) == 0x000520, "Member 'USpecterAnimInstance::_IsFalling' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _IsJumping) == 0x000521, "Member 'USpecterAnimInstance::_IsJumping' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _IsMaintanFirePosture) == 0x000522, "Member 'USpecterAnimInstance::_IsMaintanFirePosture' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _IsUnfireable) == 0x000523, "Member 'USpecterAnimInstance::_IsUnfireable' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _SprintState) == 0x000524, "Member 'USpecterAnimInstance::_SprintState' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _PostponedDeath) == 0x000525, "Member 'USpecterAnimInstance::_PostponedDeath' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _IsAlreadyLiedDeathPose) == 0x000526, "Member 'USpecterAnimInstance::_IsAlreadyLiedDeathPose' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _LowerState) == 0x000527, "Member 'USpecterAnimInstance::_LowerState' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _LowerAction) == 0x000528, "Member 'USpecterAnimInstance::_LowerAction' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _UpperState) == 0x000529, "Member 'USpecterAnimInstance::_UpperState' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _ActionSlot) == 0x00052A, "Member 'USpecterAnimInstance::_ActionSlot' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _TargettingRotator) == 0x000530, "Member 'USpecterAnimInstance::_TargettingRotator' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _OwnerForwardVector) == 0x000548, "Member 'USpecterAnimInstance::_OwnerForwardVector' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _OwnerRightVector) == 0x000560, "Member 'USpecterAnimInstance::_OwnerRightVector' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _RollDirection) == 0x000578, "Member 'USpecterAnimInstance::_RollDirection' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _LegInjuryParts) == 0x000590, "Member 'USpecterAnimInstance::_LegInjuryParts' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _LegInjury_LRate) == 0x000594, "Member 'USpecterAnimInstance::_LegInjury_LRate' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _LegInjury_RRate) == 0x0005A0, "Member 'USpecterAnimInstance::_LegInjury_RRate' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _IsPlayingAction) == 0x0005AC, "Member 'USpecterAnimInstance::_IsPlayingAction' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _Abnormals) == 0x0005AD, "Member 'USpecterAnimInstance::_Abnormals' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _IsAnyAbnormal) == 0x0005AE, "Member 'USpecterAnimInstance::_IsAnyAbnormal' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _EnableFireBlend) == 0x0005AF, "Member 'USpecterAnimInstance::_EnableFireBlend' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _FireLight_Weight) == 0x0005B0, "Member 'USpecterAnimInstance::_FireLight_Weight' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _FireMiddle_Weight) == 0x0005B4, "Member 'USpecterAnimInstance::_FireMiddle_Weight' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _FireHeavy_Weight) == 0x0005B8, "Member 'USpecterAnimInstance::_FireHeavy_Weight' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _FireZero_Weight) == 0x0005BC, "Member 'USpecterAnimInstance::_FireZero_Weight' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _1PV_Idle_BlendWeight) == 0x0005C0, "Member 'USpecterAnimInstance::_1PV_Idle_BlendWeight' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _1PV_LeftHand_FireDecoupling) == 0x0005C4, "Member 'USpecterAnimInstance::_1PV_LeftHand_FireDecoupling' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _EnableLeftHandIK) == 0x0005C8, "Member 'USpecterAnimInstance::_EnableLeftHandIK' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _ActivateLeftHandIK) == 0x0005C9, "Member 'USpecterAnimInstance::_ActivateLeftHandIK' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _LeftHandIKActivateBlendTime) == 0x0005CC, "Member 'USpecterAnimInstance::_LeftHandIKActivateBlendTime' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _LeftHandIKDeactivateBlendTime) == 0x0005D0, "Member 'USpecterAnimInstance::_LeftHandIKDeactivateBlendTime' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _AimOffsetAlpha) == 0x0005D4, "Member 'USpecterAnimInstance::_AimOffsetAlpha' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _TransientAimOffset) == 0x0005D8, "Member 'USpecterAnimInstance::_TransientAimOffset' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _EnabledTransientAimOffset) == 0x0005E0, "Member 'USpecterAnimInstance::_EnabledTransientAimOffset' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _BlendUpperStrongly_Changer) == 0x0005E8, "Member 'USpecterAnimInstance::_BlendUpperStrongly_Changer' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _BlendUpperStrongly) == 0x0005F0, "Member 'USpecterAnimInstance::_BlendUpperStrongly' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _AttackID) == 0x0005F4, "Member 'USpecterAnimInstance::_AttackID' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _LastBegun_AttackID) == 0x0005F8, "Member 'USpecterAnimInstance::_LastBegun_AttackID' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _DamagedElapsed) == 0x0005FC, "Member 'USpecterAnimInstance::_DamagedElapsed' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _LastDamaged_AttackID) == 0x000600, "Member 'USpecterAnimInstance::_LastDamaged_AttackID' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _PlayingDamaged_AttackID) == 0x000604, "Member 'USpecterAnimInstance::_PlayingDamaged_AttackID' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _DamageImpactAngle) == 0x000608, "Member 'USpecterAnimInstance::_DamageImpactAngle' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _DamageImpactHeight) == 0x00060C, "Member 'USpecterAnimInstance::_DamageImpactHeight' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _LastKnockBack_AttackID) == 0x000610, "Member 'USpecterAnimInstance::_LastKnockBack_AttackID' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _PlayingKnockBack_AttackID) == 0x000614, "Member 'USpecterAnimInstance::_PlayingKnockBack_AttackID' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _DamagedPlayRate) == 0x000618, "Member 'USpecterAnimInstance::_DamagedPlayRate' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _MotionSource_Changer) == 0x000620, "Member 'USpecterAnimInstance::_MotionSource_Changer' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _MotionSource) == 0x000628, "Member 'USpecterAnimInstance::_MotionSource' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _FullMotion_Alpha) == 0x00062C, "Member 'USpecterAnimInstance::_FullMotion_Alpha' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _HitStopPose_Alpha_Curve) == 0x000648, "Member 'USpecterAnimInstance::_HitStopPose_Alpha_Curve' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _HitStopPose_Alpha) == 0x000650, "Member 'USpecterAnimInstance::_HitStopPose_Alpha' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _IsSupportedAimOffsetInMontage) == 0x000658, "Member 'USpecterAnimInstance::_IsSupportedAimOffsetInMontage' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _AimOffsetEnabled) == 0x000659, "Member 'USpecterAnimInstance::_AimOffsetEnabled' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _DamageBlockRate) == 0x00065C, "Member 'USpecterAnimInstance::_DamageBlockRate' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _DamageMotionBlendingRate) == 0x000660, "Member 'USpecterAnimInstance::_DamageMotionBlendingRate' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _HasOnlyOneGun) == 0x000664, "Member 'USpecterAnimInstance::_HasOnlyOneGun' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _HoldingPropMode) == 0x000665, "Member 'USpecterAnimInstance::_HoldingPropMode' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _PickupTargetOffset) == 0x000668, "Member 'USpecterAnimInstance::_PickupTargetOffset' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _PickupBlendRate_High) == 0x000680, "Member 'USpecterAnimInstance::_PickupBlendRate_High' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _PickupBlendRate_Middle) == 0x000684, "Member 'USpecterAnimInstance::_PickupBlendRate_Middle' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _PickupBlendRate_Low) == 0x000688, "Member 'USpecterAnimInstance::_PickupBlendRate_Low' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _DoPickup) == 0x00068C, "Member 'USpecterAnimInstance::_DoPickup' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _LowerActionElapsed) == 0x000690, "Member 'USpecterAnimInstance::_LowerActionElapsed' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _LyingDownAlpha) == 0x000694, "Member 'USpecterAnimInstance::_LyingDownAlpha' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _EnableMotionMatching) == 0x0006B4, "Member 'USpecterAnimInstance::_EnableMotionMatching' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _AnimMoveMode) == 0x0006B5, "Member 'USpecterAnimInstance::_AnimMoveMode' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, WalkUpperLimitSpeed) == 0x0006B8, "Member 'USpecterAnimInstance::WalkUpperLimitSpeed' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _DeathPose) == 0x0006C0, "Member 'USpecterAnimInstance::_DeathPose' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _IsRagdolling) == 0x0006F8, "Member 'USpecterAnimInstance::_IsRagdolling' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _EnableTurnInPlace) == 0x0006F9, "Member 'USpecterAnimInstance::_EnableTurnInPlace' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _RootYawOffset) == 0x0006FC, "Member 'USpecterAnimInstance::_RootYawOffset' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _LowerYaw) == 0x000700, "Member 'USpecterAnimInstance::_LowerYaw' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, HitDirection) == 0x000748, "Member 'USpecterAnimInstance::HitDirection' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, HitHeight) == 0x00074C, "Member 'USpecterAnimInstance::HitHeight' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _ForwardYaw) == 0x000750, "Member 'USpecterAnimInstance::_ForwardYaw' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _Foot_IK_Weight_L) == 0x000754, "Member 'USpecterAnimInstance::_Foot_IK_Weight_L' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _Foot_IK_Weight_R) == 0x000758, "Member 'USpecterAnimInstance::_Foot_IK_Weight_R' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _Pelvis_Additive_Height) == 0x00075C, "Member 'USpecterAnimInstance::_Pelvis_Additive_Height' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _Foot_Rotation_L) == 0x000760, "Member 'USpecterAnimInstance::_Foot_Rotation_L' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _Foot_Rotation_R) == 0x000778, "Member 'USpecterAnimInstance::_Foot_Rotation_R' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _UIAnims) == 0x000790, "Member 'USpecterAnimInstance::_UIAnims' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _1PV_Idle_CurrentAnim) == 0x0007A0, "Member 'USpecterAnimInstance::_1PV_Idle_CurrentAnim' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _1PV_Idle_IdleAnim) == 0x0007A8, "Member 'USpecterAnimInstance::_1PV_Idle_IdleAnim' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _1PV_Idle_LoopAnims) == 0x0007B0, "Member 'USpecterAnimInstance::_1PV_Idle_LoopAnims' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _1PV_MoveAnim) == 0x0007C0, "Member 'USpecterAnimInstance::_1PV_MoveAnim' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _1PV_Idle_Idle_MaxPlayCount) == 0x0007C8, "Member 'USpecterAnimInstance::_1PV_Idle_Idle_MaxPlayCount' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _1PV_Idle_Loop_MaxAnimIndex) == 0x0007CC, "Member 'USpecterAnimInstance::_1PV_Idle_Loop_MaxAnimIndex' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _1PV_Idle_Idle_PlayCount) == 0x0007D0, "Member 'USpecterAnimInstance::_1PV_Idle_Idle_PlayCount' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _1PV_Idle_Loop_AnimIndex) == 0x0007D4, "Member 'USpecterAnimInstance::_1PV_Idle_Loop_AnimIndex' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _3PV_Idle_CurrentAnim) == 0x0007E0, "Member 'USpecterAnimInstance::_3PV_Idle_CurrentAnim' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _3PV_Idle_Idle_MaxPlayCount) == 0x0007E8, "Member 'USpecterAnimInstance::_3PV_Idle_Idle_MaxPlayCount' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _3PV_Idle_Loop_MaxAnimIndex) == 0x0007EC, "Member 'USpecterAnimInstance::_3PV_Idle_Loop_MaxAnimIndex' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _3PV_Idle_Idle_PlayCount) == 0x0007F0, "Member 'USpecterAnimInstance::_3PV_Idle_Idle_PlayCount' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _3PV_Idle_Loop_AnimIndex) == 0x0007F4, "Member 'USpecterAnimInstance::_3PV_Idle_Loop_AnimIndex' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _Bot_Agent_StartAnim) == 0x000800, "Member 'USpecterAnimInstance::_Bot_Agent_StartAnim' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _Bot_Agent_EndAnim) == 0x000808, "Member 'USpecterAnimInstance::_Bot_Agent_EndAnim' has a wrong offset!");
static_assert(offsetof(USpecterAnimInstance, _IsPlayingInstantAnimMontage) == 0x000810, "Member 'USpecterAnimInstance::_IsPlayingInstantAnimMontage' has a wrong offset!");

// Class Stigma.SpecterCharaMovementComponent
// 0x0000 (0x24A0 - 0x24A0)
class USpecterCharaMovementComponent final : public UBPMotionMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecterCharaMovementComponent">();
	}
	static class USpecterCharaMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecterCharaMovementComponent>();
	}
};
static_assert(alignof(USpecterCharaMovementComponent) == 0x000010, "Wrong alignment on USpecterCharaMovementComponent");
static_assert(sizeof(USpecterCharaMovementComponent) == 0x0024A0, "Wrong size on USpecterCharaMovementComponent");

// Class Stigma.SpecterSessionCallbackProxy
// 0x0068 (0x0098 - 0x0030)
class USpecterSessionCallbackProxy final : public UOnlineBlueprintCallProxyBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2415[0x48];                                    // 0x0050(0x0048)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class USpecterSessionCallbackProxy* CreateSpecterSession(class UObject* WorldContextObject, class APlayerController* PlayerController, int32 PublicConnections, bool bUseLAN, bool _UseLobbiesIfAvailable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecterSessionCallbackProxy">();
	}
	static class USpecterSessionCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecterSessionCallbackProxy>();
	}
};
static_assert(alignof(USpecterSessionCallbackProxy) == 0x000008, "Wrong alignment on USpecterSessionCallbackProxy");
static_assert(sizeof(USpecterSessionCallbackProxy) == 0x000098, "Wrong size on USpecterSessionCallbackProxy");
static_assert(offsetof(USpecterSessionCallbackProxy, OnSuccess) == 0x000030, "Member 'USpecterSessionCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(USpecterSessionCallbackProxy, OnFailure) == 0x000040, "Member 'USpecterSessionCallbackProxy::OnFailure' has a wrong offset!");

// Class Stigma.SpecterPhysicalMaterial
// 0x0008 (0x0090 - 0x0088)
class USpecterPhysicalMaterial final : public UPhysicalMaterial
{
public:
	float                                         DamageAbsorbency;                                  // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsTranslucent;                                     // 0x008C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2417[0x3];                                     // 0x008D(0x0003)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpecterPhysicalMaterial">();
	}
	static class USpecterPhysicalMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpecterPhysicalMaterial>();
	}
};
static_assert(alignof(USpecterPhysicalMaterial) == 0x000008, "Wrong alignment on USpecterPhysicalMaterial");
static_assert(sizeof(USpecterPhysicalMaterial) == 0x000090, "Wrong size on USpecterPhysicalMaterial");
static_assert(offsetof(USpecterPhysicalMaterial, DamageAbsorbency) == 0x000088, "Member 'USpecterPhysicalMaterial::DamageAbsorbency' has a wrong offset!");
static_assert(offsetof(USpecterPhysicalMaterial, IsTranslucent) == 0x00008C, "Member 'USpecterPhysicalMaterial::IsTranslucent' has a wrong offset!");

// Class Stigma.SpeedLines
// 0x0018 (0x0048 - 0x0030)
class USpeedLines final : public UAnimNotifyState
{
public:
	class UMaterialInstance*                      _PP_SpeedLines;                                    // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           _CenterPos;                                        // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpeedLines">();
	}
	static class USpeedLines* GetDefaultObj()
	{
		return GetDefaultObjImpl<USpeedLines>();
	}
};
static_assert(alignof(USpeedLines) == 0x000008, "Wrong alignment on USpeedLines");
static_assert(sizeof(USpeedLines) == 0x000048, "Wrong size on USpeedLines");
static_assert(offsetof(USpeedLines, _PP_SpeedLines) == 0x000030, "Member 'USpeedLines::_PP_SpeedLines' has a wrong offset!");
static_assert(offsetof(USpeedLines, _CenterPos) == 0x000038, "Member 'USpeedLines::_CenterPos' has a wrong offset!");

// Class Stigma.StickyBomb
// 0x0000 (0x0860 - 0x0860)
class AStickyBomb final : public ABombBase
{
public:
	bool                                          IsDriveClient;                                     // 0x0858(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2418[0x7];                                     // 0x0859(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StickyBomb">();
	}
	static class AStickyBomb* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStickyBomb>();
	}
};
static_assert(alignof(AStickyBomb) == 0x000010, "Wrong alignment on AStickyBomb");
static_assert(sizeof(AStickyBomb) == 0x000860, "Wrong size on AStickyBomb");
static_assert(offsetof(AStickyBomb, IsDriveClient) == 0x000858, "Member 'AStickyBomb::IsDriveClient' has a wrong offset!");

// Class Stigma.StigmaAIController
// 0x02E8 (0x06C8 - 0x03E0)
class AStigmaAIController : public AStigmaAIControllerBase
{
public:
	EPerceptionPhase                              PerceptionPhase;                                   // 0x03E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2419[0x3B];                                    // 0x03E1(0x003B)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         HowAggressive;                                     // 0x041C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HowSkilled;                                        // 0x0420(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GuideThreat_PullBack;                              // 0x0424(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GuideThreat_Assault;                               // 0x0428(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_241A[0x4];                                     // 0x042C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class AActor*                                 TargetEnemy;                                       // 0x0430(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_241B[0x290];                                   // 0x0438(0x0290)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ActivateCrouchFighting(bool _is_activation);
	void ActivateSideStep();
	void BuildMesh_AI_Parts();
	void DrivePerception(float _delta);
	bool ExecuteFireCommand(float* _out_maintain_command_time);
	void ExecuteProperAction();
	void FireToTargetEnemy();
	void InitBlackboardByConfig();
	void OnFinishBehavior();
	void RandomActivateAdditionalStep(bool _inculde_action);
	bool RequestChangeBehaviorType(EMainBehaviorType _type);
	void SetCharacteristics(float _aggressive, float _skilled);
	void SetOriginLocation(const struct FVector& _location);
	void SetRunType(bool _is_run_type);
	void SetTargetEnemy(class AActor* _Actor);
	void SetTargetEnemyImmediately(class AActor* _Actor);
	void SetupConfig(const struct FConfig_AI& _config_ai);
	void StepDownPerception();
	void StepUpPerception(EPerceptionPhase _phase);
	bool UpdateTargetEnemy(class AActor* _perceived_actor);
	void UpdateThreats(class AActor* _perceived_actor, const struct FAIStimulus& _stimul);
	void UpdateVariable();

	struct FSkillInfo_AI GetAvailableAction() const;
	const struct FConfig_AI GetConfig_AI() const;
	float GetCurrentAccumlatedPerception() const;
	EPerceptionPhase GetCurrentPerceptionPhase() const;
	const struct FVector GetLastTargetLocation() const;
	float GetPerceptionLevelWeight(EPerceptionPhase _phase) const;
	float GetPerceptionRequirements(EPerceptionPhase _phase) const;
	class AActor* GetTargetEnemy() const;
	float GetTotalAccumulatedPerception() const;
	bool IsImmediatelyTargetMove() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StigmaAIController">();
	}
	static class AStigmaAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStigmaAIController>();
	}
};
static_assert(alignof(AStigmaAIController) == 0x000008, "Wrong alignment on AStigmaAIController");
static_assert(sizeof(AStigmaAIController) == 0x0006C8, "Wrong size on AStigmaAIController");
static_assert(offsetof(AStigmaAIController, PerceptionPhase) == 0x0003E0, "Member 'AStigmaAIController::PerceptionPhase' has a wrong offset!");
static_assert(offsetof(AStigmaAIController, HowAggressive) == 0x00041C, "Member 'AStigmaAIController::HowAggressive' has a wrong offset!");
static_assert(offsetof(AStigmaAIController, HowSkilled) == 0x000420, "Member 'AStigmaAIController::HowSkilled' has a wrong offset!");
static_assert(offsetof(AStigmaAIController, GuideThreat_PullBack) == 0x000424, "Member 'AStigmaAIController::GuideThreat_PullBack' has a wrong offset!");
static_assert(offsetof(AStigmaAIController, GuideThreat_Assault) == 0x000428, "Member 'AStigmaAIController::GuideThreat_Assault' has a wrong offset!");
static_assert(offsetof(AStigmaAIController, TargetEnemy) == 0x000430, "Member 'AStigmaAIController::TargetEnemy' has a wrong offset!");

// Class Stigma.StigmaButtonBase
// 0x0020 (0x15A0 - 0x1580)
class UStigmaButtonBase final : public UCommonButtonBase
{
public:
	uint8                                         _override_button_text : 1;                         // 0x1580(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_2420[0x7];                                     // 0x1581(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class FText                                   _button_text;                                      // 0x1588(0x0018)(Edit, NativeAccessSpecifierPrivate)

public:
	void SetButtonText(const class FText& InText);
	void UpdateButtonStyle();
	void UpdateButtonText(const class FText& InText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StigmaButtonBase">();
	}
	static class UStigmaButtonBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStigmaButtonBase>();
	}
};
static_assert(alignof(UStigmaButtonBase) == 0x000010, "Wrong alignment on UStigmaButtonBase");
static_assert(sizeof(UStigmaButtonBase) == 0x0015A0, "Wrong size on UStigmaButtonBase");
static_assert(offsetof(UStigmaButtonBase, _button_text) == 0x001588, "Member 'UStigmaButtonBase::_button_text' has a wrong offset!");

// Class Stigma.StigmaCameraManager
// 0x0000 (0x23C0 - 0x23C0)
class AStigmaCameraManager : public APlayerCameraManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StigmaCameraManager">();
	}
	static class AStigmaCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStigmaCameraManager>();
	}
};
static_assert(alignof(AStigmaCameraManager) == 0x000010, "Wrong alignment on AStigmaCameraManager");
static_assert(sizeof(AStigmaCameraManager) == 0x0023C0, "Wrong size on AStigmaCameraManager");

// Class Stigma.StigmaCharaMovementComponent
// 0x0000 (0x24A0 - 0x24A0)
class UStigmaCharaMovementComponent final : public UBPMotionMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StigmaCharaMovementComponent">();
	}
	static class UStigmaCharaMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStigmaCharaMovementComponent>();
	}
};
static_assert(alignof(UStigmaCharaMovementComponent) == 0x000010, "Wrong alignment on UStigmaCharaMovementComponent");
static_assert(sizeof(UStigmaCharaMovementComponent) == 0x0024A0, "Wrong size on UStigmaCharaMovementComponent");

// Class Stigma.StigmaCheatManager
// 0x0008 (0x0090 - 0x0088)
class UStigmaCheatManager final : public UCheatManager
{
public:
	uint8                                         Pad_2421[0x8];                                     // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Spt_ActivateInfiniteBullet(class ACharaBase* _target_chara, bool _is_activated);
	void Spt_Annihilation(class ACharaBase* _target_chara, const class FString& _Key, const class FString& _param);
	void Spt_BattlePass_Clear(int32 _pass_id);
	void Spt_Booster(class ACharaBase* _target_chara, int32 _booster_slot_zidx, int32 _item_id);
	void Spt_Challenge(class ACharaBase* _target_chara, const class FString& _Key, const class FString& _param);
	void Spt_ChangeArmor(class ACharaBase* _target_chara, const class FString& _Key);
	void Spt_ChangeBullet(class ACharaBase* _target_chara, const class FString& _Key);
	void Spt_ChangeChara(class ACharaBase* _target_chara, ECharaType _chara_type);
	void Spt_ChangeParts(class ACharaBase* _target_chara, const class FString& _Key);
	void Spt_Crash();
	void Spt_Currency_Add(ECurrencyTypes _currency_type, int32 _Amount);
	void Spt_Currency_Clear(ECurrencyTypes _currency_type);
	void Spt_DumpChara(class ACharaBase* _target_chara);
	void Spt_ELO(int32 _elo);
	void Spt_EnableFootIK(class ACharaBase* _target_chara, bool _is_enabled);
	void Spt_ESC();
	void Spt_EventPage_AddCount(int32 _event_page_id, int32 _count, bool _is_option);
	void Spt_EventPage_Clear(int32 _event_page_id);
	void Spt_EventPage_Reset();
	void Spt_Expire_ActiveFunction(int32 _sec);
	void Spt_FillBot();
	void Spt_FinishBattle();
	void Spt_Function_Add(int32 _item_id);
	void Spt_Function_Clear();
	void Spt_GameTime(int32 _time_sec);
	void Spt_InfStock(class ACharaBase* _target_chara, bool _is_activated);
	void Spt_Item_Add(int32 _item_id, const class FString& _count_or_time, int32 _Amount);
	void Spt_Item_Clear(int32 _item_id);
	void Spt_LevelHack(float _level);
	void Spt_LoadVoiceOnInit(bool _val);
	void Spt_MannerPoint_Add(float _point_delta);
	void Spt_MasterMission_AddCount(ECharaType _chara_type, int32 _slot, int32 _count);
	void Spt_MasterMission_Clear(ECharaType _chara_type, int32 _slot);
	void Spt_MasterMission_ClearChangeCount(ECharaType _chara_type);
	void Spt_MasterMission_ExpAdd(ECharaType _chara_type, int32 _Exp);
	void Spt_MasterMission_LevelAdd(ECharaType _chara_type, int32 _level);
	void Spt_MasterMission_Success(ECharaType _chara_type, int32 _slot);
	void Spt_MasterMission_SuccessFirstMission(ECharaType _chara_type);
	void Spt_Minimap(bool _enable);
	void Spt_Mission_AddCount(const class FString& _task_id, int32 _idx, int32 _slot, int32 _count);
	void Spt_Mission_Change(const class FString& _task_id, int32 _idx, int32 _slot);
	void Spt_Mission_Clear(const class FString& _task_id, int32 _idx, int32 _slot);
	void Spt_Mission_Success(const class FString& _task_id, int32 _idx, int32 _slot);
	void Spt_PassiveSkill(class ACharaBase* _target_chara, int32 _skill_id, int32 _level);
	void Spt_RespawnChara(class ACharaBase* _target_chara);
	void Spt_Sanctum(bool _on);
	void Spt_SetBounty(class ACharaBase* _target_chara, int32 _bounty);
	void Spt_SetInvincible(class ACharaBase* _target_chara, bool _is_activated);
	void Spt_Show_Popup_CompetitionReward(int32 _Rank, float _point);
	void Spt_Show_Popup_SeasonReward(ETier _tier, int32 _Rank);
	void Spt_Show_Popup_TierPromotion(ETier _previous_tier, ETier _current_tier);
	void Spt_ShowAimDistance(class ACharaBase* _target_chara, bool _is_activated);
	void Spt_ShowDamage(class ACharaBase* _target_chara, bool _is_activated, EDebug_DamageViewerType _damage_viewer_type);
	void Spt_ShowDebugUI(class ACharaBase* _target_chara, int32 _index);
	void Spt_ShowEachHUD(class ACharaBase* _target_chara, const class FString& Key, bool _is_visible);
	void Spt_ShowHUD(class ACharaBase* _target_chara, bool _is_visible);
	void Spt_ShowMeTheMoney(class ACharaBase* _target_chara, int32 _Money);
	void Spt_Slomo(float _Key);
	void Spt_SpawnAIChara(class ACharaBase* _target_chara, const class FString& _row_name, ETeams _Team);
	void Spt_StartWelcome(int32 _scenario);
	void Spt_StaticCamera(class ACharaBase* _target_chara, bool _is_activated);
	void Spt_TierPoint_Add(float _tier_point);
	void Spt_Toggle_Mute();
	void Spt_Tutorial(int32 _tutorial);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StigmaCheatManager">();
	}
	static class UStigmaCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStigmaCheatManager>();
	}
};
static_assert(alignof(UStigmaCheatManager) == 0x000008, "Wrong alignment on UStigmaCheatManager");
static_assert(sizeof(UStigmaCheatManager) == 0x000090, "Wrong size on UStigmaCheatManager");

// Class Stigma.StigmaEngine
// 0x0000 (0x10D0 - 0x10D0)
class UStigmaEngine final : public UGameEngine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StigmaEngine">();
	}
	static class UStigmaEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStigmaEngine>();
	}
};
static_assert(alignof(UStigmaEngine) == 0x000008, "Wrong alignment on UStigmaEngine");
static_assert(sizeof(UStigmaEngine) == 0x0010D0, "Wrong size on UStigmaEngine");

// Class Stigma.StigmaLocalPlayer
// 0x0000 (0x02B0 - 0x02B0)
class UStigmaLocalPlayer final : public ULocalPlayer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StigmaLocalPlayer">();
	}
	static class UStigmaLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStigmaLocalPlayer>();
	}
};
static_assert(alignof(UStigmaLocalPlayer) == 0x000008, "Wrong alignment on UStigmaLocalPlayer");
static_assert(sizeof(UStigmaLocalPlayer) == 0x0002B0, "Wrong size on UStigmaLocalPlayer");

// Class Stigma.StigmaPhysicalAnimationComponent
// 0x0040 (0x00E0 - 0x00A0)
class UStigmaPhysicalAnimationComponent final : public UActorComponent
{
public:
	float                                         StrengthMultiplyer;                                // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_243B[0x4];                                     // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x00A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_243C[0x30];                                    // 0x00B0(0x0030)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ApplyPhysicalAnimationProfileBelow(class FName BodyName, class FName ProfileName, bool bIncludeSelf, bool bClearNotFound);
	void ApplyPhysicalAnimationSettings(class FName BodyName, const struct FPhysicalAnimationData& PhysicalAnimationData);
	void ApplyPhysicalAnimationSettingsBelow(class FName BodyName, const struct FPhysicalAnimationData& PhysicalAnimationData, bool bIncludeSelf);
	void SetSkeletalMeshComponent(class USkeletalMeshComponent* InSkeletalMeshComponent);
	void SetStrengthMultiplyer(float InStrengthMultiplyer);

	struct FTransform GetBodyTargetTransform(class FName BodyName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StigmaPhysicalAnimationComponent">();
	}
	static class UStigmaPhysicalAnimationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStigmaPhysicalAnimationComponent>();
	}
};
static_assert(alignof(UStigmaPhysicalAnimationComponent) == 0x000008, "Wrong alignment on UStigmaPhysicalAnimationComponent");
static_assert(sizeof(UStigmaPhysicalAnimationComponent) == 0x0000E0, "Wrong size on UStigmaPhysicalAnimationComponent");
static_assert(offsetof(UStigmaPhysicalAnimationComponent, StrengthMultiplyer) == 0x0000A0, "Member 'UStigmaPhysicalAnimationComponent::StrengthMultiplyer' has a wrong offset!");
static_assert(offsetof(UStigmaPhysicalAnimationComponent, SkeletalMeshComponent) == 0x0000A8, "Member 'UStigmaPhysicalAnimationComponent::SkeletalMeshComponent' has a wrong offset!");

// Class Stigma.SupplyStore
// 0x0040 (0x02D8 - 0x0298)
class ASupplyStore final : public AActor
{
public:
	uint8                                         Pad_2440[0x8];                                     // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         _SupplyRemainTime_Integer;                         // 0x02A0(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _SupplyCoolTime;                                   // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _SupplyRemainTime;                                 // 0x02A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2441[0x4];                                     // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FSupplyStoreItem>               ItemDefines;                                       // 0x02B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             SupplyDataTable;                                   // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsLocalCanInteraction;                             // 0x02C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2442[0x7];                                     // 0x02C9(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UFXSystemAsset*                         _SupplyFX;                                         // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SERVER_RequestPurchase(class ACharaBase* _requester, int32 _index);
	void SupplyFX();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SupplyStore">();
	}
	static class ASupplyStore* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASupplyStore>();
	}
};
static_assert(alignof(ASupplyStore) == 0x000008, "Wrong alignment on ASupplyStore");
static_assert(sizeof(ASupplyStore) == 0x0002D8, "Wrong size on ASupplyStore");
static_assert(offsetof(ASupplyStore, _SupplyRemainTime_Integer) == 0x0002A0, "Member 'ASupplyStore::_SupplyRemainTime_Integer' has a wrong offset!");
static_assert(offsetof(ASupplyStore, _SupplyCoolTime) == 0x0002A4, "Member 'ASupplyStore::_SupplyCoolTime' has a wrong offset!");
static_assert(offsetof(ASupplyStore, _SupplyRemainTime) == 0x0002A8, "Member 'ASupplyStore::_SupplyRemainTime' has a wrong offset!");
static_assert(offsetof(ASupplyStore, ItemDefines) == 0x0002B0, "Member 'ASupplyStore::ItemDefines' has a wrong offset!");
static_assert(offsetof(ASupplyStore, SupplyDataTable) == 0x0002C0, "Member 'ASupplyStore::SupplyDataTable' has a wrong offset!");
static_assert(offsetof(ASupplyStore, IsLocalCanInteraction) == 0x0002C8, "Member 'ASupplyStore::IsLocalCanInteraction' has a wrong offset!");
static_assert(offsetof(ASupplyStore, _SupplyFX) == 0x0002D0, "Member 'ASupplyStore::_SupplyFX' has a wrong offset!");

// Class Stigma.TableCache
// 0x35B8 (0x35E0 - 0x0028)
class UTableCache final : public UObject
{
public:
	uint8                                         Pad_2444[0x978];                                   // 0x0028(0x0978)(Fixing Size After Last Property [ Dumper-69 ])
	struct FCachedConfig_Registry                 _Objects;                                          // 0x09A0(0x0020)(Protected, NativeAccessSpecifierProtected)
	TMap<class FString, class UDataTable*>        _CacheDataTableMap;                                // 0x09C0(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<struct FItemDataTableInfo>             _ItemDataTable;                                    // 0x0A10(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2445[0x68];                                    // 0x0A20(0x0068)(Fixing Size After Last Property [ Dumper-69 ])
	TMap<int32, struct FHitEffect>                _WeaponHitEffectsMap;                              // 0x0A88(0x0050)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2446[0x2B08];                                  // 0x0AD8(0x2B08)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static TArray<struct FGunEntry_Main> FilterGunMainEntries(bool _handy, bool _balance, bool _power, bool _include_developing);
	static TArray<struct FGunEntry_Main> FindAllGunMainEntries(EGunSearchGroup _group);
	static TArray<struct FConfig_RadioChat> FindAllRadioChatDefines(ERadioChatCategory _category);
	static bool FindBattleStoreEntryByIDAndMode(struct FBattleStoreEntry* _out_entry, const struct FItemID& _id, EGameMode _mode);
	static const struct FPartsEntry_Body FindBodyDefine(ECharaType _chara_type, EArmorType _Armor);
	static bool GetActionGraph(const struct FActionGraphID& _id, struct FActionGraphEntry* _out_entry);
	static TArray<struct FActionGraphEntry> GetAllActionGraphs();
	static TArray<struct FActionGraphEntry> GetAllActionGraphsByType(EActionType _type);
	static TArray<struct FItemEntry> GetAllBodies(ECharaType _chara_type);
	static TArray<struct FConfig_Booster> GetAllBoosterDefines();
	static TArray<struct FCharacterDefine> GetAllCharacterDefineByFightingStyle(EFightingStyle _style, bool _include_upcoming);
	static TArray<struct FCharacterDefine> GetAllCharacterDefines();
	static TArray<struct FCharacterDefine> GetAllCharacterDefineSortedByFightingStyle(bool _include_upcoming);
	static TArray<struct FCurrencyDef> GetAllCurrencyDefines();
	static TArray<struct FConfig_Goods> GetAllGoodsDefines();
	static TArray<struct FGunEntry_Main> GetAllGunMainEntries();
	static TArray<struct FItemEntry> GetAllHeads(ECharaType _chara_type);
	static TArray<struct FInputActionDefine> GetAllInputActionDefines();
	static TArray<struct FMapEntry> GetAllMaps();
	static TArray<struct FMapEntry> GetAllMapsForGameMode(EGameMode _mode);
	static void GetAllMissionDefines(EMissionType _type, TArray<struct FMissionDefine>* _out_list, bool _include_platform_mission);
	static TArray<struct FPassiveSkillEntry> GetAllPassiveSkillDefines();
	static TArray<struct FConfig_Ping> GetAllPingDefines();
	static TArray<ERadioChatCategory> GetAllRadioChatCategories();
	static TArray<struct FConfig_RandomBox> GetAllRandomBoxesDefine();
	static TArray<struct FConfig_Season> GetAllSeasonEntries();
	static const TArray<ETierGroup> GetAllTierGroups();
	static struct FLinearColor GetAllyColor();
	static const struct FConfig_Armor GetArmorDefine(EArmorType _Armor);
	static bool GetArmorDisplayStats(TArray<struct FDisplayStat>* _out_display_stats, EArmorType _Armor);
	static EArmorType GetArmorType(const struct FItemID_Armor& _armor_id);
	static const struct FAttackTypeDefine GetAttackTypeDefine(EAttackType _point);
	static const struct FConfig_BasicPackage GetBasicPackage();
	static const struct FBattlePassDefine GetBattlePassDefineByID(const struct FItemID_BattlePass& _battle_pass_id);
	static const bool GetBattlePassLevelConfigs(const struct FItemID_BattlePass& _battle_pass_id, TMap<int32, struct FBattlePassLevelConfig>* _out_configs);
	static const bool GetBattlePassMissionConfigs(const struct FItemID_BattlePass& _battle_pass_id, TMap<int32, struct FBattlePassMissionConfig>* _out_configs);
	static void GetBattleStoreEntries(TArray<struct FBattleStoreEntry>* _out_entries);
	static void GetBattleStoreEntriesByMode(TArray<struct FBattleStoreEntry>* _out_entries, EGameMode _game_mode);
	static const struct FPartsEntry_Body GetBodyDefine(const struct FItemID_Skin_Body& _body_id);
	static const struct FBodyPartDefine GetBodyPartDefine(EBodyParts _part);
	static const struct FConfig_Booster GetBoosterDefineByID(const struct FItemID_Booster& _id);
	static int32 GetBoosterSlotActivatingLevel(int32 _slot_zidx);
	static const struct FBulletCaliberDefine GetBulletCaliber(EBulletType _type, EBulletTip _tip);
	static const struct FBulletTipDefine GetBulletTipDefineByType(EBulletTip _tip);
	static bool GetCharacterDefByName(const class FString& _str, struct FCharacterDefine* _out_date);
	static bool GetCharacterDefByType(ECharaType _type, struct FCharacterDefine* _out_data);
	static const struct FConfig_CommonStyle GetCommonStyleConfig();
	static const struct FConfig_GroupCompetition GetCompetitionGroupDefine(ECompetitionType _competition_type);
	static const struct FGroupCompetitionReward GetCompetitionRankReward(ECompetitionType _competition_type, int32 _Rank);
	static const struct FConfig_GroupCompetitionRewards GetCompetitionRewardDefine(ECompetitionType _competition_type);
	static TArray<struct FLinearColor> GetCrossHairColors();
	static TArray<struct FLinearColor> GetCrossHairOutlineColors();
	static bool GetCurrencyDefine(ECurrencyTypes _type, struct FCurrencyDef* _out_def);
	static struct FCurrencyDef GetCurrencyDefineFromID(const struct FItemID_Currency& _id);
	static struct FCharacterInfo GetDefaultCharacterInfo(ECharaType _type, bool _random);
	static const struct FConfig_Emblem GetEmblemDefine(const struct FItemID& _item_id);
	static const struct FConfig_Emoticon GetEmoticonDefine(const struct FItemID& _item_id);
	static struct FLinearColor GetEnemyColor();
	static void GetEntriesByCategory(TArray<struct FItemEntry>* _item_array, EItemCategory _category);
	static void GetEntriesBySubCategory(TArray<struct FItemEntry>* _item_array, EItemCategory _category, int32 _sub_category_type);
	static const struct FEventAttendanceDefine GetEventAttendanceDefineByID(const struct FItemID_EventPage& _event_page_id);
	static const struct FEventCollectionDefine GetEventCollectionDefineByID(const struct FItemID_EventPage& _event_page_id);
	static const struct FEventKeepConnectDefine GetEventKeepConnectDefineByID(const struct FItemID_EventPage& _event_page_id);
	static const struct FEventMasterMissionDefine GetEventMasterMissionDefineByID(const struct FItemID_EventPage& _event_page_id);
	static const struct FEventMasterMissionDefine GetEventMasterMissionDefineByType(ECharaType _type);
	static const struct FEventMissionDefine GetEventMissionDefineByID(const struct FItemID_EventPage& _event_page_id);
	static const struct FEventPageDefine GetEventPageDefineByID(const struct FItemID_EventPage& _event_page_id);
	static const struct FEventTrackMissionDefine GetEventTrackMissionDefineByID(const struct FItemID_EventPage& _event_page_id);
	static struct FConfig_Exp GetExpDefine(EExpType _type);
	static const struct FFightingStyleDefine GetFightingStyleDefine(EFightingStyle _style);
	static EFightingStyle GetFightingStyleFromCharaType(const ECharaType _chara_type);
	static struct FItemID GetFirstMissionOf(ECharaType _type);
	static const struct FConfig_Function GetFunctionDefine(const struct FItemID& _id);
	static const struct FConfig_Game GetGameConfig();
	static const struct FMode GetGameModeEntry(EGameMode _mode);
	static const struct FGameNotifyDefine GetGameNotify(const class FName& _name_id);
	static EBodyParts GetGearBodyParts(const struct FItemID& _item_id);
	static bool GetGearDisplayStats(TArray<struct FDisplayStat>* _out_display_stats, const struct FItemID& _item_id);
	static const struct FConfig_Goods GetGoodsDefineByID(const struct FGoodsID& _id);
	static const struct FGradeDef GetGradeDefine(EItemGrade _type);
	static const struct FGunEntry_Body GetGunBodyEntry(const struct FItemID_Gun_Body& _item_id);
	static const struct FGunEntry_Charm GetGunCharmEntry(const struct FItemID_Gun_Charm& _item_id);
	static const struct FGunEntry_Front GetGunFrontEntry(const struct FItemID_Gun_Front& _item_id);
	static TArray<EGunType> GetGunLists(class UObject* _world_ctx);
	static const struct FGunEntry_Magazine GetGunMagazineEntry(const struct FItemID_Gun_Magazine& _item_id);
	static const struct FGunEntry_Main GetGunMainEntry(EGunType _gun_type);
	static const struct FGunEntry_Sight GetGunSightEntry(const struct FItemID_Gun_Sight& _item_id);
	static const struct FGunEntry_Slide GetGunSlideEntry(const struct FItemID_Gun_Slide& _item_id);
	static const struct FGunEntry_Sticker GetGunStickerEntry(const struct FItemID_Gun_Sticker& _item_id);
	static const struct FPartsEntry_Head GetHeadDefine(const struct FItemID_Skin_Head& _head_id);
	static bool GetHitEffects(struct FHitEffect* _out_hit_effects, EAttackType _attack_type, ESurfaceMaterialType _surface_material_type, EBodyParts _body_parts, EBulletEffectScaleType _effect_type);
	static const struct FInputActionDefine GetInputActionDefine(EInputAction _input_action);
	static const struct FConfig_ItemCategory GetItemCategoryDefine(EItemCategory _category);
	static bool GetItemEntriesByFilter(class UObject* _world_ctx, TArray<struct FItemEntry>* _out_entries, const struct FItemFilterInfo& _filter_info);
	static const struct FKillStreakDefine GetKillStreakDefine(EKillStreak _point);
	static const struct FLevelEntry GetLevelDefine(int32 _level);
	static const struct FConfig_Tier GetLowTierGroupDefine(ETierGroup _tier_group);
	static struct FMapEntry GetMapEntry(const class FName& _map_name);
	static const bool GetMasterLevelConfigsByID(const struct FItemID_EventPage& _event_page_id, TMap<int32, struct FMasterLevelConfig>* _out_configs);
	static const bool GetMasterLevelConfigsByType(ECharaType _type, TMap<int32, struct FMasterLevelConfig>* _out_configs);
	static int32 GetMaxLevel();
	static const struct FMeleeAttackPointDefine GetMeleeAttackPointDefine(EMeleeAttackPoint _point);
	static const struct FMissionDefine GetMissionDefineByID(const struct FItemID_Mission& _misison_id);
	static struct FLinearColor GetMyColor();
	static const struct FConfig_NicknameFX GetNicknameFXDefine(const struct FItemID& _item_id);
	static bool GetNonItemEntry(const class FName& _name_id, struct FNonItemEntry* _out_non_item_entry);
	static const struct FOrganizationDefine GetOrganizationDefine(EOrganization _type);
	static EOrganization GetOrganizationFromCharaType(const ECharaType _chara_type);
	static struct FLinearColor GetPartyColor();
	static const struct FPassiveSkillEntry GetPassiveSkillDefineByID(const struct FPassiveSkillID& _id);
	static int32 GetPassiveSkillSlotActivatingLevel(int32 _slot_zidx);
	static struct FConfig_Ping GetPingDefine(const EBattlePingType& _ping_type);
	static const struct FConfig_ProfileCard GetProfileCardDefine(const struct FItemID& _item_id);
	static struct FConfig_RadioChat GetRadioChatDefine(const ERadioChatCategory& _category, const int32 _order);
	static const struct FConfig_RandomBox GetRandomBoxDefine(const struct FItemID_RandomBox& _id);
	static bool GetRandomBoxRewards(const struct FItemID_RandomBox& _id, TArray<struct FRandomItemEntry>* _out_confirmed, TArray<struct FRandomItemEntry>* _out_probabilitics);
	static const struct FRecruitDefine GetRecruitDefine(const struct FItemID& _item_id);
	static const struct FConfig_Region GetRegion(const class FString& _code);
	static const struct FConfig_Season GetSeasonDefine(const struct FSeasonID& _season_id);
	static const struct FSeasonReward GetSeasonRewardByTier(const struct FSeasonID& _season_id, ETier _tier);
	static const struct FServiceDefine GetServiceConfig(ERunEnv _run_type);
	static const struct FConfig_Stack GetStackItemDefine(const struct FItemID_Stack& _id);
	static struct FLinearColor GetTeamColor();
	static struct FTeamDef GetTeamDefine(ETeams _Team);
	static const struct FConfig_Tier GetTierDefine(ETier _tier);
	static TSubclassOf<class UUI_Tooltip> GetTooltipWidgetClass(ETooltipType _type);
	static const bool IsMaxLevel(int32 _level);
	static void SaveGameConfig();
	static void SetGameConfig_FOV(float _FOV);
	static void SetGunFOV(EGunType _gun_type, float _FOV);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TableCache">();
	}
	static class UTableCache* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTableCache>();
	}
};
static_assert(alignof(UTableCache) == 0x000008, "Wrong alignment on UTableCache");
static_assert(sizeof(UTableCache) == 0x0035E0, "Wrong size on UTableCache");
static_assert(offsetof(UTableCache, _Objects) == 0x0009A0, "Member 'UTableCache::_Objects' has a wrong offset!");
static_assert(offsetof(UTableCache, _CacheDataTableMap) == 0x0009C0, "Member 'UTableCache::_CacheDataTableMap' has a wrong offset!");
static_assert(offsetof(UTableCache, _ItemDataTable) == 0x000A10, "Member 'UTableCache::_ItemDataTable' has a wrong offset!");
static_assert(offsetof(UTableCache, _WeaponHitEffectsMap) == 0x000A88, "Member 'UTableCache::_WeaponHitEffectsMap' has a wrong offset!");

// Class Stigma.TableEntryBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UTableEntryBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool FindGunMainEntry(struct FGunEntry_Main* _out_config, EGunType _gun_type);
	static bool FindItemIconByItemID(class UTexture2D** Out_texture, const struct FItemID& _id);
	static bool GetDisplayNameByItemID(class FText* Out_name, const struct FItemID& _id);
	static struct FItemEntry GetItemEntry(const struct FItemID& _id);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TableEntryBlueprintLibrary">();
	}
	static class UTableEntryBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTableEntryBlueprintLibrary>();
	}
};
static_assert(alignof(UTableEntryBlueprintLibrary) == 0x000008, "Wrong alignment on UTableEntryBlueprintLibrary");
static_assert(sizeof(UTableEntryBlueprintLibrary) == 0x000028, "Wrong size on UTableEntryBlueprintLibrary");

// Class Stigma.TableRegistryItem
// 0x0010 (0x0038 - 0x0028)
class UTableRegistryItem final : public UObject
{
public:
	class FString                                 TableRowName;                                      // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TableRegistryItem">();
	}
	static class UTableRegistryItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTableRegistryItem>();
	}
};
static_assert(alignof(UTableRegistryItem) == 0x000008, "Wrong alignment on UTableRegistryItem");
static_assert(sizeof(UTableRegistryItem) == 0x000038, "Wrong size on UTableRegistryItem");
static_assert(offsetof(UTableRegistryItem, TableRowName) == 0x000028, "Member 'UTableRegistryItem::TableRowName' has a wrong offset!");

// Class Stigma.TableRegistryStructItem
// 0x0010 (0x0038 - 0x0028)
class UTableRegistryStructItem final : public UObject
{
public:
	class UScriptStruct*                          StructType;                                        // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_248E[0x8];                                     // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TableRegistryStructItem">();
	}
	static class UTableRegistryStructItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTableRegistryStructItem>();
	}
};
static_assert(alignof(UTableRegistryStructItem) == 0x000008, "Wrong alignment on UTableRegistryStructItem");
static_assert(sizeof(UTableRegistryStructItem) == 0x000038, "Wrong size on UTableRegistryStructItem");
static_assert(offsetof(UTableRegistryStructItem, StructType) == 0x000028, "Member 'UTableRegistryStructItem::StructType' has a wrong offset!");

// Class Stigma.TDM_GameMode
// 0x0018 (0x07F0 - 0x07D8)
class ATDM_GameMode : public ABattleGameModeBase
{
public:
	uint8                                         Pad_248F[0x8];                                     // 0x07D8(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class ASanctumArea*>                   _Sanctums;                                         // 0x07E0(0x0010)(ZeroConstructor, Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TDM_GameMode">();
	}
	static class ATDM_GameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATDM_GameMode>();
	}
};
static_assert(alignof(ATDM_GameMode) == 0x000008, "Wrong alignment on ATDM_GameMode");
static_assert(sizeof(ATDM_GameMode) == 0x0007F0, "Wrong size on ATDM_GameMode");
static_assert(offsetof(ATDM_GameMode, _Sanctums) == 0x0007E0, "Member 'ATDM_GameMode::_Sanctums' has a wrong offset!");

// Class Stigma.TDM_GameState
// 0x0048 (0x0950 - 0x0908)
class ATDM_GameState : public ABattleGameStateBase
{
public:
	uint8                                         _CurrentPhase;                                     // 0x0908(0x0001)(BlueprintVisible, Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2490[0x7];                                     // 0x0909(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FTDMRule                               _TDMRule;                                          // 0x0910(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FTDM_GoldRule                          _GoldRule;                                         // 0x0938(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2491[0x4];                                     // 0x094C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnRep_CurrentPhase();
	void SetCurrentPhase(int32 _phase);

	uint8 GetCurrentTDMPhase() const;
	const struct FTDMPhaseDefine GetCurrentTDMPhaseDefine() const;
	const struct FTDM_GoldRule GetGoldRule() const;
	int32 GetTargetKillCount() const;
	const struct FTDMRule GetTDMRule() const;
	int32 GetTeamRemainKillCount(ETeams _Team) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TDM_GameState">();
	}
	static class ATDM_GameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATDM_GameState>();
	}
};
static_assert(alignof(ATDM_GameState) == 0x000008, "Wrong alignment on ATDM_GameState");
static_assert(sizeof(ATDM_GameState) == 0x000950, "Wrong size on ATDM_GameState");
static_assert(offsetof(ATDM_GameState, _CurrentPhase) == 0x000908, "Member 'ATDM_GameState::_CurrentPhase' has a wrong offset!");
static_assert(offsetof(ATDM_GameState, _TDMRule) == 0x000910, "Member 'ATDM_GameState::_TDMRule' has a wrong offset!");
static_assert(offsetof(ATDM_GameState, _GoldRule) == 0x000938, "Member 'ATDM_GameState::_GoldRule' has a wrong offset!");

// Class Stigma.TDM_PlayerController
// 0x0000 (0x0E40 - 0x0E40)
class ATDM_PlayerController : public ABattlePlayerControllerBase
{
public:
	ETeams GetEnemyTeam() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TDM_PlayerController">();
	}
	static class ATDM_PlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATDM_PlayerController>();
	}
};
static_assert(alignof(ATDM_PlayerController) == 0x000008, "Wrong alignment on ATDM_PlayerController");
static_assert(sizeof(ATDM_PlayerController) == 0x000E40, "Wrong size on ATDM_PlayerController");

// Class Stigma.TDM_PlayerState
// 0x0000 (0x0C88 - 0x0C88)
class ATDM_PlayerState : public ABattlePlayerState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TDM_PlayerState">();
	}
	static class ATDM_PlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATDM_PlayerState>();
	}
};
static_assert(alignof(ATDM_PlayerState) == 0x000008, "Wrong alignment on ATDM_PlayerState");
static_assert(sizeof(ATDM_PlayerState) == 0x000C88, "Wrong size on ATDM_PlayerState");

// Class Stigma.Teamable
// 0x0000 (0x0028 - 0x0028)
class ITeamable final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Teamable">();
	}
	static class ITeamable* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITeamable>();
	}
};
static_assert(alignof(ITeamable) == 0x000008, "Wrong alignment on ITeamable");
static_assert(sizeof(ITeamable) == 0x000028, "Wrong size on ITeamable");

// Class Stigma.TeamContext
// 0x0008 (0x0030 - 0x0028)
class UTeamContext final : public UObject
{
public:
	uint8                                         Pad_2493[0x8];                                     // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamContext">();
	}
	static class UTeamContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamContext>();
	}
};
static_assert(alignof(UTeamContext) == 0x000008, "Wrong alignment on UTeamContext");
static_assert(sizeof(UTeamContext) == 0x000030, "Wrong size on UTeamContext");

// Class Stigma.TickTaskComponent
// 0x0010 (0x00B0 - 0x00A0)
class UTickTaskComponent final : public UActorComponent
{
public:
	uint8                                         Pad_2494[0x10];                                    // 0x00A0(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TickTaskComponent">();
	}
	static class UTickTaskComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTickTaskComponent>();
	}
};
static_assert(alignof(UTickTaskComponent) == 0x000008, "Wrong alignment on UTickTaskComponent");
static_assert(sizeof(UTickTaskComponent) == 0x0000B0, "Wrong size on UTickTaskComponent");

// Class Stigma.TimedNiagaraEffectStigma
// 0x0080 (0x00F8 - 0x0078)
class UTimedNiagaraEffectStigma final : public UAnimNotifyState_TimedNiagaraEffect
{
public:
	TMap<struct FItemID, class UNiagaraSystem*>   _BodyID_With_NiagaraSystem;                        // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x00C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemID                                _MaskHead;                                         // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         _resultTemplate;                                   // 0x00F0(0x0008)(BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimedNiagaraEffectStigma">();
	}
	static class UTimedNiagaraEffectStigma* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimedNiagaraEffectStigma>();
	}
};
static_assert(alignof(UTimedNiagaraEffectStigma) == 0x000008, "Wrong alignment on UTimedNiagaraEffectStigma");
static_assert(sizeof(UTimedNiagaraEffectStigma) == 0x0000F8, "Wrong size on UTimedNiagaraEffectStigma");
static_assert(offsetof(UTimedNiagaraEffectStigma, _BodyID_With_NiagaraSystem) == 0x000078, "Member 'UTimedNiagaraEffectStigma::_BodyID_With_NiagaraSystem' has a wrong offset!");
static_assert(offsetof(UTimedNiagaraEffectStigma, Scale) == 0x0000C8, "Member 'UTimedNiagaraEffectStigma::Scale' has a wrong offset!");
static_assert(offsetof(UTimedNiagaraEffectStigma, _MaskHead) == 0x0000E0, "Member 'UTimedNiagaraEffectStigma::_MaskHead' has a wrong offset!");
static_assert(offsetof(UTimedNiagaraEffectStigma, _resultTemplate) == 0x0000F0, "Member 'UTimedNiagaraEffectStigma::_resultTemplate' has a wrong offset!");

// Class Stigma.VaultTrigger
// 0x0020 (0x02B8 - 0x0298)
class AVaultTrigger final : public AActor
{
public:
	uint8                                         Pad_2495[0x8];                                     // 0x0298(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class USceneComponent*                        _Root;                                             // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBoxComponent*                          _Box;                                              // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EVaultType                                    VaultType;                                         // 0x02B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2496[0x7];                                     // 0x02B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VaultTrigger">();
	}
	static class AVaultTrigger* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVaultTrigger>();
	}
};
static_assert(alignof(AVaultTrigger) == 0x000008, "Wrong alignment on AVaultTrigger");
static_assert(sizeof(AVaultTrigger) == 0x0002B8, "Wrong size on AVaultTrigger");
static_assert(offsetof(AVaultTrigger, _Root) == 0x0002A0, "Member 'AVaultTrigger::_Root' has a wrong offset!");
static_assert(offsetof(AVaultTrigger, _Box) == 0x0002A8, "Member 'AVaultTrigger::_Box' has a wrong offset!");
static_assert(offsetof(AVaultTrigger, VaultType) == 0x0002B0, "Member 'AVaultTrigger::VaultType' has a wrong offset!");

// Class Stigma.ToastManager
// 0x0010 (0x0038 - 0x0028)
class UToastManager final : public UObject
{
public:
	uint8                                         Pad_2497[0x10];                                    // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ClearAllReservedToasts();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ToastManager">();
	}
	static class UToastManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UToastManager>();
	}
};
static_assert(alignof(UToastManager) == 0x000008, "Wrong alignment on UToastManager");
static_assert(sizeof(UToastManager) == 0x000038, "Wrong size on UToastManager");

// Class Stigma.Tools
// 0x0000 (0x0028 - 0x0028)
class UTools final : public UBlueprintFunctionLibrary
{
public:
	static bool AddDefaultAutoSystemChat(const class UObject* _world_ctx);
	static void AddGameNotify(const class UObject* _world_ctx, const class FName& _notify_name, const class FText& _text, float _overlap_life_time);
	static bool AddSystemChat(const class UObject* _world_ctx, const class FText& _context);
	static bool AddSystemChatWithColor(const class UObject* _world_ctx, const class FText& _context, const struct FLinearColor& _color);
	static bool AddToastMessage(const class UObject* _world_ctx, const class FString& _msg, bool _is_urgent);
	static void AddWidgetAsHUD(const class UObject* _world_ctx, class UWidget* _widget);
	static void AreYouSureToExitGame(const class UObject* _world_ctx);
	static class FText BuffValueToText(EBuffValueDisplayType _type, const class FString& _prev_prefix_text, float _value, bool _is_positive_beneficial, int32 _additional_value);
	static float CalcPassiveSkillEffectValue(const struct FItemID& _passive_id, int32 _level, EBuffEffectType _effect_type);
	static bool CanIRequestMatchMaking(const class UObject* _world_ctx);
	static bool CanUseMinimap(const class UObject* _world_ctx);
	static bool ChangeMinimapSpot(const class UObject* _world_ctx, class UMinimap* _Minimap);
	static bool CheckImInParty(const class UObject* _world_ctx);
	static bool CheckImPartyLeader(const class UObject* _world_ctx);
	static bool CheckIsMyFriend(const class UObject* _world_ctx, const struct FUserID& _user_id);
	static bool CheckIsMyPartyMember(const class UObject* _world_ctx, const struct FUserID& _user_id);
	static bool CheckKoreaCountry(const class UObject* _world_ctx);
	static ENicknameTestResult CheckNickname(const class UObject* _world_ctx, const class FString& _nickname);
	static bool ClearAllChatHistories(const class UObject* _world_ctx);
	static float Convert_CM_To_M(float _value);
	static float Convert_M_To_CM(float _value);
	static float Convert_Percentage_To_Weight(float _value);
	static float Convert_Weight_To_Percentage(float _value);
	static class UGunObject* CreateUnownedGun(const class UObject* _world_ctx, EGunType _gun_type);
	static class FString DamageToString(const struct FDamagedData& _damage);
	static void EnableIMEOnWebUI(class UWidget* _widget);
	static class FString ExtractBattleIDS(const class FString& _str);
	static class AMatchServicedPlayerState* FindMatchServicedPlayerStateByUserID(const class UObject* _world_ctx, const struct FUserID& _user_id);
	static class ABattlePlayerState* FindMyBattlePlayerState(const TArray<class APlayerState*>& _player_array);
	static class AMatchServicedPlayerController* FindPlayerControllerByUserID(const class UObject* _world_ctx, const struct FUserID& _user_id);
	static class FString FormatBattleIDS(const class FString& _battle_ids);
	static TArray<EGunType> GetAllGunTypes(const class UObject* _world_ctx);
	static TArray<struct FTeamPlayers> GetAllPlayerCharacters(const class UObject* _world_ctx);
	static TArray<class APlayerState*> GetAllPlayers(const class UObject* _world_ctx);
	static TArray<class ABattlePlayerState*> GetAllPlayersForTabUI(const class UObject* _world_ctx);
	static int32 GetBoostedPassiveSkillLevel(const class UObject* _world_ctx);
	static const TArray<struct FItemID_Booster> GetBoosters(const class UObject* _world_ctx);
	static float GetBuffAbilityFloatValue(const class UObject* _world_ctx, const class FName& _ability_name);
	static float GetBuffCalculatedResultStat(const class UObject* _world_ctx, ECharaType _chara_type, EBuffEffectType _type);
	static float GetBuffCalculatedResultStatFromCurrentCharacter(const class UObject* _world_ctx, EBuffEffectType _type);
	static class FText GetBuffDiffTextFormBuffOption(const struct FBuffEffectOption& _option);
	static TArray<struct FEffectDetail> GetBuffedEffects(const class UObject* _world_ctx, const struct FItemID& _item_id, int32 _level);
	static class FText GetBuffNameFormBuffType(EBuffEffectType _type);
	static TArray<class UBuffBase*> GetBuffsByItemID(const struct FItemID& _item_id);
	static TMap<class FString, class FString> GetBuffTextInfoMapFromItemID(const class UObject* _world_ctx, const struct FItemID& _item_id, int32 _level);
	static class FText GetBuffValueTextFormBuffOption(const struct FBuffEffectOption& _option, int32 _additional_value);
	static class FText GetBuffValueTextFromItemID(const class UObject* _world_ctx, bool _show_only_value, const struct FItemID& _item_id, int32 _level, int32 _additional_value);
	static struct FCharacterInfo GetCharacter(const class UObject* WorldContextObject, ECharaType _chara_type);
	static TArray<ECharaType> GetCharacterTypesByGunType(const class UObject* _world_ctx, EGunType _gun_type);
	static TSoftObjectPtr<class UTexture2D> GetCharaIconByType(ECharaType _chara_type);
	static class UChatManager* GetChatManager(const class UObject* _world_ctx);
	static int32 GetCurrencyValue(const class UObject* _world_ctx, ECurrencyTypes _type);
	static int32 GetCurrencyValueFromID(const class UObject* _world_ctx, const struct FItemID_Currency& _currency_id);
	static struct FCharacterInfo GetCurrentCharacter(const class UObject* _world_ctx);
	static ECharaType GetCurrentCharacterType(const class UObject* _world_ctx);
	static bool GetCurrentGameModeType(const class UObject* _world_ctx, EGameMode* _out_game_mode_type);
	static int32 GetDisplayCountFromBuffOptions(const TArray<struct FBuffEffectOption>& _buff_options);
	static class FString GetElapsedUtcTimeString(const struct FDateTimeISO& _standard_time_utc, const struct FDateTimeISO& _current_time_utc);
	static float GetEquipedEffectValue(const class UObject* _world_ctx, EBuffEffectType _type);
	static TMap<EItemEquipFilter, class FText> GetEquipFilterTextMap(const class UObject* _world_ctx);
	static TArray<struct FBuffEffectOption> GetEquipPassiveAndBoosterBuffOptions(const class UObject* _world_ctx, const TArray<struct FPassiveSkill>& _passive_skill_ids, const TArray<struct FItemID_Booster>& _item_ids);
	static TArray<struct FBuffEffectOption> GetEquipPassiveAndBoosterBuffOptionsEx(const class UObject* _world_ctx, const struct FItemID& _prev_mounted_item_id, const struct FItemID& _cur_mounted_item_id, const struct FItemID& _ignore_item_id, const TArray<struct FPassiveSkill>& _passive_skill_ids, const TArray<struct FItemID_Booster>& _item_ids);
	static class UEventCounterSubsystem* GetEventCounterSubsystem(const class UObject* _world_ctx);
	static const TArray<class UUserProfile*> GetFriendAskedList(const class UObject* _world_ctx);
	static class UGameContext* GetGameContext(const class UObject* _world_ctx);
	static class FText GetGunPartsSlotText(const class UObject* _world_ctx, EGunPartsSlot _gun_parts_slot);
	static TMap<EGunSpecFilter, class FText> GetGunSpecFilterTextMap(const class UObject* _world_ctx);
	static int32 GetInvatableFriendsCount(const class UObject* _world_ctx);
	static int32 GetInvatableRecentUsersCount(const class UObject* _world_ctx);
	static TArray<class UInvenItem*> GetLocalInvenItemList(const class UObject* _world_ctx, const struct FItemID& _id);
	static class UInvenItems* GetLocalInvenItems(const class UObject* _world_ctx);
	static class UStigmaLocalPlayer* GetLocalPlayer(const class UObject* _world_ctx);
	static class ACharaBase* GetLocalPlayerCharacter(const class UObject* _world_ctx);
	static class ULocalPlayerContext* GetLocalPlayerContext(const class UObject* _world_ctx);
	static class AStigmaPlayerController* GetLocalPlayerController(const class UObject* _world_ctx);
	static class APlayerState* GetLocalPlayerState(const class UObject* _world_ctx);
	static class ULocalRegistry* GetLocalRegistry(const class UObject* _world_ctx);
	static float GetLoginElapsedSec(const class UObject* _world_ctx);
	static struct FObtainGuide GetMasterObtainGuide(ECharaType _chara_type);
	static class FText GetMasterObtainGuideText(ECharaType _chara_type);
	static class FString GetMatchableTimeRange(const class UObject* _world_ctx);
	static EFindMatchStatus GetMatchMakingStatus(const class UObject* _world_ctx);
	static const TArray<class UUserProfile*> GetMyFriendList(const class UObject* _world_ctx);
	static struct FPartyID GetMyPartyID(const class UObject* _world_ctx);
	static class UStigmaLocalPlayer* GetMyPlayer(const class UObject* _world_ctx);
	static int32 GetNonBoostedPassiveSkillLevel(const class UObject* _world_ctx, const struct FPassiveSkillID& _skill_id);
	static const TArray<struct FPassiveSkill> GetPassiveSkills(const class UObject* _world_ctx);
	static class USpecterPhysicalMaterial* GetPhysicalMaterial(const struct FHitResult& _hit);
	static EPingQuality GetPingQuality(class APlayerState* _ps);
	static int32 GetPlayableCharacterCount(const class UObject* _world_ctx);
	static struct FVector2D GetProperIconSizeWRTGuide(const struct FVector2D& _icon_sz, const struct FVector2D& _guide, const struct FVector2D& _margin);
	static const TArray<class UUserProfile*> GetRecentUserList(const class UObject* _world_ctx);
	static const TArray<class UUserProfile*> GetSearchedUserList(const class UObject* _world_ctx);
	static EServerStatus GetServerStatus(const class UObject* _world_ctx);
	static ESlateVisibility GetSlateVisibility_Development(ESlateVisibility _want);
	static ETeams GetSmallestTeam(const class UObject* _world_ctx, int32 _max_team);
	static class USocialContext* GetSocialContext(const class UObject* _world_ctx);
	static const TArray<class UUserProfile*> GetSteamFriendList(const class UObject* _world_ctx);
	static ESurfaceMaterialType GetSurfaceMaterial(const class UPhysicalMaterial* _mat);
	static struct FLinearColor GetTeamColorByPlayerState(const class UObject* _world_ctx, class AMatchServicedPlayerState* _player_state);
	static struct FLinearColor GetTeamColorByTeam(const class UObject* _world_ctx, ETeams _other_team);
	static ETeamSide GetTeamSide(const class UObject* _world_ctx, ETeams _Team);
	static ETeams GetTeamWRTSide(ETeams _base_team, ETeamSide _side, int32 _max_team);
	static class FText GetTextForCooltimeAndDuration(const struct FItemID& _item_id);
	static class UToastManager* GetToastManager(const class UObject* _world_ctx);
	static class UInvenItem* GetTopLocalInvenItemByID(const class UObject* _world_ctx, const struct FItemID& _id);
	static class UPopupBase* GetTopPopup(const class UObject* _world_ctx);
	static float GetTraceValue(float _target_value, float _trace_value, float _time_add_value, float _time_sub_value, float _min, float _max);
	static int32 GetUserExp(const class UObject* _world_ctx);
	static float GetUserExpPercent(const class UObject* _world_ctx);
	static struct FUserID GetUserID(const class UObject* _world_ctx);
	static int32 GetUserLevel(const class UObject* _world_ctx);
	static int32 GetUserNextExp(const class UObject* _world_ctx);
	static const struct FUserName GetUserNickName(const class UObject* _world_ctx);
	static class UUserOption* GetUserOptionSubSystem(const class UObject* _world_ctx);
	static int32 GetUserPassiveSkillLevel(const class UObject* _world_ctx, const struct FPassiveSkillID& _skill_id);
	static const struct FUserRole GetUserRole(const class UObject* _world_ctx);
	static bool HasCharacter(const class UObject* _world_ctx, ECharaType _chara_type);
	static bool HasGun(const class UObject* _world_ctx, EGunType _gun_type);
	static bool HasItem(const class UObject* _world_ctx, const struct FItemID& _item_id);
	static bool HasUniqueItem(const class UObject* _world_ctx, const struct FItemID& _item_id);
	static void HideAllGameNotifies(const class UObject* _world_ctx, bool _hide);
	static void HideUI(const class UObject* _world_ctx, bool _hide);
	static bool IsCurrentCharaEquipedItemID(const class UObject* _world_ctx, const struct FItemID& _item_id);
	static bool IsCustomGame(const class UObject* _world_ctx);
	static bool IsEqual(const struct FNetID& _net_id_a, const struct FNetID& _net_id_b);
	static bool IsEquipedPassiveAndBoosterFromCurrentCharacter(const class UObject* _world_ctx, const struct FItemID& _item_id);
	static bool IsGoodAck(const struct FApiResult& _ack);
	static bool IsGunAccessoryID(const struct FItemID& _item_id);
	static bool IsMatchableTime(const class UObject* _world_ctx);
	static bool IsNowBattleMode(const class UObject* _world_ctx, bool _allow_only_real_battle);
	static bool IsNPC(ECharaType _chara_type);
	static bool IsPVPMode(EGameMode _game_mode_type);
	static bool IsSelectableCharacterPickUI(const class UObject* _world_ctx);
	static bool IsSupportedArmor(const struct FItemID_Skin_Body& _body_id, EArmorType _armor_type);
	static bool IsTheOnlyMatachableGameMode(const class UObject* _world_ctx, EGameMode _game_mode);
	static bool IsUnlimitedBooster(const class UObject* _world_ctx);
	static bool IsUpcommingCharacter(const class UObject* _world_ctx, ECharaType _chara_type);
	static bool IsUpcommingItem(EItemStage _stage);
	static bool IsUseableItem(EItemStage _stage);
	static bool IsUseableItemID(const struct FItemID& _item_id);
	static bool IsVisibleRedDotOnAttachableParts(const class UObject* _world_ctx, EGunType _gun_type);
	static bool IsVisibleRedDotOnGun(const class UObject* _world_ctx, const class UGunObject* _gun_object);
	static EPingQuality JudgePingQuality(int32 _ping_ms);
	static void MakeCrash();
	static struct FNetReply NetReplyFromCode(EResultCode _code);
	static void NormalizeRandomBoxProbability(TArray<struct FRandomItemEntry>& _list);
	static void OverrideWishedGameMode(struct FMatchOption& _option, EGameMode _game_mode);
	static void PopupESCMenu(const class UObject* _world_ctx);
	static void ProcessWebCommands(const class UObject* _world_ctx, const class FString& _cmd_line);
	static void ReBuildEnhancedInput(const class UObject* _world_ctx, EInputMappingRebuildType _rebuild_type);
	static void RegisterNotify_OnLoad_Characters(const class UObject* _world_ctx, const TDelegate<void()>& _callback);
	static void RegisterNotify_OnLoad_UserInfo(const class UObject* _world_ctx, const TDelegate<void()>& _callback);
	static void RemoveGameNotify(const class UObject* _world_ctx, const class FName& _notify_name, bool _force_remove);
	static void RemoveWidgetAsHUD(const class UObject* _world_ctx, class UWidget* _widget);
	static bool SetAskedFriends(const class UObject* _world_ctx, const TArray<struct FFriend>& _asked_friends);
	static void SetButtonStyleImage(class UButton* _button, class UTexture2D* _normal_texture, class UTexture2D* _hover_texture, class UTexture2D* _click_texture, class UTexture2D* _disable_texture, bool _resize);
	static void SetButtonStyleTintColor(class UButton* _button, const struct FLinearColor& _normal_color, const struct FLinearColor& _hover_color, const struct FLinearColor& _click_color, const struct FLinearColor& _disabled_color);
	static void SetInputBlocked(const class UObject* _world_ctx, bool _is_blocked);
	static void SetLobbyCurrencyBox(const class UObject* _world_ctx, const TArray<struct FItemID_Currency>& _currency_ids, bool _use_wallet, bool _use_quick_purchase);
	static void SetMannequinVisibility(const class UObject* _world_ctx, bool _visible);
	static bool SetMyFriends(const class UObject* _world_ctx, const TArray<struct FFriend>& _friends);
	static void SetNicknameFX(class URichTextBlock* _widget, const struct FItemID& _item_id, float _size);
	static bool SetRecentBattleUsers(const class UObject* _world_ctx, const TArray<struct FFriend>& _battle_users);
	static bool SetSearchedUsers(const class UObject* _world_ctx, const TArray<struct FUserSearch>& _users);
	static bool SetSteamFriends(const class UObject* _world_ctx, const TArray<struct FFriend>& _steam_friends);
	static void ShowErrorBox(const class UObject* _world_ctx, const class FText& _Title, const class FText& _msg);
	static void ShowLobbyUI(const class UObject* _world_ctx, bool _show);
	static void ShowRewardPopup(const class UObject* _world_ctx, const struct FRewardPlain& _rewards);
	static EGunPartsSocket SlotToSocket_Accessory(EGunPartsSlot _slot);
	static void SortOwnedPriorityInvenItem(TArray<class UInvenItem*>& _items, const struct FItemID& _priority_id);
	static TArray<struct FNetRankingEntry> SplitMyNearRankingForAll(const class UObject* _world_ctx, const TArray<struct FNetRankingEntry>& _ranking);
	static TArray<struct FACK_ChallengeRead> SplitMyNearRankingForChallenge(const class UObject* _world_ctx, const TArray<struct FACK_ChallengeRead>& _ranking);
	static void Subscribe_OnUpdateUser(const class UObject* _world_ctx, const TSet<EUserEvent>& _interested, const TDelegate<void(EUserEvent _event)>& _callback);
	static EGunType ToGunType(int32 _value);
	static EPlayerStatus ToPlayerStatus(int32 _val);
	static void UnregisterNotify_OnLoad_Characters(const class UObject* _world_ctx, const class UObject* _obj);
	static void UnregisterNotify_OnLoad_UserInfo(const class UObject* _world_ctx, const class UObject* _obj);
	static void Unsubscribe_OnUpdateUser(const class UObject* _world_ctx, const class UObject* _obj);
	static void UpdateFlashBangRadar(const class UObject* _world_ctx, class UImage* _target_img);
	static void UpdateGunOwnInfo(const class UObject* _world_ctx, class UGunObject* _gun_object);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Tools">();
	}
	static class UTools* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTools>();
	}
};
static_assert(alignof(UTools) == 0x000008, "Wrong alignment on UTools");
static_assert(sizeof(UTools) == 0x000028, "Wrong size on UTools");

// Class Stigma.TooltipHelper
// 0x0000 (0x0028 - 0x0028)
class UTooltipHelper final : public UBlueprintFunctionLibrary
{
public:
	static class UUI_Tooltip* CreateTooltipWidget(class UWidget* _owning_widget, ETooltipType _type);
	static ETooltipType GetTooltipTypeFromItemCategory(EItemCategory _category);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TooltipHelper">();
	}
	static class UTooltipHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTooltipHelper>();
	}
};
static_assert(alignof(UTooltipHelper) == 0x000008, "Wrong alignment on UTooltipHelper");
static_assert(sizeof(UTooltipHelper) == 0x000028, "Wrong size on UTooltipHelper");

// Class Stigma.TraceHelper
// 0x0000 (0x0028 - 0x0028)
class UTraceHelper final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceHelper">();
	}
	static class UTraceHelper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTraceHelper>();
	}
};
static_assert(alignof(UTraceHelper) == 0x000008, "Wrong alignment on UTraceHelper");
static_assert(sizeof(UTraceHelper) == 0x000028, "Wrong size on UTraceHelper");

// Class Stigma.TrainingRoomPlayerState
// 0x0008 (0x0C90 - 0x0C88)
class ATrainingRoomPlayerState final : public ABattlePlayerState
{
public:
	uint8                                         Pad_24FF[0x8];                                     // 0x0C88(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TrainingRoomPlayerState">();
	}
	static class ATrainingRoomPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATrainingRoomPlayerState>();
	}
};
static_assert(alignof(ATrainingRoomPlayerState) == 0x000008, "Wrong alignment on ATrainingRoomPlayerState");
static_assert(sizeof(ATrainingRoomPlayerState) == 0x000C90, "Wrong size on ATrainingRoomPlayerState");

// Class Stigma.VS_PlayerState
// 0x0000 (0x0C88 - 0x0C88)
class AVS_PlayerState final : public AAnnihilation_PlayerState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VS_PlayerState">();
	}
	static class AVS_PlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVS_PlayerState>();
	}
};
static_assert(alignof(AVS_PlayerState) == 0x000008, "Wrong alignment on AVS_PlayerState");
static_assert(sizeof(AVS_PlayerState) == 0x000C88, "Wrong size on AVS_PlayerState");

// Class Stigma.TransitionGameMode
// 0x0000 (0x0338 - 0x0338)
class ATransitionGameMode final : public AGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TransitionGameMode">();
	}
	static class ATransitionGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATransitionGameMode>();
	}
};
static_assert(alignof(ATransitionGameMode) == 0x000008, "Wrong alignment on ATransitionGameMode");
static_assert(sizeof(ATransitionGameMode) == 0x000338, "Wrong size on ATransitionGameMode");

// Class Stigma.TransitionPlayerController
// 0x0090 (0x0948 - 0x08B8)
class ATransitionPlayerController final : public ABPGPlayerController
{
public:
	uint8                                         Pad_2500[0x90];                                    // 0x08B8(0x0090)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TransitionPlayerController">();
	}
	static class ATransitionPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATransitionPlayerController>();
	}
};
static_assert(alignof(ATransitionPlayerController) == 0x000008, "Wrong alignment on ATransitionPlayerController");
static_assert(sizeof(ATransitionPlayerController) == 0x000948, "Wrong size on ATransitionPlayerController");

// Class Stigma.Tutorial
// 0x0020 (0x0048 - 0x0028)
class UTutorial : public UObject
{
public:
	uint8                                         Pad_2501[0x20];                                    // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void AddRefWidget(class UUserWidget* _widget);
	ETutorialStartResponse OnQueryStart();
	void RemoveRefWidget(const class UUserWidget* _widget);
	void Start();

	EBattleModePhase GetBattlePhase() const;
	float GetBattlePhaseElapsedTime() const;
	int32 GetCurrentRound() const;
	float GetHP() const;
	int32 GetPlayedCount() const;
	int32 GetPlayedMatchCount() const;
	bool IsAnyPopupOpened() const;
	bool IsBattlePhase(EBattleModePhase _phase) const;
	bool IsCurrentRound(int32 _round) const;
	bool IsPassOverTimeFromLastPlaying(int32 _secs) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Tutorial">();
	}
	static class UTutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorial>();
	}
};
static_assert(alignof(UTutorial) == 0x000008, "Wrong alignment on UTutorial");
static_assert(sizeof(UTutorial) == 0x000048, "Wrong size on UTutorial");

// Class Stigma.UIGuide_ClosePointUI
// 0x0000 (0x0038 - 0x0038)
class UUIGuide_ClosePointUI final : public UUIGuide_Base
{
public:
	static class UUIGuide_ClosePointUI* Tutorial_ClosePointUI(class UTutorial* _tutorial);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGuide_ClosePointUI">();
	}
	static class UUIGuide_ClosePointUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGuide_ClosePointUI>();
	}
};
static_assert(alignof(UUIGuide_ClosePointUI) == 0x000008, "Wrong alignment on UUIGuide_ClosePointUI");
static_assert(sizeof(UUIGuide_ClosePointUI) == 0x000038, "Wrong size on UUIGuide_ClosePointUI");

// Class Stigma.UIGuide_ShowMissionWidget
// 0x0008 (0x0040 - 0x0038)
class UUIGuide_ShowMissionWidget final : public UUIGuide_Base
{
public:
	uint8                                         Pad_2504[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UUIGuide_ShowMissionWidget* Tutorial_ShowMissionWidget(class UTutorial* _tutorial, bool _show);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGuide_ShowMissionWidget">();
	}
	static class UUIGuide_ShowMissionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGuide_ShowMissionWidget>();
	}
};
static_assert(alignof(UUIGuide_ShowMissionWidget) == 0x000008, "Wrong alignment on UUIGuide_ShowMissionWidget");
static_assert(sizeof(UUIGuide_ShowMissionWidget) == 0x000040, "Wrong size on UUIGuide_ShowMissionWidget");

// Class Stigma.UIGuide_ShowHelpWidget
// 0x0028 (0x0060 - 0x0038)
class UUIGuide_ShowHelpWidget final : public UUIGuide_Base
{
public:
	uint8                                         Pad_2506[0x18];                                    // 0x0038(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             OnCloseWidget;                                     // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UUIGuide_ShowHelpWidget* Tutorial_ShowHelpWidget(class UTutorial* _tutorial, bool _show, const class FString& _help_contents_key);

	void OnCloseHelp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGuide_ShowHelpWidget">();
	}
	static class UUIGuide_ShowHelpWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGuide_ShowHelpWidget>();
	}
};
static_assert(alignof(UUIGuide_ShowHelpWidget) == 0x000008, "Wrong alignment on UUIGuide_ShowHelpWidget");
static_assert(sizeof(UUIGuide_ShowHelpWidget) == 0x000060, "Wrong size on UUIGuide_ShowHelpWidget");
static_assert(offsetof(UUIGuide_ShowHelpWidget, OnCloseWidget) == 0x000050, "Member 'UUIGuide_ShowHelpWidget::OnCloseWidget' has a wrong offset!");

// Class Stigma.UIGuide_Finish
// 0x0000 (0x0038 - 0x0038)
class UUIGuide_Finish final : public UUIGuide_Base
{
public:
	static class UUIGuide_Finish* Tutorial_Finish(class UTutorial* _tutorial);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGuide_Finish">();
	}
	static class UUIGuide_Finish* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGuide_Finish>();
	}
};
static_assert(alignof(UUIGuide_Finish) == 0x000008, "Wrong alignment on UUIGuide_Finish");
static_assert(sizeof(UUIGuide_Finish) == 0x000038, "Wrong size on UUIGuide_Finish");

// Class Stigma.UIGuide_PauseGame
// 0x0008 (0x0040 - 0x0038)
class UUIGuide_PauseGame final : public UUIGuide_Base
{
public:
	uint8                                         Pad_2508[0x8];                                     // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UUIGuide_PauseGame* Tutorial_PauseGame(class UTutorial* _tutorial, bool _pause);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGuide_PauseGame">();
	}
	static class UUIGuide_PauseGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGuide_PauseGame>();
	}
};
static_assert(alignof(UUIGuide_PauseGame) == 0x000008, "Wrong alignment on UUIGuide_PauseGame");
static_assert(sizeof(UUIGuide_PauseGame) == 0x000040, "Wrong size on UUIGuide_PauseGame");

// Class Stigma.UIGuide_ShowBattleStore
// 0x0018 (0x0050 - 0x0038)
class UUIGuide_ShowBattleStore final : public UUIGuide_Base
{
public:
	uint8                                         Pad_250A[0x8];                                     // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             OnCloseWidget;                                     // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UUIGuide_ShowBattleStore* Tutorial_ShowBattleStore(class UTutorial* _tutorial, bool _show);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGuide_ShowBattleStore">();
	}
	static class UUIGuide_ShowBattleStore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGuide_ShowBattleStore>();
	}
};
static_assert(alignof(UUIGuide_ShowBattleStore) == 0x000008, "Wrong alignment on UUIGuide_ShowBattleStore");
static_assert(sizeof(UUIGuide_ShowBattleStore) == 0x000050, "Wrong size on UUIGuide_ShowBattleStore");
static_assert(offsetof(UUIGuide_ShowBattleStore, OnCloseWidget) == 0x000040, "Member 'UUIGuide_ShowBattleStore::OnCloseWidget' has a wrong offset!");

// Class Stigma.UIGuide_ResumeTutorial
// 0x0000 (0x0038 - 0x0038)
class UUIGuide_ResumeTutorial final : public UUIGuide_Base
{
public:
	static class UUIGuide_ResumeTutorial* Tutorial_ResumeTutorial(class UTutorial* _tutorial);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGuide_ResumeTutorial">();
	}
	static class UUIGuide_ResumeTutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGuide_ResumeTutorial>();
	}
};
static_assert(alignof(UUIGuide_ResumeTutorial) == 0x000008, "Wrong alignment on UUIGuide_ResumeTutorial");
static_assert(sizeof(UUIGuide_ResumeTutorial) == 0x000038, "Wrong size on UUIGuide_ResumeTutorial");

// Class Stigma.UIGuide_WaitCharacterSelect
// 0x0018 (0x0050 - 0x0038)
class UUIGuide_WaitCharacterSelect final : public UUIGuide_Base
{
public:
	uint8                                         Pad_250C[0x8];                                     // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             OnAfterSelect;                                     // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UUIGuide_WaitCharacterSelect* Tutorial_WaitCharacterSelect(class UTutorial* _tutorial, EFightingStyle _fighting_style);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGuide_WaitCharacterSelect">();
	}
	static class UUIGuide_WaitCharacterSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGuide_WaitCharacterSelect>();
	}
};
static_assert(alignof(UUIGuide_WaitCharacterSelect) == 0x000008, "Wrong alignment on UUIGuide_WaitCharacterSelect");
static_assert(sizeof(UUIGuide_WaitCharacterSelect) == 0x000050, "Wrong size on UUIGuide_WaitCharacterSelect");
static_assert(offsetof(UUIGuide_WaitCharacterSelect, OnAfterSelect) == 0x000040, "Member 'UUIGuide_WaitCharacterSelect::OnAfterSelect' has a wrong offset!");

// Class Stigma.UIGuide_ApplyFunction
// 0x0018 (0x0050 - 0x0038)
class UUIGuide_ApplyFunction final : public UUIGuide_Base
{
public:
	uint8                                         Pad_250E[0x18];                                    // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UUIGuide_ApplyFunction* Tutorial_ApplyFunction(class UTutorial* _tutorial, const struct FItemIDRef_Function& _func_id, bool _remove);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGuide_ApplyFunction">();
	}
	static class UUIGuide_ApplyFunction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGuide_ApplyFunction>();
	}
};
static_assert(alignof(UUIGuide_ApplyFunction) == 0x000008, "Wrong alignment on UUIGuide_ApplyFunction");
static_assert(sizeof(UUIGuide_ApplyFunction) == 0x000050, "Wrong size on UUIGuide_ApplyFunction");

// Class Stigma.UIGuide_PlayCutScene
// 0x0068 (0x00A0 - 0x0038)
class UUIGuide_PlayCutScene final : public UUIGuide_Base
{
public:
	FMulticastInlineDelegateProperty_             OnAfterDone;                                       // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2510[0x40];                                    // 0x0048(0x0040)(Fixing Size After Last Property [ Dumper-69 ])
	class ULevelStreamingDynamic*                 _level;                                            // 0x0088(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULevelSequencePlayer*                   _Player;                                           // 0x0090(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 _OldViewTarget;                                    // 0x0098(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UUIGuide_PlayCutScene* Tutorial_PlayCutScene(class UTutorial* _tutorial, TSoftObjectPtr<class UWorld> _level_path, const class FString& _sequence_name, bool _hide_ui);

	void OnCutSceneFinished();
	void OnLoadComplete();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGuide_PlayCutScene">();
	}
	static class UUIGuide_PlayCutScene* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGuide_PlayCutScene>();
	}
};
static_assert(alignof(UUIGuide_PlayCutScene) == 0x000008, "Wrong alignment on UUIGuide_PlayCutScene");
static_assert(sizeof(UUIGuide_PlayCutScene) == 0x0000A0, "Wrong size on UUIGuide_PlayCutScene");
static_assert(offsetof(UUIGuide_PlayCutScene, OnAfterDone) == 0x000038, "Member 'UUIGuide_PlayCutScene::OnAfterDone' has a wrong offset!");
static_assert(offsetof(UUIGuide_PlayCutScene, _level) == 0x000088, "Member 'UUIGuide_PlayCutScene::_level' has a wrong offset!");
static_assert(offsetof(UUIGuide_PlayCutScene, _Player) == 0x000090, "Member 'UUIGuide_PlayCutScene::_Player' has a wrong offset!");
static_assert(offsetof(UUIGuide_PlayCutScene, _OldViewTarget) == 0x000098, "Member 'UUIGuide_PlayCutScene::_OldViewTarget' has a wrong offset!");

// Class Stigma.UIGuide_Wait
// 0x0020 (0x0058 - 0x0038)
class UUIGuide_Wait final : public UUIGuide_Base
{
public:
	FMulticastInlineDelegateProperty_             OnAfterDone;                                       // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2512[0x10];                                    // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UUIGuide_Wait* Tutorial_Wait(class UTutorial* _tutorial, float _time);

	void OnWaitComplete();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGuide_Wait">();
	}
	static class UUIGuide_Wait* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGuide_Wait>();
	}
};
static_assert(alignof(UUIGuide_Wait) == 0x000008, "Wrong alignment on UUIGuide_Wait");
static_assert(sizeof(UUIGuide_Wait) == 0x000058, "Wrong size on UUIGuide_Wait");
static_assert(offsetof(UUIGuide_Wait, OnAfterDone) == 0x000038, "Member 'UUIGuide_Wait::OnAfterDone' has a wrong offset!");

// Class Stigma.UIGuide_PlayCharacterCutScene
// 0x0018 (0x0050 - 0x0038)
class UUIGuide_PlayCharacterCutScene final : public UUIGuide_Base
{
public:
	FMulticastInlineDelegateProperty_             OnAfterDone;                                       // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_2514[0x8];                                     // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UUIGuide_PlayCharacterCutScene* Tutorial_PlayCharacterCutScene(class UTutorial* _tutorial, ECharaType _chara_type);

	void OnWaitComplete();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIGuide_PlayCharacterCutScene">();
	}
	static class UUIGuide_PlayCharacterCutScene* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIGuide_PlayCharacterCutScene>();
	}
};
static_assert(alignof(UUIGuide_PlayCharacterCutScene) == 0x000008, "Wrong alignment on UUIGuide_PlayCharacterCutScene");
static_assert(sizeof(UUIGuide_PlayCharacterCutScene) == 0x000050, "Wrong size on UUIGuide_PlayCharacterCutScene");
static_assert(offsetof(UUIGuide_PlayCharacterCutScene, OnAfterDone) == 0x000038, "Member 'UUIGuide_PlayCharacterCutScene::OnAfterDone' has a wrong offset!");

// Class Stigma.UIAnimInstance
// 0x0090 (0x03E0 - 0x0350)
class UUIAnimInstance : public UAnimInstance
{
public:
	bool                                          _ShowAnimation;                                    // 0x0348(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2516[0x7];                                     // 0x0349(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UAnimSequenceBase*                      _UI_Current_Anim;                                  // 0x0350(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      _UI_Idle_Anim;                                     // 0x0358(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAnimSequenceBase*>              _UI_Loop_Anims;                                    // 0x0360(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         _Start_Loop_Anim_Index;                            // 0x0370(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _Anim_Idle_Max_count;                              // 0x0374(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _Anim_Loop_Max_Index;                              // 0x0378(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _Anim_Idle_Count;                                  // 0x037C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _Anim_Loop_Index;                                  // 0x0380(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2517[0x4];                                     // 0x0384(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UAnimSequenceBase*                      _UI_Upcomming_Idle_Anim;                           // 0x0388(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UAnimSequenceBase*>              _UI_Upcomming_Loop_Anims;                          // 0x0390(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2518[0x8];                                     // 0x03A0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UAnimSequenceBase*                      _Intro_P0;                                         // 0x03A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      _Intro_P1;                                         // 0x03B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      _Intro_P2;                                         // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      _Intro_VS;                                         // 0x03C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      _LobbySelect;                                      // 0x03C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequenceBase*                      _LobbySelect_Cam;                                  // 0x03D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2519[0x8];                                     // 0x03D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool CheckCanTransit(bool _from_idle_state, bool _can_check);
	class UAnimSequenceBase* GetCutSceneIntroAnim(int32 _Pos);
	class UAnimSequenceBase* GetCutSceneIntroAnim_VS();
	class UAnimSequenceBase* GetCutSceneLobbySelection();
	class UAnimSequenceBase* GetCutSceneLobbySelection_Cam();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIAnimInstance">();
	}
	static class UUIAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIAnimInstance>();
	}
};
static_assert(alignof(UUIAnimInstance) == 0x000010, "Wrong alignment on UUIAnimInstance");
static_assert(sizeof(UUIAnimInstance) == 0x0003E0, "Wrong size on UUIAnimInstance");
static_assert(offsetof(UUIAnimInstance, _ShowAnimation) == 0x000348, "Member 'UUIAnimInstance::_ShowAnimation' has a wrong offset!");
static_assert(offsetof(UUIAnimInstance, _UI_Current_Anim) == 0x000350, "Member 'UUIAnimInstance::_UI_Current_Anim' has a wrong offset!");
static_assert(offsetof(UUIAnimInstance, _UI_Idle_Anim) == 0x000358, "Member 'UUIAnimInstance::_UI_Idle_Anim' has a wrong offset!");
static_assert(offsetof(UUIAnimInstance, _UI_Loop_Anims) == 0x000360, "Member 'UUIAnimInstance::_UI_Loop_Anims' has a wrong offset!");
static_assert(offsetof(UUIAnimInstance, _Start_Loop_Anim_Index) == 0x000370, "Member 'UUIAnimInstance::_Start_Loop_Anim_Index' has a wrong offset!");
static_assert(offsetof(UUIAnimInstance, _Anim_Idle_Max_count) == 0x000374, "Member 'UUIAnimInstance::_Anim_Idle_Max_count' has a wrong offset!");
static_assert(offsetof(UUIAnimInstance, _Anim_Loop_Max_Index) == 0x000378, "Member 'UUIAnimInstance::_Anim_Loop_Max_Index' has a wrong offset!");
static_assert(offsetof(UUIAnimInstance, _Anim_Idle_Count) == 0x00037C, "Member 'UUIAnimInstance::_Anim_Idle_Count' has a wrong offset!");
static_assert(offsetof(UUIAnimInstance, _Anim_Loop_Index) == 0x000380, "Member 'UUIAnimInstance::_Anim_Loop_Index' has a wrong offset!");
static_assert(offsetof(UUIAnimInstance, _UI_Upcomming_Idle_Anim) == 0x000388, "Member 'UUIAnimInstance::_UI_Upcomming_Idle_Anim' has a wrong offset!");
static_assert(offsetof(UUIAnimInstance, _UI_Upcomming_Loop_Anims) == 0x000390, "Member 'UUIAnimInstance::_UI_Upcomming_Loop_Anims' has a wrong offset!");
static_assert(offsetof(UUIAnimInstance, _Intro_P0) == 0x0003A8, "Member 'UUIAnimInstance::_Intro_P0' has a wrong offset!");
static_assert(offsetof(UUIAnimInstance, _Intro_P1) == 0x0003B0, "Member 'UUIAnimInstance::_Intro_P1' has a wrong offset!");
static_assert(offsetof(UUIAnimInstance, _Intro_P2) == 0x0003B8, "Member 'UUIAnimInstance::_Intro_P2' has a wrong offset!");
static_assert(offsetof(UUIAnimInstance, _Intro_VS) == 0x0003C0, "Member 'UUIAnimInstance::_Intro_VS' has a wrong offset!");
static_assert(offsetof(UUIAnimInstance, _LobbySelect) == 0x0003C8, "Member 'UUIAnimInstance::_LobbySelect' has a wrong offset!");
static_assert(offsetof(UUIAnimInstance, _LobbySelect_Cam) == 0x0003D0, "Member 'UUIAnimInstance::_LobbySelect_Cam' has a wrong offset!");

// Class Stigma.UI_ActionWheelMenu
// 0x00B8 (0x05A8 - 0x04F0)
class UUI_ActionWheelMenu : public UPreviewableWidget
{
public:
	class ABattlePlayerControllerBase*            _PC;                                               // 0x04F0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstance*                      _MI_ActionWheel;                                   // 0x04F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_ActionWheelParts>       _ActionWheelPartsClass;                            // 0x0500(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               Material;                                          // 0x0508(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _CurSectionCount;                                  // 0x0510(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _CurSectionSize;                                   // 0x0514(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _CurPage;                                          // 0x0518(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _PageSize;                                         // 0x051C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _SelectedSection;                                  // 0x0520(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _AnySelected;                                      // 0x0524(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_251B[0x3];                                     // 0x0525(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         _PartsDistance;                                    // 0x0528(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_251C[0x4];                                     // 0x052C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UCanvasPanel*                           PartsPanel;                                        // 0x0530(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_Wheel;                                         // 0x0538(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CooltimePanel;                                     // 0x0540(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Cooltime;                                      // 0x0548(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 _MaxBounds;                                        // 0x0550(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 _MinBounds;                                        // 0x0560(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<EBattlePingType>                       _Pings;                                            // 0x0570(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FItemID_Emoticon>               _Emoticons;                                        // 0x0580(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_251D[0x18];                                    // 0x0590(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void CalculateSectionBounds();
	void Init();
	void Update();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_ActionWheelMenu">();
	}
	static class UUI_ActionWheelMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_ActionWheelMenu>();
	}
};
static_assert(alignof(UUI_ActionWheelMenu) == 0x000008, "Wrong alignment on UUI_ActionWheelMenu");
static_assert(sizeof(UUI_ActionWheelMenu) == 0x0005A8, "Wrong size on UUI_ActionWheelMenu");
static_assert(offsetof(UUI_ActionWheelMenu, _PC) == 0x0004F0, "Member 'UUI_ActionWheelMenu::_PC' has a wrong offset!");
static_assert(offsetof(UUI_ActionWheelMenu, _MI_ActionWheel) == 0x0004F8, "Member 'UUI_ActionWheelMenu::_MI_ActionWheel' has a wrong offset!");
static_assert(offsetof(UUI_ActionWheelMenu, _ActionWheelPartsClass) == 0x000500, "Member 'UUI_ActionWheelMenu::_ActionWheelPartsClass' has a wrong offset!");
static_assert(offsetof(UUI_ActionWheelMenu, Material) == 0x000508, "Member 'UUI_ActionWheelMenu::Material' has a wrong offset!");
static_assert(offsetof(UUI_ActionWheelMenu, _CurSectionCount) == 0x000510, "Member 'UUI_ActionWheelMenu::_CurSectionCount' has a wrong offset!");
static_assert(offsetof(UUI_ActionWheelMenu, _CurSectionSize) == 0x000514, "Member 'UUI_ActionWheelMenu::_CurSectionSize' has a wrong offset!");
static_assert(offsetof(UUI_ActionWheelMenu, _CurPage) == 0x000518, "Member 'UUI_ActionWheelMenu::_CurPage' has a wrong offset!");
static_assert(offsetof(UUI_ActionWheelMenu, _PageSize) == 0x00051C, "Member 'UUI_ActionWheelMenu::_PageSize' has a wrong offset!");
static_assert(offsetof(UUI_ActionWheelMenu, _SelectedSection) == 0x000520, "Member 'UUI_ActionWheelMenu::_SelectedSection' has a wrong offset!");
static_assert(offsetof(UUI_ActionWheelMenu, _AnySelected) == 0x000524, "Member 'UUI_ActionWheelMenu::_AnySelected' has a wrong offset!");
static_assert(offsetof(UUI_ActionWheelMenu, _PartsDistance) == 0x000528, "Member 'UUI_ActionWheelMenu::_PartsDistance' has a wrong offset!");
static_assert(offsetof(UUI_ActionWheelMenu, PartsPanel) == 0x000530, "Member 'UUI_ActionWheelMenu::PartsPanel' has a wrong offset!");
static_assert(offsetof(UUI_ActionWheelMenu, IMG_Wheel) == 0x000538, "Member 'UUI_ActionWheelMenu::IMG_Wheel' has a wrong offset!");
static_assert(offsetof(UUI_ActionWheelMenu, CooltimePanel) == 0x000540, "Member 'UUI_ActionWheelMenu::CooltimePanel' has a wrong offset!");
static_assert(offsetof(UUI_ActionWheelMenu, TXT_Cooltime) == 0x000548, "Member 'UUI_ActionWheelMenu::TXT_Cooltime' has a wrong offset!");
static_assert(offsetof(UUI_ActionWheelMenu, _MaxBounds) == 0x000550, "Member 'UUI_ActionWheelMenu::_MaxBounds' has a wrong offset!");
static_assert(offsetof(UUI_ActionWheelMenu, _MinBounds) == 0x000560, "Member 'UUI_ActionWheelMenu::_MinBounds' has a wrong offset!");
static_assert(offsetof(UUI_ActionWheelMenu, _Pings) == 0x000570, "Member 'UUI_ActionWheelMenu::_Pings' has a wrong offset!");
static_assert(offsetof(UUI_ActionWheelMenu, _Emoticons) == 0x000580, "Member 'UUI_ActionWheelMenu::_Emoticons' has a wrong offset!");

// Class Stigma.UI_ActionWheelParts
// 0x0000 (0x04F0 - 0x04F0)
class UUI_ActionWheelParts : public UPreviewableWidget
{
public:
	void SetValues(const TSoftObjectPtr<class UTexture2D>& _Icon, const class FText& _icon_name);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_ActionWheelParts">();
	}
	static class UUI_ActionWheelParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_ActionWheelParts>();
	}
};
static_assert(alignof(UUI_ActionWheelParts) == 0x000008, "Wrong alignment on UUI_ActionWheelParts");
static_assert(sizeof(UUI_ActionWheelParts) == 0x0004F0, "Wrong size on UUI_ActionWheelParts");

// Class Stigma.UI_ActiveFunctionBase
// 0x0068 (0x0558 - 0x04F0)
class UUI_ActiveFunctionBase : public UPreviewableWidget
{
public:
	TArray<struct FItemID>                        _FunctionIDs;                                      // 0x04F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	struct FDateTime                              _expiry;                                           // 0x0500(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsGMFunction;                                     // 0x0508(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_251E[0x3];                                     // 0x0509(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         _GMFunctionIDN;                                    // 0x050C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsPermanent;                                      // 0x0510(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_251F[0x7];                                     // 0x0511(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class FText                                   _TooltipTitle;                                     // 0x0518(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	class FText                                   _TooltipDesc;                                      // 0x0530(0x0018)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	int32                                         _LastLeftSecs;                                     // 0x0548(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2520[0x4];                                     // 0x054C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UTextBlock*                             TXT_RemainTime;                                    // 0x0550(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetCustomTooltipText(const class FText& _Title, const class FText& _Desc);
	void SetValues(const TArray<struct FItemID>& _item_ids, const struct FDateTime& Param__expiry, int32 _GM_func_idn);
	void UpdateUI();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_ActiveFunctionBase">();
	}
	static class UUI_ActiveFunctionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_ActiveFunctionBase>();
	}
};
static_assert(alignof(UUI_ActiveFunctionBase) == 0x000008, "Wrong alignment on UUI_ActiveFunctionBase");
static_assert(sizeof(UUI_ActiveFunctionBase) == 0x000558, "Wrong size on UUI_ActiveFunctionBase");
static_assert(offsetof(UUI_ActiveFunctionBase, _FunctionIDs) == 0x0004F0, "Member 'UUI_ActiveFunctionBase::_FunctionIDs' has a wrong offset!");
static_assert(offsetof(UUI_ActiveFunctionBase, _expiry) == 0x000500, "Member 'UUI_ActiveFunctionBase::_expiry' has a wrong offset!");
static_assert(offsetof(UUI_ActiveFunctionBase, _IsGMFunction) == 0x000508, "Member 'UUI_ActiveFunctionBase::_IsGMFunction' has a wrong offset!");
static_assert(offsetof(UUI_ActiveFunctionBase, _GMFunctionIDN) == 0x00050C, "Member 'UUI_ActiveFunctionBase::_GMFunctionIDN' has a wrong offset!");
static_assert(offsetof(UUI_ActiveFunctionBase, _IsPermanent) == 0x000510, "Member 'UUI_ActiveFunctionBase::_IsPermanent' has a wrong offset!");
static_assert(offsetof(UUI_ActiveFunctionBase, _TooltipTitle) == 0x000518, "Member 'UUI_ActiveFunctionBase::_TooltipTitle' has a wrong offset!");
static_assert(offsetof(UUI_ActiveFunctionBase, _TooltipDesc) == 0x000530, "Member 'UUI_ActiveFunctionBase::_TooltipDesc' has a wrong offset!");
static_assert(offsetof(UUI_ActiveFunctionBase, _LastLeftSecs) == 0x000548, "Member 'UUI_ActiveFunctionBase::_LastLeftSecs' has a wrong offset!");
static_assert(offsetof(UUI_ActiveFunctionBase, TXT_RemainTime) == 0x000550, "Member 'UUI_ActiveFunctionBase::TXT_RemainTime' has a wrong offset!");

// Class Stigma.UI_BattlePassBrief
// 0x0018 (0x0508 - 0x04F0)
class UUI_BattlePassBrief final : public UPreviewableWidget
{
public:
	class UOverlay*                               Ovl_PassBrief_First;                               // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Ovl_PassBrief_Second;                              // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_BattlePassBriefSlot>    _BriefSlotClass;                                   // 0x0500(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitWidget(const struct FItemID_BattlePass& _pass_id);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_BattlePassBrief">();
	}
	static class UUI_BattlePassBrief* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_BattlePassBrief>();
	}
};
static_assert(alignof(UUI_BattlePassBrief) == 0x000008, "Wrong alignment on UUI_BattlePassBrief");
static_assert(sizeof(UUI_BattlePassBrief) == 0x000508, "Wrong size on UUI_BattlePassBrief");
static_assert(offsetof(UUI_BattlePassBrief, Ovl_PassBrief_First) == 0x0004F0, "Member 'UUI_BattlePassBrief::Ovl_PassBrief_First' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassBrief, Ovl_PassBrief_Second) == 0x0004F8, "Member 'UUI_BattlePassBrief::Ovl_PassBrief_Second' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassBrief, _BriefSlotClass) == 0x000500, "Member 'UUI_BattlePassBrief::_BriefSlotClass' has a wrong offset!");

// Class Stigma.UI_BattlePassBriefContainer
// 0x0030 (0x0520 - 0x04F0)
class UUI_BattlePassBriefContainer : public UPreviewableWidget
{
public:
	class UScaleBox*                              SB_PassBrief_Front;                                // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScaleBox*                              SB_PassBrief_Back;                                 // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_CommonButtonBase*                 Btn_Swap;                                          // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _OnMainLobby;                                      // 0x0508(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2522[0x7];                                     // 0x0509(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UUI_BattlePassBriefSlot>    _BriefSlotClass;                                   // 0x0510(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2523[0x8];                                     // 0x0518(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void InitWidget(const struct FItemID_BattlePass& _pass_id);
	void OnClickSlot(class UAnimatableWidget* _widget, bool _selected);
	void SwapAnimation(bool _forward);
	void SwapPass();

	class UUI_BattlePassBriefSlot* GetFrontPassSlotWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_BattlePassBriefContainer">();
	}
	static class UUI_BattlePassBriefContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_BattlePassBriefContainer>();
	}
};
static_assert(alignof(UUI_BattlePassBriefContainer) == 0x000008, "Wrong alignment on UUI_BattlePassBriefContainer");
static_assert(sizeof(UUI_BattlePassBriefContainer) == 0x000520, "Wrong size on UUI_BattlePassBriefContainer");
static_assert(offsetof(UUI_BattlePassBriefContainer, SB_PassBrief_Front) == 0x0004F0, "Member 'UUI_BattlePassBriefContainer::SB_PassBrief_Front' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassBriefContainer, SB_PassBrief_Back) == 0x0004F8, "Member 'UUI_BattlePassBriefContainer::SB_PassBrief_Back' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassBriefContainer, Btn_Swap) == 0x000500, "Member 'UUI_BattlePassBriefContainer::Btn_Swap' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassBriefContainer, _OnMainLobby) == 0x000508, "Member 'UUI_BattlePassBriefContainer::_OnMainLobby' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassBriefContainer, _BriefSlotClass) == 0x000510, "Member 'UUI_BattlePassBriefContainer::_BriefSlotClass' has a wrong offset!");

// Class Stigma.UI_BattlePassBuyBackground
// 0x0000 (0x04F0 - 0x04F0)
class UUI_BattlePassBuyBackground : public UPreviewableWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_BattlePassBuyBackground">();
	}
	static class UUI_BattlePassBuyBackground* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_BattlePassBuyBackground>();
	}
};
static_assert(alignof(UUI_BattlePassBuyBackground) == 0x000008, "Wrong alignment on UUI_BattlePassBuyBackground");
static_assert(sizeof(UUI_BattlePassBuyBackground) == 0x0004F0, "Wrong size on UUI_BattlePassBuyBackground");

// Class Stigma.UI_BattlePassBuyPopup
// 0x0068 (0x05D8 - 0x0570)
class UUI_BattlePassBuyPopup : public UPopupBase
{
public:
	class UOverlay*                               Ovl_PassBG;                                        // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_Title;                                         // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HB_UserCurrency;                                   // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_RemainDateTimer*                    RemainDateTimer;                                   // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_BuyPremium;                                    // 0x0590(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_CommonButton_Currency*            Btn_BuyPremium;                                    // 0x0598(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_BuyPremiumPlus;                                // 0x05A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_CommonButton_Currency*            Btn_BuyPremiumPlus;                                // 0x05A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_CancellationPolicy*                 CancellationPolicy;                                // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_CurrencyBox>            _CurrencyBoxClass;                                 // 0x05B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2525[0x18];                                    // 0x05C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void InitWidget(const struct FItemID_BattlePass& _pass_id);
	void OnClickBuyBtn(class UAnimatableWidget* _btn, bool _selected);
	void SetDesc(const class FText& _text);
	void SetTitle(const class FText& _text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_BattlePassBuyPopup">();
	}
	static class UUI_BattlePassBuyPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_BattlePassBuyPopup>();
	}
};
static_assert(alignof(UUI_BattlePassBuyPopup) == 0x000008, "Wrong alignment on UUI_BattlePassBuyPopup");
static_assert(sizeof(UUI_BattlePassBuyPopup) == 0x0005D8, "Wrong size on UUI_BattlePassBuyPopup");
static_assert(offsetof(UUI_BattlePassBuyPopup, Ovl_PassBG) == 0x000570, "Member 'UUI_BattlePassBuyPopup::Ovl_PassBG' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassBuyPopup, Txt_Title) == 0x000578, "Member 'UUI_BattlePassBuyPopup::Txt_Title' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassBuyPopup, HB_UserCurrency) == 0x000580, "Member 'UUI_BattlePassBuyPopup::HB_UserCurrency' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassBuyPopup, RemainDateTimer) == 0x000588, "Member 'UUI_BattlePassBuyPopup::RemainDateTimer' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassBuyPopup, Txt_BuyPremium) == 0x000590, "Member 'UUI_BattlePassBuyPopup::Txt_BuyPremium' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassBuyPopup, Btn_BuyPremium) == 0x000598, "Member 'UUI_BattlePassBuyPopup::Btn_BuyPremium' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassBuyPopup, Txt_BuyPremiumPlus) == 0x0005A0, "Member 'UUI_BattlePassBuyPopup::Txt_BuyPremiumPlus' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassBuyPopup, Btn_BuyPremiumPlus) == 0x0005A8, "Member 'UUI_BattlePassBuyPopup::Btn_BuyPremiumPlus' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassBuyPopup, CancellationPolicy) == 0x0005B0, "Member 'UUI_BattlePassBuyPopup::CancellationPolicy' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassBuyPopup, _CurrencyBoxClass) == 0x0005B8, "Member 'UUI_BattlePassBuyPopup::_CurrencyBoxClass' has a wrong offset!");

// Class Stigma.UI_BattlePassInfoLevelRewardSlot
// 0x0030 (0x0520 - 0x04F0)
class UUI_BattlePassInfoLevelRewardSlot : public UPreviewableWidget
{
public:
	class UUI_RewardContainer*                    RewardContainer;                                   // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemID_BattlePass                     _PassID;                                           // 0x04F8(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2527[0x8];                                     // 0x0508(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	struct FVector2D                              _OneItemSize;                                      // 0x0510(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetPremiumLocked(bool _locked);
	void SetPremiumTag(bool _is_premium);
	void SetRewardState(ERewardItemState _reward_state);
	void SetTargetLevel(int32 _level);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_BattlePassInfoLevelRewardSlot">();
	}
	static class UUI_BattlePassInfoLevelRewardSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_BattlePassInfoLevelRewardSlot>();
	}
};
static_assert(alignof(UUI_BattlePassInfoLevelRewardSlot) == 0x000008, "Wrong alignment on UUI_BattlePassInfoLevelRewardSlot");
static_assert(sizeof(UUI_BattlePassInfoLevelRewardSlot) == 0x000520, "Wrong size on UUI_BattlePassInfoLevelRewardSlot");
static_assert(offsetof(UUI_BattlePassInfoLevelRewardSlot, RewardContainer) == 0x0004F0, "Member 'UUI_BattlePassInfoLevelRewardSlot::RewardContainer' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassInfoLevelRewardSlot, _PassID) == 0x0004F8, "Member 'UUI_BattlePassInfoLevelRewardSlot::_PassID' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassInfoLevelRewardSlot, _OneItemSize) == 0x000510, "Member 'UUI_BattlePassInfoLevelRewardSlot::_OneItemSize' has a wrong offset!");

// Class Stigma.UI_BattlePassInfoPage
// 0x0078 (0x0588 - 0x0510)
class UUI_BattlePassInfoPage : public UUI_LobbyPage
{
public:
	class UOverlay*                               Ovl_BG;                                            // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WidgetSwitcher;                                    // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_BattlePassBriefContainer*           BriefContainer;                                    // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_Preview*                            Preview;                                           // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             ScrollBox_Rewards;                                 // 0x0530(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HB_Rewards;                                        // 0x0538(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_BattlePassIntroContainer> _IntroPopupClass;                                  // 0x0540(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_BattlePassInfoLevelRewardSlot> _LevelRewardSlotClass;                             // 0x0548(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                _LevelRewardSlotPadding;                           // 0x0550(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_BattlePassLevelBuyPopup> _LevelBuyPopup;                                    // 0x0560(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2528[0x10];                                    // 0x0568(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	struct FItemID_BattlePass                     _CurrentPassID;                                    // 0x0578(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void EnableLevelBuyBtn(bool _enable);
	void EnablePurchaseBtn(bool _enable);
	void OnSwapPass(class UAnimatableWidget* _widget);
	void OpenIntroPopup(bool _is_auto_opened);
	void OpenLevelBuyPopup();
	void SetPreviewItemInfo(const class FText& _Name, EItemGrade _Grade, bool _premium_locked);
	void ShowActivateButton(bool _show);
	void ShowAllRewardBtn(bool _show);
	void ShowMain(const struct FItemID_BattlePass& _pass_id);
	void ShowPreviewItemInfo(bool _show);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_BattlePassInfoPage">();
	}
	static class UUI_BattlePassInfoPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_BattlePassInfoPage>();
	}
};
static_assert(alignof(UUI_BattlePassInfoPage) == 0x000008, "Wrong alignment on UUI_BattlePassInfoPage");
static_assert(sizeof(UUI_BattlePassInfoPage) == 0x000588, "Wrong size on UUI_BattlePassInfoPage");
static_assert(offsetof(UUI_BattlePassInfoPage, Ovl_BG) == 0x000510, "Member 'UUI_BattlePassInfoPage::Ovl_BG' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassInfoPage, WidgetSwitcher) == 0x000518, "Member 'UUI_BattlePassInfoPage::WidgetSwitcher' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassInfoPage, BriefContainer) == 0x000520, "Member 'UUI_BattlePassInfoPage::BriefContainer' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassInfoPage, Preview) == 0x000528, "Member 'UUI_BattlePassInfoPage::Preview' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassInfoPage, ScrollBox_Rewards) == 0x000530, "Member 'UUI_BattlePassInfoPage::ScrollBox_Rewards' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassInfoPage, HB_Rewards) == 0x000538, "Member 'UUI_BattlePassInfoPage::HB_Rewards' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassInfoPage, _IntroPopupClass) == 0x000540, "Member 'UUI_BattlePassInfoPage::_IntroPopupClass' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassInfoPage, _LevelRewardSlotClass) == 0x000548, "Member 'UUI_BattlePassInfoPage::_LevelRewardSlotClass' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassInfoPage, _LevelRewardSlotPadding) == 0x000550, "Member 'UUI_BattlePassInfoPage::_LevelRewardSlotPadding' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassInfoPage, _LevelBuyPopup) == 0x000560, "Member 'UUI_BattlePassInfoPage::_LevelBuyPopup' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassInfoPage, _CurrentPassID) == 0x000578, "Member 'UUI_BattlePassInfoPage::_CurrentPassID' has a wrong offset!");

// Class Stigma.UI_BattlePassMainBackground
// 0x0000 (0x04F0 - 0x04F0)
class UUI_BattlePassMainBackground : public UPreviewableWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_BattlePassMainBackground">();
	}
	static class UUI_BattlePassMainBackground* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_BattlePassMainBackground>();
	}
};
static_assert(alignof(UUI_BattlePassMainBackground) == 0x000008, "Wrong alignment on UUI_BattlePassMainBackground");
static_assert(sizeof(UUI_BattlePassMainBackground) == 0x0004F0, "Wrong size on UUI_BattlePassMainBackground");

// Class Stigma.UI_BattlePassInfoTab
// 0x0028 (0x0518 - 0x04F0)
class UUI_BattlePassInfoTab final : public UPreviewableWidget
{
public:
	class UUI_RemainDateTimer*                    RemainDateTimer;                                   // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_252A[0x20];                                    // 0x04F8(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnClickBtn();
	void SetIsActivated(bool _activated);
	void SetText(const class FText& _text);
	void ShowRemainTimer(const struct FDateTime& _end_at, int32 _alert_hour);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_BattlePassInfoTab">();
	}
	static class UUI_BattlePassInfoTab* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_BattlePassInfoTab>();
	}
};
static_assert(alignof(UUI_BattlePassInfoTab) == 0x000008, "Wrong alignment on UUI_BattlePassInfoTab");
static_assert(sizeof(UUI_BattlePassInfoTab) == 0x000518, "Wrong size on UUI_BattlePassInfoTab");
static_assert(offsetof(UUI_BattlePassInfoTab, RemainDateTimer) == 0x0004F0, "Member 'UUI_BattlePassInfoTab::RemainDateTimer' has a wrong offset!");

// Class Stigma.UI_BattlePassIntroContainer
// 0x0038 (0x05A8 - 0x0570)
class UUI_BattlePassIntroContainer : public UPopupBase
{
public:
	class USpacer*                                Spacer_Main;                                       // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Ovl_Main_Left;                                     // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Ovl_MainSlot_Left;                                 // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Ovl_Main_Right;                                    // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Ovl_MainSlot_Right;                                // 0x0590(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_BattlePassIntroSlot>    _BriefSlotClass;                                   // 0x0598(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsCheckedDoNotOpen;                               // 0x05A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_252C[0x7];                                     // 0x05A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void CheckDoNotOpen(bool _is_checked);
	void ShowDoNotOpenCheckBox(bool _show);
	void ShowMainPassPage(class UAnimatableWidget* _slot_widget, bool _selected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_BattlePassIntroContainer">();
	}
	static class UUI_BattlePassIntroContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_BattlePassIntroContainer>();
	}
};
static_assert(alignof(UUI_BattlePassIntroContainer) == 0x000008, "Wrong alignment on UUI_BattlePassIntroContainer");
static_assert(sizeof(UUI_BattlePassIntroContainer) == 0x0005A8, "Wrong size on UUI_BattlePassIntroContainer");
static_assert(offsetof(UUI_BattlePassIntroContainer, Spacer_Main) == 0x000570, "Member 'UUI_BattlePassIntroContainer::Spacer_Main' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassIntroContainer, Ovl_Main_Left) == 0x000578, "Member 'UUI_BattlePassIntroContainer::Ovl_Main_Left' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassIntroContainer, Ovl_MainSlot_Left) == 0x000580, "Member 'UUI_BattlePassIntroContainer::Ovl_MainSlot_Left' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassIntroContainer, Ovl_Main_Right) == 0x000588, "Member 'UUI_BattlePassIntroContainer::Ovl_Main_Right' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassIntroContainer, Ovl_MainSlot_Right) == 0x000590, "Member 'UUI_BattlePassIntroContainer::Ovl_MainSlot_Right' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassIntroContainer, _BriefSlotClass) == 0x000598, "Member 'UUI_BattlePassIntroContainer::_BriefSlotClass' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassIntroContainer, _IsCheckedDoNotOpen) == 0x0005A0, "Member 'UUI_BattlePassIntroContainer::_IsCheckedDoNotOpen' has a wrong offset!");

// Class Stigma.UI_SelectBuffPanel
// 0x00E8 (0x05D8 - 0x04F0)
class UUI_SelectBuffPanel : public UPreviewableWidget
{
public:
	class UVerticalBox*                           V_BuffContainer;                                   // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             ScrollBox_HistoryContainer;                        // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_NoHistory;                                     // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_BattleStore_ArmorItem*              Item_BattleStore_Armor;                            // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_BuffTypeBoxItem>        _BuffTypeBoxWidgetClass;                           // 0x0510(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_BattleStore_BuffItem>   _BuffItemWidgetclass;                              // 0x0518(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_BattleStore_HistoryItem> _HistoryItemWidgetclass;                           // 0x0520(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FString, class UUI_BuffTypeBoxItem*> _BuffTypeCategoryWidgetMap;                        // 0x0528(0x0050)(BlueprintVisible, ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<struct FItemID, class UUI_BattleStore_HistoryItem*> _HistoryWidgetMap;                                 // 0x0578(0x0050)(BlueprintVisible, ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UUI_BattleStore_BuffItem*>       _BuffItems;                                        // 0x05C8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void OnHoverBuffItem(const struct FBattleStoreEntry& _battle_store_entry);
	void UpdateDetail(const struct FBattleStoreEntry& _battle_store_entry);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_SelectBuffPanel">();
	}
	static class UUI_SelectBuffPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_SelectBuffPanel>();
	}
};
static_assert(alignof(UUI_SelectBuffPanel) == 0x000008, "Wrong alignment on UUI_SelectBuffPanel");
static_assert(sizeof(UUI_SelectBuffPanel) == 0x0005D8, "Wrong size on UUI_SelectBuffPanel");
static_assert(offsetof(UUI_SelectBuffPanel, V_BuffContainer) == 0x0004F0, "Member 'UUI_SelectBuffPanel::V_BuffContainer' has a wrong offset!");
static_assert(offsetof(UUI_SelectBuffPanel, ScrollBox_HistoryContainer) == 0x0004F8, "Member 'UUI_SelectBuffPanel::ScrollBox_HistoryContainer' has a wrong offset!");
static_assert(offsetof(UUI_SelectBuffPanel, TXT_NoHistory) == 0x000500, "Member 'UUI_SelectBuffPanel::TXT_NoHistory' has a wrong offset!");
static_assert(offsetof(UUI_SelectBuffPanel, Item_BattleStore_Armor) == 0x000508, "Member 'UUI_SelectBuffPanel::Item_BattleStore_Armor' has a wrong offset!");
static_assert(offsetof(UUI_SelectBuffPanel, _BuffTypeBoxWidgetClass) == 0x000510, "Member 'UUI_SelectBuffPanel::_BuffTypeBoxWidgetClass' has a wrong offset!");
static_assert(offsetof(UUI_SelectBuffPanel, _BuffItemWidgetclass) == 0x000518, "Member 'UUI_SelectBuffPanel::_BuffItemWidgetclass' has a wrong offset!");
static_assert(offsetof(UUI_SelectBuffPanel, _HistoryItemWidgetclass) == 0x000520, "Member 'UUI_SelectBuffPanel::_HistoryItemWidgetclass' has a wrong offset!");
static_assert(offsetof(UUI_SelectBuffPanel, _BuffTypeCategoryWidgetMap) == 0x000528, "Member 'UUI_SelectBuffPanel::_BuffTypeCategoryWidgetMap' has a wrong offset!");
static_assert(offsetof(UUI_SelectBuffPanel, _HistoryWidgetMap) == 0x000578, "Member 'UUI_SelectBuffPanel::_HistoryWidgetMap' has a wrong offset!");
static_assert(offsetof(UUI_SelectBuffPanel, _BuffItems) == 0x0005C8, "Member 'UUI_SelectBuffPanel::_BuffItems' has a wrong offset!");

// Class Stigma.UI_BattlePassIntroSlot
// 0x0048 (0x0538 - 0x04F0)
class UUI_BattlePassIntroSlot : public UPreviewableWidget
{
public:
	class UOverlay*                               Ovl_Background;                                    // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_Title;                                         // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_RemainDateTimer*                    UI_RemainDateTimer;                                // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      UGP_Reward;                                        // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_CommonButtonBase*                 Btn_PremiumPass;                                   // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_CommonButtonBase*                 Btn_ShowMain;                                      // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_ItemIDListViewItem>     _RewardItemClass;                                  // 0x0520(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemID_BattlePass                     _PassID;                                           // 0x0528(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnClickBtn(class UAnimatableWidget* _widget, bool _selected);
	void SetActivated(bool _is_activated);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_BattlePassIntroSlot">();
	}
	static class UUI_BattlePassIntroSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_BattlePassIntroSlot>();
	}
};
static_assert(alignof(UUI_BattlePassIntroSlot) == 0x000008, "Wrong alignment on UUI_BattlePassIntroSlot");
static_assert(sizeof(UUI_BattlePassIntroSlot) == 0x000538, "Wrong size on UUI_BattlePassIntroSlot");
static_assert(offsetof(UUI_BattlePassIntroSlot, Ovl_Background) == 0x0004F0, "Member 'UUI_BattlePassIntroSlot::Ovl_Background' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassIntroSlot, Txt_Title) == 0x0004F8, "Member 'UUI_BattlePassIntroSlot::Txt_Title' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassIntroSlot, UI_RemainDateTimer) == 0x000500, "Member 'UUI_BattlePassIntroSlot::UI_RemainDateTimer' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassIntroSlot, UGP_Reward) == 0x000508, "Member 'UUI_BattlePassIntroSlot::UGP_Reward' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassIntroSlot, Btn_PremiumPass) == 0x000510, "Member 'UUI_BattlePassIntroSlot::Btn_PremiumPass' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassIntroSlot, Btn_ShowMain) == 0x000518, "Member 'UUI_BattlePassIntroSlot::Btn_ShowMain' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassIntroSlot, _RewardItemClass) == 0x000520, "Member 'UUI_BattlePassIntroSlot::_RewardItemClass' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassIntroSlot, _PassID) == 0x000528, "Member 'UUI_BattlePassIntroSlot::_PassID' has a wrong offset!");

// Class Stigma.UI_BattlePassIntroBackground
// 0x0000 (0x04F0 - 0x04F0)
class UUI_BattlePassIntroBackground : public UPreviewableWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_BattlePassIntroBackground">();
	}
	static class UUI_BattlePassIntroBackground* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_BattlePassIntroBackground>();
	}
};
static_assert(alignof(UUI_BattlePassIntroBackground) == 0x000008, "Wrong alignment on UUI_BattlePassIntroBackground");
static_assert(sizeof(UUI_BattlePassIntroBackground) == 0x0004F0, "Wrong size on UUI_BattlePassIntroBackground");

// Class Stigma.UI_BattlePassLevelBuyPopup
// 0x00D0 (0x0640 - 0x0570)
class UUI_BattlePassLevelBuyPopup : public UPopupBase
{
public:
	class UUI_PreviewPopupBase*                   PreviewPopupBase;                                  // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_BattlePassLevel*                  PassLevel_Current;                                 // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_BattlePassLevel*                  PassLevel_Preview;                                 // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 BuySlider;                                         // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_SubDesc;                                       // 0x0590(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      UGP_Items;                                         // 0x0598(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HB_BuyBtn;                                         // 0x05A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_CancellationPolicy*                 CancellationPolicy;                                // 0x05A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_ItemIDListViewItem>     _ItemWidgetClass;                                  // 0x05B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCtrl_CommonButton_Currency> _BuyButtonClass;                                   // 0x05B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              _BuyButtonHorizontalPadding;                       // 0x05C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemID_BattlePass                     _PassID;                                           // 0x05D0(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _CurrentLevel;                                     // 0x05E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _PreviewLevel;                                     // 0x05E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_252F[0x8];                                     // 0x05E8(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TMap<struct FItemIDRef_Currency, float>       _CurrencyPerExpMap;                                // 0x05F0(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	void InitBuySlider(int32 _slider_max_value);
	void InitWidget(const struct FItemID_BattlePass& _pass_id);
	void OnBuyLevelChanged(int32 _level);
	void OnClickBuyBtn(class UAnimatableWidget* _widget, bool _selected);
	void OnClickItem(class UAnimatableWidget* _widget, bool _selected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_BattlePassLevelBuyPopup">();
	}
	static class UUI_BattlePassLevelBuyPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_BattlePassLevelBuyPopup>();
	}
};
static_assert(alignof(UUI_BattlePassLevelBuyPopup) == 0x000008, "Wrong alignment on UUI_BattlePassLevelBuyPopup");
static_assert(sizeof(UUI_BattlePassLevelBuyPopup) == 0x000640, "Wrong size on UUI_BattlePassLevelBuyPopup");
static_assert(offsetof(UUI_BattlePassLevelBuyPopup, PreviewPopupBase) == 0x000570, "Member 'UUI_BattlePassLevelBuyPopup::PreviewPopupBase' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassLevelBuyPopup, PassLevel_Current) == 0x000578, "Member 'UUI_BattlePassLevelBuyPopup::PassLevel_Current' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassLevelBuyPopup, PassLevel_Preview) == 0x000580, "Member 'UUI_BattlePassLevelBuyPopup::PassLevel_Preview' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassLevelBuyPopup, BuySlider) == 0x000588, "Member 'UUI_BattlePassLevelBuyPopup::BuySlider' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassLevelBuyPopup, Txt_SubDesc) == 0x000590, "Member 'UUI_BattlePassLevelBuyPopup::Txt_SubDesc' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassLevelBuyPopup, UGP_Items) == 0x000598, "Member 'UUI_BattlePassLevelBuyPopup::UGP_Items' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassLevelBuyPopup, HB_BuyBtn) == 0x0005A0, "Member 'UUI_BattlePassLevelBuyPopup::HB_BuyBtn' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassLevelBuyPopup, CancellationPolicy) == 0x0005A8, "Member 'UUI_BattlePassLevelBuyPopup::CancellationPolicy' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassLevelBuyPopup, _ItemWidgetClass) == 0x0005B0, "Member 'UUI_BattlePassLevelBuyPopup::_ItemWidgetClass' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassLevelBuyPopup, _BuyButtonClass) == 0x0005B8, "Member 'UUI_BattlePassLevelBuyPopup::_BuyButtonClass' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassLevelBuyPopup, _BuyButtonHorizontalPadding) == 0x0005C0, "Member 'UUI_BattlePassLevelBuyPopup::_BuyButtonHorizontalPadding' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassLevelBuyPopup, _PassID) == 0x0005D0, "Member 'UUI_BattlePassLevelBuyPopup::_PassID' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassLevelBuyPopup, _CurrentLevel) == 0x0005E0, "Member 'UUI_BattlePassLevelBuyPopup::_CurrentLevel' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassLevelBuyPopup, _PreviewLevel) == 0x0005E4, "Member 'UUI_BattlePassLevelBuyPopup::_PreviewLevel' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassLevelBuyPopup, _CurrencyPerExpMap) == 0x0005F0, "Member 'UUI_BattlePassLevelBuyPopup::_CurrencyPerExpMap' has a wrong offset!");

// Class Stigma.UI_ShopGridFilterButton
// 0x0050 (0x0540 - 0x04F0)
class UUI_ShopGridFilterButton : public UPreviewableWidget
{
public:
	class UImage*                                 Img_Icon;                                          // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URadioButton*                           Btn_Filter;                                        // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              IconTexture;                                       // 0x0500(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2532[0x18];                                    // 0x0528(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnClickFilterButton();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_ShopGridFilterButton">();
	}
	static class UUI_ShopGridFilterButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_ShopGridFilterButton>();
	}
};
static_assert(alignof(UUI_ShopGridFilterButton) == 0x000008, "Wrong alignment on UUI_ShopGridFilterButton");
static_assert(sizeof(UUI_ShopGridFilterButton) == 0x000540, "Wrong size on UUI_ShopGridFilterButton");
static_assert(offsetof(UUI_ShopGridFilterButton, Img_Icon) == 0x0004F0, "Member 'UUI_ShopGridFilterButton::Img_Icon' has a wrong offset!");
static_assert(offsetof(UUI_ShopGridFilterButton, Btn_Filter) == 0x0004F8, "Member 'UUI_ShopGridFilterButton::Btn_Filter' has a wrong offset!");
static_assert(offsetof(UUI_ShopGridFilterButton, IconTexture) == 0x000500, "Member 'UUI_ShopGridFilterButton::IconTexture' has a wrong offset!");

// Class Stigma.UI_BattlePassRewardPreviewPopup
// 0x0030 (0x05A0 - 0x0570)
class UUI_BattlePassRewardPreviewPopup : public UPopupBase
{
public:
	class UUI_PreviewPopupBase*                   PreviewPopupBase;                                  // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      UGP_Free_Items;                                    // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      UGP_Premium_Items;                                 // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_ItemIDListViewItem>     _ItemWidgetClass;                                  // 0x0588(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemID_BattlePass                     _PassID;                                           // 0x0590(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitWidget(const struct FItemID_BattlePass& _pass_id);
	void OnClickItem(class UAnimatableWidget* _widget, bool _selected);
	void SetDesc(const class FText& _text);
	void ShowBuyPremiumBtn(bool _show);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_BattlePassRewardPreviewPopup">();
	}
	static class UUI_BattlePassRewardPreviewPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_BattlePassRewardPreviewPopup>();
	}
};
static_assert(alignof(UUI_BattlePassRewardPreviewPopup) == 0x000008, "Wrong alignment on UUI_BattlePassRewardPreviewPopup");
static_assert(sizeof(UUI_BattlePassRewardPreviewPopup) == 0x0005A0, "Wrong size on UUI_BattlePassRewardPreviewPopup");
static_assert(offsetof(UUI_BattlePassRewardPreviewPopup, PreviewPopupBase) == 0x000570, "Member 'UUI_BattlePassRewardPreviewPopup::PreviewPopupBase' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassRewardPreviewPopup, UGP_Free_Items) == 0x000578, "Member 'UUI_BattlePassRewardPreviewPopup::UGP_Free_Items' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassRewardPreviewPopup, UGP_Premium_Items) == 0x000580, "Member 'UUI_BattlePassRewardPreviewPopup::UGP_Premium_Items' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassRewardPreviewPopup, _ItemWidgetClass) == 0x000588, "Member 'UUI_BattlePassRewardPreviewPopup::_ItemWidgetClass' has a wrong offset!");
static_assert(offsetof(UUI_BattlePassRewardPreviewPopup, _PassID) == 0x000590, "Member 'UUI_BattlePassRewardPreviewPopup::_PassID' has a wrong offset!");

// Class Stigma.UI_BattleStorePopup
// 0x0090 (0x0600 - 0x0570)
class UUI_BattleStorePopup : public UPopupBase
{
public:
	class UCtrl_CommonTabPanel*                   Tab_Main;                                          // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WS_Main;                                           // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_SelectBuffPanel*                    PANEL_SelectBuff;                                  // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_SelectWeaponPanel*                  PANEL_SelectWeapon;                                // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2534[0x4];                                     // 0x0590(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class FName                                   _InputKeyName;                                     // 0x0594(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2535[0x4];                                     // 0x059C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<EBattleStoreTab>                       _EnableTabTypes;                                   // 0x05A0(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<EBattleStoreTab, class FName>            _EnableTabIDMap;                                   // 0x05B0(0x0050)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)

public:
	void OnChangedGun(const struct FGunPreset& _gun_preset);
	void OnChangedMaster(int32 _idx_master);
	void OnTabChanged(class FName _id, int32 _idx);
	void OnUpdateBattleStore();
	void UpdateMasterDetail(int32 _chara_idx, const struct FGunPreset& _gun_preset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_BattleStorePopup">();
	}
	static class UUI_BattleStorePopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_BattleStorePopup>();
	}
};
static_assert(alignof(UUI_BattleStorePopup) == 0x000008, "Wrong alignment on UUI_BattleStorePopup");
static_assert(sizeof(UUI_BattleStorePopup) == 0x000600, "Wrong size on UUI_BattleStorePopup");
static_assert(offsetof(UUI_BattleStorePopup, Tab_Main) == 0x000570, "Member 'UUI_BattleStorePopup::Tab_Main' has a wrong offset!");
static_assert(offsetof(UUI_BattleStorePopup, WS_Main) == 0x000578, "Member 'UUI_BattleStorePopup::WS_Main' has a wrong offset!");
static_assert(offsetof(UUI_BattleStorePopup, PANEL_SelectBuff) == 0x000580, "Member 'UUI_BattleStorePopup::PANEL_SelectBuff' has a wrong offset!");
static_assert(offsetof(UUI_BattleStorePopup, PANEL_SelectWeapon) == 0x000588, "Member 'UUI_BattleStorePopup::PANEL_SelectWeapon' has a wrong offset!");
static_assert(offsetof(UUI_BattleStorePopup, _InputKeyName) == 0x000594, "Member 'UUI_BattleStorePopup::_InputKeyName' has a wrong offset!");
static_assert(offsetof(UUI_BattleStorePopup, _EnableTabTypes) == 0x0005A0, "Member 'UUI_BattleStorePopup::_EnableTabTypes' has a wrong offset!");
static_assert(offsetof(UUI_BattleStorePopup, _EnableTabIDMap) == 0x0005B0, "Member 'UUI_BattleStorePopup::_EnableTabIDMap' has a wrong offset!");

// Class Stigma.UI_BattleStore_ArmorItem
// 0x00A0 (0x0590 - 0x04F0)
class UUI_BattleStore_ArmorItem : public UPreviewableWidget
{
public:
	class UTextBlock*                             TXT_Func_ArmorPerRound;                            // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Icon;                                          // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_ArmorName;                                     // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_RemainArmor;                                   // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           Panel_Price;                                       // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_Price;                                         // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                Btn_Main;                                          // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Alert;                                         // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           Panel_Swap;                                        // 0x0530(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       AlertAnim;                                         // 0x0538(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateColor                            Color_CanPurchase_Txt_Price;                       // 0x0540(0x0014)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            Color_CantPurchase_Txt_Price;                      // 0x0554(0x0014)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     _RemainArmor_FontMaterial;                         // 0x0568(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               _RemainArmor_FontMaterialInst;                     // 0x0570(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     _ArmorIcon_Material;                               // 0x0578(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               _ArmorIcon_MaterialInst;                           // 0x0580(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsEnableArmorItem;                                // 0x0588(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2537[0x3];                                     // 0x0589(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         _CurrentArmor;                                     // 0x058C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Clicked();
	void Hovered();
	void UnHovered();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_BattleStore_ArmorItem">();
	}
	static class UUI_BattleStore_ArmorItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_BattleStore_ArmorItem>();
	}
};
static_assert(alignof(UUI_BattleStore_ArmorItem) == 0x000008, "Wrong alignment on UUI_BattleStore_ArmorItem");
static_assert(sizeof(UUI_BattleStore_ArmorItem) == 0x000590, "Wrong size on UUI_BattleStore_ArmorItem");
static_assert(offsetof(UUI_BattleStore_ArmorItem, TXT_Func_ArmorPerRound) == 0x0004F0, "Member 'UUI_BattleStore_ArmorItem::TXT_Func_ArmorPerRound' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_ArmorItem, Img_Icon) == 0x0004F8, "Member 'UUI_BattleStore_ArmorItem::Img_Icon' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_ArmorItem, Txt_ArmorName) == 0x000500, "Member 'UUI_BattleStore_ArmorItem::Txt_ArmorName' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_ArmorItem, Txt_RemainArmor) == 0x000508, "Member 'UUI_BattleStore_ArmorItem::Txt_RemainArmor' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_ArmorItem, Panel_Price) == 0x000510, "Member 'UUI_BattleStore_ArmorItem::Panel_Price' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_ArmorItem, Txt_Price) == 0x000518, "Member 'UUI_BattleStore_ArmorItem::Txt_Price' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_ArmorItem, Btn_Main) == 0x000520, "Member 'UUI_BattleStore_ArmorItem::Btn_Main' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_ArmorItem, Img_Alert) == 0x000528, "Member 'UUI_BattleStore_ArmorItem::Img_Alert' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_ArmorItem, Panel_Swap) == 0x000530, "Member 'UUI_BattleStore_ArmorItem::Panel_Swap' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_ArmorItem, AlertAnim) == 0x000538, "Member 'UUI_BattleStore_ArmorItem::AlertAnim' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_ArmorItem, Color_CanPurchase_Txt_Price) == 0x000540, "Member 'UUI_BattleStore_ArmorItem::Color_CanPurchase_Txt_Price' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_ArmorItem, Color_CantPurchase_Txt_Price) == 0x000554, "Member 'UUI_BattleStore_ArmorItem::Color_CantPurchase_Txt_Price' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_ArmorItem, _RemainArmor_FontMaterial) == 0x000568, "Member 'UUI_BattleStore_ArmorItem::_RemainArmor_FontMaterial' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_ArmorItem, _RemainArmor_FontMaterialInst) == 0x000570, "Member 'UUI_BattleStore_ArmorItem::_RemainArmor_FontMaterialInst' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_ArmorItem, _ArmorIcon_Material) == 0x000578, "Member 'UUI_BattleStore_ArmorItem::_ArmorIcon_Material' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_ArmorItem, _ArmorIcon_MaterialInst) == 0x000580, "Member 'UUI_BattleStore_ArmorItem::_ArmorIcon_MaterialInst' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_ArmorItem, _IsEnableArmorItem) == 0x000588, "Member 'UUI_BattleStore_ArmorItem::_IsEnableArmorItem' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_ArmorItem, _CurrentArmor) == 0x00058C, "Member 'UUI_BattleStore_ArmorItem::_CurrentArmor' has a wrong offset!");

// Class Stigma.UI_BattleStore_BuffItem
// 0x0120 (0x0610 - 0x04F0)
class UUI_BattleStore_BuffItem : public UPreviewableWidget
{
public:
	class UTextBlock*                             Txt_Title;                                         // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WS_Price;                                          // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_Price;                                         // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_Stack;                                         // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Icon;                                          // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           Panel_Swap;                                        // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                Btn_Main;                                          // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateColor                            Color_CanPurchase_Txt_Price;                       // 0x0528(0x0014)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            Color_CantPurchase_Txt_Price;                      // 0x053C(0x0014)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FBattleStoreEntry                      _BattleStoreEntry;                                 // 0x0550(0x00B0)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnHover;                                           // 0x0600(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void Clicked();
	void Hovered();
	void UnHovered();
	void UpdateUI();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_BattleStore_BuffItem">();
	}
	static class UUI_BattleStore_BuffItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_BattleStore_BuffItem>();
	}
};
static_assert(alignof(UUI_BattleStore_BuffItem) == 0x000008, "Wrong alignment on UUI_BattleStore_BuffItem");
static_assert(sizeof(UUI_BattleStore_BuffItem) == 0x000610, "Wrong size on UUI_BattleStore_BuffItem");
static_assert(offsetof(UUI_BattleStore_BuffItem, Txt_Title) == 0x0004F0, "Member 'UUI_BattleStore_BuffItem::Txt_Title' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_BuffItem, WS_Price) == 0x0004F8, "Member 'UUI_BattleStore_BuffItem::WS_Price' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_BuffItem, Txt_Price) == 0x000500, "Member 'UUI_BattleStore_BuffItem::Txt_Price' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_BuffItem, Txt_Stack) == 0x000508, "Member 'UUI_BattleStore_BuffItem::Txt_Stack' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_BuffItem, Img_Icon) == 0x000510, "Member 'UUI_BattleStore_BuffItem::Img_Icon' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_BuffItem, Panel_Swap) == 0x000518, "Member 'UUI_BattleStore_BuffItem::Panel_Swap' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_BuffItem, Btn_Main) == 0x000520, "Member 'UUI_BattleStore_BuffItem::Btn_Main' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_BuffItem, Color_CanPurchase_Txt_Price) == 0x000528, "Member 'UUI_BattleStore_BuffItem::Color_CanPurchase_Txt_Price' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_BuffItem, Color_CantPurchase_Txt_Price) == 0x00053C, "Member 'UUI_BattleStore_BuffItem::Color_CantPurchase_Txt_Price' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_BuffItem, _BattleStoreEntry) == 0x000550, "Member 'UUI_BattleStore_BuffItem::_BattleStoreEntry' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_BuffItem, OnHover) == 0x000600, "Member 'UUI_BattleStore_BuffItem::OnHover' has a wrong offset!");

// Class Stigma.UI_ShopQuickPurchase
// 0x0080 (0x05F0 - 0x0570)
class UUI_ShopQuickPurchase : public UPopupBase
{
public:
	class UListView*                              LV_GoodsList;                                      // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_CurrencyBox*                        CurrencyBox;                                       // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_Status*                           Ctrl_Status_Normal;                                // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2538[0x18];                                    // 0x0588(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	TSet<struct FGoodsID>                         _QucikPurchaseGoodsList;                           // 0x05A0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)

public:
	TArray<struct FGoodsID> GetCurrencyGoodsList(const struct FItemID_Currency& _currency_type);
	TArray<struct FGoodsID> GetGunTypeGoodsList(EGunType _gun_type);
	void Init(const TArray<struct FGoodsID>& _quick_purchase_goods_list, EGoodsCategory _goods_category);
	void OnUpdateGoods(EUserEvent _event);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_ShopQuickPurchase">();
	}
	static class UUI_ShopQuickPurchase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_ShopQuickPurchase>();
	}
};
static_assert(alignof(UUI_ShopQuickPurchase) == 0x000008, "Wrong alignment on UUI_ShopQuickPurchase");
static_assert(sizeof(UUI_ShopQuickPurchase) == 0x0005F0, "Wrong size on UUI_ShopQuickPurchase");
static_assert(offsetof(UUI_ShopQuickPurchase, LV_GoodsList) == 0x000570, "Member 'UUI_ShopQuickPurchase::LV_GoodsList' has a wrong offset!");
static_assert(offsetof(UUI_ShopQuickPurchase, CurrencyBox) == 0x000578, "Member 'UUI_ShopQuickPurchase::CurrencyBox' has a wrong offset!");
static_assert(offsetof(UUI_ShopQuickPurchase, Ctrl_Status_Normal) == 0x000580, "Member 'UUI_ShopQuickPurchase::Ctrl_Status_Normal' has a wrong offset!");
static_assert(offsetof(UUI_ShopQuickPurchase, _QucikPurchaseGoodsList) == 0x0005A0, "Member 'UUI_ShopQuickPurchase::_QucikPurchaseGoodsList' has a wrong offset!");

// Class Stigma.UI_BattleStore_HistoryItem
// 0x0048 (0x0538 - 0x04F0)
class UUI_BattleStore_HistoryItem : public UPreviewableWidget
{
public:
	class UTextBlock*                             Txt_Title;                                         // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_Price;                                         // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Icon;                                          // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           Panel_Hover;                                       // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                Btn_Main;                                          // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_253B[0x20];                                    // 0x0518(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Clicked();
	void Hovered();
	void UnHovered();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_BattleStore_HistoryItem">();
	}
	static class UUI_BattleStore_HistoryItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_BattleStore_HistoryItem>();
	}
};
static_assert(alignof(UUI_BattleStore_HistoryItem) == 0x000008, "Wrong alignment on UUI_BattleStore_HistoryItem");
static_assert(sizeof(UUI_BattleStore_HistoryItem) == 0x000538, "Wrong size on UUI_BattleStore_HistoryItem");
static_assert(offsetof(UUI_BattleStore_HistoryItem, Txt_Title) == 0x0004F0, "Member 'UUI_BattleStore_HistoryItem::Txt_Title' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_HistoryItem, Txt_Price) == 0x0004F8, "Member 'UUI_BattleStore_HistoryItem::Txt_Price' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_HistoryItem, Img_Icon) == 0x000500, "Member 'UUI_BattleStore_HistoryItem::Img_Icon' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_HistoryItem, Panel_Hover) == 0x000508, "Member 'UUI_BattleStore_HistoryItem::Panel_Hover' has a wrong offset!");
static_assert(offsetof(UUI_BattleStore_HistoryItem, Btn_Main) == 0x000510, "Member 'UUI_BattleStore_HistoryItem::Btn_Main' has a wrong offset!");

// Class Stigma.UI_BoosterSelectMenu
// 0x0018 (0x02D8 - 0x02C0)
class UUI_BoosterSelectMenu : public UUserWidget
{
public:
	TSubclassOf<class UUI_BoosterSelectMenuItem>  _MenuItemClass;                                    // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _GridMaxColumnCount;                               // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_253C[0x4];                                     // 0x02CC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UUniformGridPanel*                      MenuGridPanel;                                     // 0x02D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_BoosterSelectMenu">();
	}
	static class UUI_BoosterSelectMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_BoosterSelectMenu>();
	}
};
static_assert(alignof(UUI_BoosterSelectMenu) == 0x000008, "Wrong alignment on UUI_BoosterSelectMenu");
static_assert(sizeof(UUI_BoosterSelectMenu) == 0x0002D8, "Wrong size on UUI_BoosterSelectMenu");
static_assert(offsetof(UUI_BoosterSelectMenu, _MenuItemClass) == 0x0002C0, "Member 'UUI_BoosterSelectMenu::_MenuItemClass' has a wrong offset!");
static_assert(offsetof(UUI_BoosterSelectMenu, _GridMaxColumnCount) == 0x0002C8, "Member 'UUI_BoosterSelectMenu::_GridMaxColumnCount' has a wrong offset!");
static_assert(offsetof(UUI_BoosterSelectMenu, MenuGridPanel) == 0x0002D0, "Member 'UUI_BoosterSelectMenu::MenuGridPanel' has a wrong offset!");

// Class Stigma.UI_BoosterSelectMenuItem
// 0x0058 (0x0318 - 0x02C0)
class UUI_BoosterSelectMenuItem : public UUserWidget
{
public:
	class UOverlay*                               OVL_EquipSlotNumber;                               // 0x02C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_EquipSlotNumber;                               // 0x02C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Icon;                                          // 0x02D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Name;                                          // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                BTN_Select;                                        // 0x02E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        SWITCHER_Menu;                                     // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               OVL_Equip;                                         // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               OVL_UnEquip;                                       // 0x02F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_253D[0x18];                                    // 0x0300(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void InitBuffDesc(const struct FConfig_Booster& _booster_def);
	void OnClickSelect();

	struct FItemID GetBoosterID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_BoosterSelectMenuItem">();
	}
	static class UUI_BoosterSelectMenuItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_BoosterSelectMenuItem>();
	}
};
static_assert(alignof(UUI_BoosterSelectMenuItem) == 0x000008, "Wrong alignment on UUI_BoosterSelectMenuItem");
static_assert(sizeof(UUI_BoosterSelectMenuItem) == 0x000318, "Wrong size on UUI_BoosterSelectMenuItem");
static_assert(offsetof(UUI_BoosterSelectMenuItem, OVL_EquipSlotNumber) == 0x0002C0, "Member 'UUI_BoosterSelectMenuItem::OVL_EquipSlotNumber' has a wrong offset!");
static_assert(offsetof(UUI_BoosterSelectMenuItem, TXT_EquipSlotNumber) == 0x0002C8, "Member 'UUI_BoosterSelectMenuItem::TXT_EquipSlotNumber' has a wrong offset!");
static_assert(offsetof(UUI_BoosterSelectMenuItem, Img_Icon) == 0x0002D0, "Member 'UUI_BoosterSelectMenuItem::Img_Icon' has a wrong offset!");
static_assert(offsetof(UUI_BoosterSelectMenuItem, TXT_Name) == 0x0002D8, "Member 'UUI_BoosterSelectMenuItem::TXT_Name' has a wrong offset!");
static_assert(offsetof(UUI_BoosterSelectMenuItem, BTN_Select) == 0x0002E0, "Member 'UUI_BoosterSelectMenuItem::BTN_Select' has a wrong offset!");
static_assert(offsetof(UUI_BoosterSelectMenuItem, SWITCHER_Menu) == 0x0002E8, "Member 'UUI_BoosterSelectMenuItem::SWITCHER_Menu' has a wrong offset!");
static_assert(offsetof(UUI_BoosterSelectMenuItem, OVL_Equip) == 0x0002F0, "Member 'UUI_BoosterSelectMenuItem::OVL_Equip' has a wrong offset!");
static_assert(offsetof(UUI_BoosterSelectMenuItem, OVL_UnEquip) == 0x0002F8, "Member 'UUI_BoosterSelectMenuItem::OVL_UnEquip' has a wrong offset!");

// Class Stigma.UI_SurveyWeb
// 0x0000 (0x0570 - 0x0570)
class UUI_SurveyWeb : public UPopupBase
{
public:
	bool OnOpen(const class FString& _url);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_SurveyWeb">();
	}
	static class UUI_SurveyWeb* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_SurveyWeb>();
	}
};
static_assert(alignof(UUI_SurveyWeb) == 0x000008, "Wrong alignment on UUI_SurveyWeb");
static_assert(sizeof(UUI_SurveyWeb) == 0x000570, "Wrong size on UUI_SurveyWeb");

// Class Stigma.UI_BoosterSlotList
// 0x0050 (0x0310 - 0x02C0)
class UUI_BoosterSlotList : public UUserWidget
{
public:
	class UUI_BoosterSlot*                        BoosterSlot_0;                                     // 0x02C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_BoosterSlot*                        BoosterSlot_1;                                     // 0x02C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_BoosterSlot*                        BoosterSlot_2;                                     // 0x02D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_BoosterSlot*                        BoosterSlot_3;                                     // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMenuAnchor*                            BoosterMenuAnchor;                                 // 0x02E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUI_BoosterSlot*>                _SlotList;                                         // 0x02E8(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_253F[0x18];                                    // 0x02F8(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnAck_BoosterUpdate(const struct FACK_BoosterUpdate& _ack);
	class UUserWidget* OnCreateMenuWidget();
	void OnMenuOpenChanged(bool _is_open);
	void OnSelectBoosterSlot(int32 _slot_index);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_BoosterSlotList">();
	}
	static class UUI_BoosterSlotList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_BoosterSlotList>();
	}
};
static_assert(alignof(UUI_BoosterSlotList) == 0x000008, "Wrong alignment on UUI_BoosterSlotList");
static_assert(sizeof(UUI_BoosterSlotList) == 0x000310, "Wrong size on UUI_BoosterSlotList");
static_assert(offsetof(UUI_BoosterSlotList, BoosterSlot_0) == 0x0002C0, "Member 'UUI_BoosterSlotList::BoosterSlot_0' has a wrong offset!");
static_assert(offsetof(UUI_BoosterSlotList, BoosterSlot_1) == 0x0002C8, "Member 'UUI_BoosterSlotList::BoosterSlot_1' has a wrong offset!");
static_assert(offsetof(UUI_BoosterSlotList, BoosterSlot_2) == 0x0002D0, "Member 'UUI_BoosterSlotList::BoosterSlot_2' has a wrong offset!");
static_assert(offsetof(UUI_BoosterSlotList, BoosterSlot_3) == 0x0002D8, "Member 'UUI_BoosterSlotList::BoosterSlot_3' has a wrong offset!");
static_assert(offsetof(UUI_BoosterSlotList, BoosterMenuAnchor) == 0x0002E0, "Member 'UUI_BoosterSlotList::BoosterMenuAnchor' has a wrong offset!");
static_assert(offsetof(UUI_BoosterSlotList, _SlotList) == 0x0002E8, "Member 'UUI_BoosterSlotList::_SlotList' has a wrong offset!");

// Class Stigma.UI_Bounty_Progress
// 0x0038 (0x0528 - 0x04F0)
class UUI_Bounty_Progress : public UPreviewableWidget
{
public:
	EBountyActionType                             _BountyActionType;                                 // 0x04F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2540[0x3];                                     // 0x04F1(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         _RemainTime;                                       // 0x04F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2541[0x8];                                     // 0x04F8(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         _TimePercent;                                      // 0x0500(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2542[0x24];                                    // 0x0504(0x0024)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void CancelTimer(EBountyActionType _bounty_action_type, const bool _hide_widget);
	void DriveTimer(float _delta);
	void ResetTimerVars();
	void SetBountyActionType(EBountyActionType _bounty_action_type);
	void StartTimer(EBountyActionType _bounty_action_type, float _start_time, float _max_time, bool _reverse, const TDelegate<void(bool _end_success)>& _proc);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Bounty_Progress">();
	}
	static class UUI_Bounty_Progress* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Bounty_Progress>();
	}
};
static_assert(alignof(UUI_Bounty_Progress) == 0x000008, "Wrong alignment on UUI_Bounty_Progress");
static_assert(sizeof(UUI_Bounty_Progress) == 0x000528, "Wrong size on UUI_Bounty_Progress");
static_assert(offsetof(UUI_Bounty_Progress, _BountyActionType) == 0x0004F0, "Member 'UUI_Bounty_Progress::_BountyActionType' has a wrong offset!");
static_assert(offsetof(UUI_Bounty_Progress, _RemainTime) == 0x0004F4, "Member 'UUI_Bounty_Progress::_RemainTime' has a wrong offset!");
static_assert(offsetof(UUI_Bounty_Progress, _TimePercent) == 0x000500, "Member 'UUI_Bounty_Progress::_TimePercent' has a wrong offset!");

// Class Stigma.UI_BriefUserSlot
// 0x01B0 (0x06A0 - 0x04F0)
class UUI_BriefUserSlot : public UPreviewableWidget
{
public:
	class UUserProfile*                           _BriefUser;                                        // 0x04F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EUserProfileType                              _UserAs;                                           // 0x04F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2545[0x7];                                     // 0x04F9(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UImage*                                 RightStick;                                        // 0x0500(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 HoverCover;                                        // 0x0508(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             PartyInvitingText;                                 // 0x0510(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           OfflineHoverCoverColor;                            // 0x0518(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           OfflineRightStickColor;                            // 0x0528(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateColor                            OfflineNicknameTextColor;                          // 0x0538(0x0014)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           OfflineUserStateTextColor;                         // 0x054C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           OnlineHoverCoverColor;                             // 0x055C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           OnlineRightStickColor;                             // 0x056C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateColor                            OnlineNicknameTextColor;                           // 0x057C(0x0014)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           OnlineUserStateTextColor;                          // 0x0590(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           BattleHoverCoverColor;                             // 0x05A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           BattleRightStickColor;                             // 0x05B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateColor                            BattleNicknameTextColor;                           // 0x05C0(0x0014)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           BattleUserStateTextColor;                          // 0x05D4(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           PartyMemberHoverCoverColor;                        // 0x05E4(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           PartyMemberRightStickColor;                        // 0x05F4(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateColor                            PartyMemberNicknameTextColor;                      // 0x0604(0x0014)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           PartyMemberUserStateTextColor;                     // 0x0618(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           AskedUserHoverCoverColor;                          // 0x0628(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           AskedUserRightStickColor;                          // 0x0638(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FSlateColor                            AskedUserNicknameTextColor;                        // 0x0648(0x0014)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           AskedUserStateTextColor;                           // 0x065C(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2546[0x4];                                     // 0x066C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             OnLeftClick;                                       // 0x0670(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRightClick;                                      // 0x0680(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFriendRemoveRequest;                             // 0x0690(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	TArray<struct FHoverMenuEntry> GetBriefToolTipEntries();
	void InitContext(class UUserProfile* _brief_user, EUserProfileType _as);
	void SetActivePartyInvitingText(bool _flag);
	void SetNickNameColor(const struct FSlateColor& _color);
	void SetNickNameText(const class FText& _nickname);
	void SetStateColor(const struct FSlateColor& _color);
	void SetStateText(const class FText& _state);
	void UpdateContext();
	void UpdateProfileCard(class UUserProfile* _brief_user);

	const class UUserProfile* GetBriefUser() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_BriefUserSlot">();
	}
	static class UUI_BriefUserSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_BriefUserSlot>();
	}
};
static_assert(alignof(UUI_BriefUserSlot) == 0x000008, "Wrong alignment on UUI_BriefUserSlot");
static_assert(sizeof(UUI_BriefUserSlot) == 0x0006A0, "Wrong size on UUI_BriefUserSlot");
static_assert(offsetof(UUI_BriefUserSlot, _BriefUser) == 0x0004F0, "Member 'UUI_BriefUserSlot::_BriefUser' has a wrong offset!");
static_assert(offsetof(UUI_BriefUserSlot, _UserAs) == 0x0004F8, "Member 'UUI_BriefUserSlot::_UserAs' has a wrong offset!");
static_assert(offsetof(UUI_BriefUserSlot, RightStick) == 0x000500, "Member 'UUI_BriefUserSlot::RightStick' has a wrong offset!");
static_assert(offsetof(UUI_BriefUserSlot, HoverCover) == 0x000508, "Member 'UUI_BriefUserSlot::HoverCover' has a wrong offset!");
static_assert(offsetof(UUI_BriefUserSlot, PartyInvitingText) == 0x000510, "Member 'UUI_BriefUserSlot::PartyInvitingText' has a wrong offset!");
static_assert(offsetof(UUI_BriefUserSlot, OfflineHoverCoverColor) == 0x000518, "Member 'UUI_BriefUserSlot::OfflineHoverCoverColor' has a wrong offset!");
static_assert(offsetof(UUI_BriefUserSlot, OfflineRightStickColor) == 0x000528, "Member 'UUI_BriefUserSlot::OfflineRightStickColor' has a wrong offset!");
static_assert(offsetof(UUI_BriefUserSlot, OfflineNicknameTextColor) == 0x000538, "Member 'UUI_BriefUserSlot::OfflineNicknameTextColor' has a wrong offset!");
static_assert(offsetof(UUI_BriefUserSlot, OfflineUserStateTextColor) == 0x00054C, "Member 'UUI_BriefUserSlot::OfflineUserStateTextColor' has a wrong offset!");
static_assert(offsetof(UUI_BriefUserSlot, OnlineHoverCoverColor) == 0x00055C, "Member 'UUI_BriefUserSlot::OnlineHoverCoverColor' has a wrong offset!");
static_assert(offsetof(UUI_BriefUserSlot, OnlineRightStickColor) == 0x00056C, "Member 'UUI_BriefUserSlot::OnlineRightStickColor' has a wrong offset!");
static_assert(offsetof(UUI_BriefUserSlot, OnlineNicknameTextColor) == 0x00057C, "Member 'UUI_BriefUserSlot::OnlineNicknameTextColor' has a wrong offset!");
static_assert(offsetof(UUI_BriefUserSlot, OnlineUserStateTextColor) == 0x000590, "Member 'UUI_BriefUserSlot::OnlineUserStateTextColor' has a wrong offset!");
static_assert(offsetof(UUI_BriefUserSlot, BattleHoverCoverColor) == 0x0005A0, "Member 'UUI_BriefUserSlot::BattleHoverCoverColor' has a wrong offset!");
static_assert(offsetof(UUI_BriefUserSlot, BattleRightStickColor) == 0x0005B0, "Member 'UUI_BriefUserSlot::BattleRightStickColor' has a wrong offset!");
static_assert(offsetof(UUI_BriefUserSlot, BattleNicknameTextColor) == 0x0005C0, "Member 'UUI_BriefUserSlot::BattleNicknameTextColor' has a wrong offset!");
static_assert(offsetof(UUI_BriefUserSlot, BattleUserStateTextColor) == 0x0005D4, "Member 'UUI_BriefUserSlot::BattleUserStateTextColor' has a wrong offset!");
static_assert(offsetof(UUI_BriefUserSlot, PartyMemberHoverCoverColor) == 0x0005E4, "Member 'UUI_BriefUserSlot::PartyMemberHoverCoverColor' has a wrong offset!");
static_assert(offsetof(UUI_BriefUserSlot, PartyMemberRightStickColor) == 0x0005F4, "Member 'UUI_BriefUserSlot::PartyMemberRightStickColor' has a wrong offset!");
static_assert(offsetof(UUI_BriefUserSlot, PartyMemberNicknameTextColor) == 0x000604, "Member 'UUI_BriefUserSlot::PartyMemberNicknameTextColor' has a wrong offset!");
static_assert(offsetof(UUI_BriefUserSlot, PartyMemberUserStateTextColor) == 0x000618, "Member 'UUI_BriefUserSlot::PartyMemberUserStateTextColor' has a wrong offset!");
static_assert(offsetof(UUI_BriefUserSlot, AskedUserHoverCoverColor) == 0x000628, "Member 'UUI_BriefUserSlot::AskedUserHoverCoverColor' has a wrong offset!");
static_assert(offsetof(UUI_BriefUserSlot, AskedUserRightStickColor) == 0x000638, "Member 'UUI_BriefUserSlot::AskedUserRightStickColor' has a wrong offset!");
static_assert(offsetof(UUI_BriefUserSlot, AskedUserNicknameTextColor) == 0x000648, "Member 'UUI_BriefUserSlot::AskedUserNicknameTextColor' has a wrong offset!");
static_assert(offsetof(UUI_BriefUserSlot, AskedUserStateTextColor) == 0x00065C, "Member 'UUI_BriefUserSlot::AskedUserStateTextColor' has a wrong offset!");
static_assert(offsetof(UUI_BriefUserSlot, OnLeftClick) == 0x000670, "Member 'UUI_BriefUserSlot::OnLeftClick' has a wrong offset!");
static_assert(offsetof(UUI_BriefUserSlot, OnRightClick) == 0x000680, "Member 'UUI_BriefUserSlot::OnRightClick' has a wrong offset!");
static_assert(offsetof(UUI_BriefUserSlot, OnFriendRemoveRequest) == 0x000690, "Member 'UUI_BriefUserSlot::OnFriendRemoveRequest' has a wrong offset!");

// Class Stigma.UI_BuffTypeBoxItem
// 0x0018 (0x0508 - 0x04F0)
class UUI_BuffTypeBoxItem : public UPreviewableWidget
{
public:
	class UWrapBox*                               WrapBox_Buffs;                                     // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                _BuffItemMargin;                                   // 0x04F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void SetTitle(const class FText& _buff_category);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_BuffTypeBoxItem">();
	}
	static class UUI_BuffTypeBoxItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_BuffTypeBoxItem>();
	}
};
static_assert(alignof(UUI_BuffTypeBoxItem) == 0x000008, "Wrong alignment on UUI_BuffTypeBoxItem");
static_assert(sizeof(UUI_BuffTypeBoxItem) == 0x000508, "Wrong size on UUI_BuffTypeBoxItem");
static_assert(offsetof(UUI_BuffTypeBoxItem, WrapBox_Buffs) == 0x0004F0, "Member 'UUI_BuffTypeBoxItem::WrapBox_Buffs' has a wrong offset!");
static_assert(offsetof(UUI_BuffTypeBoxItem, _BuffItemMargin) == 0x0004F8, "Member 'UUI_BuffTypeBoxItem::_BuffItemMargin' has a wrong offset!");

// Class Stigma.UI_BulletTipBtn
// 0x0068 (0x0558 - 0x04F0)
class UUI_BulletTipBtn : public UPreviewableWidget
{
public:
	class UGunObject*                             _GunObject;                                        // 0x04F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBulletTip                                    _BulletTipType;                                    // 0x04F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2548[0x3];                                     // 0x04F9(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	TDelegate<void(EBulletTip _bullet_tip)>       _OnSelectedDelegate;                               // 0x04FC(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2549[0x4];                                     // 0x050C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UButton*                                BTN_Button;                                        // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_Slot;                                          // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_BulletTip;                                     // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_Icon_Equipped;                                 // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_SelectedBG;                                    // 0x0530(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           Panel_Lock;                                        // 0x0538(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_BulletTipName;                                 // 0x0540(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             IMG_Slot_BG_Equipped;                              // 0x0548(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             IMG_Slot_BG_Normal;                                // 0x0550(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CheckAvailable(const TSet<EBulletTip>& _available_bullet_tips);
	void SetGunObject(class UGunObject* _gun_object);
	void UpdateUI();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_BulletTipBtn">();
	}
	static class UUI_BulletTipBtn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_BulletTipBtn>();
	}
};
static_assert(alignof(UUI_BulletTipBtn) == 0x000008, "Wrong alignment on UUI_BulletTipBtn");
static_assert(sizeof(UUI_BulletTipBtn) == 0x000558, "Wrong size on UUI_BulletTipBtn");
static_assert(offsetof(UUI_BulletTipBtn, _GunObject) == 0x0004F0, "Member 'UUI_BulletTipBtn::_GunObject' has a wrong offset!");
static_assert(offsetof(UUI_BulletTipBtn, _BulletTipType) == 0x0004F8, "Member 'UUI_BulletTipBtn::_BulletTipType' has a wrong offset!");
static_assert(offsetof(UUI_BulletTipBtn, _OnSelectedDelegate) == 0x0004FC, "Member 'UUI_BulletTipBtn::_OnSelectedDelegate' has a wrong offset!");
static_assert(offsetof(UUI_BulletTipBtn, BTN_Button) == 0x000510, "Member 'UUI_BulletTipBtn::BTN_Button' has a wrong offset!");
static_assert(offsetof(UUI_BulletTipBtn, IMG_Slot) == 0x000518, "Member 'UUI_BulletTipBtn::IMG_Slot' has a wrong offset!");
static_assert(offsetof(UUI_BulletTipBtn, IMG_BulletTip) == 0x000520, "Member 'UUI_BulletTipBtn::IMG_BulletTip' has a wrong offset!");
static_assert(offsetof(UUI_BulletTipBtn, IMG_Icon_Equipped) == 0x000528, "Member 'UUI_BulletTipBtn::IMG_Icon_Equipped' has a wrong offset!");
static_assert(offsetof(UUI_BulletTipBtn, IMG_SelectedBG) == 0x000530, "Member 'UUI_BulletTipBtn::IMG_SelectedBG' has a wrong offset!");
static_assert(offsetof(UUI_BulletTipBtn, Panel_Lock) == 0x000538, "Member 'UUI_BulletTipBtn::Panel_Lock' has a wrong offset!");
static_assert(offsetof(UUI_BulletTipBtn, TXT_BulletTipName) == 0x000540, "Member 'UUI_BulletTipBtn::TXT_BulletTipName' has a wrong offset!");
static_assert(offsetof(UUI_BulletTipBtn, IMG_Slot_BG_Equipped) == 0x000548, "Member 'UUI_BulletTipBtn::IMG_Slot_BG_Equipped' has a wrong offset!");
static_assert(offsetof(UUI_BulletTipBtn, IMG_Slot_BG_Normal) == 0x000550, "Member 'UUI_BulletTipBtn::IMG_Slot_BG_Normal' has a wrong offset!");

// Class Stigma.UI_BulletTipSelection
// 0x0048 (0x0538 - 0x04F0)
class UUI_BulletTipSelection : public UPreviewableWidget
{
public:
	uint8                                         Pad_254A[0x8];                                     // 0x04F0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UGunObject*                             _GunObject;                                        // 0x04F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_ExpireTime;                                    // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                BTN_Purchase;                                      // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_BulletTipBtn*                       Btn_BulletTip_AP;                                  // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_BulletTipBtn*                       Btn_BulletTip_T;                                   // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_BulletTipBtn*                       Btn_BulletTip_HP;                                  // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_BulletTipBtn*                       Btn_BulletTip_FMJ;                                 // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_254B[0x8];                                     // 0x0530(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void AddToastMessage(EBulletTip _bullet_tip);
	void CheckBuff();
	struct FNetReply OnUpdateGunAck(EResultCode _rcode, const struct FACK_UpdateGunSpec& _ack);
	void SelectBulletTip(EBulletTip _bullet_tip);
	void SetGunObject(class UGunObject* _gun_object);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_BulletTipSelection">();
	}
	static class UUI_BulletTipSelection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_BulletTipSelection>();
	}
};
static_assert(alignof(UUI_BulletTipSelection) == 0x000008, "Wrong alignment on UUI_BulletTipSelection");
static_assert(sizeof(UUI_BulletTipSelection) == 0x000538, "Wrong size on UUI_BulletTipSelection");
static_assert(offsetof(UUI_BulletTipSelection, _GunObject) == 0x0004F8, "Member 'UUI_BulletTipSelection::_GunObject' has a wrong offset!");
static_assert(offsetof(UUI_BulletTipSelection, TXT_ExpireTime) == 0x000500, "Member 'UUI_BulletTipSelection::TXT_ExpireTime' has a wrong offset!");
static_assert(offsetof(UUI_BulletTipSelection, BTN_Purchase) == 0x000508, "Member 'UUI_BulletTipSelection::BTN_Purchase' has a wrong offset!");
static_assert(offsetof(UUI_BulletTipSelection, Btn_BulletTip_AP) == 0x000510, "Member 'UUI_BulletTipSelection::Btn_BulletTip_AP' has a wrong offset!");
static_assert(offsetof(UUI_BulletTipSelection, Btn_BulletTip_T) == 0x000518, "Member 'UUI_BulletTipSelection::Btn_BulletTip_T' has a wrong offset!");
static_assert(offsetof(UUI_BulletTipSelection, Btn_BulletTip_HP) == 0x000520, "Member 'UUI_BulletTipSelection::Btn_BulletTip_HP' has a wrong offset!");
static_assert(offsetof(UUI_BulletTipSelection, Btn_BulletTip_FMJ) == 0x000528, "Member 'UUI_BulletTipSelection::Btn_BulletTip_FMJ' has a wrong offset!");

// Class Stigma.UI_CancellationPolicy
// 0x0008 (0x04F8 - 0x04F0)
class UUI_CancellationPolicy : public UPreviewableWidget
{
public:
	uint8                                         Pad_254D[0x8];                                     // 0x04F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void CheckCurrencyType(const TArray<struct FItemID_Currency>& _currency_types);
	void InitWidget(const TArray<struct FItemID_Currency>& _currency_types);
	void OpenPolicyURL();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_CancellationPolicy">();
	}
	static class UUI_CancellationPolicy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_CancellationPolicy>();
	}
};
static_assert(alignof(UUI_CancellationPolicy) == 0x000008, "Wrong alignment on UUI_CancellationPolicy");
static_assert(sizeof(UUI_CancellationPolicy) == 0x0004F8, "Wrong size on UUI_CancellationPolicy");

// Class Stigma.UI_CharacterPalette
// 0x0050 (0x0540 - 0x04F0)
class UUI_CharacterPalette : public UPreviewableWidget
{
public:
	uint8                                         Pad_254E[0x50];                                    // 0x04F0(0x0050)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnUpdateSelectedCharacters();

	bool IsSelectedCharacter(ECharaType _chara_type) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_CharacterPalette">();
	}
	static class UUI_CharacterPalette* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_CharacterPalette>();
	}
};
static_assert(alignof(UUI_CharacterPalette) == 0x000008, "Wrong alignment on UUI_CharacterPalette");
static_assert(sizeof(UUI_CharacterPalette) == 0x000540, "Wrong size on UUI_CharacterPalette");

// Class Stigma.UI_CharacterPicker
// 0x0008 (0x0550 - 0x0548)
class UUI_CharacterPicker : public UUI_PlayerJoinDetectable
{
public:
	uint8                                         Pad_254F[0x8];                                     // 0x0548(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool Ready();
	void SelectCharacter(ECharaType _chara_type);

	const struct FCharacterInfo GetPickedCharacter(int32 _idx) const;
	const struct FGunSpec GetPickedCharacterGun(int32 _idx) const;
	ECharaType GetPickedCharacterType(int32 _idx) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_CharacterPicker">();
	}
	static class UUI_CharacterPicker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_CharacterPicker>();
	}
};
static_assert(alignof(UUI_CharacterPicker) == 0x000008, "Wrong alignment on UUI_CharacterPicker");
static_assert(sizeof(UUI_CharacterPicker) == 0x000550, "Wrong size on UUI_CharacterPicker");

// Class Stigma.POPUP_ChangeMaster
// 0x0000 (0x0570 - 0x0570)
class UPOPUP_ChangeMaster : public UPopupBase
{
public:
	void InitEvent();
	void SetTimeLimit(int32 _limit_time_sec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"POPUP_ChangeMaster">();
	}
	static class UPOPUP_ChangeMaster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPOPUP_ChangeMaster>();
	}
};
static_assert(alignof(UPOPUP_ChangeMaster) == 0x000008, "Wrong alignment on UPOPUP_ChangeMaster");
static_assert(sizeof(UPOPUP_ChangeMaster) == 0x000570, "Wrong size on UPOPUP_ChangeMaster");

// Class Stigma.LVData_ChatItem
// 0x0060 (0x0088 - 0x0028)
class ULVData_ChatItem final : public UObject
{
public:
	uint8                                         Pad_2553[0x60];                                    // 0x0028(0x0060)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LVData_ChatItem">();
	}
	static class ULVData_ChatItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULVData_ChatItem>();
	}
};
static_assert(alignof(ULVData_ChatItem) == 0x000008, "Wrong alignment on ULVData_ChatItem");
static_assert(sizeof(ULVData_ChatItem) == 0x000088, "Wrong size on ULVData_ChatItem");

// Class Stigma.UI_ChatSlot
// 0x0218 (0x0708 - 0x04F0)
class UUI_ChatSlot : public UPreviewableWidget
{
public:
	uint8                                         Pad_2554[0x8];                                     // 0x04F0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UBorder*                                RootBackground;                                    // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ContentBackground;                                 // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             ChannelTypeText;                                   // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             NicknameText;                                      // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             ChatTypeText;                                      // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class URichTextBlock*                         ChatContentText;                                   // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         _Font;                                             // 0x0528(0x0058)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _BackgroundColorForUserEnter;                      // 0x0580(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _BackgroundColorForPartyEnter;                     // 0x0590(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         _ChatSlotFont;                                     // 0x05A0(0x0058)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         _ChatSlotTipFont;                                  // 0x05F8(0x0058)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _TeamChannelColor;                                 // 0x0650(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _PartyChannelColor;                                // 0x0660(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _MyChatNicknameColor;                              // 0x0670(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _MyChatContextColor;                               // 0x0680(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _NetChatNicknameColor;                             // 0x0690(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           _NetChatContextColor;                              // 0x06A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULVData_ChatItem*                       _ItemObject;                                       // 0x06B0(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2555[0x50];                                    // 0x06B8(0x0050)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void SetChannelTypeText(const class FText& _channel_type_text);
	void SetChannelTypeTextColor(const struct FLinearColor& _color);
	bool SetChat(EChatType _chat_type, const class FText& _nickname, const class FText& _chat_text);
	void SetChatTypeText(const class FText& _chat_type_text);
	void SetChatTypeTextColor(const struct FLinearColor& _color);
	void SetContextTextColor(const struct FLinearColor& _color);
	void SetFont(const struct FSlateFontInfo& _font_info);
	void SetNicknameTextColor(const struct FLinearColor& _color);
	void SetUseChatTypeText(bool _is_use);
	void UpdateBackgroundSize();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_ChatSlot">();
	}
	static class UUI_ChatSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_ChatSlot>();
	}
};
static_assert(alignof(UUI_ChatSlot) == 0x000008, "Wrong alignment on UUI_ChatSlot");
static_assert(sizeof(UUI_ChatSlot) == 0x000708, "Wrong size on UUI_ChatSlot");
static_assert(offsetof(UUI_ChatSlot, RootBackground) == 0x0004F8, "Member 'UUI_ChatSlot::RootBackground' has a wrong offset!");
static_assert(offsetof(UUI_ChatSlot, ContentBackground) == 0x000500, "Member 'UUI_ChatSlot::ContentBackground' has a wrong offset!");
static_assert(offsetof(UUI_ChatSlot, ChannelTypeText) == 0x000508, "Member 'UUI_ChatSlot::ChannelTypeText' has a wrong offset!");
static_assert(offsetof(UUI_ChatSlot, NicknameText) == 0x000510, "Member 'UUI_ChatSlot::NicknameText' has a wrong offset!");
static_assert(offsetof(UUI_ChatSlot, ChatTypeText) == 0x000518, "Member 'UUI_ChatSlot::ChatTypeText' has a wrong offset!");
static_assert(offsetof(UUI_ChatSlot, ChatContentText) == 0x000520, "Member 'UUI_ChatSlot::ChatContentText' has a wrong offset!");
static_assert(offsetof(UUI_ChatSlot, _Font) == 0x000528, "Member 'UUI_ChatSlot::_Font' has a wrong offset!");
static_assert(offsetof(UUI_ChatSlot, _BackgroundColorForUserEnter) == 0x000580, "Member 'UUI_ChatSlot::_BackgroundColorForUserEnter' has a wrong offset!");
static_assert(offsetof(UUI_ChatSlot, _BackgroundColorForPartyEnter) == 0x000590, "Member 'UUI_ChatSlot::_BackgroundColorForPartyEnter' has a wrong offset!");
static_assert(offsetof(UUI_ChatSlot, _ChatSlotFont) == 0x0005A0, "Member 'UUI_ChatSlot::_ChatSlotFont' has a wrong offset!");
static_assert(offsetof(UUI_ChatSlot, _ChatSlotTipFont) == 0x0005F8, "Member 'UUI_ChatSlot::_ChatSlotTipFont' has a wrong offset!");
static_assert(offsetof(UUI_ChatSlot, _TeamChannelColor) == 0x000650, "Member 'UUI_ChatSlot::_TeamChannelColor' has a wrong offset!");
static_assert(offsetof(UUI_ChatSlot, _PartyChannelColor) == 0x000660, "Member 'UUI_ChatSlot::_PartyChannelColor' has a wrong offset!");
static_assert(offsetof(UUI_ChatSlot, _MyChatNicknameColor) == 0x000670, "Member 'UUI_ChatSlot::_MyChatNicknameColor' has a wrong offset!");
static_assert(offsetof(UUI_ChatSlot, _MyChatContextColor) == 0x000680, "Member 'UUI_ChatSlot::_MyChatContextColor' has a wrong offset!");
static_assert(offsetof(UUI_ChatSlot, _NetChatNicknameColor) == 0x000690, "Member 'UUI_ChatSlot::_NetChatNicknameColor' has a wrong offset!");
static_assert(offsetof(UUI_ChatSlot, _NetChatContextColor) == 0x0006A0, "Member 'UUI_ChatSlot::_NetChatContextColor' has a wrong offset!");
static_assert(offsetof(UUI_ChatSlot, _ItemObject) == 0x0006B0, "Member 'UUI_ChatSlot::_ItemObject' has a wrong offset!");

// Class Stigma.UI_CheatBase
// 0x0008 (0x0578 - 0x0570)
class UUI_CheatBase : public UPopupBase
{
public:
	class ACharaBase*                             _chara;                                            // 0x0570(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool OnBindChara(class ACharaBase* _pawn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_CheatBase">();
	}
	static class UUI_CheatBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_CheatBase>();
	}
};
static_assert(alignof(UUI_CheatBase) == 0x000008, "Wrong alignment on UUI_CheatBase");
static_assert(sizeof(UUI_CheatBase) == 0x000578, "Wrong size on UUI_CheatBase");
static_assert(offsetof(UUI_CheatBase, _chara) == 0x000570, "Member 'UUI_CheatBase::_chara' has a wrong offset!");

// Class Stigma.UI_StorePopup
// 0x0008 (0x0578 - 0x0570)
class UUI_StorePopup : public UPopupBase
{
public:
	class AProp_Store*                            PropStore;                                         // 0x0570(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_StorePopup">();
	}
	static class UUI_StorePopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_StorePopup>();
	}
};
static_assert(alignof(UUI_StorePopup) == 0x000008, "Wrong alignment on UUI_StorePopup");
static_assert(sizeof(UUI_StorePopup) == 0x000578, "Wrong size on UUI_StorePopup");
static_assert(offsetof(UUI_StorePopup, PropStore) == 0x000570, "Member 'UUI_StorePopup::PropStore' has a wrong offset!");

// Class Stigma.UI_CLBStorePopup
// 0x0000 (0x0578 - 0x0578)
class UUI_CLBStorePopup final : public UUI_StorePopup
{
public:
	bool OnClearAllItems();
	bool OnFinishAllItems();
	bool OnInitializeItem(class UCLB_StoreItem* Item, int32 Item_index);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_CLBStorePopup">();
	}
	static class UUI_CLBStorePopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_CLBStorePopup>();
	}
};
static_assert(alignof(UUI_CLBStorePopup) == 0x000008, "Wrong alignment on UUI_CLBStorePopup");
static_assert(sizeof(UUI_CLBStorePopup) == 0x000578, "Wrong size on UUI_CLBStorePopup");

// Class Stigma.UI_CompetitionBrief
// 0x0058 (0x0548 - 0x04F0)
class UUI_CompetitionBrief : public UPreviewableWidget
{
public:
	class UCompetitionBriefInfo*                  _BriefInfo;                                        // 0x04F0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCompetitionBriefPlayer*                _MyBrief;                                          // 0x04F8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECompetitionType                              _CurCompetitionType;                               // 0x0500(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_255A[0x7];                                     // 0x0501(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UWidgetSwitcher*                        WS_Competition_Status;                             // 0x0508(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WS_State_Text;                                     // 0x0510(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_State;                                         // 0x0518(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Unlock;                                        // 0x0520(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_CompetitionBreakTime;                          // 0x0528(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               OVL_State;                                         // 0x0530(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_RemainDateTimer*                    RemainDateTimer;                                   // 0x0538(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_255B[0x8];                                     // 0x0540(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool InitWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_CompetitionBrief">();
	}
	static class UUI_CompetitionBrief* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_CompetitionBrief>();
	}
};
static_assert(alignof(UUI_CompetitionBrief) == 0x000008, "Wrong alignment on UUI_CompetitionBrief");
static_assert(sizeof(UUI_CompetitionBrief) == 0x000548, "Wrong size on UUI_CompetitionBrief");
static_assert(offsetof(UUI_CompetitionBrief, _BriefInfo) == 0x0004F0, "Member 'UUI_CompetitionBrief::_BriefInfo' has a wrong offset!");
static_assert(offsetof(UUI_CompetitionBrief, _MyBrief) == 0x0004F8, "Member 'UUI_CompetitionBrief::_MyBrief' has a wrong offset!");
static_assert(offsetof(UUI_CompetitionBrief, _CurCompetitionType) == 0x000500, "Member 'UUI_CompetitionBrief::_CurCompetitionType' has a wrong offset!");
static_assert(offsetof(UUI_CompetitionBrief, WS_Competition_Status) == 0x000508, "Member 'UUI_CompetitionBrief::WS_Competition_Status' has a wrong offset!");
static_assert(offsetof(UUI_CompetitionBrief, WS_State_Text) == 0x000510, "Member 'UUI_CompetitionBrief::WS_State_Text' has a wrong offset!");
static_assert(offsetof(UUI_CompetitionBrief, TXT_State) == 0x000518, "Member 'UUI_CompetitionBrief::TXT_State' has a wrong offset!");
static_assert(offsetof(UUI_CompetitionBrief, TXT_Unlock) == 0x000520, "Member 'UUI_CompetitionBrief::TXT_Unlock' has a wrong offset!");
static_assert(offsetof(UUI_CompetitionBrief, TXT_CompetitionBreakTime) == 0x000528, "Member 'UUI_CompetitionBrief::TXT_CompetitionBreakTime' has a wrong offset!");
static_assert(offsetof(UUI_CompetitionBrief, OVL_State) == 0x000530, "Member 'UUI_CompetitionBrief::OVL_State' has a wrong offset!");
static_assert(offsetof(UUI_CompetitionBrief, RemainDateTimer) == 0x000538, "Member 'UUI_CompetitionBrief::RemainDateTimer' has a wrong offset!");

// Class Stigma.UI_CompetitionRankingListItem
// 0x0010 (0x0500 - 0x04F0)
class UUI_CompetitionRankingListItem : public UPreviewableWidget
{
public:
	uint8                                         Pad_255C[0x8];                                     // 0x04F0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TWeakObjectPtr<class ULVData_CompetitionRankingItem> _ItemData;                                         // 0x04F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool UpdateUI();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_CompetitionRankingListItem">();
	}
	static class UUI_CompetitionRankingListItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_CompetitionRankingListItem>();
	}
};
static_assert(alignof(UUI_CompetitionRankingListItem) == 0x000008, "Wrong alignment on UUI_CompetitionRankingListItem");
static_assert(sizeof(UUI_CompetitionRankingListItem) == 0x000500, "Wrong size on UUI_CompetitionRankingListItem");
static_assert(offsetof(UUI_CompetitionRankingListItem, _ItemData) == 0x0004F8, "Member 'UUI_CompetitionRankingListItem::_ItemData' has a wrong offset!");

// Class Stigma.UI_Comp_Indicator_Abnormals
// 0x0088 (0x0578 - 0x04F0)
class UUI_Comp_Indicator_Abnormals : public UPreviewableWidget
{
public:
	TSubclassOf<class UUI_Abnormal_Icon>          _IconClass;                                        // 0x04F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HorizontalBox;                                     // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EAbnormal, class UTexture2D*>            _AbnormalImages;                                   // 0x0500(0x0050)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FVector2D                              _IconSize;                                         // 0x0550(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                _ImagePadding;                                     // 0x0560(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_255D[0x8];                                     // 0x0570(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Comp_Indicator_Abnormals">();
	}
	static class UUI_Comp_Indicator_Abnormals* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Comp_Indicator_Abnormals>();
	}
};
static_assert(alignof(UUI_Comp_Indicator_Abnormals) == 0x000008, "Wrong alignment on UUI_Comp_Indicator_Abnormals");
static_assert(sizeof(UUI_Comp_Indicator_Abnormals) == 0x000578, "Wrong size on UUI_Comp_Indicator_Abnormals");
static_assert(offsetof(UUI_Comp_Indicator_Abnormals, _IconClass) == 0x0004F0, "Member 'UUI_Comp_Indicator_Abnormals::_IconClass' has a wrong offset!");
static_assert(offsetof(UUI_Comp_Indicator_Abnormals, HorizontalBox) == 0x0004F8, "Member 'UUI_Comp_Indicator_Abnormals::HorizontalBox' has a wrong offset!");
static_assert(offsetof(UUI_Comp_Indicator_Abnormals, _AbnormalImages) == 0x000500, "Member 'UUI_Comp_Indicator_Abnormals::_AbnormalImages' has a wrong offset!");
static_assert(offsetof(UUI_Comp_Indicator_Abnormals, _IconSize) == 0x000550, "Member 'UUI_Comp_Indicator_Abnormals::_IconSize' has a wrong offset!");
static_assert(offsetof(UUI_Comp_Indicator_Abnormals, _ImagePadding) == 0x000560, "Member 'UUI_Comp_Indicator_Abnormals::_ImagePadding' has a wrong offset!");

// Class Stigma.UI_Abnormal_Icon
// 0x00E0 (0x05D0 - 0x04F0)
class UUI_Abnormal_Icon : public UPreviewableWidget
{
public:
	class UImage*                                 Image;                                             // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_255E[0x8];                                     // 0x04F8(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	struct FSlateBrush                            _brush;                                            // 0x0500(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Abnormal_Icon">();
	}
	static class UUI_Abnormal_Icon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Abnormal_Icon>();
	}
};
static_assert(alignof(UUI_Abnormal_Icon) == 0x000010, "Wrong alignment on UUI_Abnormal_Icon");
static_assert(sizeof(UUI_Abnormal_Icon) == 0x0005D0, "Wrong size on UUI_Abnormal_Icon");
static_assert(offsetof(UUI_Abnormal_Icon, Image) == 0x0004F0, "Member 'UUI_Abnormal_Icon::Image' has a wrong offset!");
static_assert(offsetof(UUI_Abnormal_Icon, _brush) == 0x000500, "Member 'UUI_Abnormal_Icon::_brush' has a wrong offset!");

// Class Stigma.UI_Comp_Indicator_HPBar
// 0x0020 (0x0510 - 0x04F0)
class UUI_Comp_Indicator_HPBar : public UPreviewableWidget
{
public:
	uint8                                         Pad_255F[0x18];                                    // 0x04F0(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         _InterpSpeed;                                      // 0x0508(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2560[0x4];                                     // 0x050C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void SetArmor(float _armor_percent);
	void SetArmor_Interp(float _armor_percent);
	void SetArmorTypeIcon(const TSoftObjectPtr<class UTexture2D>& _Icon);
	void SetHP(float _hp_percent);
	void SetHP_Interp(float _hp_percent);
	void UpdateDistance(float _distance);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Comp_Indicator_HPBar">();
	}
	static class UUI_Comp_Indicator_HPBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Comp_Indicator_HPBar>();
	}
};
static_assert(alignof(UUI_Comp_Indicator_HPBar) == 0x000008, "Wrong alignment on UUI_Comp_Indicator_HPBar");
static_assert(sizeof(UUI_Comp_Indicator_HPBar) == 0x000510, "Wrong size on UUI_Comp_Indicator_HPBar");
static_assert(offsetof(UUI_Comp_Indicator_HPBar, _InterpSpeed) == 0x000508, "Member 'UUI_Comp_Indicator_HPBar::_InterpSpeed' has a wrong offset!");

// Class Stigma.UI_ControlPowerMasterList
// 0x0020 (0x0510 - 0x04F0)
class UUI_ControlPowerMasterList : public UPreviewableWidget
{
public:
	class UCtrl_CommonTileView*                   TILEVIEW_Masters;                                  // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGunObject*                             _GunObject;                                        // 0x04F8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ULVData_ControlPowerMaster*>     _LVData_Masters;                                   // 0x0500(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void BuildMasterList();
	bool HasLackCPInSelectedMaster();
	void SetGunObject(class UGunObject* _gun_object);
	void UpdateUI(class ULVData_ControlPowerMaster* _item);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_ControlPowerMasterList">();
	}
	static class UUI_ControlPowerMasterList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_ControlPowerMasterList>();
	}
};
static_assert(alignof(UUI_ControlPowerMasterList) == 0x000008, "Wrong alignment on UUI_ControlPowerMasterList");
static_assert(sizeof(UUI_ControlPowerMasterList) == 0x000510, "Wrong size on UUI_ControlPowerMasterList");
static_assert(offsetof(UUI_ControlPowerMasterList, TILEVIEW_Masters) == 0x0004F0, "Member 'UUI_ControlPowerMasterList::TILEVIEW_Masters' has a wrong offset!");
static_assert(offsetof(UUI_ControlPowerMasterList, _GunObject) == 0x0004F8, "Member 'UUI_ControlPowerMasterList::_GunObject' has a wrong offset!");
static_assert(offsetof(UUI_ControlPowerMasterList, _LVData_Masters) == 0x000500, "Member 'UUI_ControlPowerMasterList::_LVData_Masters' has a wrong offset!");

// Class Stigma.UI_CurrencyBox
// 0x0070 (0x0560 - 0x04F0)
class UUI_CurrencyBox : public UPreviewableWidget
{
public:
	class UButton*                                Btn_Wallet;                                        // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                Border;                                            // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                Btn_BuyCurrency;                                   // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_Currency;                                      // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_CurrencySimple;                                // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              _PanelSize;                                        // 0x0518(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsShowTooltip;                                    // 0x0528(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2561[0x7];                                     // 0x0529(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UPopupBase>                 _WalletPopupClass;                                 // 0x0530(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPopupBase>                 _QuickPurchasePopupClass;                          // 0x0538(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsUseWallet;                                      // 0x0540(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsForcedUnNotQuickPurchase;                       // 0x0541(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsAutoInitCurrency;                               // 0x0542(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2562[0x5];                                     // 0x0543(0x0005)(Fixing Size After Last Property [ Dumper-69 ])
	struct FItemID_Currency                       _CurrencyType;                                     // 0x0548(0x0010)(Edit, BlueprintVisible, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2563[0x8];                                     // 0x0558(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void InitWidget(const struct FItemID_Currency& _currency_type);
	void OnClickPurchaseCurrency();
	void OnClickWallet();
	void OnUpdateUser(EUserEvent _event);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_CurrencyBox">();
	}
	static class UUI_CurrencyBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_CurrencyBox>();
	}
};
static_assert(alignof(UUI_CurrencyBox) == 0x000008, "Wrong alignment on UUI_CurrencyBox");
static_assert(sizeof(UUI_CurrencyBox) == 0x000560, "Wrong size on UUI_CurrencyBox");
static_assert(offsetof(UUI_CurrencyBox, Btn_Wallet) == 0x0004F0, "Member 'UUI_CurrencyBox::Btn_Wallet' has a wrong offset!");
static_assert(offsetof(UUI_CurrencyBox, Border) == 0x0004F8, "Member 'UUI_CurrencyBox::Border' has a wrong offset!");
static_assert(offsetof(UUI_CurrencyBox, Btn_BuyCurrency) == 0x000500, "Member 'UUI_CurrencyBox::Btn_BuyCurrency' has a wrong offset!");
static_assert(offsetof(UUI_CurrencyBox, Txt_Currency) == 0x000508, "Member 'UUI_CurrencyBox::Txt_Currency' has a wrong offset!");
static_assert(offsetof(UUI_CurrencyBox, Img_CurrencySimple) == 0x000510, "Member 'UUI_CurrencyBox::Img_CurrencySimple' has a wrong offset!");
static_assert(offsetof(UUI_CurrencyBox, _PanelSize) == 0x000518, "Member 'UUI_CurrencyBox::_PanelSize' has a wrong offset!");
static_assert(offsetof(UUI_CurrencyBox, _IsShowTooltip) == 0x000528, "Member 'UUI_CurrencyBox::_IsShowTooltip' has a wrong offset!");
static_assert(offsetof(UUI_CurrencyBox, _WalletPopupClass) == 0x000530, "Member 'UUI_CurrencyBox::_WalletPopupClass' has a wrong offset!");
static_assert(offsetof(UUI_CurrencyBox, _QuickPurchasePopupClass) == 0x000538, "Member 'UUI_CurrencyBox::_QuickPurchasePopupClass' has a wrong offset!");
static_assert(offsetof(UUI_CurrencyBox, _IsUseWallet) == 0x000540, "Member 'UUI_CurrencyBox::_IsUseWallet' has a wrong offset!");
static_assert(offsetof(UUI_CurrencyBox, _IsForcedUnNotQuickPurchase) == 0x000541, "Member 'UUI_CurrencyBox::_IsForcedUnNotQuickPurchase' has a wrong offset!");
static_assert(offsetof(UUI_CurrencyBox, _IsAutoInitCurrency) == 0x000542, "Member 'UUI_CurrencyBox::_IsAutoInitCurrency' has a wrong offset!");
static_assert(offsetof(UUI_CurrencyBox, _CurrencyType) == 0x000548, "Member 'UUI_CurrencyBox::_CurrencyType' has a wrong offset!");

// Class Stigma.UI_CurrencyBoxList
// 0x0068 (0x0558 - 0x04F0)
class UUI_CurrencyBoxList : public UPreviewableWidget
{
public:
	class UHorizontalBox*                         HB_CurrencyList;                                   // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_CurrencyBox>            _CurrencyBoxClass;                                 // 0x04F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _Padding;                                          // 0x0500(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2564[0x4];                                     // 0x0504(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TMap<struct FItemID_Currency, class UUI_CurrencyBox*> _CurrencyBoxMap;                                   // 0x0508(0x0050)(ExportObject, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_CurrencyBoxList">();
	}
	static class UUI_CurrencyBoxList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_CurrencyBoxList>();
	}
};
static_assert(alignof(UUI_CurrencyBoxList) == 0x000008, "Wrong alignment on UUI_CurrencyBoxList");
static_assert(sizeof(UUI_CurrencyBoxList) == 0x000558, "Wrong size on UUI_CurrencyBoxList");
static_assert(offsetof(UUI_CurrencyBoxList, HB_CurrencyList) == 0x0004F0, "Member 'UUI_CurrencyBoxList::HB_CurrencyList' has a wrong offset!");
static_assert(offsetof(UUI_CurrencyBoxList, _CurrencyBoxClass) == 0x0004F8, "Member 'UUI_CurrencyBoxList::_CurrencyBoxClass' has a wrong offset!");
static_assert(offsetof(UUI_CurrencyBoxList, _Padding) == 0x000500, "Member 'UUI_CurrencyBoxList::_Padding' has a wrong offset!");
static_assert(offsetof(UUI_CurrencyBoxList, _CurrencyBoxMap) == 0x000508, "Member 'UUI_CurrencyBoxList::_CurrencyBoxMap' has a wrong offset!");

// Class Stigma.CustomGameDragAndDropOp
// 0x0018 (0x00A8 - 0x0090)
class UCustomGameDragAndDropOp final : public UDragDropOperation
{
public:
	class UUI_CustomGame_Slot*                    Slot;                                              // 0x0090(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DragOffset;                                        // 0x0098(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomGameDragAndDropOp">();
	}
	static class UCustomGameDragAndDropOp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomGameDragAndDropOp>();
	}
};
static_assert(alignof(UCustomGameDragAndDropOp) == 0x000008, "Wrong alignment on UCustomGameDragAndDropOp");
static_assert(sizeof(UCustomGameDragAndDropOp) == 0x0000A8, "Wrong size on UCustomGameDragAndDropOp");
static_assert(offsetof(UCustomGameDragAndDropOp, Slot) == 0x000090, "Member 'UCustomGameDragAndDropOp::Slot' has a wrong offset!");
static_assert(offsetof(UCustomGameDragAndDropOp, DragOffset) == 0x000098, "Member 'UCustomGameDragAndDropOp::DragOffset' has a wrong offset!");

// Class Stigma.UI_CustomGame_Slot
// 0x0050 (0x0540 - 0x04F0)
class UUI_CustomGame_Slot final : public UPreviewableWidget
{
public:
	TSubclassOf<class UMessageBox>                _MessageBoxClass;                                  // 0x04F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCustomGameSlotIndex                   _SlotIndex;                                        // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsDragging;                                       // 0x0500(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2565[0x7];                                     // 0x0501(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FVector2D                              _DragOffset;                                       // 0x0508(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsRoomLeader;                                     // 0x0518(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsRoomManager;                                    // 0x0519(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2566[0x26];                                    // 0x051A(0x0026)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnBanThisPlayer();
	bool OnUpdateSlot();
	bool OnUpdateState();
	void RequestBan();
	void RequestCloseSlot(bool _close);
	void RequestMove(const struct FCustomGameSlotIndex& _to);
	void SetSlotIndex(const struct FCustomGameSlotIndex& _idx);
	void ToggleCloseSlot();

	class AWaitingRoomGameState* GameState() const;
	class AWaitingRoomPlayerState* GetBoundPlayerState() const;
	struct FUserName GetNickname() const;
	class AWaitingRoomPlayerController* GetPC() const;
	const struct FCustomGameSlot GetSlot() const;
	const struct FCustomGameSlotIndex GetSlotIndex() const;
	struct FUserID GetUserID() const;
	bool IsBound() const;
	bool IsClosedSlot() const;
	bool IsFriend() const;
	bool IsLocalRoomLeader() const;
	bool IsLocalRoomManager() const;
	bool IsMine() const;
	bool IsRoomLeader() const;
	bool IsRoomManager() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_CustomGame_Slot">();
	}
	static class UUI_CustomGame_Slot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_CustomGame_Slot>();
	}
};
static_assert(alignof(UUI_CustomGame_Slot) == 0x000008, "Wrong alignment on UUI_CustomGame_Slot");
static_assert(sizeof(UUI_CustomGame_Slot) == 0x000540, "Wrong size on UUI_CustomGame_Slot");
static_assert(offsetof(UUI_CustomGame_Slot, _MessageBoxClass) == 0x0004F0, "Member 'UUI_CustomGame_Slot::_MessageBoxClass' has a wrong offset!");
static_assert(offsetof(UUI_CustomGame_Slot, _SlotIndex) == 0x0004F8, "Member 'UUI_CustomGame_Slot::_SlotIndex' has a wrong offset!");
static_assert(offsetof(UUI_CustomGame_Slot, _IsDragging) == 0x000500, "Member 'UUI_CustomGame_Slot::_IsDragging' has a wrong offset!");
static_assert(offsetof(UUI_CustomGame_Slot, _DragOffset) == 0x000508, "Member 'UUI_CustomGame_Slot::_DragOffset' has a wrong offset!");
static_assert(offsetof(UUI_CustomGame_Slot, _IsRoomLeader) == 0x000518, "Member 'UUI_CustomGame_Slot::_IsRoomLeader' has a wrong offset!");
static_assert(offsetof(UUI_CustomGame_Slot, _IsRoomManager) == 0x000519, "Member 'UUI_CustomGame_Slot::_IsRoomManager' has a wrong offset!");

// Class Stigma.UI_CustomItemUsing
// 0x0008 (0x0578 - 0x0570)
class UUI_CustomItemUsing : public UPopupBase
{
public:
	class UInvenItem*                             _ItemObject;                                       // 0x0570(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Open(class UInvenItem* _item);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_CustomItemUsing">();
	}
	static class UUI_CustomItemUsing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_CustomItemUsing>();
	}
};
static_assert(alignof(UUI_CustomItemUsing) == 0x000008, "Wrong alignment on UUI_CustomItemUsing");
static_assert(sizeof(UUI_CustomItemUsing) == 0x000578, "Wrong size on UUI_CustomItemUsing");
static_assert(offsetof(UUI_CustomItemUsing, _ItemObject) == 0x000570, "Member 'UUI_CustomItemUsing::_ItemObject' has a wrong offset!");

// Class Stigma.UI_FloatingGuideContainer
// 0x0050 (0x0540 - 0x04F0)
class UUI_FloatingGuideContainer : public UPreviewableWidget
{
public:
	class FName                                   FloatingGuideName;                                 // 0x04F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_FloatingGuide>          FloatingGuideClass;                                // 0x04F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EFloatingGuidePosition                        FloatingGuidePosition;                             // 0x0500(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2567[0x7];                                     // 0x0501(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UUserWidget>                SubWidgetClass;                                    // 0x0508(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   HelpURL;                                           // 0x0510(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         FloatingGuideDuration;                             // 0x0528(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2568[0x4];                                     // 0x052C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FVector2D                              FloatingGuideSpace;                                // 0x0530(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_FloatingGuideContainer">();
	}
	static class UUI_FloatingGuideContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_FloatingGuideContainer>();
	}
};
static_assert(alignof(UUI_FloatingGuideContainer) == 0x000008, "Wrong alignment on UUI_FloatingGuideContainer");
static_assert(sizeof(UUI_FloatingGuideContainer) == 0x000540, "Wrong size on UUI_FloatingGuideContainer");
static_assert(offsetof(UUI_FloatingGuideContainer, FloatingGuideName) == 0x0004F0, "Member 'UUI_FloatingGuideContainer::FloatingGuideName' has a wrong offset!");
static_assert(offsetof(UUI_FloatingGuideContainer, FloatingGuideClass) == 0x0004F8, "Member 'UUI_FloatingGuideContainer::FloatingGuideClass' has a wrong offset!");
static_assert(offsetof(UUI_FloatingGuideContainer, FloatingGuidePosition) == 0x000500, "Member 'UUI_FloatingGuideContainer::FloatingGuidePosition' has a wrong offset!");
static_assert(offsetof(UUI_FloatingGuideContainer, SubWidgetClass) == 0x000508, "Member 'UUI_FloatingGuideContainer::SubWidgetClass' has a wrong offset!");
static_assert(offsetof(UUI_FloatingGuideContainer, HelpURL) == 0x000510, "Member 'UUI_FloatingGuideContainer::HelpURL' has a wrong offset!");
static_assert(offsetof(UUI_FloatingGuideContainer, FloatingGuideDuration) == 0x000528, "Member 'UUI_FloatingGuideContainer::FloatingGuideDuration' has a wrong offset!");
static_assert(offsetof(UUI_FloatingGuideContainer, FloatingGuideSpace) == 0x000530, "Member 'UUI_FloatingGuideContainer::FloatingGuideSpace' has a wrong offset!");

// Class Stigma.UI_DamageViewer
// 0x0070 (0x05B0 - 0x0540)
class UUI_DamageViewer : public UUI_FloatingGuideContainer
{
public:
	float                                         _DisplayDuration;                                  // 0x0540(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2569[0x4];                                     // 0x0544(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FVector2D                              PivotOffsetInWorldSpace;                           // 0x0548(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _ShowScaleCurve;                                   // 0x0558(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            _UpDirCurve;                                       // 0x0560(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _UpDirScale;                                       // 0x0568(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_256A[0x4];                                     // 0x056C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class AActor*                                 _HittedActor;                                      // 0x0570(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_256B[0x38];                                    // 0x0578(0x0038)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool OnShow(const struct FDamagedData& _data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_DamageViewer">();
	}
	static class UUI_DamageViewer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_DamageViewer>();
	}
};
static_assert(alignof(UUI_DamageViewer) == 0x000008, "Wrong alignment on UUI_DamageViewer");
static_assert(sizeof(UUI_DamageViewer) == 0x0005B0, "Wrong size on UUI_DamageViewer");
static_assert(offsetof(UUI_DamageViewer, _DisplayDuration) == 0x000540, "Member 'UUI_DamageViewer::_DisplayDuration' has a wrong offset!");
static_assert(offsetof(UUI_DamageViewer, PivotOffsetInWorldSpace) == 0x000548, "Member 'UUI_DamageViewer::PivotOffsetInWorldSpace' has a wrong offset!");
static_assert(offsetof(UUI_DamageViewer, _ShowScaleCurve) == 0x000558, "Member 'UUI_DamageViewer::_ShowScaleCurve' has a wrong offset!");
static_assert(offsetof(UUI_DamageViewer, _UpDirCurve) == 0x000560, "Member 'UUI_DamageViewer::_UpDirCurve' has a wrong offset!");
static_assert(offsetof(UUI_DamageViewer, _UpDirScale) == 0x000568, "Member 'UUI_DamageViewer::_UpDirScale' has a wrong offset!");
static_assert(offsetof(UUI_DamageViewer, _HittedActor) == 0x000570, "Member 'UUI_DamageViewer::_HittedActor' has a wrong offset!");

// Class Stigma.UI_Debug_CharaBase
// 0x0010 (0x0500 - 0x04F0)
class UUI_Debug_CharaBase : public UPreviewableWidget
{
public:
	int32                                         SwitchIndex;                                       // 0x04F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_256D[0x4];                                     // 0x04F4(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class ACharaBase*                             _target;                                           // 0x04F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnChangeSwitchIndex(int32 _index);
	void OnChangeTarget(class ACharaBase* _chara);
	void SetSwitchIndex(int32 _index);

	int32 GetSwitchIndex() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Debug_CharaBase">();
	}
	static class UUI_Debug_CharaBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Debug_CharaBase>();
	}
};
static_assert(alignof(UUI_Debug_CharaBase) == 0x000008, "Wrong alignment on UUI_Debug_CharaBase");
static_assert(sizeof(UUI_Debug_CharaBase) == 0x000500, "Wrong size on UUI_Debug_CharaBase");
static_assert(offsetof(UUI_Debug_CharaBase, SwitchIndex) == 0x0004F0, "Member 'UUI_Debug_CharaBase::SwitchIndex' has a wrong offset!");
static_assert(offsetof(UUI_Debug_CharaBase, _target) == 0x0004F8, "Member 'UUI_Debug_CharaBase::_target' has a wrong offset!");

// Class Stigma.UI_ResultBase
// 0x01D0 (0x0740 - 0x0570)
class UUI_ResultBase : public UPopupBase
{
public:
	class UUI_GameResult_Report*                  UI_GameResult_Report;                              // 0x0570(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   _text;                                             // 0x0578(0x0018)(Edit, BlueprintVisible, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FUserName                              _MyNickname;                                       // 0x0590(0x0018)(Edit, BlueprintVisible, Transient, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeams                                        _MyTeam;                                           // 0x05A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_256E[0x7];                                     // 0x05A9(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FUserBattleResult                      _MyResult;                                         // 0x05B0(0x0090)(Edit, BlueprintVisible, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	EGameMode                                     Mode;                                              // 0x0640(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_256F[0x3];                                     // 0x0641(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class FName                                   MapName;                                           // 0x0644(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBattleDecision                               Decision;                                          // 0x064C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeams                                        WinTeam;                                           // 0x064D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsAllyTeamWin;                                    // 0x064E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2570[0x1];                                     // 0x064F(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         _AllyTeamWinCount;                                 // 0x0650(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _EnemyTeamWinCount;                                // 0x0654(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimespan                              PlayLength;                                        // 0x0658(0x0008)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FBattleDecisionDetail                  Result;                                            // 0x0660(0x00D0)(Edit, BlueprintVisible, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<struct FUserBattleResult>              Players;                                           // 0x0730(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	void ChangeLevelToLobby();
	void FillUpWithMockup();

	class UWidget* GetFocusControl() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_ResultBase">();
	}
	static class UUI_ResultBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_ResultBase>();
	}
};
static_assert(alignof(UUI_ResultBase) == 0x000008, "Wrong alignment on UUI_ResultBase");
static_assert(sizeof(UUI_ResultBase) == 0x000740, "Wrong size on UUI_ResultBase");
static_assert(offsetof(UUI_ResultBase, UI_GameResult_Report) == 0x000570, "Member 'UUI_ResultBase::UI_GameResult_Report' has a wrong offset!");
static_assert(offsetof(UUI_ResultBase, _text) == 0x000578, "Member 'UUI_ResultBase::_text' has a wrong offset!");
static_assert(offsetof(UUI_ResultBase, _MyNickname) == 0x000590, "Member 'UUI_ResultBase::_MyNickname' has a wrong offset!");
static_assert(offsetof(UUI_ResultBase, _MyTeam) == 0x0005A8, "Member 'UUI_ResultBase::_MyTeam' has a wrong offset!");
static_assert(offsetof(UUI_ResultBase, _MyResult) == 0x0005B0, "Member 'UUI_ResultBase::_MyResult' has a wrong offset!");
static_assert(offsetof(UUI_ResultBase, Mode) == 0x000640, "Member 'UUI_ResultBase::Mode' has a wrong offset!");
static_assert(offsetof(UUI_ResultBase, MapName) == 0x000644, "Member 'UUI_ResultBase::MapName' has a wrong offset!");
static_assert(offsetof(UUI_ResultBase, Decision) == 0x00064C, "Member 'UUI_ResultBase::Decision' has a wrong offset!");
static_assert(offsetof(UUI_ResultBase, WinTeam) == 0x00064D, "Member 'UUI_ResultBase::WinTeam' has a wrong offset!");
static_assert(offsetof(UUI_ResultBase, _IsAllyTeamWin) == 0x00064E, "Member 'UUI_ResultBase::_IsAllyTeamWin' has a wrong offset!");
static_assert(offsetof(UUI_ResultBase, _AllyTeamWinCount) == 0x000650, "Member 'UUI_ResultBase::_AllyTeamWinCount' has a wrong offset!");
static_assert(offsetof(UUI_ResultBase, _EnemyTeamWinCount) == 0x000654, "Member 'UUI_ResultBase::_EnemyTeamWinCount' has a wrong offset!");
static_assert(offsetof(UUI_ResultBase, PlayLength) == 0x000658, "Member 'UUI_ResultBase::PlayLength' has a wrong offset!");
static_assert(offsetof(UUI_ResultBase, Result) == 0x000660, "Member 'UUI_ResultBase::Result' has a wrong offset!");
static_assert(offsetof(UUI_ResultBase, Players) == 0x000730, "Member 'UUI_ResultBase::Players' has a wrong offset!");

// Class Stigma.UI_EquippedGunParts
// 0x0130 (0x0620 - 0x04F0)
class UUI_EquippedGunParts : public UPreviewableWidget
{
public:
	class UGunObject*                             _GunObject;                                        // 0x04F0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInvenItem*                             _ItemObject;                                       // 0x04F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGunPartsSlot                                 _GunPartsSlot;                                     // 0x0500(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2571[0x7];                                     // 0x0501(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UImage*                                 Img_Icon;                                          // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           H_ExpireTimes;                                     // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_ExpireTime;                                    // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               OVL_Unowned;                                       // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              _BodyIcon;                                         // 0x0528(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              _SlideIcon;                                        // 0x0550(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              _MagazineIcon;                                     // 0x0578(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              _FrontIcon;                                        // 0x05A0(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              _TopIcon;                                          // 0x05C8(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              _UnderIcon;                                        // 0x05F0(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2572[0x8];                                     // 0x0618(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnUpdatedGunSpec(class UGunObject* _gun_object);
	void SetGunObject(class UGunObject* _gun_object);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_EquippedGunParts">();
	}
	static class UUI_EquippedGunParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_EquippedGunParts>();
	}
};
static_assert(alignof(UUI_EquippedGunParts) == 0x000008, "Wrong alignment on UUI_EquippedGunParts");
static_assert(sizeof(UUI_EquippedGunParts) == 0x000620, "Wrong size on UUI_EquippedGunParts");
static_assert(offsetof(UUI_EquippedGunParts, _GunObject) == 0x0004F0, "Member 'UUI_EquippedGunParts::_GunObject' has a wrong offset!");
static_assert(offsetof(UUI_EquippedGunParts, _ItemObject) == 0x0004F8, "Member 'UUI_EquippedGunParts::_ItemObject' has a wrong offset!");
static_assert(offsetof(UUI_EquippedGunParts, _GunPartsSlot) == 0x000500, "Member 'UUI_EquippedGunParts::_GunPartsSlot' has a wrong offset!");
static_assert(offsetof(UUI_EquippedGunParts, Img_Icon) == 0x000508, "Member 'UUI_EquippedGunParts::Img_Icon' has a wrong offset!");
static_assert(offsetof(UUI_EquippedGunParts, H_ExpireTimes) == 0x000510, "Member 'UUI_EquippedGunParts::H_ExpireTimes' has a wrong offset!");
static_assert(offsetof(UUI_EquippedGunParts, TXT_ExpireTime) == 0x000518, "Member 'UUI_EquippedGunParts::TXT_ExpireTime' has a wrong offset!");
static_assert(offsetof(UUI_EquippedGunParts, OVL_Unowned) == 0x000520, "Member 'UUI_EquippedGunParts::OVL_Unowned' has a wrong offset!");
static_assert(offsetof(UUI_EquippedGunParts, _BodyIcon) == 0x000528, "Member 'UUI_EquippedGunParts::_BodyIcon' has a wrong offset!");
static_assert(offsetof(UUI_EquippedGunParts, _SlideIcon) == 0x000550, "Member 'UUI_EquippedGunParts::_SlideIcon' has a wrong offset!");
static_assert(offsetof(UUI_EquippedGunParts, _MagazineIcon) == 0x000578, "Member 'UUI_EquippedGunParts::_MagazineIcon' has a wrong offset!");
static_assert(offsetof(UUI_EquippedGunParts, _FrontIcon) == 0x0005A0, "Member 'UUI_EquippedGunParts::_FrontIcon' has a wrong offset!");
static_assert(offsetof(UUI_EquippedGunParts, _TopIcon) == 0x0005C8, "Member 'UUI_EquippedGunParts::_TopIcon' has a wrong offset!");
static_assert(offsetof(UUI_EquippedGunParts, _UnderIcon) == 0x0005F0, "Member 'UUI_EquippedGunParts::_UnderIcon' has a wrong offset!");

// Class Stigma.UI_EventAttendance
// 0x0020 (0x0510 - 0x04F0)
class UUI_EventAttendance : public UPreviewableWidget
{
public:
	struct FItemID_EventPage                      _EventPageID;                                      // 0x04F0(0x0010)(BlueprintVisible, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUI_EventPageRewardItem*>        _RewardWidgets;                                    // 0x0500(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void InitWidget(const struct FItemID_EventPage& _event_page_id);
	void SetFromEventInfo(const struct FEventPageInfo& _event_page_info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_EventAttendance">();
	}
	static class UUI_EventAttendance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_EventAttendance>();
	}
};
static_assert(alignof(UUI_EventAttendance) == 0x000008, "Wrong alignment on UUI_EventAttendance");
static_assert(sizeof(UUI_EventAttendance) == 0x000510, "Wrong size on UUI_EventAttendance");
static_assert(offsetof(UUI_EventAttendance, _EventPageID) == 0x0004F0, "Member 'UUI_EventAttendance::_EventPageID' has a wrong offset!");
static_assert(offsetof(UUI_EventAttendance, _RewardWidgets) == 0x000500, "Member 'UUI_EventAttendance::_RewardWidgets' has a wrong offset!");

// Class Stigma.UI_EventCollection
// 0x0000 (0x04F0 - 0x04F0)
class UUI_EventCollection final : public UPreviewableWidget
{
public:
	void InitWidget(const struct FItemID_EventPage& _event_page_id);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_EventCollection">();
	}
	static class UUI_EventCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_EventCollection>();
	}
};
static_assert(alignof(UUI_EventCollection) == 0x000008, "Wrong alignment on UUI_EventCollection");
static_assert(sizeof(UUI_EventCollection) == 0x0004F0, "Wrong size on UUI_EventCollection");

// Class Stigma.UI_EventCurrency
// 0x0000 (0x04F0 - 0x04F0)
class UUI_EventCurrency final : public UPreviewableWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_EventCurrency">();
	}
	static class UUI_EventCurrency* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_EventCurrency>();
	}
};
static_assert(alignof(UUI_EventCurrency) == 0x000008, "Wrong alignment on UUI_EventCurrency");
static_assert(sizeof(UUI_EventCurrency) == 0x0004F0, "Wrong size on UUI_EventCurrency");

// Class Stigma.UI_RewardContainer
// 0x0038 (0x0528 - 0x04F0)
class UUI_RewardContainer : public UPreviewableWidget
{
public:
	class UUniformGridPanel*                      UGP_Reward;                                        // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              _UI_ItemSize;                                      // 0x04F8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                _ItemPadding;                                      // 0x0508(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2573[0x10];                                    // 0x0518(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	class UUI_RewardItem* CreateRewardWidget();
	void SetRewardState(ERewardItemState _state);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_RewardContainer">();
	}
	static class UUI_RewardContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_RewardContainer>();
	}
};
static_assert(alignof(UUI_RewardContainer) == 0x000008, "Wrong alignment on UUI_RewardContainer");
static_assert(sizeof(UUI_RewardContainer) == 0x000528, "Wrong size on UUI_RewardContainer");
static_assert(offsetof(UUI_RewardContainer, UGP_Reward) == 0x0004F0, "Member 'UUI_RewardContainer::UGP_Reward' has a wrong offset!");
static_assert(offsetof(UUI_RewardContainer, _UI_ItemSize) == 0x0004F8, "Member 'UUI_RewardContainer::_UI_ItemSize' has a wrong offset!");
static_assert(offsetof(UUI_RewardContainer, _ItemPadding) == 0x000508, "Member 'UUI_RewardContainer::_ItemPadding' has a wrong offset!");

// Class Stigma.UI_EventCurrencyTab
// 0x0010 (0x0500 - 0x04F0)
class UUI_EventCurrencyTab : public UPreviewableWidget
{
public:
	struct FItemID_Currency                       _CurrencyID;                                       // 0x04F0(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitWidget(const struct FItemID_Currency& _currency_id);
	void OpenEventShop();
	void SetAmount(int32 _Amount);
	void SetIcon(const TSoftObjectPtr<class UTexture2D>& _Icon);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_EventCurrencyTab">();
	}
	static class UUI_EventCurrencyTab* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_EventCurrencyTab>();
	}
};
static_assert(alignof(UUI_EventCurrencyTab) == 0x000008, "Wrong alignment on UUI_EventCurrencyTab");
static_assert(sizeof(UUI_EventCurrencyTab) == 0x000500, "Wrong size on UUI_EventCurrencyTab");
static_assert(offsetof(UUI_EventCurrencyTab, _CurrencyID) == 0x0004F0, "Member 'UUI_EventCurrencyTab::_CurrencyID' has a wrong offset!");

// Class Stigma.UI_EventKeepConnect
// 0x0020 (0x0510 - 0x04F0)
class UUI_EventKeepConnect : public UPreviewableWidget
{
public:
	class UHorizontalBox*                         HorizontalBox;                                     // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemID_EventPage                      _EventPageID;                                      // 0x04F8(0x0010)(BlueprintVisible, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2574[0x8];                                     // 0x0508(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool CheckReawrdItemStateUpdated();
	void InitWidget(const struct FItemID_EventPage& _event_page_id);
	void SetFromEventInfo(const struct FEventPageInfo& _event_page_info);
	void ShowNextRemainMinutes(bool _show, int32 _minutes);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_EventKeepConnect">();
	}
	static class UUI_EventKeepConnect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_EventKeepConnect>();
	}
};
static_assert(alignof(UUI_EventKeepConnect) == 0x000008, "Wrong alignment on UUI_EventKeepConnect");
static_assert(sizeof(UUI_EventKeepConnect) == 0x000510, "Wrong size on UUI_EventKeepConnect");
static_assert(offsetof(UUI_EventKeepConnect, HorizontalBox) == 0x0004F0, "Member 'UUI_EventKeepConnect::HorizontalBox' has a wrong offset!");
static_assert(offsetof(UUI_EventKeepConnect, _EventPageID) == 0x0004F8, "Member 'UUI_EventKeepConnect::_EventPageID' has a wrong offset!");

// Class Stigma.UI_EventMission
// 0x0020 (0x0510 - 0x04F0)
class UUI_EventMission : public UPreviewableWidget
{
public:
	class UUniformGridPanel*                      UGP_MissionSlot;                                   // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_EventMissionSlot>       _EventMissionSlotClass;                            // 0x04F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemID_EventPage                      _EventPageID;                                      // 0x0500(0x0010)(BlueprintVisible, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitWidget(const struct FItemID_EventPage& _event_page_id);
	void SetFromEventInfo(const struct FEventPageInfo& _event_page_info);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_EventMission">();
	}
	static class UUI_EventMission* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_EventMission>();
	}
};
static_assert(alignof(UUI_EventMission) == 0x000008, "Wrong alignment on UUI_EventMission");
static_assert(sizeof(UUI_EventMission) == 0x000510, "Wrong size on UUI_EventMission");
static_assert(offsetof(UUI_EventMission, UGP_MissionSlot) == 0x0004F0, "Member 'UUI_EventMission::UGP_MissionSlot' has a wrong offset!");
static_assert(offsetof(UUI_EventMission, _EventMissionSlotClass) == 0x0004F8, "Member 'UUI_EventMission::_EventMissionSlotClass' has a wrong offset!");
static_assert(offsetof(UUI_EventMission, _EventPageID) == 0x000500, "Member 'UUI_EventMission::_EventPageID' has a wrong offset!");

// Class Stigma.UI_EventMissionSlot
// 0x0028 (0x0518 - 0x04F0)
class UUI_EventMissionSlot : public UPreviewableWidget
{
public:
	class UUI_RewardContainer*                    RewardContainer;                                   // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2576[0x20];                                    // 0x04F8(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnUpdateMission(EMissionUpdateType _type, class UMission* _updated_mission);
	void RequestReward();
	void SetCanReward(bool _can_reward);
	void SetDesc(const class FText& _text);
	void SetProgress(EMissionProgressType _progress_type, const float& _rate, int32 _count, int32 _target_count);
	void SetTitle(const class FText& _text);
	void ShowGoToButton(bool _show);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_EventMissionSlot">();
	}
	static class UUI_EventMissionSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_EventMissionSlot>();
	}
};
static_assert(alignof(UUI_EventMissionSlot) == 0x000008, "Wrong alignment on UUI_EventMissionSlot");
static_assert(sizeof(UUI_EventMissionSlot) == 0x000518, "Wrong size on UUI_EventMissionSlot");
static_assert(offsetof(UUI_EventMissionSlot, RewardContainer) == 0x0004F0, "Member 'UUI_EventMissionSlot::RewardContainer' has a wrong offset!");

// Class Stigma.ListViewRewardItemData
// 0x0018 (0x0040 - 0x0028)
class UListViewRewardItemData final : public UObject
{
public:
	struct FItemID                                _ItemID;                                           // 0x0028(0x0010)(Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _Amount;                                           // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERewardItemState                              _RewardState;                                      // 0x003C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2579[0x3];                                     // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ListViewRewardItemData">();
	}
	static class UListViewRewardItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UListViewRewardItemData>();
	}
};
static_assert(alignof(UListViewRewardItemData) == 0x000008, "Wrong alignment on UListViewRewardItemData");
static_assert(sizeof(UListViewRewardItemData) == 0x000040, "Wrong size on UListViewRewardItemData");
static_assert(offsetof(UListViewRewardItemData, _ItemID) == 0x000028, "Member 'UListViewRewardItemData::_ItemID' has a wrong offset!");
static_assert(offsetof(UListViewRewardItemData, _Amount) == 0x000038, "Member 'UListViewRewardItemData::_Amount' has a wrong offset!");
static_assert(offsetof(UListViewRewardItemData, _RewardState) == 0x00003C, "Member 'UListViewRewardItemData::_RewardState' has a wrong offset!");

// Class Stigma.UI_EventPagePopup
// 0x0048 (0x05B8 - 0x0570)
class UUI_EventPagePopup : public UPopupBase
{
public:
	class UWidgetSwitcher*                        WS_Main;                                           // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WS_BackgroundContainer;                            // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      UGP_PopupTab;                                      // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WS_PopupContainer;                                 // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_EventPagePopupTab>      _PopupTabClass;                                    // 0x0590(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_257A[0x20];                                    // 0x0598(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool InitWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_EventPagePopup">();
	}
	static class UUI_EventPagePopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_EventPagePopup>();
	}
};
static_assert(alignof(UUI_EventPagePopup) == 0x000008, "Wrong alignment on UUI_EventPagePopup");
static_assert(sizeof(UUI_EventPagePopup) == 0x0005B8, "Wrong size on UUI_EventPagePopup");
static_assert(offsetof(UUI_EventPagePopup, WS_Main) == 0x000570, "Member 'UUI_EventPagePopup::WS_Main' has a wrong offset!");
static_assert(offsetof(UUI_EventPagePopup, WS_BackgroundContainer) == 0x000578, "Member 'UUI_EventPagePopup::WS_BackgroundContainer' has a wrong offset!");
static_assert(offsetof(UUI_EventPagePopup, UGP_PopupTab) == 0x000580, "Member 'UUI_EventPagePopup::UGP_PopupTab' has a wrong offset!");
static_assert(offsetof(UUI_EventPagePopup, WS_PopupContainer) == 0x000588, "Member 'UUI_EventPagePopup::WS_PopupContainer' has a wrong offset!");
static_assert(offsetof(UUI_EventPagePopup, _PopupTabClass) == 0x000590, "Member 'UUI_EventPagePopup::_PopupTabClass' has a wrong offset!");

// Class Stigma.UI_EventPagePopupBackground
// 0x0000 (0x04F0 - 0x04F0)
class UUI_EventPagePopupBackground : public UPreviewableWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_EventPagePopupBackground">();
	}
	static class UUI_EventPagePopupBackground* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_EventPagePopupBackground>();
	}
};
static_assert(alignof(UUI_EventPagePopupBackground) == 0x000008, "Wrong alignment on UUI_EventPagePopupBackground");
static_assert(sizeof(UUI_EventPagePopupBackground) == 0x0004F0, "Wrong size on UUI_EventPagePopupBackground");

// Class Stigma.UI_EventPagePopupContainer
// 0x0010 (0x0500 - 0x04F0)
class UUI_EventPagePopupContainer : public UPreviewableWidget
{
public:
	struct FItemID_EventPage                      _EventPageID;                                      // 0x04F0(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void EnableRewardButton(bool _is_enable);
	void OnClickRewardBtn(bool _is_option);
	void OnInitWidget();
	void OnUpdateEventPageInfo(const struct FEventPageInfo& _event_page_info);
	void SetCompleteCountRewardItems(int32 _count, int32 _reward_count);
	void SetDailyResetTimer(const struct FDateTime& _end_at, int32 _alert_hour);
	void SetDate(const class FString& _start_at_str, const class FString& _end_at_str);
	void SetDesc(const class FText& _text);
	void SetEventCurrency(const struct FItemID_Currency& _currency_id);
	void SetRemainTimer(const struct FDateTime& _end_at, int32 _alert_hour);
	void SetRepeatRewardItem(const struct FRewardItem& _reward_item, int32 _repeat_count, int32 _repeat_reward_count, ERewardItemState _reward_state);
	void SetTextures(const struct FSlateBrush& _bubble_image, const struct FSlateBrush& _speecher_image);
	void SetTitle(const class FText& _text);
	void UpdateFromEventInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_EventPagePopupContainer">();
	}
	static class UUI_EventPagePopupContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_EventPagePopupContainer>();
	}
};
static_assert(alignof(UUI_EventPagePopupContainer) == 0x000008, "Wrong alignment on UUI_EventPagePopupContainer");
static_assert(sizeof(UUI_EventPagePopupContainer) == 0x000500, "Wrong size on UUI_EventPagePopupContainer");
static_assert(offsetof(UUI_EventPagePopupContainer, _EventPageID) == 0x0004F0, "Member 'UUI_EventPagePopupContainer::_EventPageID' has a wrong offset!");

// Class Stigma.UI_EventPagePopupTab
// 0x0028 (0x0518 - 0x04F0)
class UUI_EventPagePopupTab : public UPreviewableWidget
{
public:
	class UUI_RemainDateTimer*                    RemainDateTimer;                                   // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_257E[0x20];                                    // 0x04F8(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnButtonClicked();
	void SetBackground(const struct FSlateBrush& _brush);
	void SetTitle(const class FText& _text);
	void ShowRedDot(bool _show);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_EventPagePopupTab">();
	}
	static class UUI_EventPagePopupTab* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_EventPagePopupTab>();
	}
};
static_assert(alignof(UUI_EventPagePopupTab) == 0x000008, "Wrong alignment on UUI_EventPagePopupTab");
static_assert(sizeof(UUI_EventPagePopupTab) == 0x000518, "Wrong size on UUI_EventPagePopupTab");
static_assert(offsetof(UUI_EventPagePopupTab, RemainDateTimer) == 0x0004F0, "Member 'UUI_EventPagePopupTab::RemainDateTimer' has a wrong offset!");

// Class Stigma.UI_RoundCountDown
// 0x0010 (0x0500 - 0x04F0)
class UUI_RoundCountDown : public UPreviewableWidget
{
public:
	class USoundBase*                             _StartSound;                                       // 0x04F0(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_257F[0x8];                                     // 0x04F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void SetCount(int32 _count);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_RoundCountDown">();
	}
	static class UUI_RoundCountDown* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_RoundCountDown>();
	}
};
static_assert(alignof(UUI_RoundCountDown) == 0x000008, "Wrong alignment on UUI_RoundCountDown");
static_assert(sizeof(UUI_RoundCountDown) == 0x000500, "Wrong size on UUI_RoundCountDown");
static_assert(offsetof(UUI_RoundCountDown, _StartSound) == 0x0004F0, "Member 'UUI_RoundCountDown::_StartSound' has a wrong offset!");

// Class Stigma.UI_EventPageRewardItem
// 0x0028 (0x0518 - 0x04F0)
class UUI_EventPageRewardItem : public UPreviewableWidget
{
public:
	class UUI_RewardItem*                         RewardItem;                                        // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRewardItem                            _RewardItemData;                                   // 0x04F8(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	int32                                         _value;                                            // 0x0510(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2580[0x4];                                     // 0x0514(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void SetState(ERewardItemState _state);

	ERewardItemState GetState() const;
	int32 GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_EventPageRewardItem">();
	}
	static class UUI_EventPageRewardItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_EventPageRewardItem>();
	}
};
static_assert(alignof(UUI_EventPageRewardItem) == 0x000008, "Wrong alignment on UUI_EventPageRewardItem");
static_assert(sizeof(UUI_EventPageRewardItem) == 0x000518, "Wrong size on UUI_EventPageRewardItem");
static_assert(offsetof(UUI_EventPageRewardItem, RewardItem) == 0x0004F0, "Member 'UUI_EventPageRewardItem::RewardItem' has a wrong offset!");
static_assert(offsetof(UUI_EventPageRewardItem, _RewardItemData) == 0x0004F8, "Member 'UUI_EventPageRewardItem::_RewardItemData' has a wrong offset!");
static_assert(offsetof(UUI_EventPageRewardItem, _value) == 0x000510, "Member 'UUI_EventPageRewardItem::_value' has a wrong offset!");

// Class Stigma.UI_EventShopPopup
// 0x0000 (0x0570 - 0x0570)
class UUI_EventShopPopup final : public UPopupBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_EventShopPopup">();
	}
	static class UUI_EventShopPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_EventShopPopup>();
	}
};
static_assert(alignof(UUI_EventShopPopup) == 0x000008, "Wrong alignment on UUI_EventShopPopup");
static_assert(sizeof(UUI_EventShopPopup) == 0x000570, "Wrong size on UUI_EventShopPopup");

// Class Stigma.UI_FloatingGuide
// 0x0160 (0x0650 - 0x04F0)
class UUI_FloatingGuide : public UPreviewableWidget
{
public:
	uint8                                         Pad_2581[0x10];                                    // 0x04F0(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	struct FSlateBrush                            AreaIndicatorBrush;                                // 0x0500(0x00D0)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FVector2D                              _IndicatorSizeMargin;                              // 0x05D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinkedHelp                            LinkedHelp;                                        // 0x05E0(0x0038)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2582[0x38];                                    // 0x0618(0x0038)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UUI_FloatingGuide* ShowFloatingGuide(class UObject* _world_ctx, class FName _Name, class UWidget* _parent, TSubclassOf<class UUI_FloatingGuide> _Class, EFloatingGuidePosition _position, const struct FVector2D& _Space, TSubclassOf<class UUserWidget> _sub_widget_type, const class FText& _help_url, float _show_duration);

	bool OnInsertSubWidget(class UUserWidget* _widget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_FloatingGuide">();
	}
	static class UUI_FloatingGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_FloatingGuide>();
	}
};
static_assert(alignof(UUI_FloatingGuide) == 0x000010, "Wrong alignment on UUI_FloatingGuide");
static_assert(sizeof(UUI_FloatingGuide) == 0x000650, "Wrong size on UUI_FloatingGuide");
static_assert(offsetof(UUI_FloatingGuide, AreaIndicatorBrush) == 0x000500, "Member 'UUI_FloatingGuide::AreaIndicatorBrush' has a wrong offset!");
static_assert(offsetof(UUI_FloatingGuide, _IndicatorSizeMargin) == 0x0005D0, "Member 'UUI_FloatingGuide::_IndicatorSizeMargin' has a wrong offset!");
static_assert(offsetof(UUI_FloatingGuide, LinkedHelp) == 0x0005E0, "Member 'UUI_FloatingGuide::LinkedHelp' has a wrong offset!");

// Class Stigma.UI_NotifySlot
// 0x0028 (0x0518 - 0x04F0)
class UUI_NotifySlot : public UPreviewableWidget
{
public:
	class UOverlay*                               Ovl_BG;                                            // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_CommonButtonBase*                 Button;                                            // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2586[0x4];                                     // 0x0500(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         _LifeTime;                                         // 0x0504(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2587[0x8];                                     // 0x0508(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UUserProfile*                           _UserProfile;                                      // 0x0510(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DriveLifeTimeGauge(float _percent);
	void ForceFinish(bool _force_immediately);
	void ShowLifeTimeGauge(bool _show);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_NotifySlot">();
	}
	static class UUI_NotifySlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_NotifySlot>();
	}
};
static_assert(alignof(UUI_NotifySlot) == 0x000008, "Wrong alignment on UUI_NotifySlot");
static_assert(sizeof(UUI_NotifySlot) == 0x000518, "Wrong size on UUI_NotifySlot");
static_assert(offsetof(UUI_NotifySlot, Ovl_BG) == 0x0004F0, "Member 'UUI_NotifySlot::Ovl_BG' has a wrong offset!");
static_assert(offsetof(UUI_NotifySlot, Button) == 0x0004F8, "Member 'UUI_NotifySlot::Button' has a wrong offset!");
static_assert(offsetof(UUI_NotifySlot, _LifeTime) == 0x000504, "Member 'UUI_NotifySlot::_LifeTime' has a wrong offset!");
static_assert(offsetof(UUI_NotifySlot, _UserProfile) == 0x000510, "Member 'UUI_NotifySlot::_UserProfile' has a wrong offset!");

// Class Stigma.WIDGET_TutorialPointUI
// 0x0080 (0x05F0 - 0x0570)
class UWIDGET_TutorialPointUI : public UPopupBase
{
public:
	struct FVector2D                              _LeftTop;                                          // 0x0570(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              _RightBottom;                                      // 0x0580(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _GuideInput;                                       // 0x0590(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2588[0x7];                                     // 0x0591(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FKey                                   _GuideKey;                                         // 0x0598(0x0018)(Edit, BlueprintVisible, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2589[0x8];                                     // 0x05B0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UPreviewableWidget*                     _TargetWidget;                                     // 0x05B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_258A[0x30];                                    // 0x05C0(0x0030)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnUpdateArea();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WIDGET_TutorialPointUI">();
	}
	static class UWIDGET_TutorialPointUI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWIDGET_TutorialPointUI>();
	}
};
static_assert(alignof(UWIDGET_TutorialPointUI) == 0x000008, "Wrong alignment on UWIDGET_TutorialPointUI");
static_assert(sizeof(UWIDGET_TutorialPointUI) == 0x0005F0, "Wrong size on UWIDGET_TutorialPointUI");
static_assert(offsetof(UWIDGET_TutorialPointUI, _LeftTop) == 0x000570, "Member 'UWIDGET_TutorialPointUI::_LeftTop' has a wrong offset!");
static_assert(offsetof(UWIDGET_TutorialPointUI, _RightBottom) == 0x000580, "Member 'UWIDGET_TutorialPointUI::_RightBottom' has a wrong offset!");
static_assert(offsetof(UWIDGET_TutorialPointUI, _GuideInput) == 0x000590, "Member 'UWIDGET_TutorialPointUI::_GuideInput' has a wrong offset!");
static_assert(offsetof(UWIDGET_TutorialPointUI, _GuideKey) == 0x000598, "Member 'UWIDGET_TutorialPointUI::_GuideKey' has a wrong offset!");
static_assert(offsetof(UWIDGET_TutorialPointUI, _TargetWidget) == 0x0005B8, "Member 'UWIDGET_TutorialPointUI::_TargetWidget' has a wrong offset!");

// Class Stigma.UI_FriendNotifySlot
// 0x0000 (0x0518 - 0x0518)
class UUI_FriendNotifySlot : public UUI_NotifySlot
{
public:
	void SetText(const class FText& _text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_FriendNotifySlot">();
	}
	static class UUI_FriendNotifySlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_FriendNotifySlot>();
	}
};
static_assert(alignof(UUI_FriendNotifySlot) == 0x000008, "Wrong alignment on UUI_FriendNotifySlot");
static_assert(sizeof(UUI_FriendNotifySlot) == 0x000518, "Wrong size on UUI_FriendNotifySlot");

// Class Stigma.UI_GameNotify
// 0x0020 (0x0510 - 0x04F0)
class UUI_GameNotify : public UPreviewableWidget
{
public:
	class FText                                   _TextParam;                                        // 0x04F0(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	float                                         _LifeTime;                                         // 0x0508(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_258B[0x4];                                     // 0x050C(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void InitWidget(const class FText& _text, float _duration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_GameNotify">();
	}
	static class UUI_GameNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_GameNotify>();
	}
};
static_assert(alignof(UUI_GameNotify) == 0x000008, "Wrong alignment on UUI_GameNotify");
static_assert(sizeof(UUI_GameNotify) == 0x000510, "Wrong size on UUI_GameNotify");
static_assert(offsetof(UUI_GameNotify, _TextParam) == 0x0004F0, "Member 'UUI_GameNotify::_TextParam' has a wrong offset!");
static_assert(offsetof(UUI_GameNotify, _LifeTime) == 0x000508, "Member 'UUI_GameNotify::_LifeTime' has a wrong offset!");

// Class Stigma.UI_GameNotifyContainer
// 0x0060 (0x0550 - 0x04F0)
class UUI_GameNotifyContainer : public UPreviewableWidget
{
public:
	class UCanvasPanel*                           CanvasPanel;                                       // 0x04F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, class UUI_GameNotify*>      _NotifyWidgetMap;                                  // 0x04F8(0x0050)(ExportObject, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_258D[0x8];                                     // 0x0548(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_GameNotifyContainer">();
	}
	static class UUI_GameNotifyContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_GameNotifyContainer>();
	}
};
static_assert(alignof(UUI_GameNotifyContainer) == 0x000008, "Wrong alignment on UUI_GameNotifyContainer");
static_assert(sizeof(UUI_GameNotifyContainer) == 0x000550, "Wrong size on UUI_GameNotifyContainer");
static_assert(offsetof(UUI_GameNotifyContainer, CanvasPanel) == 0x0004F0, "Member 'UUI_GameNotifyContainer::CanvasPanel' has a wrong offset!");
static_assert(offsetof(UUI_GameNotifyContainer, _NotifyWidgetMap) == 0x0004F8, "Member 'UUI_GameNotifyContainer::_NotifyWidgetMap' has a wrong offset!");

// Class Stigma.UI_GameNotify_ContentUnlockerContainer
// 0x0040 (0x0550 - 0x0510)
class alignas(0x10) UUI_GameNotify_ContentUnlockerContainer : public UUI_GameNotify
{
public:
	class UVerticalBox*                           VerticalBox;                                       // 0x0510(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_ContentUnlocker>        _ContentUnlockerClass;                             // 0x0518(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _BottomPadding;                                    // 0x0520(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _QueueTime;                                        // 0x0524(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_258E[0x28];                                    // 0x0528(0x0028)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void CloseAllUnlockers(class UAnimatableWidget* _widget, bool _select);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_GameNotify_ContentUnlockerContainer">();
	}
	static class UUI_GameNotify_ContentUnlockerContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_GameNotify_ContentUnlockerContainer>();
	}
};
static_assert(alignof(UUI_GameNotify_ContentUnlockerContainer) == 0x000010, "Wrong alignment on UUI_GameNotify_ContentUnlockerContainer");
static_assert(sizeof(UUI_GameNotify_ContentUnlockerContainer) == 0x000550, "Wrong size on UUI_GameNotify_ContentUnlockerContainer");
static_assert(offsetof(UUI_GameNotify_ContentUnlockerContainer, VerticalBox) == 0x000510, "Member 'UUI_GameNotify_ContentUnlockerContainer::VerticalBox' has a wrong offset!");
static_assert(offsetof(UUI_GameNotify_ContentUnlockerContainer, _ContentUnlockerClass) == 0x000518, "Member 'UUI_GameNotify_ContentUnlockerContainer::_ContentUnlockerClass' has a wrong offset!");
static_assert(offsetof(UUI_GameNotify_ContentUnlockerContainer, _BottomPadding) == 0x000520, "Member 'UUI_GameNotify_ContentUnlockerContainer::_BottomPadding' has a wrong offset!");
static_assert(offsetof(UUI_GameNotify_ContentUnlockerContainer, _QueueTime) == 0x000524, "Member 'UUI_GameNotify_ContentUnlockerContainer::_QueueTime' has a wrong offset!");

// Class Stigma.UI_GameNotify_MissionSuccessContainer
// 0x0040 (0x0550 - 0x0510)
class alignas(0x10) UUI_GameNotify_MissionSuccessContainer : public UUI_GameNotify
{
public:
	class UOverlay*                               Overlay;                                           // 0x0510(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_MissionSuccessSlot>     _MissionSuccessSlotClass;                          // 0x0518(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _QueueTime;                                        // 0x0520(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2590[0x1C];                                    // 0x0524(0x001C)(Fixing Size After Last Property [ Dumper-69 ])
	class UUI_MissionSuccessSlot*                 _CurrentSlot;                                      // 0x0540(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2591[0x8];                                     // 0x0548(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_GameNotify_MissionSuccessContainer">();
	}
	static class UUI_GameNotify_MissionSuccessContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_GameNotify_MissionSuccessContainer>();
	}
};
static_assert(alignof(UUI_GameNotify_MissionSuccessContainer) == 0x000010, "Wrong alignment on UUI_GameNotify_MissionSuccessContainer");
static_assert(sizeof(UUI_GameNotify_MissionSuccessContainer) == 0x000550, "Wrong size on UUI_GameNotify_MissionSuccessContainer");
static_assert(offsetof(UUI_GameNotify_MissionSuccessContainer, Overlay) == 0x000510, "Member 'UUI_GameNotify_MissionSuccessContainer::Overlay' has a wrong offset!");
static_assert(offsetof(UUI_GameNotify_MissionSuccessContainer, _MissionSuccessSlotClass) == 0x000518, "Member 'UUI_GameNotify_MissionSuccessContainer::_MissionSuccessSlotClass' has a wrong offset!");
static_assert(offsetof(UUI_GameNotify_MissionSuccessContainer, _QueueTime) == 0x000520, "Member 'UUI_GameNotify_MissionSuccessContainer::_QueueTime' has a wrong offset!");
static_assert(offsetof(UUI_GameNotify_MissionSuccessContainer, _CurrentSlot) == 0x000540, "Member 'UUI_GameNotify_MissionSuccessContainer::_CurrentSlot' has a wrong offset!");

// Class Stigma.UI_GameResult_BackBase
// 0x0000 (0x04F0 - 0x04F0)
class UUI_GameResult_BackBase : public UPreviewableWidget
{
public:
	void InitWidget(ETeams _my_team, const struct FBattleDecisionDetail& _result);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_GameResult_BackBase">();
	}
	static class UUI_GameResult_BackBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_GameResult_BackBase>();
	}
};
static_assert(alignof(UUI_GameResult_BackBase) == 0x000008, "Wrong alignment on UUI_GameResult_BackBase");
static_assert(sizeof(UUI_GameResult_BackBase) == 0x0004F0, "Wrong size on UUI_GameResult_BackBase");

// Class Stigma.UI_GameResult_Report
// 0x0220 (0x0710 - 0x04F0)
class UUI_GameResult_Report : public UPreviewableWidget
{
public:
	class URichTextBlock*                         TXT_GameResult;                                    // 0x04F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_Result_UserLevel*                   Ctrl_Result_UserLevel;                             // 0x04F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_CommonTabPanel*                   TabPanel;                                          // 0x0500(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WS_TabContainer;                                   // 0x0508(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           Container_TeamResult;                              // 0x0510(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               OVL_TierInfo;                                      // 0x0518(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTileView*                              TILEVIEW_KillStreak;                               // 0x0520(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScrollBox*                             SCROLLBOX_Missions;                                // 0x0528(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_Result_Mission>         _ResultMissionClass;                               // 0x0530(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_TeamResultItem>         _TeamResultItemClass;                              // 0x0538(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FUserName                              _MyNickname;                                       // 0x0540(0x0018)(Edit, BlueprintVisible, Transient, EditConst, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETeams                                        _MyTeam;                                           // 0x0558(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2593[0x7];                                     // 0x0559(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FUserBattleResult                      _MyResult;                                         // 0x0560(0x0090)(Edit, BlueprintVisible, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FBattleDecisionDetail                  _result;                                           // 0x05F0(0x00D0)(Edit, BlueprintVisible, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FNetStatisticTier                      _MyTierInfo;                                       // 0x06C0(0x0050)(Edit, BlueprintVisible, Transient, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	void ChangeLevelToLobby();
	void InitMissions();
	struct FNetReply OnACK_GetUserTierInfo(EResultCode _rcode, const struct FACK_ReadUserTierInfo& _ack);
	void OnInit();
	void OnUpdateAttainmentUI();
	void SetDecision(ETeams _my_team, const struct FUserName& _my_nickname, const struct FBattleDecisionDetail& _decision);
	void UpdateUI();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_GameResult_Report">();
	}
	static class UUI_GameResult_Report* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_GameResult_Report>();
	}
};
static_assert(alignof(UUI_GameResult_Report) == 0x000008, "Wrong alignment on UUI_GameResult_Report");
static_assert(sizeof(UUI_GameResult_Report) == 0x000710, "Wrong size on UUI_GameResult_Report");
static_assert(offsetof(UUI_GameResult_Report, TXT_GameResult) == 0x0004F0, "Member 'UUI_GameResult_Report::TXT_GameResult' has a wrong offset!");
static_assert(offsetof(UUI_GameResult_Report, Ctrl_Result_UserLevel) == 0x0004F8, "Member 'UUI_GameResult_Report::Ctrl_Result_UserLevel' has a wrong offset!");
static_assert(offsetof(UUI_GameResult_Report, TabPanel) == 0x000500, "Member 'UUI_GameResult_Report::TabPanel' has a wrong offset!");
static_assert(offsetof(UUI_GameResult_Report, WS_TabContainer) == 0x000508, "Member 'UUI_GameResult_Report::WS_TabContainer' has a wrong offset!");
static_assert(offsetof(UUI_GameResult_Report, Container_TeamResult) == 0x000510, "Member 'UUI_GameResult_Report::Container_TeamResult' has a wrong offset!");
static_assert(offsetof(UUI_GameResult_Report, OVL_TierInfo) == 0x000518, "Member 'UUI_GameResult_Report::OVL_TierInfo' has a wrong offset!");
static_assert(offsetof(UUI_GameResult_Report, TILEVIEW_KillStreak) == 0x000520, "Member 'UUI_GameResult_Report::TILEVIEW_KillStreak' has a wrong offset!");
static_assert(offsetof(UUI_GameResult_Report, SCROLLBOX_Missions) == 0x000528, "Member 'UUI_GameResult_Report::SCROLLBOX_Missions' has a wrong offset!");
static_assert(offsetof(UUI_GameResult_Report, _ResultMissionClass) == 0x000530, "Member 'UUI_GameResult_Report::_ResultMissionClass' has a wrong offset!");
static_assert(offsetof(UUI_GameResult_Report, _TeamResultItemClass) == 0x000538, "Member 'UUI_GameResult_Report::_TeamResultItemClass' has a wrong offset!");
static_assert(offsetof(UUI_GameResult_Report, _MyNickname) == 0x000540, "Member 'UUI_GameResult_Report::_MyNickname' has a wrong offset!");
static_assert(offsetof(UUI_GameResult_Report, _MyTeam) == 0x000558, "Member 'UUI_GameResult_Report::_MyTeam' has a wrong offset!");
static_assert(offsetof(UUI_GameResult_Report, _MyResult) == 0x000560, "Member 'UUI_GameResult_Report::_MyResult' has a wrong offset!");
static_assert(offsetof(UUI_GameResult_Report, _result) == 0x0005F0, "Member 'UUI_GameResult_Report::_result' has a wrong offset!");
static_assert(offsetof(UUI_GameResult_Report, _MyTierInfo) == 0x0006C0, "Member 'UUI_GameResult_Report::_MyTierInfo' has a wrong offset!");

// Class Stigma.UI_GNB_LobbyBase
// 0x0008 (0x04F8 - 0x04F0)
class UUI_GNB_LobbyBase : public UPreviewableWidget
{
public:
	class UUI_CurrencyBoxList*                    CurrencyBoxListPanel;                              // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnUpdateUser(EUserEvent _event);
	void SetCurrencyBoxList(const TArray<struct FItemID_Currency>& _currency_ids, bool _use_wallet, bool _use_quick_purchase);
	void UpdateContext();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_GNB_LobbyBase">();
	}
	static class UUI_GNB_LobbyBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_GNB_LobbyBase>();
	}
};
static_assert(alignof(UUI_GNB_LobbyBase) == 0x000008, "Wrong alignment on UUI_GNB_LobbyBase");
static_assert(sizeof(UUI_GNB_LobbyBase) == 0x0004F8, "Wrong size on UUI_GNB_LobbyBase");
static_assert(offsetof(UUI_GNB_LobbyBase, CurrencyBoxListPanel) == 0x0004F0, "Member 'UUI_GNB_LobbyBase::CurrencyBoxListPanel' has a wrong offset!");

// Class Stigma.UI_GunCustomizePopupBase
// 0x0020 (0x0590 - 0x0570)
class UUI_GunCustomizePopupBase final : public UPopupBase
{
public:
	class UGunObject*                             _CurGunObject;                                     // 0x0570(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGunObject*                             _OriginGunObject;                                  // 0x0578(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<EGunType>                              SortedGunTypes;                                    // 0x0580(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void Init();
	void OnBeforeClose_CallBack(const class UPopupBase* _popup, class FName _ctrl_id);
	void SetGunType(EGunType _gun_type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_GunCustomizePopupBase">();
	}
	static class UUI_GunCustomizePopupBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_GunCustomizePopupBase>();
	}
};
static_assert(alignof(UUI_GunCustomizePopupBase) == 0x000008, "Wrong alignment on UUI_GunCustomizePopupBase");
static_assert(sizeof(UUI_GunCustomizePopupBase) == 0x000590, "Wrong size on UUI_GunCustomizePopupBase");
static_assert(offsetof(UUI_GunCustomizePopupBase, _CurGunObject) == 0x000570, "Member 'UUI_GunCustomizePopupBase::_CurGunObject' has a wrong offset!");
static_assert(offsetof(UUI_GunCustomizePopupBase, _OriginGunObject) == 0x000578, "Member 'UUI_GunCustomizePopupBase::_OriginGunObject' has a wrong offset!");
static_assert(offsetof(UUI_GunCustomizePopupBase, SortedGunTypes) == 0x000580, "Member 'UUI_GunCustomizePopupBase::SortedGunTypes' has a wrong offset!");

// Class Stigma.UI_GunListItem
// 0x0048 (0x0538 - 0x04F0)
class UUI_GunListItem : public UPreviewableWidget
{
public:
	uint8                                         Pad_2597[0x8];                                     // 0x04F0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UObject*                                IMG_Owned;                                         // 0x04F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                IMG_Unowned;                                       // 0x0500(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                IMG_Hovered;                                       // 0x0508(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObject*                                Img_Selected;                                      // 0x0510(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULVData_Gun*                            _ItemObject;                                       // 0x0518(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_Bg;                                            // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_DisplayName;                                   // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2598[0x8];                                     // 0x0530(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool IsSelection() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_GunListItem">();
	}
	static class UUI_GunListItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_GunListItem>();
	}
};
static_assert(alignof(UUI_GunListItem) == 0x000008, "Wrong alignment on UUI_GunListItem");
static_assert(sizeof(UUI_GunListItem) == 0x000538, "Wrong size on UUI_GunListItem");
static_assert(offsetof(UUI_GunListItem, IMG_Owned) == 0x0004F8, "Member 'UUI_GunListItem::IMG_Owned' has a wrong offset!");
static_assert(offsetof(UUI_GunListItem, IMG_Unowned) == 0x000500, "Member 'UUI_GunListItem::IMG_Unowned' has a wrong offset!");
static_assert(offsetof(UUI_GunListItem, IMG_Hovered) == 0x000508, "Member 'UUI_GunListItem::IMG_Hovered' has a wrong offset!");
static_assert(offsetof(UUI_GunListItem, Img_Selected) == 0x000510, "Member 'UUI_GunListItem::Img_Selected' has a wrong offset!");
static_assert(offsetof(UUI_GunListItem, _ItemObject) == 0x000518, "Member 'UUI_GunListItem::_ItemObject' has a wrong offset!");
static_assert(offsetof(UUI_GunListItem, IMG_Bg) == 0x000520, "Member 'UUI_GunListItem::IMG_Bg' has a wrong offset!");
static_assert(offsetof(UUI_GunListItem, TXT_DisplayName) == 0x000528, "Member 'UUI_GunListItem::TXT_DisplayName' has a wrong offset!");

// Class Stigma.UI_GunNPartsListViews
// 0x0128 (0x0618 - 0x04F0)
class UUI_GunNPartsListViews : public UPreviewableWidget
{
public:
	class UCtrl_CommonListView*                   _GunListView;                                      // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_CommonTileView*                   _GunPartsListView;                                 // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_Title;                                         // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_CommonButtonBase*                 Btn_CloseParts;                                    // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       GunToPartsAnimation;                               // 0x0510(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       PartsToGunAnimation;                               // 0x0518(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGunObject*                             _SelectedGunObject;                                // 0x0520(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULVData_GunParts*                       _SelectedGunPartsItem;                             // 0x0528(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<EGunType>                              _AllGunTypeItems;                                  // 0x0530(0x0010)(BlueprintVisible, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<class UInvenItem*>                     _AllGunPartsItems;                                 // 0x0540(0x0010)(BlueprintVisible, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<EGunType, class ULVData_Gun*>            _GunDataMap;                                       // 0x0550(0x0050)(BlueprintVisible, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<struct FItemID, class ULVData_GunParts*> _GunPartsDataMap;                                  // 0x05A0(0x0050)(BlueprintVisible, Transient, Protected, NativeAccessSpecifierProtected)
	class UUI_WeaponPage*                         _OwnerPage;                                        // 0x05F0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2599[0x20];                                    // 0x05F8(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void BuildGunPartsListView(EGunPartsSlot _gun_parts_slot, EGunType _gun_type, const struct FItemID& _selected_parts_id);
	void ChangeListView(bool _is_selecting_parts);
	void Init(class UObject* _owner, const struct FGunPreset& _selected_gun_preset);
	void OnClickCloseBtn(class UAnimatableWidget* _widget, bool _select);
	void RefreshGunListView(const struct FGunPreset& _selected_gun_preset);
	void SetSelectGun(class ULVData_Gun* _item, bool _from_ctrl);
	void SetSelectGunParts(class ULVData_GunParts* _item, bool _from_ctrl);
	void UpdatePartsListState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_GunNPartsListViews">();
	}
	static class UUI_GunNPartsListViews* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_GunNPartsListViews>();
	}
};
static_assert(alignof(UUI_GunNPartsListViews) == 0x000008, "Wrong alignment on UUI_GunNPartsListViews");
static_assert(sizeof(UUI_GunNPartsListViews) == 0x000618, "Wrong size on UUI_GunNPartsListViews");
static_assert(offsetof(UUI_GunNPartsListViews, _GunListView) == 0x0004F0, "Member 'UUI_GunNPartsListViews::_GunListView' has a wrong offset!");
static_assert(offsetof(UUI_GunNPartsListViews, _GunPartsListView) == 0x0004F8, "Member 'UUI_GunNPartsListViews::_GunPartsListView' has a wrong offset!");
static_assert(offsetof(UUI_GunNPartsListViews, Txt_Title) == 0x000500, "Member 'UUI_GunNPartsListViews::Txt_Title' has a wrong offset!");
static_assert(offsetof(UUI_GunNPartsListViews, Btn_CloseParts) == 0x000508, "Member 'UUI_GunNPartsListViews::Btn_CloseParts' has a wrong offset!");
static_assert(offsetof(UUI_GunNPartsListViews, GunToPartsAnimation) == 0x000510, "Member 'UUI_GunNPartsListViews::GunToPartsAnimation' has a wrong offset!");
static_assert(offsetof(UUI_GunNPartsListViews, PartsToGunAnimation) == 0x000518, "Member 'UUI_GunNPartsListViews::PartsToGunAnimation' has a wrong offset!");
static_assert(offsetof(UUI_GunNPartsListViews, _SelectedGunObject) == 0x000520, "Member 'UUI_GunNPartsListViews::_SelectedGunObject' has a wrong offset!");
static_assert(offsetof(UUI_GunNPartsListViews, _SelectedGunPartsItem) == 0x000528, "Member 'UUI_GunNPartsListViews::_SelectedGunPartsItem' has a wrong offset!");
static_assert(offsetof(UUI_GunNPartsListViews, _AllGunTypeItems) == 0x000530, "Member 'UUI_GunNPartsListViews::_AllGunTypeItems' has a wrong offset!");
static_assert(offsetof(UUI_GunNPartsListViews, _AllGunPartsItems) == 0x000540, "Member 'UUI_GunNPartsListViews::_AllGunPartsItems' has a wrong offset!");
static_assert(offsetof(UUI_GunNPartsListViews, _GunDataMap) == 0x000550, "Member 'UUI_GunNPartsListViews::_GunDataMap' has a wrong offset!");
static_assert(offsetof(UUI_GunNPartsListViews, _GunPartsDataMap) == 0x0005A0, "Member 'UUI_GunNPartsListViews::_GunPartsDataMap' has a wrong offset!");
static_assert(offsetof(UUI_GunNPartsListViews, _OwnerPage) == 0x0005F0, "Member 'UUI_GunNPartsListViews::_OwnerPage' has a wrong offset!");

// Class Stigma.UI_GunPartsListItem
// 0x00B8 (0x05A8 - 0x04F0)
class UUI_GunPartsListItem : public UPreviewableWidget
{
public:
	uint8                                         Pad_259E[0x8];                                     // 0x04F0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class ULVData_GunParts*                       _ItemData;                                         // 0x04F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInvenItem*                             _ItemObject;                                       // 0x0500(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGunObject*                             _DuplicatedGunObject;                              // 0x0508(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGunPartsSlot                                 _CurrentPartsSlot;                                 // 0x0510(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_259F[0x7];                                     // 0x0511(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UCtrl_ScrollTextBlock*                  TXT_DisplayName;                                   // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_ItemState;                                     // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Icon;                                          // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_ListItem_Border*                  Ctrl_ListItem_Border;                              // 0x0530(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EGunPartsSlot, TSoftObjectPtr<class UTexture2D>> _NullIcons;                                        // 0x0538(0x0050)(Edit, BlueprintVisible, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class FText                                   _NullText;                                         // 0x0588(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	bool                                          _ShowRedDot;                                       // 0x05A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25A0[0x7];                                     // 0x05A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void BindItem(EGunPartsSlot _current_slot, class UInvenItem* _item, class UGunObject* _current_gun_obj);
	void OnCheckBoxStateChanged(bool _is_checked);
	void SetSelection(bool _is_selected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_GunPartsListItem">();
	}
	static class UUI_GunPartsListItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_GunPartsListItem>();
	}
};
static_assert(alignof(UUI_GunPartsListItem) == 0x000008, "Wrong alignment on UUI_GunPartsListItem");
static_assert(sizeof(UUI_GunPartsListItem) == 0x0005A8, "Wrong size on UUI_GunPartsListItem");
static_assert(offsetof(UUI_GunPartsListItem, _ItemData) == 0x0004F8, "Member 'UUI_GunPartsListItem::_ItemData' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsListItem, _ItemObject) == 0x000500, "Member 'UUI_GunPartsListItem::_ItemObject' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsListItem, _DuplicatedGunObject) == 0x000508, "Member 'UUI_GunPartsListItem::_DuplicatedGunObject' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsListItem, _CurrentPartsSlot) == 0x000510, "Member 'UUI_GunPartsListItem::_CurrentPartsSlot' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsListItem, TXT_DisplayName) == 0x000518, "Member 'UUI_GunPartsListItem::TXT_DisplayName' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsListItem, Txt_ItemState) == 0x000520, "Member 'UUI_GunPartsListItem::Txt_ItemState' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsListItem, Img_Icon) == 0x000528, "Member 'UUI_GunPartsListItem::Img_Icon' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsListItem, Ctrl_ListItem_Border) == 0x000530, "Member 'UUI_GunPartsListItem::Ctrl_ListItem_Border' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsListItem, _NullIcons) == 0x000538, "Member 'UUI_GunPartsListItem::_NullIcons' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsListItem, _NullText) == 0x000588, "Member 'UUI_GunPartsListItem::_NullText' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsListItem, _ShowRedDot) == 0x0005A0, "Member 'UUI_GunPartsListItem::_ShowRedDot' has a wrong offset!");

// Class Stigma.UI_GunPartsSlot
// 0x00C0 (0x05B0 - 0x04F0)
class UUI_GunPartsSlot : public UPreviewableWidget
{
public:
	class UButton*                                BTN_GunCustom;                                     // 0x04F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Icon;                                          // 0x04F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_Unowned;                                       // 0x0500(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Ovl_PartsCount;                                    // 0x0508(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_PartsCount;                                    // 0x0510(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_ScrollTextBlock*                  Txt_PartsName;                                     // 0x0518(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_StatUpdate*                       Ctrl_StatUpdate;                                   // 0x0520(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_RemainDateTimer*                    UI_RemainDateTimer;                                // 0x0528(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_TutorialMissionGuide*               UI_TutorialMissionGuide;                           // 0x0530(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGunPartsSlot                                 _GunPartsSlot;                                     // 0x0538(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25A2[0x7];                                     // 0x0539(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UGunObject*                             _GunObject;                                        // 0x0540(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EGunPartsSlot, TSoftObjectPtr<class UTexture2D>> _UnEquipPartsIconMap;                              // 0x0548(0x0050)(Edit, BlueprintVisible, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_25A3[0x8];                                     // 0x0598(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             OnButtonClick;                                     // 0x05A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void BtnClicked();
	int32 GetAttachablePartsCount();
	ESlateVisibility GetVisibility_Img_RedDot();
	ESlateVisibility GetVisibility_IsUnOwned();
	void OnExpiredGunParts();
	void SetGunObject(class UGunObject* _gun_object, EGunPartsSlot _slot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_GunPartsSlot">();
	}
	static class UUI_GunPartsSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_GunPartsSlot>();
	}
};
static_assert(alignof(UUI_GunPartsSlot) == 0x000008, "Wrong alignment on UUI_GunPartsSlot");
static_assert(sizeof(UUI_GunPartsSlot) == 0x0005B0, "Wrong size on UUI_GunPartsSlot");
static_assert(offsetof(UUI_GunPartsSlot, BTN_GunCustom) == 0x0004F0, "Member 'UUI_GunPartsSlot::BTN_GunCustom' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsSlot, Img_Icon) == 0x0004F8, "Member 'UUI_GunPartsSlot::Img_Icon' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsSlot, IMG_Unowned) == 0x000500, "Member 'UUI_GunPartsSlot::IMG_Unowned' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsSlot, Ovl_PartsCount) == 0x000508, "Member 'UUI_GunPartsSlot::Ovl_PartsCount' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsSlot, Txt_PartsCount) == 0x000510, "Member 'UUI_GunPartsSlot::Txt_PartsCount' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsSlot, Txt_PartsName) == 0x000518, "Member 'UUI_GunPartsSlot::Txt_PartsName' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsSlot, Ctrl_StatUpdate) == 0x000520, "Member 'UUI_GunPartsSlot::Ctrl_StatUpdate' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsSlot, UI_RemainDateTimer) == 0x000528, "Member 'UUI_GunPartsSlot::UI_RemainDateTimer' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsSlot, UI_TutorialMissionGuide) == 0x000530, "Member 'UUI_GunPartsSlot::UI_TutorialMissionGuide' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsSlot, _GunPartsSlot) == 0x000538, "Member 'UUI_GunPartsSlot::_GunPartsSlot' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsSlot, _GunObject) == 0x000540, "Member 'UUI_GunPartsSlot::_GunObject' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsSlot, _UnEquipPartsIconMap) == 0x000548, "Member 'UUI_GunPartsSlot::_UnEquipPartsIconMap' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsSlot, OnButtonClick) == 0x0005A0, "Member 'UUI_GunPartsSlot::OnButtonClick' has a wrong offset!");

// Class Stigma.UI_GunPartsSlotAccessory
// 0x00A8 (0x0598 - 0x04F0)
class UUI_GunPartsSlotAccessory : public UPreviewableWidget
{
public:
	class UButton*                                BTN_GunCustom;                                     // 0x04F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Icon;                                          // 0x04F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_Unowned;                                       // 0x0500(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Ovl_PartsCount;                                    // 0x0508(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_PartsCount;                                    // 0x0510(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_StatUpdate*                       Ctrl_StatUpdate;                                   // 0x0518(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_RemainDateTimer*                    UI_RemainDateTimer;                                // 0x0520(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGunPartsSlot                                 _ParentPartsSlot;                                  // 0x0528(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGunPartsSlot                                 _MainPartsSlot;                                    // 0x0529(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25A5[0x6];                                     // 0x052A(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	class UGunObject*                             _GunObject;                                        // 0x0530(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EGunPartsSlot, TSoftObjectPtr<class UTexture2D>> _UnEquipAccessoryPartsIconMap;                     // 0x0538(0x0050)(Edit, BlueprintVisible, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnButtonClick;                                     // 0x0588(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void BtnClicked();
	ESlateVisibility GetVisibility_Img_RedDot();
	ESlateVisibility GetVisibility_IsUnOwned();
	void OnExpiredGunParts();
	void SetGunObject(class UGunObject* _gun_object, EGunPartsSlot _parent_slot, EGunPartsSlot _main_slot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_GunPartsSlotAccessory">();
	}
	static class UUI_GunPartsSlotAccessory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_GunPartsSlotAccessory>();
	}
};
static_assert(alignof(UUI_GunPartsSlotAccessory) == 0x000008, "Wrong alignment on UUI_GunPartsSlotAccessory");
static_assert(sizeof(UUI_GunPartsSlotAccessory) == 0x000598, "Wrong size on UUI_GunPartsSlotAccessory");
static_assert(offsetof(UUI_GunPartsSlotAccessory, BTN_GunCustom) == 0x0004F0, "Member 'UUI_GunPartsSlotAccessory::BTN_GunCustom' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsSlotAccessory, Img_Icon) == 0x0004F8, "Member 'UUI_GunPartsSlotAccessory::Img_Icon' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsSlotAccessory, IMG_Unowned) == 0x000500, "Member 'UUI_GunPartsSlotAccessory::IMG_Unowned' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsSlotAccessory, Ovl_PartsCount) == 0x000508, "Member 'UUI_GunPartsSlotAccessory::Ovl_PartsCount' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsSlotAccessory, Txt_PartsCount) == 0x000510, "Member 'UUI_GunPartsSlotAccessory::Txt_PartsCount' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsSlotAccessory, Ctrl_StatUpdate) == 0x000518, "Member 'UUI_GunPartsSlotAccessory::Ctrl_StatUpdate' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsSlotAccessory, UI_RemainDateTimer) == 0x000520, "Member 'UUI_GunPartsSlotAccessory::UI_RemainDateTimer' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsSlotAccessory, _ParentPartsSlot) == 0x000528, "Member 'UUI_GunPartsSlotAccessory::_ParentPartsSlot' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsSlotAccessory, _MainPartsSlot) == 0x000529, "Member 'UUI_GunPartsSlotAccessory::_MainPartsSlot' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsSlotAccessory, _GunObject) == 0x000530, "Member 'UUI_GunPartsSlotAccessory::_GunObject' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsSlotAccessory, _UnEquipAccessoryPartsIconMap) == 0x000538, "Member 'UUI_GunPartsSlotAccessory::_UnEquipAccessoryPartsIconMap' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsSlotAccessory, OnButtonClick) == 0x000588, "Member 'UUI_GunPartsSlotAccessory::OnButtonClick' has a wrong offset!");

// Class Stigma.UI_GunPartsSlotGroup
// 0x0048 (0x0538 - 0x04F0)
class UUI_GunPartsSlotGroup : public UPreviewableWidget
{
public:
	class UHorizontalBox*                         HB_AccessoryGroup;                                 // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_GunPartsSlot*                       SlotMain;                                          // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_GunPartsSlotAccessory>  _AccessoryWidgetClass;                             // 0x0500(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EGunPartsSlot                                 _MainPartsSlot;                                    // 0x0508(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25A7[0x7];                                     // 0x0509(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<EGunPartsSlot>                         _AccessoryPartsSlots;                              // 0x0510(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UGunObject*                             _GunObject;                                        // 0x0520(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnClickParts;                                      // 0x0528(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnClickPartsSlot(EGunPartsSlot _slot);
	void SetGunObject(class UGunObject* _gun_object);
	void UpdateAccessoryGroup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_GunPartsSlotGroup">();
	}
	static class UUI_GunPartsSlotGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_GunPartsSlotGroup>();
	}
};
static_assert(alignof(UUI_GunPartsSlotGroup) == 0x000008, "Wrong alignment on UUI_GunPartsSlotGroup");
static_assert(sizeof(UUI_GunPartsSlotGroup) == 0x000538, "Wrong size on UUI_GunPartsSlotGroup");
static_assert(offsetof(UUI_GunPartsSlotGroup, HB_AccessoryGroup) == 0x0004F0, "Member 'UUI_GunPartsSlotGroup::HB_AccessoryGroup' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsSlotGroup, SlotMain) == 0x0004F8, "Member 'UUI_GunPartsSlotGroup::SlotMain' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsSlotGroup, _AccessoryWidgetClass) == 0x000500, "Member 'UUI_GunPartsSlotGroup::_AccessoryWidgetClass' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsSlotGroup, _MainPartsSlot) == 0x000508, "Member 'UUI_GunPartsSlotGroup::_MainPartsSlot' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsSlotGroup, _AccessoryPartsSlots) == 0x000510, "Member 'UUI_GunPartsSlotGroup::_AccessoryPartsSlots' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsSlotGroup, _GunObject) == 0x000520, "Member 'UUI_GunPartsSlotGroup::_GunObject' has a wrong offset!");
static_assert(offsetof(UUI_GunPartsSlotGroup, OnClickParts) == 0x000528, "Member 'UUI_GunPartsSlotGroup::OnClickParts' has a wrong offset!");

// Class Stigma.UI_GunPresetEditor
// 0x0000 (0x04F0 - 0x04F0)
class UUI_GunPresetEditor : public UPreviewableWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_GunPresetEditor">();
	}
	static class UUI_GunPresetEditor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_GunPresetEditor>();
	}
};
static_assert(alignof(UUI_GunPresetEditor) == 0x000008, "Wrong alignment on UUI_GunPresetEditor");
static_assert(sizeof(UUI_GunPresetEditor) == 0x0004F0, "Wrong size on UUI_GunPresetEditor");

// Class Stigma.UI_TDM_SubScore
// 0x0018 (0x0508 - 0x04F0)
class UUI_TDM_SubScore : public UPreviewableWidget
{
public:
	class UUI_TDM_SubScoreContainer*              Container_MyTeam;                                  // 0x04F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_TDM_SubScoreContainer*              Container_EnemyTeam;                               // 0x04F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25A8[0x8];                                     // 0x0500(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_TDM_SubScore">();
	}
	static class UUI_TDM_SubScore* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_TDM_SubScore>();
	}
};
static_assert(alignof(UUI_TDM_SubScore) == 0x000008, "Wrong alignment on UUI_TDM_SubScore");
static_assert(sizeof(UUI_TDM_SubScore) == 0x000508, "Wrong size on UUI_TDM_SubScore");
static_assert(offsetof(UUI_TDM_SubScore, Container_MyTeam) == 0x0004F0, "Member 'UUI_TDM_SubScore::Container_MyTeam' has a wrong offset!");
static_assert(offsetof(UUI_TDM_SubScore, Container_EnemyTeam) == 0x0004F8, "Member 'UUI_TDM_SubScore::Container_EnemyTeam' has a wrong offset!");

// Class Stigma.UI_GunPresetItem
// 0x0040 (0x0530 - 0x04F0)
class UUI_GunPresetItem : public UPreviewableWidget
{
public:
	class UButton*                                Btn_Main;                                          // 0x04F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGunObject*                             _GunObject;                                        // 0x04F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _MasterIdx;                                        // 0x0500(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _ControlPowerLack;                                 // 0x0504(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECharaType                                    _MasterCharaType;                                  // 0x0508(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25A9[0x7];                                     // 0x0509(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	FMulticastInlineDelegateProperty_             OnChangedHovered;                                  // 0x0510(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSelectGun;                                       // 0x0520(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void BtnClicked();
	void BtnHovered();
	void BtnUnHovered();
	struct FNetReply OnAck_SetGunType(EResultCode _rcode, const struct FApiResult& _ack);
	void UpdateUI();

	bool CanEquipGun() const;
	bool IsSelectedItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_GunPresetItem">();
	}
	static class UUI_GunPresetItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_GunPresetItem>();
	}
};
static_assert(alignof(UUI_GunPresetItem) == 0x000008, "Wrong alignment on UUI_GunPresetItem");
static_assert(sizeof(UUI_GunPresetItem) == 0x000530, "Wrong size on UUI_GunPresetItem");
static_assert(offsetof(UUI_GunPresetItem, Btn_Main) == 0x0004F0, "Member 'UUI_GunPresetItem::Btn_Main' has a wrong offset!");
static_assert(offsetof(UUI_GunPresetItem, _GunObject) == 0x0004F8, "Member 'UUI_GunPresetItem::_GunObject' has a wrong offset!");
static_assert(offsetof(UUI_GunPresetItem, _MasterIdx) == 0x000500, "Member 'UUI_GunPresetItem::_MasterIdx' has a wrong offset!");
static_assert(offsetof(UUI_GunPresetItem, _ControlPowerLack) == 0x000504, "Member 'UUI_GunPresetItem::_ControlPowerLack' has a wrong offset!");
static_assert(offsetof(UUI_GunPresetItem, _MasterCharaType) == 0x000508, "Member 'UUI_GunPresetItem::_MasterCharaType' has a wrong offset!");
static_assert(offsetof(UUI_GunPresetItem, OnChangedHovered) == 0x000510, "Member 'UUI_GunPresetItem::OnChangedHovered' has a wrong offset!");
static_assert(offsetof(UUI_GunPresetItem, OnSelectGun) == 0x000520, "Member 'UUI_GunPresetItem::OnSelectGun' has a wrong offset!");

// Class Stigma.UI_PreviewBase
// 0x0048 (0x0538 - 0x04F0)
class UUI_PreviewBase : public UPreviewableWidget
{
public:
	uint8                                         Pad_25AC[0x8];                                     // 0x04F0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class ULevelStreamingDynamic*                 _SubLevel;                                         // 0x04F8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AFollowCameraActor*                     _cam;                                              // 0x0500(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 _PreviewActor;                                     // 0x0508(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         _CamBlending;                                      // 0x0510(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25AD[0x4];                                     // 0x0514(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FRotator                               _PreviewActorInitialRot;                           // 0x0518(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         _PreviewCamInitialDist;                            // 0x0530(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25AE[0x4];                                     // 0x0534(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ActivateSubLevel(bool _activate);
	void OnSubLevelHidden();
	void OnSubLevelShown();
	void SetPreviewCam(const class FName& _tag, class AActor* _target);

	bool IsSubLevelActived() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_PreviewBase">();
	}
	static class UUI_PreviewBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_PreviewBase>();
	}
};
static_assert(alignof(UUI_PreviewBase) == 0x000008, "Wrong alignment on UUI_PreviewBase");
static_assert(sizeof(UUI_PreviewBase) == 0x000538, "Wrong size on UUI_PreviewBase");
static_assert(offsetof(UUI_PreviewBase, _SubLevel) == 0x0004F8, "Member 'UUI_PreviewBase::_SubLevel' has a wrong offset!");
static_assert(offsetof(UUI_PreviewBase, _cam) == 0x000500, "Member 'UUI_PreviewBase::_cam' has a wrong offset!");
static_assert(offsetof(UUI_PreviewBase, _PreviewActor) == 0x000508, "Member 'UUI_PreviewBase::_PreviewActor' has a wrong offset!");
static_assert(offsetof(UUI_PreviewBase, _CamBlending) == 0x000510, "Member 'UUI_PreviewBase::_CamBlending' has a wrong offset!");
static_assert(offsetof(UUI_PreviewBase, _PreviewActorInitialRot) == 0x000518, "Member 'UUI_PreviewBase::_PreviewActorInitialRot' has a wrong offset!");
static_assert(offsetof(UUI_PreviewBase, _PreviewCamInitialDist) == 0x000530, "Member 'UUI_PreviewBase::_PreviewCamInitialDist' has a wrong offset!");

// Class Stigma.UI_GunPreview
// 0x0038 (0x0570 - 0x0538)
class UUI_GunPreview : public UUI_PreviewBase
{
public:
	uint8                                         Pad_25AF[0x18];                                    // 0x0538(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	class FName                                   _CamTag_Gun;                                       // 0x0550(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APreviewActor*                          _LobbyGunPreviewer;                                // 0x0558(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class APreviewActor>              _LobbyGunPreviewerClass;                           // 0x0560(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25B0[0x8];                                     // 0x0568(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void AllowRotationMode(bool _allow);
	void RegisterOnSubLevelShown(const TDelegate<void()>& _callback);
	void SetGunPreviewer(class UGunObject* _gun_obj);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_GunPreview">();
	}
	static class UUI_GunPreview* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_GunPreview>();
	}
};
static_assert(alignof(UUI_GunPreview) == 0x000008, "Wrong alignment on UUI_GunPreview");
static_assert(sizeof(UUI_GunPreview) == 0x000570, "Wrong size on UUI_GunPreview");
static_assert(offsetof(UUI_GunPreview, _CamTag_Gun) == 0x000550, "Member 'UUI_GunPreview::_CamTag_Gun' has a wrong offset!");
static_assert(offsetof(UUI_GunPreview, _LobbyGunPreviewer) == 0x000558, "Member 'UUI_GunPreview::_LobbyGunPreviewer' has a wrong offset!");
static_assert(offsetof(UUI_GunPreview, _LobbyGunPreviewerClass) == 0x000560, "Member 'UUI_GunPreview::_LobbyGunPreviewerClass' has a wrong offset!");

// Class Stigma.UI_HelpDesc
// 0x0010 (0x02D0 - 0x02C0)
class UUI_HelpDesc : public UUserWidget
{
public:
	class UTextBlock*                             Txt_Title;                                         // 0x02C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Desc;                                          // 0x02C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_HelpDesc">();
	}
	static class UUI_HelpDesc* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_HelpDesc>();
	}
};
static_assert(alignof(UUI_HelpDesc) == 0x000008, "Wrong alignment on UUI_HelpDesc");
static_assert(sizeof(UUI_HelpDesc) == 0x0002D0, "Wrong size on UUI_HelpDesc");
static_assert(offsetof(UUI_HelpDesc, Txt_Title) == 0x0002C0, "Member 'UUI_HelpDesc::Txt_Title' has a wrong offset!");
static_assert(offsetof(UUI_HelpDesc, TXT_Desc) == 0x0002C8, "Member 'UUI_HelpDesc::TXT_Desc' has a wrong offset!");

// Class Stigma.UI_HelpMenu
// 0x0088 (0x0348 - 0x02C0)
class UUI_HelpMenu : public UUserWidget
{
public:
	uint8                                         Pad_25B1[0x8];                                     // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class URichTextBlock*                         Txt_Title;                                         // 0x02C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USpacer*                                SPACER_Title;                                      // 0x02D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        SWITCHER_Background;                               // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EHelpMenuStateType, struct FSlateColor>  _MenuTextColors;                                   // 0x02E0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UHelpMenuItemData*                      _MenuItemData;                                     // 0x0330(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25B2[0x10];                                    // 0x0338(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void UpdateMenuState();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_HelpMenu">();
	}
	static class UUI_HelpMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_HelpMenu>();
	}
};
static_assert(alignof(UUI_HelpMenu) == 0x000008, "Wrong alignment on UUI_HelpMenu");
static_assert(sizeof(UUI_HelpMenu) == 0x000348, "Wrong size on UUI_HelpMenu");
static_assert(offsetof(UUI_HelpMenu, Txt_Title) == 0x0002C8, "Member 'UUI_HelpMenu::Txt_Title' has a wrong offset!");
static_assert(offsetof(UUI_HelpMenu, SPACER_Title) == 0x0002D0, "Member 'UUI_HelpMenu::SPACER_Title' has a wrong offset!");
static_assert(offsetof(UUI_HelpMenu, SWITCHER_Background) == 0x0002D8, "Member 'UUI_HelpMenu::SWITCHER_Background' has a wrong offset!");
static_assert(offsetof(UUI_HelpMenu, _MenuTextColors) == 0x0002E0, "Member 'UUI_HelpMenu::_MenuTextColors' has a wrong offset!");
static_assert(offsetof(UUI_HelpMenu, _MenuItemData) == 0x000330, "Member 'UUI_HelpMenu::_MenuItemData' has a wrong offset!");

// Class Stigma.UI_HelpPopup
// 0x0250 (0x07C0 - 0x0570)
class UUI_HelpPopup : public UPopupBase
{
public:
	class UMediaPlayer*                           _MediaPlayer;                                      // 0x0570(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMediaTexture*                          _MediaTexture;                                     // 0x0578(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     _MatMovie;                                         // 0x0580(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_HelpDesc>               _HelpDescWidgetClass;                              // 0x0588(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_Title;                                         // 0x0590(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        SWITCHER_Contents;                                 // 0x0598(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_MovieTexture;                                  // 0x05A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_Texture;                                       // 0x05A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VERT_ContentsBox;                                  // 0x05B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTreeView*                              TREEVIEW_Menu;                                     // 0x05B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_SearchHint;                                    // 0x05C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                BTN_ClearSearch;                                   // 0x05C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                BTN_Search;                                        // 0x05D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEditableText*                          INPUT_Search;                                      // 0x05D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUI_HelpDesc*>                   _ContentsList;                                     // 0x05E0(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, class UHelpMenuItemData*> _OriginalCategoryMenuData;                         // 0x05F0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, struct FHelpContentsMenuItemData> _OriginalContentsMenuData;                         // 0x0640(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, class UHelpMenuItemData*> _FilteredCategoryMenuData;                         // 0x0690(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, struct FHelpContentsMenuItemData> _FilteredContentsMenuData;                         // 0x06E0(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class FString, struct FHelpContent>      _HelpConfigs;                                      // 0x0730(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	class UMaterialInstanceDynamic*               _MatInstMovie;                                     // 0x0780(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25B3[0x38];                                    // 0x0788(0x0038)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	class UUserWidget* GetCategoryMenuWidget(const class FString& _category);
	class UUserWidget* GetContentsMenuWidget(const class FString& _contents_key);
	void OnClickClearSearch();
	void OnClickSearch();
	void OnTextChangedSearch(const class FText& _text);
	void OnTextCommittedSearch(const class FText& _text, ETextCommit _type);
	void UpdateContents(const class FString& _contents_key);
	void UpdateMenuWidgetStates();
	void UpdateTargetTreeViewMenu(const class FString& _contents_key);
	void UpdateTreeViewFilteredMenu(const class FText& _filtered_text);
	void UpdateTreeViewMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_HelpPopup">();
	}
	static class UUI_HelpPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_HelpPopup>();
	}
};
static_assert(alignof(UUI_HelpPopup) == 0x000008, "Wrong alignment on UUI_HelpPopup");
static_assert(sizeof(UUI_HelpPopup) == 0x0007C0, "Wrong size on UUI_HelpPopup");
static_assert(offsetof(UUI_HelpPopup, _MediaPlayer) == 0x000570, "Member 'UUI_HelpPopup::_MediaPlayer' has a wrong offset!");
static_assert(offsetof(UUI_HelpPopup, _MediaTexture) == 0x000578, "Member 'UUI_HelpPopup::_MediaTexture' has a wrong offset!");
static_assert(offsetof(UUI_HelpPopup, _MatMovie) == 0x000580, "Member 'UUI_HelpPopup::_MatMovie' has a wrong offset!");
static_assert(offsetof(UUI_HelpPopup, _HelpDescWidgetClass) == 0x000588, "Member 'UUI_HelpPopup::_HelpDescWidgetClass' has a wrong offset!");
static_assert(offsetof(UUI_HelpPopup, Txt_Title) == 0x000590, "Member 'UUI_HelpPopup::Txt_Title' has a wrong offset!");
static_assert(offsetof(UUI_HelpPopup, SWITCHER_Contents) == 0x000598, "Member 'UUI_HelpPopup::SWITCHER_Contents' has a wrong offset!");
static_assert(offsetof(UUI_HelpPopup, IMG_MovieTexture) == 0x0005A0, "Member 'UUI_HelpPopup::IMG_MovieTexture' has a wrong offset!");
static_assert(offsetof(UUI_HelpPopup, IMG_Texture) == 0x0005A8, "Member 'UUI_HelpPopup::IMG_Texture' has a wrong offset!");
static_assert(offsetof(UUI_HelpPopup, VERT_ContentsBox) == 0x0005B0, "Member 'UUI_HelpPopup::VERT_ContentsBox' has a wrong offset!");
static_assert(offsetof(UUI_HelpPopup, TREEVIEW_Menu) == 0x0005B8, "Member 'UUI_HelpPopup::TREEVIEW_Menu' has a wrong offset!");
static_assert(offsetof(UUI_HelpPopup, TXT_SearchHint) == 0x0005C0, "Member 'UUI_HelpPopup::TXT_SearchHint' has a wrong offset!");
static_assert(offsetof(UUI_HelpPopup, BTN_ClearSearch) == 0x0005C8, "Member 'UUI_HelpPopup::BTN_ClearSearch' has a wrong offset!");
static_assert(offsetof(UUI_HelpPopup, BTN_Search) == 0x0005D0, "Member 'UUI_HelpPopup::BTN_Search' has a wrong offset!");
static_assert(offsetof(UUI_HelpPopup, INPUT_Search) == 0x0005D8, "Member 'UUI_HelpPopup::INPUT_Search' has a wrong offset!");
static_assert(offsetof(UUI_HelpPopup, _ContentsList) == 0x0005E0, "Member 'UUI_HelpPopup::_ContentsList' has a wrong offset!");
static_assert(offsetof(UUI_HelpPopup, _OriginalCategoryMenuData) == 0x0005F0, "Member 'UUI_HelpPopup::_OriginalCategoryMenuData' has a wrong offset!");
static_assert(offsetof(UUI_HelpPopup, _OriginalContentsMenuData) == 0x000640, "Member 'UUI_HelpPopup::_OriginalContentsMenuData' has a wrong offset!");
static_assert(offsetof(UUI_HelpPopup, _FilteredCategoryMenuData) == 0x000690, "Member 'UUI_HelpPopup::_FilteredCategoryMenuData' has a wrong offset!");
static_assert(offsetof(UUI_HelpPopup, _FilteredContentsMenuData) == 0x0006E0, "Member 'UUI_HelpPopup::_FilteredContentsMenuData' has a wrong offset!");
static_assert(offsetof(UUI_HelpPopup, _HelpConfigs) == 0x000730, "Member 'UUI_HelpPopup::_HelpConfigs' has a wrong offset!");
static_assert(offsetof(UUI_HelpPopup, _MatInstMovie) == 0x000780, "Member 'UUI_HelpPopup::_MatInstMovie' has a wrong offset!");

// Class Stigma.UI_HoverMenuWidget
// 0x0060 (0x0550 - 0x04F0)
class UUI_HoverMenuWidget : public UPreviewableWidget
{
public:
	struct FHoverMenuEntry                        _entry;                                            // 0x04F0(0x0058)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)
	bool                                          _IsOdd;                                            // 0x0548(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25B5[0x7];                                     // 0x0549(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool Init(const struct FHoverMenuEntry& _menu_entry, bool _is_odd);

	class FName GetID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_HoverMenuWidget">();
	}
	static class UUI_HoverMenuWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_HoverMenuWidget>();
	}
};
static_assert(alignof(UUI_HoverMenuWidget) == 0x000008, "Wrong alignment on UUI_HoverMenuWidget");
static_assert(sizeof(UUI_HoverMenuWidget) == 0x000550, "Wrong size on UUI_HoverMenuWidget");
static_assert(offsetof(UUI_HoverMenuWidget, _entry) == 0x0004F0, "Member 'UUI_HoverMenuWidget::_entry' has a wrong offset!");
static_assert(offsetof(UUI_HoverMenuWidget, _IsOdd) == 0x000548, "Member 'UUI_HoverMenuWidget::_IsOdd' has a wrong offset!");

// Class Stigma.UI_ToastMessageContainerBase
// 0x0030 (0x0520 - 0x04F0)
class UUI_ToastMessageContainerBase : public UPreviewableWidget
{
public:
	class UVerticalBox*                           Container;                                         // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_ToastMessageBase*                   ToastMsg_0;                                        // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_ToastMessageBase*                   ToastMsg_1;                                        // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_ToastMessageBase*                   ToastMsg_2;                                        // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUI_ToastMessageBase*>           _InactiveToastMsgList;                             // 0x0510(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	bool AddSimpleToast(const class FString& _msg);
	int32 GetRestToastCount();
	void Init();
	void OnToastInactived(class UAnimatableWidget* _widget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_ToastMessageContainerBase">();
	}
	static class UUI_ToastMessageContainerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_ToastMessageContainerBase>();
	}
};
static_assert(alignof(UUI_ToastMessageContainerBase) == 0x000008, "Wrong alignment on UUI_ToastMessageContainerBase");
static_assert(sizeof(UUI_ToastMessageContainerBase) == 0x000520, "Wrong size on UUI_ToastMessageContainerBase");
static_assert(offsetof(UUI_ToastMessageContainerBase, Container) == 0x0004F0, "Member 'UUI_ToastMessageContainerBase::Container' has a wrong offset!");
static_assert(offsetof(UUI_ToastMessageContainerBase, ToastMsg_0) == 0x0004F8, "Member 'UUI_ToastMessageContainerBase::ToastMsg_0' has a wrong offset!");
static_assert(offsetof(UUI_ToastMessageContainerBase, ToastMsg_1) == 0x000500, "Member 'UUI_ToastMessageContainerBase::ToastMsg_1' has a wrong offset!");
static_assert(offsetof(UUI_ToastMessageContainerBase, ToastMsg_2) == 0x000508, "Member 'UUI_ToastMessageContainerBase::ToastMsg_2' has a wrong offset!");
static_assert(offsetof(UUI_ToastMessageContainerBase, _InactiveToastMsgList) == 0x000510, "Member 'UUI_ToastMessageContainerBase::_InactiveToastMsgList' has a wrong offset!");

// Class Stigma.UI_HoverMenuBase
// 0x0088 (0x0578 - 0x04F0)
class UUI_HoverMenuBase : public UPreviewableWidget
{
public:
	class UVerticalBox*                           MenuContainer;                                     // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_HoverMenuWidget>        _EntryWidgetClass;                                 // 0x04F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FHoverMenuEntry>                _MenuEntries;                                      // 0x0500(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, ExposeOnSpawn, NativeAccessSpecifierProtected)
	TMap<class FName, class UUI_HoverMenuWidget*> _EntryMap;                                         // 0x0510(0x0050)(ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	class UObject*                                _referer;                                          // 0x0560(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             OnEntryKeyBoardInput;                              // 0x0568(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	bool Init();
	void SetMenuText(class FName _id, const class FText& _text);
	void SetMenuVisibility(class FName _id, bool _show);
	void Setup(const TArray<struct FHoverMenuEntry>& _setting);
	void SetupWithReferer(const TArray<struct FHoverMenuEntry>& _setting, class UObject* _refer_obj);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_HoverMenuBase">();
	}
	static class UUI_HoverMenuBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_HoverMenuBase>();
	}
};
static_assert(alignof(UUI_HoverMenuBase) == 0x000008, "Wrong alignment on UUI_HoverMenuBase");
static_assert(sizeof(UUI_HoverMenuBase) == 0x000578, "Wrong size on UUI_HoverMenuBase");
static_assert(offsetof(UUI_HoverMenuBase, MenuContainer) == 0x0004F0, "Member 'UUI_HoverMenuBase::MenuContainer' has a wrong offset!");
static_assert(offsetof(UUI_HoverMenuBase, _EntryWidgetClass) == 0x0004F8, "Member 'UUI_HoverMenuBase::_EntryWidgetClass' has a wrong offset!");
static_assert(offsetof(UUI_HoverMenuBase, _MenuEntries) == 0x000500, "Member 'UUI_HoverMenuBase::_MenuEntries' has a wrong offset!");
static_assert(offsetof(UUI_HoverMenuBase, _EntryMap) == 0x000510, "Member 'UUI_HoverMenuBase::_EntryMap' has a wrong offset!");
static_assert(offsetof(UUI_HoverMenuBase, _referer) == 0x000560, "Member 'UUI_HoverMenuBase::_referer' has a wrong offset!");
static_assert(offsetof(UUI_HoverMenuBase, OnEntryKeyBoardInput) == 0x000568, "Member 'UUI_HoverMenuBase::OnEntryKeyBoardInput' has a wrong offset!");

// Class Stigma.UI_HTMLHelpViewer
// 0x0000 (0x0570 - 0x0570)
class UUI_HTMLHelpViewer : public UPopupBase
{
public:
	bool OpenHelp(const class FText& _url);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_HTMLHelpViewer">();
	}
	static class UUI_HTMLHelpViewer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_HTMLHelpViewer>();
	}
};
static_assert(alignof(UUI_HTMLHelpViewer) == 0x000008, "Wrong alignment on UUI_HTMLHelpViewer");
static_assert(sizeof(UUI_HTMLHelpViewer) == 0x000570, "Wrong size on UUI_HTMLHelpViewer");

// Class Stigma.UI_HUDBase
// 0x07E8 (0x0CD8 - 0x04F0)
class UUI_HUDBase : public UPreviewableWidget
{
public:
	struct FConfig_Game                           _GameConfig;                                       // 0x04F0(0x0560)(Protected, NativeAccessSpecifierProtected)
	class ACharaBase*                             _TargetChara;                                      // 0x0A50(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _deviation;                                        // 0x0A58(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _hp;                                               // 0x0A5C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _MaxHP;                                            // 0x0A60(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _Armor;                                            // 0x0A64(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _RecoveryHP;                                       // 0x0A68(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25BA[0x4];                                     // 0x0A6C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UHUD_CrossHair*                         HUD_CrossHair;                                     // 0x0A70(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHUD_HpProgress*                        HUD_HpProgress;                                    // 0x0A78(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHUD_CooldownBaseSlotPanel*             UI_HUD_SkillSlotList;                              // 0x0A80(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHUD_CooldownBaseSlotPanel*             UI_HUD_BoosterSlotList;                            // 0x0A88(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHUD_GunPanel*                          HUD_GunPanel;                                      // 0x0A90(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUI_DamageIndicator>        _DamageIndicatorWidgetClass;                       // 0x0A98(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_DamageIndicator>        _DamageFXWidgetClass;                              // 0x0AA0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class ACharaBase*, struct FDamageIndicator> _DamageIndicators;                                 // 0x0AA8(0x0050)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_25BB[0x8];                                     // 0x0AF8(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UHUD_Blood*                             HUD_Blood;                                         // 0x0B00(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, struct FGameNotifyInfo>     _HUD_GameNotiInfos;                                // 0x0B08(0x0050)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_25BC[0xF4];                                    // 0x0B58(0x00F4)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         _StreakDuration;                                   // 0x0C4C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsShowKillStreak_DEBUG;                           // 0x0C50(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _IsShowFloatingHit_DEBUG;                          // 0x0C51(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25BD[0x1E];                                    // 0x0C52(0x001E)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UUI_DamageViewer>           _DamageViewerClass;                                // 0x0C70(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FDamageViewer>                  _DamageViewers;                                    // 0x0C78(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_25BE[0x8];                                     // 0x0C88(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          _IsShowEnemyDamageMode;                            // 0x0C90(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25BF[0x7];                                     // 0x0C91(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UUI_HUDMode*                            _HUDMode;                                          // 0x0C98(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               FullScreen_Slot;                                   // 0x0CA0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_ChatBox*                            ChatBox;                                           // 0x0CA8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHUD_ScopePanel*                        HUD_ScopePanel;                                    // 0x0CB0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHUD_KillAssistTag*                     UI_KillTag;                                        // 0x0CB8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHUD_KillAssistTag*                     UI_AssistTag;                                      // 0x0CC0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHUD_KillerInfoCard*                    UI_KillerInfoCard;                                 // 0x0CC8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_RoundCountDown*                     UI_RoundCountDown;                                 // 0x0CD0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool AddActionLog_Bounty(const struct FActionLog_Bounty& _log);
	void AddChat(const struct FChatMsg& _chat_msg);
	void AddFullScreenWidget(class UWidget* _widget);
	bool AddHitData(const struct FHitData& _hit);
	bool AddKillLog(const struct FKillLog& _log);
	bool AddKillLog_Revive(const struct FKillLog_ForRevive& _log);
	void BindTargetChara(class ACharaBase* _chara);
	bool OnBindTargetChara(class ACharaBase* _chara);
	bool OnChangeActionSetting();
	bool OnChangeGun(class AGunBase* _old_gun, class AGunBase* _new_gun);
	bool OnChangeLinkedSkillKeyGuide(const struct FLinkedSkillGuide& _Key);
	class UUserWidget* OnCreateFloatingHitMessageWidget(EAbnormal _abnormal);
	bool OnDiscoverEnemy(class ACharaBase* _enemy, bool _discovered);
	void OnGetIngameMoney(int32 _inc_money, EGoldRewardType _reward_type);
	bool OnPointingActor(class AActor* _Actor);
	bool OnReloadEnd(class AGunBase* _gun, bool _is_cancel);
	bool OnReloadStart(class AGunBase* _gun);
	bool OnShowKillStreak(bool _show, const struct FKillStreakDefine& _streak);
	void OnStartChat();
	bool OnTargetCharaIsKilled(class ACharaBase* _killer);
	bool OnTargetCharaIsRespawned();
	bool OnUpdateKillStreakAlpha(float _t);
	void OnUseAutoBooster(bool _is_used);
	void RemoveFullScreenWidget(class UWidget* _widget);
	bool Reset();
	void SelectRadioChatCategory(int32 _idx);
	void SelectRadioChatListItem(int32 _idx);
	void SetChatBox(class UUI_ChatBox* _chat_box);
	void SetHUDMode(class UUI_HUDMode* _hud_mode);
	bool SetInteractionProgressBar(bool _visibility, float _duration);
	void SetShowEnemyDamageMode(bool _show_enemy_damage);
	bool ShowLoadingThrobber(bool _show);
	void TestShot(class AGunBase* _gun);
	void ToggleRadioChat();
	void ToggleSpectatingBanner();

	class UUI_HUDMode* GetHUDMode() const;
	class ACharaBase* GetTargetChara() const;
	ESlateVisibility OnGetVisibility_ValidTargetCharacter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_HUDBase">();
	}
	static class UUI_HUDBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_HUDBase>();
	}
};
static_assert(alignof(UUI_HUDBase) == 0x000008, "Wrong alignment on UUI_HUDBase");
static_assert(sizeof(UUI_HUDBase) == 0x000CD8, "Wrong size on UUI_HUDBase");
static_assert(offsetof(UUI_HUDBase, _GameConfig) == 0x0004F0, "Member 'UUI_HUDBase::_GameConfig' has a wrong offset!");
static_assert(offsetof(UUI_HUDBase, _TargetChara) == 0x000A50, "Member 'UUI_HUDBase::_TargetChara' has a wrong offset!");
static_assert(offsetof(UUI_HUDBase, _deviation) == 0x000A58, "Member 'UUI_HUDBase::_deviation' has a wrong offset!");
static_assert(offsetof(UUI_HUDBase, _hp) == 0x000A5C, "Member 'UUI_HUDBase::_hp' has a wrong offset!");
static_assert(offsetof(UUI_HUDBase, _MaxHP) == 0x000A60, "Member 'UUI_HUDBase::_MaxHP' has a wrong offset!");
static_assert(offsetof(UUI_HUDBase, _Armor) == 0x000A64, "Member 'UUI_HUDBase::_Armor' has a wrong offset!");
static_assert(offsetof(UUI_HUDBase, _RecoveryHP) == 0x000A68, "Member 'UUI_HUDBase::_RecoveryHP' has a wrong offset!");
static_assert(offsetof(UUI_HUDBase, HUD_CrossHair) == 0x000A70, "Member 'UUI_HUDBase::HUD_CrossHair' has a wrong offset!");
static_assert(offsetof(UUI_HUDBase, HUD_HpProgress) == 0x000A78, "Member 'UUI_HUDBase::HUD_HpProgress' has a wrong offset!");
static_assert(offsetof(UUI_HUDBase, UI_HUD_SkillSlotList) == 0x000A80, "Member 'UUI_HUDBase::UI_HUD_SkillSlotList' has a wrong offset!");
static_assert(offsetof(UUI_HUDBase, UI_HUD_BoosterSlotList) == 0x000A88, "Member 'UUI_HUDBase::UI_HUD_BoosterSlotList' has a wrong offset!");
static_assert(offsetof(UUI_HUDBase, HUD_GunPanel) == 0x000A90, "Member 'UUI_HUDBase::HUD_GunPanel' has a wrong offset!");
static_assert(offsetof(UUI_HUDBase, _DamageIndicatorWidgetClass) == 0x000A98, "Member 'UUI_HUDBase::_DamageIndicatorWidgetClass' has a wrong offset!");
static_assert(offsetof(UUI_HUDBase, _DamageFXWidgetClass) == 0x000AA0, "Member 'UUI_HUDBase::_DamageFXWidgetClass' has a wrong offset!");
static_assert(offsetof(UUI_HUDBase, _DamageIndicators) == 0x000AA8, "Member 'UUI_HUDBase::_DamageIndicators' has a wrong offset!");
static_assert(offsetof(UUI_HUDBase, HUD_Blood) == 0x000B00, "Member 'UUI_HUDBase::HUD_Blood' has a wrong offset!");
static_assert(offsetof(UUI_HUDBase, _HUD_GameNotiInfos) == 0x000B08, "Member 'UUI_HUDBase::_HUD_GameNotiInfos' has a wrong offset!");
static_assert(offsetof(UUI_HUDBase, _StreakDuration) == 0x000C4C, "Member 'UUI_HUDBase::_StreakDuration' has a wrong offset!");
static_assert(offsetof(UUI_HUDBase, _IsShowKillStreak_DEBUG) == 0x000C50, "Member 'UUI_HUDBase::_IsShowKillStreak_DEBUG' has a wrong offset!");
static_assert(offsetof(UUI_HUDBase, _IsShowFloatingHit_DEBUG) == 0x000C51, "Member 'UUI_HUDBase::_IsShowFloatingHit_DEBUG' has a wrong offset!");
static_assert(offsetof(UUI_HUDBase, _DamageViewerClass) == 0x000C70, "Member 'UUI_HUDBase::_DamageViewerClass' has a wrong offset!");
static_assert(offsetof(UUI_HUDBase, _DamageViewers) == 0x000C78, "Member 'UUI_HUDBase::_DamageViewers' has a wrong offset!");
static_assert(offsetof(UUI_HUDBase, _IsShowEnemyDamageMode) == 0x000C90, "Member 'UUI_HUDBase::_IsShowEnemyDamageMode' has a wrong offset!");
static_assert(offsetof(UUI_HUDBase, _HUDMode) == 0x000C98, "Member 'UUI_HUDBase::_HUDMode' has a wrong offset!");
static_assert(offsetof(UUI_HUDBase, FullScreen_Slot) == 0x000CA0, "Member 'UUI_HUDBase::FullScreen_Slot' has a wrong offset!");
static_assert(offsetof(UUI_HUDBase, ChatBox) == 0x000CA8, "Member 'UUI_HUDBase::ChatBox' has a wrong offset!");
static_assert(offsetof(UUI_HUDBase, HUD_ScopePanel) == 0x000CB0, "Member 'UUI_HUDBase::HUD_ScopePanel' has a wrong offset!");
static_assert(offsetof(UUI_HUDBase, UI_KillTag) == 0x000CB8, "Member 'UUI_HUDBase::UI_KillTag' has a wrong offset!");
static_assert(offsetof(UUI_HUDBase, UI_AssistTag) == 0x000CC0, "Member 'UUI_HUDBase::UI_AssistTag' has a wrong offset!");
static_assert(offsetof(UUI_HUDBase, UI_KillerInfoCard) == 0x000CC8, "Member 'UUI_HUDBase::UI_KillerInfoCard' has a wrong offset!");
static_assert(offsetof(UUI_HUDBase, UI_RoundCountDown) == 0x000CD0, "Member 'UUI_HUDBase::UI_RoundCountDown' has a wrong offset!");

// Class Stigma.UI_TrainingRoomHUD
// 0x0008 (0x0508 - 0x0500)
class UUI_TrainingRoomHUD : public UUI_HUDMode
{
public:
	class ALemmingsGameZone*                      _LemmingsGameZone;                                 // 0x0500(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool OnLemmingsGame_ChangeGameState(class ALemmingsGameZone* _game, const struct FLemmingsGameState& _state);
	bool OnLemmingsGame_KillNPC(class ALemmingsGameZone* _game, class ANPC_Lemming* _lemming, bool _is_killed_by_player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_TrainingRoomHUD">();
	}
	static class UUI_TrainingRoomHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_TrainingRoomHUD>();
	}
};
static_assert(alignof(UUI_TrainingRoomHUD) == 0x000008, "Wrong alignment on UUI_TrainingRoomHUD");
static_assert(sizeof(UUI_TrainingRoomHUD) == 0x000508, "Wrong size on UUI_TrainingRoomHUD");
static_assert(offsetof(UUI_TrainingRoomHUD, _LemmingsGameZone) == 0x000500, "Member 'UUI_TrainingRoomHUD::_LemmingsGameZone' has a wrong offset!");

// Class Stigma.UI_HUDMode_Bounty
// 0x0008 (0x0508 - 0x0500)
class UUI_HUDMode_Bounty : public UUI_HUDMode
{
public:
	int32                                         _GetteringAmount;                                  // 0x0500(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25D5[0x4];                                     // 0x0504(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void DriveHacking(class ACharaBase* _owning_chara);
	void HideProgressHacking();
	void HideProgressTransfer();
	void HighlightWinningTeamScore(ETeams _Team, bool _highlight);
	void OnHacking(ETeams _target_team);
	void OnStartHacking();
	void SetGettering(int32 _Amount);
	void StartTransfer();
	void UpdateGettering();
	void WarningBeHacking(bool _be_hacking);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_HUDMode_Bounty">();
	}
	static class UUI_HUDMode_Bounty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_HUDMode_Bounty>();
	}
};
static_assert(alignof(UUI_HUDMode_Bounty) == 0x000008, "Wrong alignment on UUI_HUDMode_Bounty");
static_assert(sizeof(UUI_HUDMode_Bounty) == 0x000508, "Wrong size on UUI_HUDMode_Bounty");
static_assert(offsetof(UUI_HUDMode_Bounty, _GetteringAmount) == 0x000500, "Member 'UUI_HUDMode_Bounty::_GetteringAmount' has a wrong offset!");

// Class Stigma.UI_HUDMode_TDM
// 0x0010 (0x0510 - 0x0500)
class UUI_HUDMode_TDM : public UUI_HUDMode
{
public:
	class UUI_TDM_MainScore*                      UI_MainScore;                                      // 0x0500(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_TDM_SubScore*                       UI_SubScore;                                       // 0x0508(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_HUDMode_TDM">();
	}
	static class UUI_HUDMode_TDM* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_HUDMode_TDM>();
	}
};
static_assert(alignof(UUI_HUDMode_TDM) == 0x000008, "Wrong alignment on UUI_HUDMode_TDM");
static_assert(sizeof(UUI_HUDMode_TDM) == 0x000510, "Wrong size on UUI_HUDMode_TDM");
static_assert(offsetof(UUI_HUDMode_TDM, UI_MainScore) == 0x000500, "Member 'UUI_HUDMode_TDM::UI_MainScore' has a wrong offset!");
static_assert(offsetof(UUI_HUDMode_TDM, UI_SubScore) == 0x000508, "Member 'UUI_HUDMode_TDM::UI_SubScore' has a wrong offset!");

// Class Stigma.UI_HUDRadar
// 0x0010 (0x0500 - 0x04F0)
class UUI_HUDRadar : public UPreviewableWidget
{
public:
	class UImage*                                 IMG_FlashBang;                                     // 0x04F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _ZoomScale;                                        // 0x04F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25D6[0x4];                                     // 0x04FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_HUDRadar">();
	}
	static class UUI_HUDRadar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_HUDRadar>();
	}
};
static_assert(alignof(UUI_HUDRadar) == 0x000008, "Wrong alignment on UUI_HUDRadar");
static_assert(sizeof(UUI_HUDRadar) == 0x000500, "Wrong size on UUI_HUDRadar");
static_assert(offsetof(UUI_HUDRadar, IMG_FlashBang) == 0x0004F0, "Member 'UUI_HUDRadar::IMG_FlashBang' has a wrong offset!");
static_assert(offsetof(UUI_HUDRadar, _ZoomScale) == 0x0004F8, "Member 'UUI_HUDRadar::_ZoomScale' has a wrong offset!");

// Class Stigma.UI_IndicatorWidget
// 0x0010 (0x05A8 - 0x0598)
class UUI_IndicatorWidget : public UIndicatorBaseWidget
{
public:
	uint8                                         Pad_25D7[0x9];                                     // 0x0598(0x0009)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          _LastOnSight;                                      // 0x05A1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25D8[0x6];                                     // 0x05A2(0x0006)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_IndicatorWidget">();
	}
	static class UUI_IndicatorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_IndicatorWidget>();
	}
};
static_assert(alignof(UUI_IndicatorWidget) == 0x000008, "Wrong alignment on UUI_IndicatorWidget");
static_assert(sizeof(UUI_IndicatorWidget) == 0x0005A8, "Wrong size on UUI_IndicatorWidget");
static_assert(offsetof(UUI_IndicatorWidget, _LastOnSight) == 0x0005A1, "Member 'UUI_IndicatorWidget::_LastOnSight' has a wrong offset!");

// Class Stigma.UI_Record_KillStreakListItem
// 0x0020 (0x02E0 - 0x02C0)
class UUI_Record_KillStreakListItem : public UUserWidget
{
public:
	uint8                                         Pad_25D9[0x8];                                     // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UWidget*                                CP_KillStreakListItem;                             // 0x02C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_StreakCount;                                   // 0x02D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25DA[0x8];                                     // 0x02D8(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnSetKillStreakIcon(EKillStreak _kill_streak);

	class URecord_KillStreak_ListItemData* GetSkillStreakItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Record_KillStreakListItem">();
	}
	static class UUI_Record_KillStreakListItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Record_KillStreakListItem>();
	}
};
static_assert(alignof(UUI_Record_KillStreakListItem) == 0x000008, "Wrong alignment on UUI_Record_KillStreakListItem");
static_assert(sizeof(UUI_Record_KillStreakListItem) == 0x0002E0, "Wrong size on UUI_Record_KillStreakListItem");
static_assert(offsetof(UUI_Record_KillStreakListItem, CP_KillStreakListItem) == 0x0002C8, "Member 'UUI_Record_KillStreakListItem::CP_KillStreakListItem' has a wrong offset!");
static_assert(offsetof(UUI_Record_KillStreakListItem, TXT_StreakCount) == 0x0002D0, "Member 'UUI_Record_KillStreakListItem::TXT_StreakCount' has a wrong offset!");

// Class Stigma.UI_IndicatorPingWidget
// 0x0008 (0x05B0 - 0x05A8)
class UUI_IndicatorPingWidget : public UUI_IndicatorWidget
{
public:
	EBattlePingType                               _PingType;                                         // 0x05A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25DB[0x7];                                     // 0x05A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void UpdateUI();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_IndicatorPingWidget">();
	}
	static class UUI_IndicatorPingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_IndicatorPingWidget>();
	}
};
static_assert(alignof(UUI_IndicatorPingWidget) == 0x000008, "Wrong alignment on UUI_IndicatorPingWidget");
static_assert(sizeof(UUI_IndicatorPingWidget) == 0x0005B0, "Wrong size on UUI_IndicatorPingWidget");
static_assert(offsetof(UUI_IndicatorPingWidget, _PingType) == 0x0005A8, "Member 'UUI_IndicatorPingWidget::_PingType' has a wrong offset!");

// Class Stigma.UI_Indicator_BombBase
// 0x0008 (0x05B0 - 0x05A8)
class UUI_Indicator_BombBase final : public UUI_IndicatorWidget
{
public:
	bool                                          _HideIfOutOfSight;                                 // 0x05A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25DC[0x7];                                     // 0x05A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Indicator_BombBase">();
	}
	static class UUI_Indicator_BombBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Indicator_BombBase>();
	}
};
static_assert(alignof(UUI_Indicator_BombBase) == 0x000008, "Wrong alignment on UUI_Indicator_BombBase");
static_assert(sizeof(UUI_Indicator_BombBase) == 0x0005B0, "Wrong size on UUI_Indicator_BombBase");
static_assert(offsetof(UUI_Indicator_BombBase, _HideIfOutOfSight) == 0x0005A8, "Member 'UUI_Indicator_BombBase::_HideIfOutOfSight' has a wrong offset!");

// Class Stigma.UI_Indicator_CharaStat
// 0x0020 (0x05C8 - 0x05A8)
class UUI_Indicator_CharaStat : public UUI_IndicatorWidget
{
public:
	class UUI_Comp_Indicator_HPBar*               HPBar;                                             // 0x05A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_Comp_Indicator_Abnormals*           AbnormalContainer;                                 // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25DD[0x4];                                     // 0x05B8(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	float                                         _HPShowTime;                                       // 0x05BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25DE[0x8];                                     // 0x05C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Indicator_CharaStat">();
	}
	static class UUI_Indicator_CharaStat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Indicator_CharaStat>();
	}
};
static_assert(alignof(UUI_Indicator_CharaStat) == 0x000008, "Wrong alignment on UUI_Indicator_CharaStat");
static_assert(sizeof(UUI_Indicator_CharaStat) == 0x0005C8, "Wrong size on UUI_Indicator_CharaStat");
static_assert(offsetof(UUI_Indicator_CharaStat, HPBar) == 0x0005A8, "Member 'UUI_Indicator_CharaStat::HPBar' has a wrong offset!");
static_assert(offsetof(UUI_Indicator_CharaStat, AbnormalContainer) == 0x0005B0, "Member 'UUI_Indicator_CharaStat::AbnormalContainer' has a wrong offset!");
static_assert(offsetof(UUI_Indicator_CharaStat, _HPShowTime) == 0x0005BC, "Member 'UUI_Indicator_CharaStat::_HPShowTime' has a wrong offset!");

// Class Stigma.UI_Indicator_Scan
// 0x0000 (0x05A8 - 0x05A8)
class UUI_Indicator_Scan : public UUI_IndicatorWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Indicator_Scan">();
	}
	static class UUI_Indicator_Scan* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Indicator_Scan>();
	}
};
static_assert(alignof(UUI_Indicator_Scan) == 0x000008, "Wrong alignment on UUI_Indicator_Scan");
static_assert(sizeof(UUI_Indicator_Scan) == 0x0005A8, "Wrong size on UUI_Indicator_Scan");

// Class Stigma.UI_RecruitBuyButton
// 0x0098 (0x0588 - 0x04F0)
class UUI_RecruitBuyButton : public UPreviewableWidget
{
public:
	class UTextBlock*                             Txt_RecruitCount;                                  // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_Amount;                                        // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Currency;                                      // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_CommonButtonBase*                 Btn_Buy;                                           // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRecruitExcuteData                     _RecruitExcuteData;                                // 0x0510(0x0060)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_25DF[0x18];                                    // 0x0570(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnClickButton(class UAnimatableWidget* _widget, bool _select);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_RecruitBuyButton">();
	}
	static class UUI_RecruitBuyButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_RecruitBuyButton>();
	}
};
static_assert(alignof(UUI_RecruitBuyButton) == 0x000008, "Wrong alignment on UUI_RecruitBuyButton");
static_assert(sizeof(UUI_RecruitBuyButton) == 0x000588, "Wrong size on UUI_RecruitBuyButton");
static_assert(offsetof(UUI_RecruitBuyButton, Txt_RecruitCount) == 0x0004F0, "Member 'UUI_RecruitBuyButton::Txt_RecruitCount' has a wrong offset!");
static_assert(offsetof(UUI_RecruitBuyButton, Txt_Amount) == 0x0004F8, "Member 'UUI_RecruitBuyButton::Txt_Amount' has a wrong offset!");
static_assert(offsetof(UUI_RecruitBuyButton, Img_Currency) == 0x000500, "Member 'UUI_RecruitBuyButton::Img_Currency' has a wrong offset!");
static_assert(offsetof(UUI_RecruitBuyButton, Btn_Buy) == 0x000508, "Member 'UUI_RecruitBuyButton::Btn_Buy' has a wrong offset!");
static_assert(offsetof(UUI_RecruitBuyButton, _RecruitExcuteData) == 0x000510, "Member 'UUI_RecruitBuyButton::_RecruitExcuteData' has a wrong offset!");

// Class Stigma.UI_Interaction
// 0x0000 (0x02C0 - 0x02C0)
class UUI_Interaction : public UUserWidget
{
public:
	bool HideInteractionUI();
	bool HideProgress();
	bool ShowInteractionUI(class AActor* _target, const struct FInteractionData& _data);
	bool ShowProgress(class AActor* _target, int32 _param, float _Delay);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Interaction">();
	}
	static class UUI_Interaction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Interaction>();
	}
};
static_assert(alignof(UUI_Interaction) == 0x000008, "Wrong alignment on UUI_Interaction");
static_assert(sizeof(UUI_Interaction) == 0x0002C0, "Wrong size on UUI_Interaction");

// Class Stigma.UI_InvenSlotToolTipBase
// 0x0028 (0x0518 - 0x04F0)
class UUI_InvenSlotToolTipBase final : public UPreviewableWidget
{
public:
	class UTextBlock*                             ItemNameText;                                      // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemCountText;                                     // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemDescText;                                      // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         ExpireTimeContainer;                               // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ExpireTimeText;                                    // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool Init(const class UUI_InventoryItemSlotBase* _slot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_InvenSlotToolTipBase">();
	}
	static class UUI_InvenSlotToolTipBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_InvenSlotToolTipBase>();
	}
};
static_assert(alignof(UUI_InvenSlotToolTipBase) == 0x000008, "Wrong alignment on UUI_InvenSlotToolTipBase");
static_assert(sizeof(UUI_InvenSlotToolTipBase) == 0x000518, "Wrong size on UUI_InvenSlotToolTipBase");
static_assert(offsetof(UUI_InvenSlotToolTipBase, ItemNameText) == 0x0004F0, "Member 'UUI_InvenSlotToolTipBase::ItemNameText' has a wrong offset!");
static_assert(offsetof(UUI_InvenSlotToolTipBase, ItemCountText) == 0x0004F8, "Member 'UUI_InvenSlotToolTipBase::ItemCountText' has a wrong offset!");
static_assert(offsetof(UUI_InvenSlotToolTipBase, ItemDescText) == 0x000500, "Member 'UUI_InvenSlotToolTipBase::ItemDescText' has a wrong offset!");
static_assert(offsetof(UUI_InvenSlotToolTipBase, ExpireTimeContainer) == 0x000508, "Member 'UUI_InvenSlotToolTipBase::ExpireTimeContainer' has a wrong offset!");
static_assert(offsetof(UUI_InvenSlotToolTipBase, ExpireTimeText) == 0x000510, "Member 'UUI_InvenSlotToolTipBase::ExpireTimeText' has a wrong offset!");

// Class Stigma.UI_InventoryItemSlotBase
// 0x0048 (0x0538 - 0x04F0)
class UUI_InventoryItemSlotBase final : public UPreviewableWidget
{
public:
	struct FSlateColor                            _NormalBackgroundColor;                            // 0x04F0(0x0014)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	struct FSlateColor                            _HoverBackgroundColor;                             // 0x0504(0x0014)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemNameText;                                      // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             ItemCountText;                                     // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 NoticeDot;                                         // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 ItemImage;                                         // 0x0530(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetActiveNoticeDot(bool _flag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_InventoryItemSlotBase">();
	}
	static class UUI_InventoryItemSlotBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_InventoryItemSlotBase>();
	}
};
static_assert(alignof(UUI_InventoryItemSlotBase) == 0x000008, "Wrong alignment on UUI_InventoryItemSlotBase");
static_assert(sizeof(UUI_InventoryItemSlotBase) == 0x000538, "Wrong size on UUI_InventoryItemSlotBase");
static_assert(offsetof(UUI_InventoryItemSlotBase, _NormalBackgroundColor) == 0x0004F0, "Member 'UUI_InventoryItemSlotBase::_NormalBackgroundColor' has a wrong offset!");
static_assert(offsetof(UUI_InventoryItemSlotBase, _HoverBackgroundColor) == 0x000504, "Member 'UUI_InventoryItemSlotBase::_HoverBackgroundColor' has a wrong offset!");
static_assert(offsetof(UUI_InventoryItemSlotBase, ItemNameText) == 0x000518, "Member 'UUI_InventoryItemSlotBase::ItemNameText' has a wrong offset!");
static_assert(offsetof(UUI_InventoryItemSlotBase, ItemCountText) == 0x000520, "Member 'UUI_InventoryItemSlotBase::ItemCountText' has a wrong offset!");
static_assert(offsetof(UUI_InventoryItemSlotBase, NoticeDot) == 0x000528, "Member 'UUI_InventoryItemSlotBase::NoticeDot' has a wrong offset!");
static_assert(offsetof(UUI_InventoryItemSlotBase, ItemImage) == 0x000530, "Member 'UUI_InventoryItemSlotBase::ItemImage' has a wrong offset!");

// Class Stigma.UI_InviteBattleNotifySlot
// 0x0020 (0x0538 - 0x0518)
class UUI_InviteBattleNotifySlot : public UUI_NotifySlot
{
public:
	struct FBattleInviteNotify                    Invitation;                                        // 0x0518(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, Protected, NativeAccessSpecifierProtected)

public:
	void OnClickYesNo(const class UPopupBase* _popup, class FName _ctrl_id);
	void SetText(const class FText& _text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_InviteBattleNotifySlot">();
	}
	static class UUI_InviteBattleNotifySlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_InviteBattleNotifySlot>();
	}
};
static_assert(alignof(UUI_InviteBattleNotifySlot) == 0x000008, "Wrong alignment on UUI_InviteBattleNotifySlot");
static_assert(sizeof(UUI_InviteBattleNotifySlot) == 0x000538, "Wrong size on UUI_InviteBattleNotifySlot");
static_assert(offsetof(UUI_InviteBattleNotifySlot, Invitation) == 0x000518, "Member 'UUI_InviteBattleNotifySlot::Invitation' has a wrong offset!");

// Class Stigma.UI_RecruitHistoryRewardText
// 0x0018 (0x0508 - 0x04F0)
class UUI_RecruitHistoryRewardText : public UPreviewableWidget
{
public:
	class UTextBlock*                             Txt_Number;                                        // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_ItemType;                                      // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_Reward;                                        // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_RecruitHistoryRewardText">();
	}
	static class UUI_RecruitHistoryRewardText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_RecruitHistoryRewardText>();
	}
};
static_assert(alignof(UUI_RecruitHistoryRewardText) == 0x000008, "Wrong alignment on UUI_RecruitHistoryRewardText");
static_assert(sizeof(UUI_RecruitHistoryRewardText) == 0x000508, "Wrong size on UUI_RecruitHistoryRewardText");
static_assert(offsetof(UUI_RecruitHistoryRewardText, Txt_Number) == 0x0004F0, "Member 'UUI_RecruitHistoryRewardText::Txt_Number' has a wrong offset!");
static_assert(offsetof(UUI_RecruitHistoryRewardText, Txt_ItemType) == 0x0004F8, "Member 'UUI_RecruitHistoryRewardText::Txt_ItemType' has a wrong offset!");
static_assert(offsetof(UUI_RecruitHistoryRewardText, Txt_Reward) == 0x000500, "Member 'UUI_RecruitHistoryRewardText::Txt_Reward' has a wrong offset!");

// Class Stigma.UI_ItemIDListViewItem
// 0x0170 (0x0660 - 0x04F0)
class UUI_ItemIDListViewItem : public UPreviewableWidget
{
public:
	uint8                                         Pad_25E4[0x8];                                     // 0x04F0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          IsHoverEnabled;                                    // 0x04F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          _IsShowTooltip;                                    // 0x04F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsShowTooltipKeyUI;                               // 0x04FA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsShowRedDot;                                     // 0x04FB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOwnedViewingState                            OwnedViewingState;                                 // 0x04FC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EOwnedStandardType                            OwnedStandardType;                                 // 0x04FD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25E5[0x2];                                     // 0x04FE(0x0002)(Fixing Size After Last Property [ Dumper-69 ])
	TDelegate<void(struct FItemID& _item_id)>     _IsEquippedDelegate;                               // 0x0500(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TDelegate<void(struct FItemID& _item_id)>     _IsOccupiedDelegate;                               // 0x0510(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInvenItem*                             _ItemObject;                                       // 0x0520(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              _PanelSize;                                        // 0x0528(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              _NullIcon;                                         // 0x0538(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   _NullText;                                         // 0x0560(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_25E6[0x1];                                     // 0x0578(0x0001)(Fixing Size After Last Property [ Dumper-69 ])
	bool                                          _IsVisibleRedDot;                                  // 0x0579(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _ShouldUpdateExpireTime;                           // 0x057A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25E7[0x5];                                     // 0x057B(0x0005)(Fixing Size After Last Property [ Dumper-69 ])
	class UCanvasPanel*                           MainPanel;                                         // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           EquippedPanel;                                     // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           OccupiedPanel;                                     // 0x0590(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           UnownedPanel;                                      // 0x0598(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           OwnedPanel;                                        // 0x05A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Selected;                                      // 0x05A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_Hovered;                                       // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               OVL_IconContainer;                                 // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        Switch_ItemType;                                   // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               SZ_WidgetIcon;                                     // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Icon;                                          // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_ScrollTextBlock*                  TXT_DisplayName;                                   // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_SubName;                                       // 0x05E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScaleBox*                              SB_SubName;                                        // 0x05E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Count;                                         // 0x05F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_OccupiedBy;                                    // 0x05F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               AREA_Count;                                        // 0x0600(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_Category;                                      // 0x0608(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           H_ExpireTimes;                                     // 0x0610(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_ExpireTime;                                    // 0x0618(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         H_ArmorTypes;                                      // 0x0620(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                ArmorType_Soft;                                    // 0x0628(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                ArmorType_Medium;                                  // 0x0630(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                ArmorType_Hard;                                    // 0x0638(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         TXT_NicknameFX;                                    // 0x0640(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_CommonButtonBase*                 Button;                                            // 0x0648(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESlateVisibility                              _visibilityItemCategoryImage;                      // 0x0650(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25E8[0x7];                                     // 0x0651(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UUserWidget*                            _ProfileCardWidget;                                // 0x0658(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void BindItem(class UInvenItem* _item);
	void OnClickBtn(class UAnimatableWidget* _widget, bool _selected);
	void OnUpdateItems();
	void SetEquippedDelegate(const TDelegate<void(struct FItemID& _item_id)>& _event);
	void SetOccupiedDelegate(const TDelegate<void(struct FItemID& _item_id)>& _event);
	void SetPanelSize(const struct FVector2D& _size);
	void SetSelection(bool _is_selected);
	void SetShouldUpdateExpireTime(bool _value);
	void SetShowRedDot(bool _is_show);
	void SetShowTooltip(bool _is_show);
	void SetShowTooltipKeyUI(bool _is_show);
	void SetTags(const TArray<EItemUITag>& _tags);

	ESlateVisibility GetHoverImageVisibility() const;
	bool IsEquippedItem() const;
	struct FIsOccupiedResult IsOccupiedItem() const;
	bool IsOwnedItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_ItemIDListViewItem">();
	}
	static class UUI_ItemIDListViewItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_ItemIDListViewItem>();
	}
};
static_assert(alignof(UUI_ItemIDListViewItem) == 0x000008, "Wrong alignment on UUI_ItemIDListViewItem");
static_assert(sizeof(UUI_ItemIDListViewItem) == 0x000660, "Wrong size on UUI_ItemIDListViewItem");
static_assert(offsetof(UUI_ItemIDListViewItem, IsHoverEnabled) == 0x0004F8, "Member 'UUI_ItemIDListViewItem::IsHoverEnabled' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, _IsShowTooltip) == 0x0004F9, "Member 'UUI_ItemIDListViewItem::_IsShowTooltip' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, _IsShowTooltipKeyUI) == 0x0004FA, "Member 'UUI_ItemIDListViewItem::_IsShowTooltipKeyUI' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, _IsShowRedDot) == 0x0004FB, "Member 'UUI_ItemIDListViewItem::_IsShowRedDot' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, OwnedViewingState) == 0x0004FC, "Member 'UUI_ItemIDListViewItem::OwnedViewingState' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, OwnedStandardType) == 0x0004FD, "Member 'UUI_ItemIDListViewItem::OwnedStandardType' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, _IsEquippedDelegate) == 0x000500, "Member 'UUI_ItemIDListViewItem::_IsEquippedDelegate' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, _IsOccupiedDelegate) == 0x000510, "Member 'UUI_ItemIDListViewItem::_IsOccupiedDelegate' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, _ItemObject) == 0x000520, "Member 'UUI_ItemIDListViewItem::_ItemObject' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, _PanelSize) == 0x000528, "Member 'UUI_ItemIDListViewItem::_PanelSize' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, _NullIcon) == 0x000538, "Member 'UUI_ItemIDListViewItem::_NullIcon' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, _NullText) == 0x000560, "Member 'UUI_ItemIDListViewItem::_NullText' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, _IsVisibleRedDot) == 0x000579, "Member 'UUI_ItemIDListViewItem::_IsVisibleRedDot' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, _ShouldUpdateExpireTime) == 0x00057A, "Member 'UUI_ItemIDListViewItem::_ShouldUpdateExpireTime' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, MainPanel) == 0x000580, "Member 'UUI_ItemIDListViewItem::MainPanel' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, EquippedPanel) == 0x000588, "Member 'UUI_ItemIDListViewItem::EquippedPanel' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, OccupiedPanel) == 0x000590, "Member 'UUI_ItemIDListViewItem::OccupiedPanel' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, UnownedPanel) == 0x000598, "Member 'UUI_ItemIDListViewItem::UnownedPanel' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, OwnedPanel) == 0x0005A0, "Member 'UUI_ItemIDListViewItem::OwnedPanel' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, Img_Selected) == 0x0005A8, "Member 'UUI_ItemIDListViewItem::Img_Selected' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, IMG_Hovered) == 0x0005B0, "Member 'UUI_ItemIDListViewItem::IMG_Hovered' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, OVL_IconContainer) == 0x0005B8, "Member 'UUI_ItemIDListViewItem::OVL_IconContainer' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, Switch_ItemType) == 0x0005C0, "Member 'UUI_ItemIDListViewItem::Switch_ItemType' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, SZ_WidgetIcon) == 0x0005C8, "Member 'UUI_ItemIDListViewItem::SZ_WidgetIcon' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, Img_Icon) == 0x0005D0, "Member 'UUI_ItemIDListViewItem::Img_Icon' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, TXT_DisplayName) == 0x0005D8, "Member 'UUI_ItemIDListViewItem::TXT_DisplayName' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, TXT_SubName) == 0x0005E0, "Member 'UUI_ItemIDListViewItem::TXT_SubName' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, SB_SubName) == 0x0005E8, "Member 'UUI_ItemIDListViewItem::SB_SubName' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, TXT_Count) == 0x0005F0, "Member 'UUI_ItemIDListViewItem::TXT_Count' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, TXT_OccupiedBy) == 0x0005F8, "Member 'UUI_ItemIDListViewItem::TXT_OccupiedBy' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, AREA_Count) == 0x000600, "Member 'UUI_ItemIDListViewItem::AREA_Count' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, IMG_Category) == 0x000608, "Member 'UUI_ItemIDListViewItem::IMG_Category' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, H_ExpireTimes) == 0x000610, "Member 'UUI_ItemIDListViewItem::H_ExpireTimes' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, TXT_ExpireTime) == 0x000618, "Member 'UUI_ItemIDListViewItem::TXT_ExpireTime' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, H_ArmorTypes) == 0x000620, "Member 'UUI_ItemIDListViewItem::H_ArmorTypes' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, ArmorType_Soft) == 0x000628, "Member 'UUI_ItemIDListViewItem::ArmorType_Soft' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, ArmorType_Medium) == 0x000630, "Member 'UUI_ItemIDListViewItem::ArmorType_Medium' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, ArmorType_Hard) == 0x000638, "Member 'UUI_ItemIDListViewItem::ArmorType_Hard' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, TXT_NicknameFX) == 0x000640, "Member 'UUI_ItemIDListViewItem::TXT_NicknameFX' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, Button) == 0x000648, "Member 'UUI_ItemIDListViewItem::Button' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, _visibilityItemCategoryImage) == 0x000650, "Member 'UUI_ItemIDListViewItem::_visibilityItemCategoryImage' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDListViewItem, _ProfileCardWidget) == 0x000658, "Member 'UUI_ItemIDListViewItem::_ProfileCardWidget' has a wrong offset!");

// Class Stigma.UI_ItemIDTileView
// 0x0118 (0x0608 - 0x04F0)
class UUI_ItemIDTileView : public UPreviewableWidget
{
public:
	TDelegate<void(struct FItemID& _item_id)>     _IsEquippedDelegate;                               // 0x04F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TDelegate<void(struct FItemID& _item_id)>     _IsOccupiedDelegate;                               // 0x0500(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TDelegate<void(struct FItemID& _item_id)>     _IsFilteredDelegate;                               // 0x0510(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TDelegate<void(struct FItemID& _item_id)>     _IsOwnedDelegate;                                  // 0x0520(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSet<struct FShowingItemCategory>             _ItemCategories;                                   // 0x0530(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	EItemEquipFilter                              _EquipFilter;                                      // 0x0580(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25EA[0x7];                                     // 0x0581(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FVector2D                              _ItemPanelSize;                                    // 0x0588(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IncludeNonPossessed;                               // 0x0598(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESlateVisibility                              _visibilityItemCategoryImage;                      // 0x0599(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _ShowSubName;                                      // 0x059A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _HasNullItem;                                      // 0x059B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25EB[0x4];                                     // 0x059C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	TSoftObjectPtr<class UTexture2D>              _NullIcon;                                         // 0x05A0(0x0028)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   _NullText;                                         // 0x05C8(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UTileView*                              TileView;                                          // 0x05E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UInvenItem*>                     _AllItems;                                         // 0x05E8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UInvenItem*>                     _FilteredItems;                                    // 0x05F8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void InitializeTileViewEntry(class UUserWidget* _widget, class UObject* _item);
	void RefreshTileView();
	void SelectWidget(const struct FItemID& _id);
	void SetCustomFilter(const TDelegate<void(struct FItemID& _item_id)>& _event);
	void SetEquippedEvent(const TDelegate<void(struct FItemID& _item_id)>& _event);
	void SetFilter(EItemEquipFilter _equip_filter);
	void SetHasNullItem(bool _has_item);
	void SetItemCategory(EItemCategory _category, int32 _sub_category, bool _is_adding, bool _rebuild_list, bool _has_null_item);
	void SetOccupiedEvent(const TDelegate<void(struct FItemID& _item_id)>& _event);
	void SetOwnedEvent(const TDelegate<void(struct FItemID& _item_id)>& _event);
	void SetVisibleItemCategoryImage(ESlateVisibility _visibility);
	void SortExpiredDate(bool _is_descending_order);
	void SortGrade(bool _is_descending_order);
	void SortGun();
	void SortLaunchingDate(bool _is_descending_order);
	void UpdateWidgets();

	bool IsFilteredItem(const struct FItemID& _id) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_ItemIDTileView">();
	}
	static class UUI_ItemIDTileView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_ItemIDTileView>();
	}
};
static_assert(alignof(UUI_ItemIDTileView) == 0x000008, "Wrong alignment on UUI_ItemIDTileView");
static_assert(sizeof(UUI_ItemIDTileView) == 0x000608, "Wrong size on UUI_ItemIDTileView");
static_assert(offsetof(UUI_ItemIDTileView, _IsEquippedDelegate) == 0x0004F0, "Member 'UUI_ItemIDTileView::_IsEquippedDelegate' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDTileView, _IsOccupiedDelegate) == 0x000500, "Member 'UUI_ItemIDTileView::_IsOccupiedDelegate' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDTileView, _IsFilteredDelegate) == 0x000510, "Member 'UUI_ItemIDTileView::_IsFilteredDelegate' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDTileView, _IsOwnedDelegate) == 0x000520, "Member 'UUI_ItemIDTileView::_IsOwnedDelegate' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDTileView, _ItemCategories) == 0x000530, "Member 'UUI_ItemIDTileView::_ItemCategories' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDTileView, _EquipFilter) == 0x000580, "Member 'UUI_ItemIDTileView::_EquipFilter' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDTileView, _ItemPanelSize) == 0x000588, "Member 'UUI_ItemIDTileView::_ItemPanelSize' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDTileView, IncludeNonPossessed) == 0x000598, "Member 'UUI_ItemIDTileView::IncludeNonPossessed' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDTileView, _visibilityItemCategoryImage) == 0x000599, "Member 'UUI_ItemIDTileView::_visibilityItemCategoryImage' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDTileView, _ShowSubName) == 0x00059A, "Member 'UUI_ItemIDTileView::_ShowSubName' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDTileView, _HasNullItem) == 0x00059B, "Member 'UUI_ItemIDTileView::_HasNullItem' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDTileView, _NullIcon) == 0x0005A0, "Member 'UUI_ItemIDTileView::_NullIcon' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDTileView, _NullText) == 0x0005C8, "Member 'UUI_ItemIDTileView::_NullText' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDTileView, TileView) == 0x0005E0, "Member 'UUI_ItemIDTileView::TileView' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDTileView, _AllItems) == 0x0005E8, "Member 'UUI_ItemIDTileView::_AllItems' has a wrong offset!");
static_assert(offsetof(UUI_ItemIDTileView, _FilteredItems) == 0x0005F8, "Member 'UUI_ItemIDTileView::_FilteredItems' has a wrong offset!");

// Class Stigma.UI_KeyMappingBase
// 0x0038 (0x0528 - 0x04F0)
class UUI_KeyMappingBase : public UPreviewableWidget
{
public:
	EInputAction                                  _KeyInputAction;                                   // 0x04F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsUsedKeyGuide;                                   // 0x04F1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25EF[0x6];                                     // 0x04F2(0x0006)(Fixing Size After Last Property [ Dumper-69 ])
	struct FKeyMapping                            _KeyMapping;                                       // 0x04F8(0x0030)(Edit, BlueprintVisible, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void UpdateUI();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_KeyMappingBase">();
	}
	static class UUI_KeyMappingBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_KeyMappingBase>();
	}
};
static_assert(alignof(UUI_KeyMappingBase) == 0x000008, "Wrong alignment on UUI_KeyMappingBase");
static_assert(sizeof(UUI_KeyMappingBase) == 0x000528, "Wrong size on UUI_KeyMappingBase");
static_assert(offsetof(UUI_KeyMappingBase, _KeyInputAction) == 0x0004F0, "Member 'UUI_KeyMappingBase::_KeyInputAction' has a wrong offset!");
static_assert(offsetof(UUI_KeyMappingBase, _IsUsedKeyGuide) == 0x0004F1, "Member 'UUI_KeyMappingBase::_IsUsedKeyGuide' has a wrong offset!");
static_assert(offsetof(UUI_KeyMappingBase, _KeyMapping) == 0x0004F8, "Member 'UUI_KeyMappingBase::_KeyMapping' has a wrong offset!");

// Class Stigma.UI_LackControlPower
// 0x0020 (0x0510 - 0x04F0)
class UUI_LackControlPower : public UPreviewableWidget
{
public:
	class UGunObject*                             _TargetGunObject;                                  // 0x04F0(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _TargetCP;                                         // 0x04F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25F0[0x4];                                     // 0x04FC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UTextBlock*                             TXT_Lack_ControlPower;                             // 0x0500(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsLackControlPower;                               // 0x0508(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25F1[0x7];                                     // 0x0509(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool CheckAndBindTarget(int32 _target_cp, class UGunObject* _gun_object);
	void Clear();
	bool IsLackControlPower();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_LackControlPower">();
	}
	static class UUI_LackControlPower* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_LackControlPower>();
	}
};
static_assert(alignof(UUI_LackControlPower) == 0x000008, "Wrong alignment on UUI_LackControlPower");
static_assert(sizeof(UUI_LackControlPower) == 0x000510, "Wrong size on UUI_LackControlPower");
static_assert(offsetof(UUI_LackControlPower, _TargetGunObject) == 0x0004F0, "Member 'UUI_LackControlPower::_TargetGunObject' has a wrong offset!");
static_assert(offsetof(UUI_LackControlPower, _TargetCP) == 0x0004F8, "Member 'UUI_LackControlPower::_TargetCP' has a wrong offset!");
static_assert(offsetof(UUI_LackControlPower, TXT_Lack_ControlPower) == 0x000500, "Member 'UUI_LackControlPower::TXT_Lack_ControlPower' has a wrong offset!");
static_assert(offsetof(UUI_LackControlPower, _IsLackControlPower) == 0x000508, "Member 'UUI_LackControlPower::_IsLackControlPower' has a wrong offset!");

// Class Stigma.UI_RecruitResultRewardItem
// 0x00C8 (0x05B8 - 0x04F0)
class UUI_RecruitResultRewardItem : public UPreviewableWidget
{
public:
	uint8                                         Pad_25F4[0x8];                                     // 0x04F0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UCtrl_ScrollTextBlock*                  ScrollTxt_Name;                                    // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_SubName;                                       // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Count;                                         // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_Category;                                      // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Grade_Corner;                                  // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Grade_Glow;                                    // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Grade_Smoke;                                   // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Grade_Border;                                  // 0x0530(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               OVL_Count;                                         // 0x0538(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_RemainDateTimer*                    UI_RemainTime;                                     // 0x0540(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Icon;                                          // 0x0548(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_RecruitRefundItem*                  Refund;                                            // 0x0550(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FNetRecruitRewardItemSet               _reward;                                           // 0x0558(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FItemID                                _ItemID;                                           // 0x05A8(0x0010)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_RecruitResultRewardItem">();
	}
	static class UUI_RecruitResultRewardItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_RecruitResultRewardItem>();
	}
};
static_assert(alignof(UUI_RecruitResultRewardItem) == 0x000008, "Wrong alignment on UUI_RecruitResultRewardItem");
static_assert(sizeof(UUI_RecruitResultRewardItem) == 0x0005B8, "Wrong size on UUI_RecruitResultRewardItem");
static_assert(offsetof(UUI_RecruitResultRewardItem, ScrollTxt_Name) == 0x0004F8, "Member 'UUI_RecruitResultRewardItem::ScrollTxt_Name' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultRewardItem, TXT_SubName) == 0x000500, "Member 'UUI_RecruitResultRewardItem::TXT_SubName' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultRewardItem, TXT_Count) == 0x000508, "Member 'UUI_RecruitResultRewardItem::TXT_Count' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultRewardItem, IMG_Category) == 0x000510, "Member 'UUI_RecruitResultRewardItem::IMG_Category' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultRewardItem, Img_Grade_Corner) == 0x000518, "Member 'UUI_RecruitResultRewardItem::Img_Grade_Corner' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultRewardItem, Img_Grade_Glow) == 0x000520, "Member 'UUI_RecruitResultRewardItem::Img_Grade_Glow' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultRewardItem, Img_Grade_Smoke) == 0x000528, "Member 'UUI_RecruitResultRewardItem::Img_Grade_Smoke' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultRewardItem, Img_Grade_Border) == 0x000530, "Member 'UUI_RecruitResultRewardItem::Img_Grade_Border' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultRewardItem, OVL_Count) == 0x000538, "Member 'UUI_RecruitResultRewardItem::OVL_Count' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultRewardItem, UI_RemainTime) == 0x000540, "Member 'UUI_RecruitResultRewardItem::UI_RemainTime' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultRewardItem, Img_Icon) == 0x000548, "Member 'UUI_RecruitResultRewardItem::Img_Icon' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultRewardItem, Refund) == 0x000550, "Member 'UUI_RecruitResultRewardItem::Refund' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultRewardItem, _reward) == 0x000558, "Member 'UUI_RecruitResultRewardItem::_reward' has a wrong offset!");
static_assert(offsetof(UUI_RecruitResultRewardItem, _ItemID) == 0x0005A8, "Member 'UUI_RecruitResultRewardItem::_ItemID' has a wrong offset!");

// Class Stigma.UI_LevelUp
// 0x0028 (0x0598 - 0x0570)
class UUI_LevelUp : public UPopupBase
{
public:
	int32                                         _level;                                            // 0x0570(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25F5[0x4];                                     // 0x0574(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FRewardPlain                           _reward;                                           // 0x0578(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	void InitWidget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_LevelUp">();
	}
	static class UUI_LevelUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_LevelUp>();
	}
};
static_assert(alignof(UUI_LevelUp) == 0x000008, "Wrong alignment on UUI_LevelUp");
static_assert(sizeof(UUI_LevelUp) == 0x000598, "Wrong size on UUI_LevelUp");
static_assert(offsetof(UUI_LevelUp, _level) == 0x000570, "Member 'UUI_LevelUp::_level' has a wrong offset!");
static_assert(offsetof(UUI_LevelUp, _reward) == 0x000578, "Member 'UUI_LevelUp::_reward' has a wrong offset!");

// Class Stigma.UI_Lobby
// 0x00E0 (0x05D0 - 0x04F0)
class UUI_Lobby : public UPreviewableWidget
{
public:
	TSubclassOf<class UUI_MailBox>                _MailUIClass;                                      // 0x04F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<ELobbyPage, struct FLobbyPageConfig>     _PageConfigs;                                      // 0x04F8(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TArray<struct FItemID_Currency>               DefaultShowCurrencyList;                           // 0x0548(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           MainCanvas;                                        // 0x0558(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_GNB_LobbyBase*                      GNB_Lobby;                                         // 0x0560(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           GNB_OverCanvas;                                    // 0x0568(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_ChatBox*                            UI_ChatBox;                                        // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               OVL_Mail;                                          // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25F6[0x18];                                    // 0x0580(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	ELobbyPage                                    _CurrentPage;                                      // 0x0598(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25F7[0x7];                                     // 0x0599(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<class AMannequin*>                     _Mannequins;                                       // 0x05A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	class UUI_LobbyPage*                          _CurrentPageUI;                                    // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AFollowCameraActor*                     _TheCamera;                                        // 0x05B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMannequin*                             _CharaModel;                                       // 0x05C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_MailBox*                            _MailBox;                                          // 0x05C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UUI_LobbyPage* GetCurrentLobbyPage(const class UObject* _world_ctx);
	static void GotoLobbyPage(const class UObject* _world_ctx, ELobbyPage _page, EItemCategory _sub_option);

	void ActivateCameraForPage();
	bool CloseMailBox();
	class UUI_ChatBox* GetChatBox();
	ELobbyPage GetCurrentPage();
	class UUI_LobbyPage* GetCurrentPageUI();
	class UUI_GNB_LobbyBase* GetGNBLobby();
	void GotoPage(ELobbyPage _page, EItemCategory _sub_option);
	bool OnGotoPage(ELobbyPage _page, EItemCategory _sub_option);
	bool OnInit();
	void OnParty_CharacterUpdated(const struct FUserID& _user_id, const struct FCharSpec& _chara);
	void OnParty_LeaderUpdated(const struct FUserID& _leader_id);
	void OnParty_MemberAdded(const class UBriefParty* _party, const class UUserProfile* _member);
	void OnParty_MemberDeleted(const class UBriefParty* _party, const struct FUserID& _user_id);
	void OnPartyEntered(const class UBriefParty* _party);
	void OnPartyExited();
	bool OnUpdateCharaModel();
	void RegisterOnLobbyPageChanged(const TDelegate<void(ELobbyPage _lobby_type)>& _callback);
	void RegisterSocialCallbacks();
	void ShowMailBox();
	void UnRegisterSocialCallbacks();
	void UpdateAllMannequins(ELobbyPage _page);

	class AFollowCameraActor* GetCamera() const;
	class AMannequin* GetCharaModel() const;
	bool IsMannequinVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Lobby">();
	}
	static class UUI_Lobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Lobby>();
	}
};
static_assert(alignof(UUI_Lobby) == 0x000008, "Wrong alignment on UUI_Lobby");
static_assert(sizeof(UUI_Lobby) == 0x0005D0, "Wrong size on UUI_Lobby");
static_assert(offsetof(UUI_Lobby, _MailUIClass) == 0x0004F0, "Member 'UUI_Lobby::_MailUIClass' has a wrong offset!");
static_assert(offsetof(UUI_Lobby, _PageConfigs) == 0x0004F8, "Member 'UUI_Lobby::_PageConfigs' has a wrong offset!");
static_assert(offsetof(UUI_Lobby, DefaultShowCurrencyList) == 0x000548, "Member 'UUI_Lobby::DefaultShowCurrencyList' has a wrong offset!");
static_assert(offsetof(UUI_Lobby, MainCanvas) == 0x000558, "Member 'UUI_Lobby::MainCanvas' has a wrong offset!");
static_assert(offsetof(UUI_Lobby, GNB_Lobby) == 0x000560, "Member 'UUI_Lobby::GNB_Lobby' has a wrong offset!");
static_assert(offsetof(UUI_Lobby, GNB_OverCanvas) == 0x000568, "Member 'UUI_Lobby::GNB_OverCanvas' has a wrong offset!");
static_assert(offsetof(UUI_Lobby, UI_ChatBox) == 0x000570, "Member 'UUI_Lobby::UI_ChatBox' has a wrong offset!");
static_assert(offsetof(UUI_Lobby, OVL_Mail) == 0x000578, "Member 'UUI_Lobby::OVL_Mail' has a wrong offset!");
static_assert(offsetof(UUI_Lobby, _CurrentPage) == 0x000598, "Member 'UUI_Lobby::_CurrentPage' has a wrong offset!");
static_assert(offsetof(UUI_Lobby, _Mannequins) == 0x0005A0, "Member 'UUI_Lobby::_Mannequins' has a wrong offset!");
static_assert(offsetof(UUI_Lobby, _CurrentPageUI) == 0x0005B0, "Member 'UUI_Lobby::_CurrentPageUI' has a wrong offset!");
static_assert(offsetof(UUI_Lobby, _TheCamera) == 0x0005B8, "Member 'UUI_Lobby::_TheCamera' has a wrong offset!");
static_assert(offsetof(UUI_Lobby, _CharaModel) == 0x0005C0, "Member 'UUI_Lobby::_CharaModel' has a wrong offset!");
static_assert(offsetof(UUI_Lobby, _MailBox) == 0x0005C8, "Member 'UUI_Lobby::_MailBox' has a wrong offset!");

// Class Stigma.UI_MailBox
// 0x0120 (0x0610 - 0x04F0)
class UUI_MailBox : public UPreviewableWidget
{
public:
	class UCheckBox*                              CheckBox_Select;                                   // 0x04F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_MailContentDetailBox*               MailContentDetailBox;                              // 0x04F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_MailCount;                                     // 0x0500(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        SWITCHER_MailBox_Status;                           // 0x0508(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                btn_close;                                         // 0x0510(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                BTN_Refresh;                                       // 0x0518(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                BTN_ReceiveAll;                                    // 0x0520(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                BTN_Delete;                                        // 0x0528(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UListView*                              LISTVIEW_MailList;                                 // 0x0530(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       UI_Open;                                           // 0x0538(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       UI_Close;                                          // 0x0540(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<int32, class UMailListItemData*>         _MailDataMap;                                      // 0x0548(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	TSet<int32>                                   _SelectedMailIDNs;                                 // 0x0598(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_25F9[0x28];                                    // 0x05E8(0x0028)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Close(bool _play_animation);
	void OnAck_MailDelete(const struct FACK_MailDelete& _ack);
	void OnAck_MailRead(const struct FACK_MailRead& _ack);
	void OnAck_MailUpdate(const struct FACK_MailUpdate& _ack);
	void OnClickClose();
	void OnClickDelete();
	void OnClickReceiveAll();
	void OnClickRefresh();
	void OnClickSelectAll(bool _is_selected);
	void OnEndCloseAnimation();
	void OnMailRead(int32 _mail_idn);
	void OnMailSelect(int32 _mail_idn, bool _is_selected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_MailBox">();
	}
	static class UUI_MailBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_MailBox>();
	}
};
static_assert(alignof(UUI_MailBox) == 0x000008, "Wrong alignment on UUI_MailBox");
static_assert(sizeof(UUI_MailBox) == 0x000610, "Wrong size on UUI_MailBox");
static_assert(offsetof(UUI_MailBox, CheckBox_Select) == 0x0004F0, "Member 'UUI_MailBox::CheckBox_Select' has a wrong offset!");
static_assert(offsetof(UUI_MailBox, MailContentDetailBox) == 0x0004F8, "Member 'UUI_MailBox::MailContentDetailBox' has a wrong offset!");
static_assert(offsetof(UUI_MailBox, TXT_MailCount) == 0x000500, "Member 'UUI_MailBox::TXT_MailCount' has a wrong offset!");
static_assert(offsetof(UUI_MailBox, SWITCHER_MailBox_Status) == 0x000508, "Member 'UUI_MailBox::SWITCHER_MailBox_Status' has a wrong offset!");
static_assert(offsetof(UUI_MailBox, btn_close) == 0x000510, "Member 'UUI_MailBox::btn_close' has a wrong offset!");
static_assert(offsetof(UUI_MailBox, BTN_Refresh) == 0x000518, "Member 'UUI_MailBox::BTN_Refresh' has a wrong offset!");
static_assert(offsetof(UUI_MailBox, BTN_ReceiveAll) == 0x000520, "Member 'UUI_MailBox::BTN_ReceiveAll' has a wrong offset!");
static_assert(offsetof(UUI_MailBox, BTN_Delete) == 0x000528, "Member 'UUI_MailBox::BTN_Delete' has a wrong offset!");
static_assert(offsetof(UUI_MailBox, LISTVIEW_MailList) == 0x000530, "Member 'UUI_MailBox::LISTVIEW_MailList' has a wrong offset!");
static_assert(offsetof(UUI_MailBox, UI_Open) == 0x000538, "Member 'UUI_MailBox::UI_Open' has a wrong offset!");
static_assert(offsetof(UUI_MailBox, UI_Close) == 0x000540, "Member 'UUI_MailBox::UI_Close' has a wrong offset!");
static_assert(offsetof(UUI_MailBox, _MailDataMap) == 0x000548, "Member 'UUI_MailBox::_MailDataMap' has a wrong offset!");
static_assert(offsetof(UUI_MailBox, _SelectedMailIDNs) == 0x000598, "Member 'UUI_MailBox::_SelectedMailIDNs' has a wrong offset!");

// Class Stigma.UI_MailContentDetailBox
// 0x0078 (0x0568 - 0x04F0)
class UUI_MailContentDetailBox : public UPreviewableWidget
{
public:
	class UTextBlock*                             Txt_Title;                                         // 0x04F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_ReceivedDate;                                  // 0x04F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_RemainTime;                                    // 0x0500(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Content;                                       // 0x0508(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_BtnReceiveText;                                // 0x0510(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UListView*                              LV_RewardList;                                     // 0x0518(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                btn_close;                                         // 0x0520(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                BTN_Delete;                                        // 0x0528(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        SWITCHER_Button;                                   // 0x0530(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                BTN_Receive;                                       // 0x0538(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                BTN_Confirm;                                       // 0x0540(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       UI_Open;                                           // 0x0548(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       UI_Close;                                          // 0x0550(0x0008)(BlueprintVisible, ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25FB[0x10];                                    // 0x0558(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnClickClose();
	void OnClickDelete();
	void OnClickReceive();
	void OnEndCloseAnimation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_MailContentDetailBox">();
	}
	static class UUI_MailContentDetailBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_MailContentDetailBox>();
	}
};
static_assert(alignof(UUI_MailContentDetailBox) == 0x000008, "Wrong alignment on UUI_MailContentDetailBox");
static_assert(sizeof(UUI_MailContentDetailBox) == 0x000568, "Wrong size on UUI_MailContentDetailBox");
static_assert(offsetof(UUI_MailContentDetailBox, Txt_Title) == 0x0004F0, "Member 'UUI_MailContentDetailBox::Txt_Title' has a wrong offset!");
static_assert(offsetof(UUI_MailContentDetailBox, TXT_ReceivedDate) == 0x0004F8, "Member 'UUI_MailContentDetailBox::TXT_ReceivedDate' has a wrong offset!");
static_assert(offsetof(UUI_MailContentDetailBox, TXT_RemainTime) == 0x000500, "Member 'UUI_MailContentDetailBox::TXT_RemainTime' has a wrong offset!");
static_assert(offsetof(UUI_MailContentDetailBox, TXT_Content) == 0x000508, "Member 'UUI_MailContentDetailBox::TXT_Content' has a wrong offset!");
static_assert(offsetof(UUI_MailContentDetailBox, TXT_BtnReceiveText) == 0x000510, "Member 'UUI_MailContentDetailBox::TXT_BtnReceiveText' has a wrong offset!");
static_assert(offsetof(UUI_MailContentDetailBox, LV_RewardList) == 0x000518, "Member 'UUI_MailContentDetailBox::LV_RewardList' has a wrong offset!");
static_assert(offsetof(UUI_MailContentDetailBox, btn_close) == 0x000520, "Member 'UUI_MailContentDetailBox::btn_close' has a wrong offset!");
static_assert(offsetof(UUI_MailContentDetailBox, BTN_Delete) == 0x000528, "Member 'UUI_MailContentDetailBox::BTN_Delete' has a wrong offset!");
static_assert(offsetof(UUI_MailContentDetailBox, SWITCHER_Button) == 0x000530, "Member 'UUI_MailContentDetailBox::SWITCHER_Button' has a wrong offset!");
static_assert(offsetof(UUI_MailContentDetailBox, BTN_Receive) == 0x000538, "Member 'UUI_MailContentDetailBox::BTN_Receive' has a wrong offset!");
static_assert(offsetof(UUI_MailContentDetailBox, BTN_Confirm) == 0x000540, "Member 'UUI_MailContentDetailBox::BTN_Confirm' has a wrong offset!");
static_assert(offsetof(UUI_MailContentDetailBox, UI_Open) == 0x000548, "Member 'UUI_MailContentDetailBox::UI_Open' has a wrong offset!");
static_assert(offsetof(UUI_MailContentDetailBox, UI_Close) == 0x000550, "Member 'UUI_MailContentDetailBox::UI_Close' has a wrong offset!");

// Class Stigma.UI_MainBase
// 0x0018 (0x0508 - 0x04F0)
class UUI_MainBase final : public UPreviewableWidget
{
public:
	uint8                                         Pad_25FC[0x18];                                    // 0x04F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool OnSetAnnouncements(const TArray<struct FAnnounce>& _announcements);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_MainBase">();
	}
	static class UUI_MainBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_MainBase>();
	}
};
static_assert(alignof(UUI_MainBase) == 0x000008, "Wrong alignment on UUI_MainBase");
static_assert(sizeof(UUI_MainBase) == 0x000508, "Wrong size on UUI_MainBase");

// Class Stigma.UI_MasterLevelRewardSlot
// 0x0020 (0x0510 - 0x04F0)
class UUI_MasterLevelRewardSlot : public UPreviewableWidget
{
public:
	class UWidgetSwitcher*                        WS_Reward;                                         // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_RewardContainer*                    RewardContainer;                                   // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              _RewardItemSize_OneItem;                           // 0x0500(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void FillPercentBar(bool _fill_left, bool _fill_right);
	void SetCheckPoint(bool _checked);
	void SetLevel(int32 _level);
	void SetMasterImage(const TSoftObjectPtr<class UTexture2D>& _soft_texture);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_MasterLevelRewardSlot">();
	}
	static class UUI_MasterLevelRewardSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_MasterLevelRewardSlot>();
	}
};
static_assert(alignof(UUI_MasterLevelRewardSlot) == 0x000008, "Wrong alignment on UUI_MasterLevelRewardSlot");
static_assert(sizeof(UUI_MasterLevelRewardSlot) == 0x000510, "Wrong size on UUI_MasterLevelRewardSlot");
static_assert(offsetof(UUI_MasterLevelRewardSlot, WS_Reward) == 0x0004F0, "Member 'UUI_MasterLevelRewardSlot::WS_Reward' has a wrong offset!");
static_assert(offsetof(UUI_MasterLevelRewardSlot, RewardContainer) == 0x0004F8, "Member 'UUI_MasterLevelRewardSlot::RewardContainer' has a wrong offset!");
static_assert(offsetof(UUI_MasterLevelRewardSlot, _RewardItemSize_OneItem) == 0x000500, "Member 'UUI_MasterLevelRewardSlot::_RewardItemSize_OneItem' has a wrong offset!");

// Class Stigma.UI_MasterMissionBrief
// 0x0060 (0x0550 - 0x04F0)
class UUI_MasterMissionBrief : public UPreviewableWidget
{
public:
	class UWidgetSwitcher*                        WidgetSwitcher;                                    // 0x04F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VB_Missions;                                       // 0x04F8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               Ovl_FirstMission;                                  // 0x0500(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _ShowPopupButton;                                  // 0x0508(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25FE[0x7];                                     // 0x0509(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TSubclassOf<class UUI_MissionBriefSlot>       _MissionSlotClass;                                 // 0x0510(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_MissionBriefSlot>       _FirstMissionSlotClass;                            // 0x0518(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_MissionPopup>           _MissionPopupClass;                                // 0x0520(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                _SlotPadding;                                      // 0x0528(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FItemID_EventPage                      _MasterMissionTaskID;                              // 0x0538(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECharaType                                    _CurrentCharaType;                                 // 0x0548(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_25FF[0x7];                                     // 0x0549(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ClearLocked();
	void FirstMissionLocked();
	bool InitWidget(ECharaType _chara_type);
	void MaxLevelLocked();
	void NoMasterLocked();
	void OpenMissionPopup();
	void SetLockedIfFirstMissionEnabled();
	void SetTitle(const class FText& _text);
	void ShowRedDot(bool _show);
	void UserLevelLocked(int32 _level);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_MasterMissionBrief">();
	}
	static class UUI_MasterMissionBrief* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_MasterMissionBrief>();
	}
};
static_assert(alignof(UUI_MasterMissionBrief) == 0x000008, "Wrong alignment on UUI_MasterMissionBrief");
static_assert(sizeof(UUI_MasterMissionBrief) == 0x000550, "Wrong size on UUI_MasterMissionBrief");
static_assert(offsetof(UUI_MasterMissionBrief, WidgetSwitcher) == 0x0004F0, "Member 'UUI_MasterMissionBrief::WidgetSwitcher' has a wrong offset!");
static_assert(offsetof(UUI_MasterMissionBrief, VB_Missions) == 0x0004F8, "Member 'UUI_MasterMissionBrief::VB_Missions' has a wrong offset!");
static_assert(offsetof(UUI_MasterMissionBrief, Ovl_FirstMission) == 0x000500, "Member 'UUI_MasterMissionBrief::Ovl_FirstMission' has a wrong offset!");
static_assert(offsetof(UUI_MasterMissionBrief, _ShowPopupButton) == 0x000508, "Member 'UUI_MasterMissionBrief::_ShowPopupButton' has a wrong offset!");
static_assert(offsetof(UUI_MasterMissionBrief, _MissionSlotClass) == 0x000510, "Member 'UUI_MasterMissionBrief::_MissionSlotClass' has a wrong offset!");
static_assert(offsetof(UUI_MasterMissionBrief, _FirstMissionSlotClass) == 0x000518, "Member 'UUI_MasterMissionBrief::_FirstMissionSlotClass' has a wrong offset!");
static_assert(offsetof(UUI_MasterMissionBrief, _MissionPopupClass) == 0x000520, "Member 'UUI_MasterMissionBrief::_MissionPopupClass' has a wrong offset!");
static_assert(offsetof(UUI_MasterMissionBrief, _SlotPadding) == 0x000528, "Member 'UUI_MasterMissionBrief::_SlotPadding' has a wrong offset!");
static_assert(offsetof(UUI_MasterMissionBrief, _MasterMissionTaskID) == 0x000538, "Member 'UUI_MasterMissionBrief::_MasterMissionTaskID' has a wrong offset!");
static_assert(offsetof(UUI_MasterMissionBrief, _CurrentCharaType) == 0x000548, "Member 'UUI_MasterMissionBrief::_CurrentCharaType' has a wrong offset!");

// Class Stigma.VS_GameMode
// 0x0000 (0x0800 - 0x0800)
class AVS_GameMode : public AAnnihilation_GameMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VS_GameMode">();
	}
	static class AVS_GameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVS_GameMode>();
	}
};
static_assert(alignof(AVS_GameMode) == 0x000008, "Wrong alignment on AVS_GameMode");
static_assert(sizeof(AVS_GameMode) == 0x000800, "Wrong size on AVS_GameMode");

// Class Stigma.UI_MasterMissionRewardPopup
// 0x0040 (0x05B0 - 0x0570)
class UUI_MasterMissionRewardPopup : public UPopupBase
{
public:
	class UUI_PreviewPopupBase*                   PreviewPopupBase;                                  // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      UGP_Items;                                         // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_ItemIDListViewItem>     _ItemWidgetClass;                                  // 0x0580(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   _Desc;                                             // 0x0588(0x0018)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FItemID_EventPage                      _MasterEventID;                                    // 0x05A0(0x0010)(BlueprintVisible, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitWidget(const struct FItemID_EventPage& _master_event_id);
	void OnClickItem(class UAnimatableWidget* _widget, bool _selected);
	void SetTitle(ECharaType _chara_type, int32 _max_level);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_MasterMissionRewardPopup">();
	}
	static class UUI_MasterMissionRewardPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_MasterMissionRewardPopup>();
	}
};
static_assert(alignof(UUI_MasterMissionRewardPopup) == 0x000008, "Wrong alignment on UUI_MasterMissionRewardPopup");
static_assert(sizeof(UUI_MasterMissionRewardPopup) == 0x0005B0, "Wrong size on UUI_MasterMissionRewardPopup");
static_assert(offsetof(UUI_MasterMissionRewardPopup, PreviewPopupBase) == 0x000570, "Member 'UUI_MasterMissionRewardPopup::PreviewPopupBase' has a wrong offset!");
static_assert(offsetof(UUI_MasterMissionRewardPopup, UGP_Items) == 0x000578, "Member 'UUI_MasterMissionRewardPopup::UGP_Items' has a wrong offset!");
static_assert(offsetof(UUI_MasterMissionRewardPopup, _ItemWidgetClass) == 0x000580, "Member 'UUI_MasterMissionRewardPopup::_ItemWidgetClass' has a wrong offset!");
static_assert(offsetof(UUI_MasterMissionRewardPopup, _Desc) == 0x000588, "Member 'UUI_MasterMissionRewardPopup::_Desc' has a wrong offset!");
static_assert(offsetof(UUI_MasterMissionRewardPopup, _MasterEventID) == 0x0005A0, "Member 'UUI_MasterMissionRewardPopup::_MasterEventID' has a wrong offset!");

// Class Stigma.UI_MenuBar
// 0x0000 (0x04F0 - 0x04F0)
class UUI_MenuBar final : public UPreviewableWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_MenuBar">();
	}
	static class UUI_MenuBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_MenuBar>();
	}
};
static_assert(alignof(UUI_MenuBar) == 0x000008, "Wrong alignment on UUI_MenuBar");
static_assert(sizeof(UUI_MenuBar) == 0x0004F0, "Wrong size on UUI_MenuBar");

// Class Stigma.UI_MissionBrief
// 0x0048 (0x0538 - 0x04F0)
class UUI_MissionBrief : public UPreviewableWidget
{
public:
	TSubclassOf<class UUI_MissionBriefTab>        _MissionBriefTabClass;                             // 0x04F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_MissionBriefContainer>  _MissionBriefContainerClass;                       // 0x04F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_MissionBriefContainer_Track> _TrackMissionBriefContainerClass;                  // 0x0500(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_MissionPopup>           _MissionPopupClass;                                // 0x0508(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WS_BriefTab;                                       // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_TabInspector*                       TabInspector;                                      // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WS_BriefContainer;                                 // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2602[0x10];                                    // 0x0528(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnShowTask(const struct FItemID& _task_id);
	void OpenMissionPopup();
	void ShowNextTask(ESideViewSide _side);

	const struct FItemID GetCurrentTaskID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_MissionBrief">();
	}
	static class UUI_MissionBrief* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_MissionBrief>();
	}
};
static_assert(alignof(UUI_MissionBrief) == 0x000008, "Wrong alignment on UUI_MissionBrief");
static_assert(sizeof(UUI_MissionBrief) == 0x000538, "Wrong size on UUI_MissionBrief");
static_assert(offsetof(UUI_MissionBrief, _MissionBriefTabClass) == 0x0004F0, "Member 'UUI_MissionBrief::_MissionBriefTabClass' has a wrong offset!");
static_assert(offsetof(UUI_MissionBrief, _MissionBriefContainerClass) == 0x0004F8, "Member 'UUI_MissionBrief::_MissionBriefContainerClass' has a wrong offset!");
static_assert(offsetof(UUI_MissionBrief, _TrackMissionBriefContainerClass) == 0x000500, "Member 'UUI_MissionBrief::_TrackMissionBriefContainerClass' has a wrong offset!");
static_assert(offsetof(UUI_MissionBrief, _MissionPopupClass) == 0x000508, "Member 'UUI_MissionBrief::_MissionPopupClass' has a wrong offset!");
static_assert(offsetof(UUI_MissionBrief, WS_BriefTab) == 0x000510, "Member 'UUI_MissionBrief::WS_BriefTab' has a wrong offset!");
static_assert(offsetof(UUI_MissionBrief, TabInspector) == 0x000518, "Member 'UUI_MissionBrief::TabInspector' has a wrong offset!");
static_assert(offsetof(UUI_MissionBrief, WS_BriefContainer) == 0x000520, "Member 'UUI_MissionBrief::WS_BriefContainer' has a wrong offset!");

// Class Stigma.UI_MissionBriefSlot
// 0x0020 (0x0510 - 0x04F0)
class UUI_MissionBriefSlot : public UPreviewableWidget
{
public:
	class UUI_RewardContainer*                    RewardContainer;                                   // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_MissionRepeatContainer*           RepeatContainer;                                   // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_CommonProgressBar*                ProgressBar;                                       // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMission*                               _mission;                                          // 0x0508(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitWidget(class UMission* _new_mission);
	void OnUpdateMission(EMissionUpdateType _type, class UMission* _updated_mission);
	void RequestReward();
	void SetCanReward(bool _can_reward);
	void SetDesc(const class FText& _text);
	void SetTitle(const class FText& _text);
	void ShowGoToButton(bool _show);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_MissionBriefSlot">();
	}
	static class UUI_MissionBriefSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_MissionBriefSlot>();
	}
};
static_assert(alignof(UUI_MissionBriefSlot) == 0x000008, "Wrong alignment on UUI_MissionBriefSlot");
static_assert(sizeof(UUI_MissionBriefSlot) == 0x000510, "Wrong size on UUI_MissionBriefSlot");
static_assert(offsetof(UUI_MissionBriefSlot, RewardContainer) == 0x0004F0, "Member 'UUI_MissionBriefSlot::RewardContainer' has a wrong offset!");
static_assert(offsetof(UUI_MissionBriefSlot, RepeatContainer) == 0x0004F8, "Member 'UUI_MissionBriefSlot::RepeatContainer' has a wrong offset!");
static_assert(offsetof(UUI_MissionBriefSlot, ProgressBar) == 0x000500, "Member 'UUI_MissionBriefSlot::ProgressBar' has a wrong offset!");
static_assert(offsetof(UUI_MissionBriefSlot, _mission) == 0x000508, "Member 'UUI_MissionBriefSlot::_mission' has a wrong offset!");

// Class Stigma.UI_MissionBriefSlot_Track
// 0x0000 (0x0510 - 0x0510)
class UUI_MissionBriefSlot_Track : public UUI_MissionBriefSlot
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_MissionBriefSlot_Track">();
	}
	static class UUI_MissionBriefSlot_Track* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_MissionBriefSlot_Track>();
	}
};
static_assert(alignof(UUI_MissionBriefSlot_Track) == 0x000008, "Wrong alignment on UUI_MissionBriefSlot_Track");
static_assert(sizeof(UUI_MissionBriefSlot_Track) == 0x000510, "Wrong size on UUI_MissionBriefSlot_Track");

// Class Stigma.UI_MissionBriefTab
// 0x0010 (0x0500 - 0x04F0)
class UUI_MissionBriefTab : public UPreviewableWidget
{
public:
	uint8                                         Pad_2604[0x10];                                    // 0x04F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnButtonClicked(ESideViewSide _side);
	void SetIcon(const TSoftObjectPtr<class UTexture2D>& _Icon);
	void SetTitleText(const class FText& _text);
	void ShowButtons(bool _show);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_MissionBriefTab">();
	}
	static class UUI_MissionBriefTab* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_MissionBriefTab>();
	}
};
static_assert(alignof(UUI_MissionBriefTab) == 0x000008, "Wrong alignment on UUI_MissionBriefTab");
static_assert(sizeof(UUI_MissionBriefTab) == 0x000500, "Wrong size on UUI_MissionBriefTab");

// Class Stigma.WaitingRoom_AICharacter
// 0x0000 (0x3840 - 0x3840)
class AWaitingRoom_AICharacter final : public AAICharaBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaitingRoom_AICharacter">();
	}
	static class AWaitingRoom_AICharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWaitingRoom_AICharacter>();
	}
};
static_assert(alignof(AWaitingRoom_AICharacter) == 0x000010, "Wrong alignment on AWaitingRoom_AICharacter");
static_assert(sizeof(AWaitingRoom_AICharacter) == 0x003840, "Wrong size on AWaitingRoom_AICharacter");

// Class Stigma.UI_MissionPopup
// 0x0068 (0x05D8 - 0x0570)
class UUI_MissionPopup : public UPopupBase
{
public:
	class UHorizontalBox*                         HB_PopupTab;                                       // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WS_PopupContainer;                                 // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_MissionPopupTab>        _MissionPopupTabClass;                             // 0x0580(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FMargin                                _TabPadding;                                       // 0x0588(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_MissionPopupContainerDaily> _MissionPopupContainerDailyClass;                  // 0x0598(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_MissionPopupContainerBattlePass> _MissionPopupContainerBattlePassClass;             // 0x05A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_MissionPopupContainerTrack> _MissionPopupContainerTrackClass;                  // 0x05A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_MissionPopupContainerMaster> _MissionPopupContainerMasterClass;                 // 0x05B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2605[0x20];                                    // 0x05B8(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void InitWidget(const struct FItemID& _to_show_task_id);
	void OnTabSelected(class UAnimatableWidget* _tab_widget, bool _selected);

	class UPreviewableWidget* GetCurrentContainerWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_MissionPopup">();
	}
	static class UUI_MissionPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_MissionPopup>();
	}
};
static_assert(alignof(UUI_MissionPopup) == 0x000008, "Wrong alignment on UUI_MissionPopup");
static_assert(sizeof(UUI_MissionPopup) == 0x0005D8, "Wrong size on UUI_MissionPopup");
static_assert(offsetof(UUI_MissionPopup, HB_PopupTab) == 0x000570, "Member 'UUI_MissionPopup::HB_PopupTab' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopup, WS_PopupContainer) == 0x000578, "Member 'UUI_MissionPopup::WS_PopupContainer' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopup, _MissionPopupTabClass) == 0x000580, "Member 'UUI_MissionPopup::_MissionPopupTabClass' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopup, _TabPadding) == 0x000588, "Member 'UUI_MissionPopup::_TabPadding' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopup, _MissionPopupContainerDailyClass) == 0x000598, "Member 'UUI_MissionPopup::_MissionPopupContainerDailyClass' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopup, _MissionPopupContainerBattlePassClass) == 0x0005A0, "Member 'UUI_MissionPopup::_MissionPopupContainerBattlePassClass' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopup, _MissionPopupContainerTrackClass) == 0x0005A8, "Member 'UUI_MissionPopup::_MissionPopupContainerTrackClass' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopup, _MissionPopupContainerMasterClass) == 0x0005B0, "Member 'UUI_MissionPopup::_MissionPopupContainerMasterClass' has a wrong offset!");

// Class Stigma.UI_MissionPopupContainerBattlePass
// 0x0068 (0x0558 - 0x04F0)
class UUI_MissionPopupContainerBattlePass : public UPreviewableWidget
{
public:
	class UUI_RemainDateTimer*                    RemainDateTimer;                                   // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      UGP_WeekTab;                                       // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WS_WeekContainer;                                  // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_RewardContainer*                    RewardContainer_Free;                              // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_RewardContainer*                    RewardContainer_Premium;                           // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_BattlePassLevel*                  UI_PassLevel;                                      // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_CommonProgressBar*                UI_ExpBar;                                         // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_PassMissionWeekTab>     _PassMissionWeekTabClass;                          // 0x0528(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_PassMissionWeekContainer> _PassMissionWeekContainerClass;                    // 0x0530(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemID_BattlePass                     _PassID;                                           // 0x0538(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2607[0x10];                                    // 0x0548(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void SetIsActivated(bool _is_activated);
	void SetNextReward(const struct FReward& _free_reward, const struct FReward& _premium_reward, bool _is_max_level);
	void SetTitleText(const class FText& _text);
	void ShowBuyPremiumBtn(bool _show);
	void ShowWeekMission(int32 _new_week);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_MissionPopupContainerBattlePass">();
	}
	static class UUI_MissionPopupContainerBattlePass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_MissionPopupContainerBattlePass>();
	}
};
static_assert(alignof(UUI_MissionPopupContainerBattlePass) == 0x000008, "Wrong alignment on UUI_MissionPopupContainerBattlePass");
static_assert(sizeof(UUI_MissionPopupContainerBattlePass) == 0x000558, "Wrong size on UUI_MissionPopupContainerBattlePass");
static_assert(offsetof(UUI_MissionPopupContainerBattlePass, RemainDateTimer) == 0x0004F0, "Member 'UUI_MissionPopupContainerBattlePass::RemainDateTimer' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupContainerBattlePass, UGP_WeekTab) == 0x0004F8, "Member 'UUI_MissionPopupContainerBattlePass::UGP_WeekTab' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupContainerBattlePass, WS_WeekContainer) == 0x000500, "Member 'UUI_MissionPopupContainerBattlePass::WS_WeekContainer' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupContainerBattlePass, RewardContainer_Free) == 0x000508, "Member 'UUI_MissionPopupContainerBattlePass::RewardContainer_Free' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupContainerBattlePass, RewardContainer_Premium) == 0x000510, "Member 'UUI_MissionPopupContainerBattlePass::RewardContainer_Premium' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupContainerBattlePass, UI_PassLevel) == 0x000518, "Member 'UUI_MissionPopupContainerBattlePass::UI_PassLevel' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupContainerBattlePass, UI_ExpBar) == 0x000520, "Member 'UUI_MissionPopupContainerBattlePass::UI_ExpBar' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupContainerBattlePass, _PassMissionWeekTabClass) == 0x000528, "Member 'UUI_MissionPopupContainerBattlePass::_PassMissionWeekTabClass' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupContainerBattlePass, _PassMissionWeekContainerClass) == 0x000530, "Member 'UUI_MissionPopupContainerBattlePass::_PassMissionWeekContainerClass' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupContainerBattlePass, _PassID) == 0x000538, "Member 'UUI_MissionPopupContainerBattlePass::_PassID' has a wrong offset!");

// Class Stigma.UI_MissionPopupContainerDaily
// 0x0050 (0x0540 - 0x04F0)
class UUI_MissionPopupContainerDaily : public UPreviewableWidget
{
public:
	class UUI_RemainDateTimer*                    RemainDateTimer;                                   // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      UGP_MissionSlot;                                   // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_RewardItem*                         FinalRewardItem;                                   // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_MissionPopupSlotDaily>  _MissionPopupSlotDailyClass;                       // 0x0508(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _MaxMissionChangeCount;                            // 0x0510(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2609[0x4];                                     // 0x0514(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UMission*                               _FinalMission;                                     // 0x0518(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_260A[0x20];                                    // 0x0520(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnMissionUpdated(EMissionUpdateType _type, class UMission* _updated_mission);
	void OnReadNewMission();
	void ReadNewMission(TDelegate<void(EResultCode _rcode, struct FACK_MissionRead& _ack)> _proc);
	void RequestFinalReward(TDelegate<void(EResultCode _rcode, struct FACK_MissionReward& _ack)> _proc);
	void SetFinalMissionProgress(int32 _current_count, int32 _target_count);
	void SetFinalMissionProgressType(EMissionProgressType _type);
	void SetFinalMissionRewardText(const class FText& _text);
	void SetLocked(bool _locked, int32 _limited_level);
	void SetMissionChangeCount(int32 _current_count);
	void SetUserLevelExp(int32 _level, int32 _cur_exp, int32 _tar_exp);
	void ShowChangeInfoText(bool _show);
	void ShowFinalMissionRewardBtn(bool _show);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_MissionPopupContainerDaily">();
	}
	static class UUI_MissionPopupContainerDaily* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_MissionPopupContainerDaily>();
	}
};
static_assert(alignof(UUI_MissionPopupContainerDaily) == 0x000008, "Wrong alignment on UUI_MissionPopupContainerDaily");
static_assert(sizeof(UUI_MissionPopupContainerDaily) == 0x000540, "Wrong size on UUI_MissionPopupContainerDaily");
static_assert(offsetof(UUI_MissionPopupContainerDaily, RemainDateTimer) == 0x0004F0, "Member 'UUI_MissionPopupContainerDaily::RemainDateTimer' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupContainerDaily, UGP_MissionSlot) == 0x0004F8, "Member 'UUI_MissionPopupContainerDaily::UGP_MissionSlot' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupContainerDaily, FinalRewardItem) == 0x000500, "Member 'UUI_MissionPopupContainerDaily::FinalRewardItem' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupContainerDaily, _MissionPopupSlotDailyClass) == 0x000508, "Member 'UUI_MissionPopupContainerDaily::_MissionPopupSlotDailyClass' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupContainerDaily, _MaxMissionChangeCount) == 0x000510, "Member 'UUI_MissionPopupContainerDaily::_MaxMissionChangeCount' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupContainerDaily, _FinalMission) == 0x000518, "Member 'UUI_MissionPopupContainerDaily::_FinalMission' has a wrong offset!");

// Class Stigma.UI_MissionPopupSlotBattlePass
// 0x0040 (0x0530 - 0x04F0)
class UUI_MissionPopupSlotBattlePass : public UPreviewableWidget
{
public:
	class UUI_RewardContainer*                    RewardContainer;                                   // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_MissionRepeatContainer*           RepeatContainer;                                   // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_260D[0x28];                                    // 0x0500(0x0028)(Fixing Size After Last Property [ Dumper-69 ])
	class UMission*                               _mission;                                          // 0x0528(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnUpdateMission(EMissionUpdateType _type, class UMission* _updated_mission);
	void RequestReward();
	void SetBookmark(bool _bookmark);
	void SetCanReward(bool _can_reward);
	void SetDesc(const class FText& _text);
	void SetLocked(bool _locked);
	void SetProgress(EMissionProgressType _progress_type, int32 _count, int32 _target_count);
	void SetTitle(const class FText& _text);
	void ShowBookmarkBtn(bool _show);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_MissionPopupSlotBattlePass">();
	}
	static class UUI_MissionPopupSlotBattlePass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_MissionPopupSlotBattlePass>();
	}
};
static_assert(alignof(UUI_MissionPopupSlotBattlePass) == 0x000008, "Wrong alignment on UUI_MissionPopupSlotBattlePass");
static_assert(sizeof(UUI_MissionPopupSlotBattlePass) == 0x000530, "Wrong size on UUI_MissionPopupSlotBattlePass");
static_assert(offsetof(UUI_MissionPopupSlotBattlePass, RewardContainer) == 0x0004F0, "Member 'UUI_MissionPopupSlotBattlePass::RewardContainer' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupSlotBattlePass, RepeatContainer) == 0x0004F8, "Member 'UUI_MissionPopupSlotBattlePass::RepeatContainer' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupSlotBattlePass, _mission) == 0x000528, "Member 'UUI_MissionPopupSlotBattlePass::_mission' has a wrong offset!");

// Class Stigma.UI_MissionPopupSlotDaily
// 0x0038 (0x0528 - 0x04F0)
class UUI_MissionPopupSlotDaily : public UPreviewableWidget
{
public:
	class UUI_RewardContainer*                    RewardContainer;                                   // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_MissionRepeatContainer*           RepeatContainer;                                   // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemID_EventPage                      _DailyID;                                          // 0x0500(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemID_Mission                        _MissionID;                                        // 0x0510(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2610[0x8];                                     // 0x0520(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnUpdateMission(EMissionUpdateType _type, class UMission* _updated_mission);
	void RequestReward();
	void SetCanReward(bool _can_reward);
	void SetDesc(const class FText& _text);
	void SetProgress(EMissionProgressType _progress_type, int32 _count, int32 _target_count);
	void SetTitle(const class FText& _text);
	void ShowChangeBtn(bool _show);
	void UpdateDailyInfo(class UMission* _mission);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_MissionPopupSlotDaily">();
	}
	static class UUI_MissionPopupSlotDaily* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_MissionPopupSlotDaily>();
	}
};
static_assert(alignof(UUI_MissionPopupSlotDaily) == 0x000008, "Wrong alignment on UUI_MissionPopupSlotDaily");
static_assert(sizeof(UUI_MissionPopupSlotDaily) == 0x000528, "Wrong size on UUI_MissionPopupSlotDaily");
static_assert(offsetof(UUI_MissionPopupSlotDaily, RewardContainer) == 0x0004F0, "Member 'UUI_MissionPopupSlotDaily::RewardContainer' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupSlotDaily, RepeatContainer) == 0x0004F8, "Member 'UUI_MissionPopupSlotDaily::RepeatContainer' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupSlotDaily, _DailyID) == 0x000500, "Member 'UUI_MissionPopupSlotDaily::_DailyID' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupSlotDaily, _MissionID) == 0x000510, "Member 'UUI_MissionPopupSlotDaily::_MissionID' has a wrong offset!");

// Class Stigma.UI_MissionPopupSlotMaster
// 0x0038 (0x0528 - 0x04F0)
class UUI_MissionPopupSlotMaster : public UPreviewableWidget
{
public:
	class UUI_RewardContainer*                    RewardContainer;                                   // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_MissionRepeatContainer*           RepeatContainer;                                   // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemID_EventPage                      _MasterEventID;                                    // 0x0500(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemID_Mission                        _MissionID;                                        // 0x0510(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2613[0x8];                                     // 0x0520(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnUpdateMission(EMissionUpdateType _type, class UMission* _updated_mission);
	void RequestReward();
	void SetCanReward(bool _can_reward);
	void SetDesc(const class FText& _text);
	void SetProgress(EMissionProgressType _progress_type, int32 _count, int32 _target_count);
	void SetTitle(const class FText& _text);
	void ShowChangeBtn(bool _show);
	void UpdateMasterInfo(class UMission* _mission);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_MissionPopupSlotMaster">();
	}
	static class UUI_MissionPopupSlotMaster* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_MissionPopupSlotMaster>();
	}
};
static_assert(alignof(UUI_MissionPopupSlotMaster) == 0x000008, "Wrong alignment on UUI_MissionPopupSlotMaster");
static_assert(sizeof(UUI_MissionPopupSlotMaster) == 0x000528, "Wrong size on UUI_MissionPopupSlotMaster");
static_assert(offsetof(UUI_MissionPopupSlotMaster, RewardContainer) == 0x0004F0, "Member 'UUI_MissionPopupSlotMaster::RewardContainer' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupSlotMaster, RepeatContainer) == 0x0004F8, "Member 'UUI_MissionPopupSlotMaster::RepeatContainer' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupSlotMaster, _MasterEventID) == 0x000500, "Member 'UUI_MissionPopupSlotMaster::_MasterEventID' has a wrong offset!");
static_assert(offsetof(UUI_MissionPopupSlotMaster, _MissionID) == 0x000510, "Member 'UUI_MissionPopupSlotMaster::_MissionID' has a wrong offset!");

// Class Stigma.UI_MissionPopupTab
// 0x0010 (0x0500 - 0x04F0)
class UUI_MissionPopupTab : public UPreviewableWidget
{
public:
	uint8                                         Pad_2616[0x10];                                    // 0x04F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void HideWidgetSwithcer();
	void OnUpdateMission(EMissionUpdateType _type, class UMission* _updated_mission);
	void SetCompleted(bool _completed);
	void SetImminent(bool _imminent, const struct FTimespan& _remain_time_span);
	void SetLocked(bool _locked);
	void SetPassActivate(bool _activate);
	void SetRedDot(bool _red_dot);
	void SetTitle(const class FText& _text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_MissionPopupTab">();
	}
	static class UUI_MissionPopupTab* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_MissionPopupTab>();
	}
};
static_assert(alignof(UUI_MissionPopupTab) == 0x000008, "Wrong alignment on UUI_MissionPopupTab");
static_assert(sizeof(UUI_MissionPopupTab) == 0x000500, "Wrong size on UUI_MissionPopupTab");

// Class Stigma.UI_MissionSuccessSlot
// 0x0000 (0x04F0 - 0x04F0)
class UUI_MissionSuccessSlot : public UPreviewableWidget
{
public:
	void SetColor(const struct FLinearColor& _color);
	void SetTitle(const class FText& _text);
	void SetType(EMissionType _mission_type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_MissionSuccessSlot">();
	}
	static class UUI_MissionSuccessSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_MissionSuccessSlot>();
	}
};
static_assert(alignof(UUI_MissionSuccessSlot) == 0x000008, "Wrong alignment on UUI_MissionSuccessSlot");
static_assert(sizeof(UUI_MissionSuccessSlot) == 0x0004F0, "Wrong size on UUI_MissionSuccessSlot");

// Class Stigma.UI_ModeRecordItem
// 0x0000 (0x04F0 - 0x04F0)
class UUI_ModeRecordItem : public UPreviewableWidget
{
public:
	void SetValues(const struct FModeRecord& _records);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_ModeRecordItem">();
	}
	static class UUI_ModeRecordItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_ModeRecordItem>();
	}
};
static_assert(alignof(UUI_ModeRecordItem) == 0x000008, "Wrong alignment on UUI_ModeRecordItem");
static_assert(sizeof(UUI_ModeRecordItem) == 0x0004F0, "Wrong size on UUI_ModeRecordItem");

// Class Stigma.UI_MouseDetector
// 0x0028 (0x02E8 - 0x02C0)
class UUI_MouseDetector final : public UUserWidget
{
public:
	class UCanvasPanel*                           CanvasPanel;                                       // 0x02C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	FMulticastInlineDelegateProperty_             _OnMouseClickDetectedEvent;                        // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             _OnMouseWheelScrollDetectedEvent;                  // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_MouseDetector">();
	}
	static class UUI_MouseDetector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_MouseDetector>();
	}
};
static_assert(alignof(UUI_MouseDetector) == 0x000008, "Wrong alignment on UUI_MouseDetector");
static_assert(sizeof(UUI_MouseDetector) == 0x0002E8, "Wrong size on UUI_MouseDetector");
static_assert(offsetof(UUI_MouseDetector, CanvasPanel) == 0x0002C0, "Member 'UUI_MouseDetector::CanvasPanel' has a wrong offset!");
static_assert(offsetof(UUI_MouseDetector, _OnMouseClickDetectedEvent) == 0x0002C8, "Member 'UUI_MouseDetector::_OnMouseClickDetectedEvent' has a wrong offset!");
static_assert(offsetof(UUI_MouseDetector, _OnMouseWheelScrollDetectedEvent) == 0x0002D8, "Member 'UUI_MouseDetector::_OnMouseWheelScrollDetectedEvent' has a wrong offset!");

// Class Stigma.UI_Nickname
// 0x0008 (0x04F8 - 0x04F0)
class UUI_Nickname : public UPreviewableWidget
{
public:
	class ACharaBase*                             _owner;                                            // 0x04F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool SetNickname(const class FText& _text);
	bool SetPlayerSide(EPlayerSide _side);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Nickname">();
	}
	static class UUI_Nickname* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Nickname>();
	}
};
static_assert(alignof(UUI_Nickname) == 0x000008, "Wrong alignment on UUI_Nickname");
static_assert(sizeof(UUI_Nickname) == 0x0004F8, "Wrong size on UUI_Nickname");
static_assert(offsetof(UUI_Nickname, _owner) == 0x0004F0, "Member 'UUI_Nickname::_owner' has a wrong offset!");

// Class Stigma.UI_NoticePopup
// 0x0008 (0x0578 - 0x0570)
class UUI_NoticePopup : public UPopupBase
{
public:
	bool                                          _IsCheckedDoNotOpen;                               // 0x0570(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_261A[0x7];                                     // 0x0571(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void CheckDoNotOpen(bool _is_checked);
	void InitWidget(const struct FLoginNotice& _packet, bool _is_auto_open);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_NoticePopup">();
	}
	static class UUI_NoticePopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_NoticePopup>();
	}
};
static_assert(alignof(UUI_NoticePopup) == 0x000008, "Wrong alignment on UUI_NoticePopup");
static_assert(sizeof(UUI_NoticePopup) == 0x000578, "Wrong size on UUI_NoticePopup");
static_assert(offsetof(UUI_NoticePopup, _IsCheckedDoNotOpen) == 0x000570, "Member 'UUI_NoticePopup::_IsCheckedDoNotOpen' has a wrong offset!");

// Class Stigma.UI_OptionPageBase
// 0x0100 (0x05F0 - 0x04F0)
class UUI_OptionPageBase : public UPreviewableWidget
{
public:
	TMap<class FName, struct FOptionDescEntry>    _DescEntries;                                      // 0x04F0(0x0050)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_Option_TextDescriptionBase> _TextDescWidget;                                   // 0x0540(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                _CurDescWidget;                                    // 0x0548(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           ContentsContainer;                                 // 0x0550(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           Desc_Container;                                    // 0x0558(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        Desc_Switcher;                                     // 0x0560(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_261C[0x10];                                    // 0x0568(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	TMap<class UWidget*, int32>                   _DescIndexMap;                                     // 0x0578(0x0050)(Edit, BlueprintVisible, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_261D[0x28];                                    // 0x05C8(0x0028)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ApplyCurTabOptionAsRealTime();
	EOptionCategoryType GetPageType();
	void Init();
	void InvokeOnPageContextChanged(bool _apply_real_time);
	void OnAfterApplyOptions();
	void OnPanelHoverChanged(const class UCtrl_OptionItemEntry* _panel, bool _is_hover);
	void RegisterOnPageDataChanged(const TDelegate<void(class UUI_OptionPageBase* _page)>& _callback);
	void Setup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_OptionPageBase">();
	}
	static class UUI_OptionPageBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_OptionPageBase>();
	}
};
static_assert(alignof(UUI_OptionPageBase) == 0x000008, "Wrong alignment on UUI_OptionPageBase");
static_assert(sizeof(UUI_OptionPageBase) == 0x0005F0, "Wrong size on UUI_OptionPageBase");
static_assert(offsetof(UUI_OptionPageBase, _DescEntries) == 0x0004F0, "Member 'UUI_OptionPageBase::_DescEntries' has a wrong offset!");
static_assert(offsetof(UUI_OptionPageBase, _TextDescWidget) == 0x000540, "Member 'UUI_OptionPageBase::_TextDescWidget' has a wrong offset!");
static_assert(offsetof(UUI_OptionPageBase, _CurDescWidget) == 0x000548, "Member 'UUI_OptionPageBase::_CurDescWidget' has a wrong offset!");
static_assert(offsetof(UUI_OptionPageBase, ContentsContainer) == 0x000550, "Member 'UUI_OptionPageBase::ContentsContainer' has a wrong offset!");
static_assert(offsetof(UUI_OptionPageBase, Desc_Container) == 0x000558, "Member 'UUI_OptionPageBase::Desc_Container' has a wrong offset!");
static_assert(offsetof(UUI_OptionPageBase, Desc_Switcher) == 0x000560, "Member 'UUI_OptionPageBase::Desc_Switcher' has a wrong offset!");
static_assert(offsetof(UUI_OptionPageBase, _DescIndexMap) == 0x000578, "Member 'UUI_OptionPageBase::_DescIndexMap' has a wrong offset!");

// Class Stigma.UI_OptionPopupBase
// 0x0020 (0x0590 - 0x0570)
class UUI_OptionPopupBase : public UPopupBase
{
public:
	class UUI_OptionPageBase*                     _CurShowPage;                                      // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<bool>                                  _HasChangedDataExists;                             // 0x0578(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UMessageBox>                _YesorNoPopupClass;                                // 0x0588(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnClickApplyButton();
	void OnProcReset(EOptionPopupResetType _reset_type);
	void ProcUpdateOptionContext(int32 _page_idx);
	void UpdateApplyAndResetButtons();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_OptionPopupBase">();
	}
	static class UUI_OptionPopupBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_OptionPopupBase>();
	}
};
static_assert(alignof(UUI_OptionPopupBase) == 0x000008, "Wrong alignment on UUI_OptionPopupBase");
static_assert(sizeof(UUI_OptionPopupBase) == 0x000590, "Wrong size on UUI_OptionPopupBase");
static_assert(offsetof(UUI_OptionPopupBase, _CurShowPage) == 0x000570, "Member 'UUI_OptionPopupBase::_CurShowPage' has a wrong offset!");
static_assert(offsetof(UUI_OptionPopupBase, _HasChangedDataExists) == 0x000578, "Member 'UUI_OptionPopupBase::_HasChangedDataExists' has a wrong offset!");
static_assert(offsetof(UUI_OptionPopupBase, _YesorNoPopupClass) == 0x000588, "Member 'UUI_OptionPopupBase::_YesorNoPopupClass' has a wrong offset!");

// Class Stigma.UI_OptionResetMessageBoxBase
// 0x0028 (0x0598 - 0x0570)
class UUI_OptionResetMessageBoxBase : public UPopupBase
{
public:
	class URichTextBlock*                         TXT_Message;                                       // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URadioButton*                           Radio_ResetDefault;                                // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URadioButton*                           Radio_RevertOriginal;                              // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URichTextBlock*                         AdditionalAlertText;                               // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_261F[0x8];                                     // 0x0590(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	EOptionPopupResetType GetSelectedResetType();
	void SelectResetDefault();
	void SelectRevertOriginal();
	void SetActiveAdditionalAlertText(bool _flag);
	void SetCurrentTab(EOptionCategoryType _tab_type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_OptionResetMessageBoxBase">();
	}
	static class UUI_OptionResetMessageBoxBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_OptionResetMessageBoxBase>();
	}
};
static_assert(alignof(UUI_OptionResetMessageBoxBase) == 0x000008, "Wrong alignment on UUI_OptionResetMessageBoxBase");
static_assert(sizeof(UUI_OptionResetMessageBoxBase) == 0x000598, "Wrong size on UUI_OptionResetMessageBoxBase");
static_assert(offsetof(UUI_OptionResetMessageBoxBase, TXT_Message) == 0x000570, "Member 'UUI_OptionResetMessageBoxBase::TXT_Message' has a wrong offset!");
static_assert(offsetof(UUI_OptionResetMessageBoxBase, Radio_ResetDefault) == 0x000578, "Member 'UUI_OptionResetMessageBoxBase::Radio_ResetDefault' has a wrong offset!");
static_assert(offsetof(UUI_OptionResetMessageBoxBase, Radio_RevertOriginal) == 0x000580, "Member 'UUI_OptionResetMessageBoxBase::Radio_RevertOriginal' has a wrong offset!");
static_assert(offsetof(UUI_OptionResetMessageBoxBase, AdditionalAlertText) == 0x000588, "Member 'UUI_OptionResetMessageBoxBase::AdditionalAlertText' has a wrong offset!");

// Class Stigma.UI_Option_ActionKeyDescBase
// 0x0030 (0x0520 - 0x04F0)
class UUI_Option_ActionKeyDescBase : public UUI_Option_DescBase
{
public:
	class UTextBlock*                             TXT_DescTitle;                                     // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_DescContext;                                   // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           V_Duplicates;                                      // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           V_KeyBindDesc;                                     // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_KeyBindDesc;                                   // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_DuplicateKeyPanelBase>  Panel_DuplicatesKey;                               // 0x0518(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Option_ActionKeyDescBase">();
	}
	static class UUI_Option_ActionKeyDescBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Option_ActionKeyDescBase>();
	}
};
static_assert(alignof(UUI_Option_ActionKeyDescBase) == 0x000008, "Wrong alignment on UUI_Option_ActionKeyDescBase");
static_assert(sizeof(UUI_Option_ActionKeyDescBase) == 0x000520, "Wrong size on UUI_Option_ActionKeyDescBase");
static_assert(offsetof(UUI_Option_ActionKeyDescBase, TXT_DescTitle) == 0x0004F0, "Member 'UUI_Option_ActionKeyDescBase::TXT_DescTitle' has a wrong offset!");
static_assert(offsetof(UUI_Option_ActionKeyDescBase, TXT_DescContext) == 0x0004F8, "Member 'UUI_Option_ActionKeyDescBase::TXT_DescContext' has a wrong offset!");
static_assert(offsetof(UUI_Option_ActionKeyDescBase, V_Duplicates) == 0x000500, "Member 'UUI_Option_ActionKeyDescBase::V_Duplicates' has a wrong offset!");
static_assert(offsetof(UUI_Option_ActionKeyDescBase, V_KeyBindDesc) == 0x000508, "Member 'UUI_Option_ActionKeyDescBase::V_KeyBindDesc' has a wrong offset!");
static_assert(offsetof(UUI_Option_ActionKeyDescBase, TXT_KeyBindDesc) == 0x000510, "Member 'UUI_Option_ActionKeyDescBase::TXT_KeyBindDesc' has a wrong offset!");
static_assert(offsetof(UUI_Option_ActionKeyDescBase, Panel_DuplicatesKey) == 0x000518, "Member 'UUI_Option_ActionKeyDescBase::Panel_DuplicatesKey' has a wrong offset!");

// Class Stigma.UI_Option_Audio
// 0x00E0 (0x06D0 - 0x05F0)
class UUI_Option_Audio : public UUI_OptionPageBase
{
public:
	class UCtrl_OptionItemPanelBase*              Panel_MasterVolume;                                // 0x05F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 Slider_MasterVolume;                               // 0x05F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_AnnouncerVoice;                              // 0x0600(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionDropDownBase*               ComboBox_AnnouncerVoice;                           // 0x0608(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_TotalBGMVolume;                              // 0x0610(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 Slider_TotalBGMVolume;                             // 0x0618(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_LobbyBGMVolume;                              // 0x0620(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 Slider_LobbyBGMVolume;                             // 0x0628(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_BattleBGMVolume;                             // 0x0630(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 Slider_BattleBGMVolume;                            // 0x0638(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_TotalFXVolume;                               // 0x0640(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 Slider_TotalFXVolume;                              // 0x0648(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_FootPrintFXVolume;                           // 0x0650(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 Slider_FootPrintFXVolume;                          // 0x0658(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_HitDetectionFXVolume;                        // 0x0660(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 Slider_HitDetectionFXVolume;                       // 0x0668(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_CartridgeFXVolume;                           // 0x0670(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 Slider_CartridgeFXVolume;                          // 0x0678(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_AmbientFXVolume;                             // 0x0680(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 Slider_AmbientFXVolume;                            // 0x0688(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_UIFXVolume;                                  // 0x0690(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 Slider_UIFXVolume;                                 // 0x0698(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_TotalVoiceVolume;                            // 0x06A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 Slider_TotalVoiceVolume;                           // 0x06A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_AnnounceVoiceVolume;                         // 0x06B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 Slider_AnnounceVoiceVolume;                        // 0x06B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_CharaVoiceVolume;                            // 0x06C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 Slider_CharaVoiceVolume;                           // 0x06C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Option_Audio">();
	}
	static class UUI_Option_Audio* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Option_Audio>();
	}
};
static_assert(alignof(UUI_Option_Audio) == 0x000008, "Wrong alignment on UUI_Option_Audio");
static_assert(sizeof(UUI_Option_Audio) == 0x0006D0, "Wrong size on UUI_Option_Audio");
static_assert(offsetof(UUI_Option_Audio, Panel_MasterVolume) == 0x0005F0, "Member 'UUI_Option_Audio::Panel_MasterVolume' has a wrong offset!");
static_assert(offsetof(UUI_Option_Audio, Slider_MasterVolume) == 0x0005F8, "Member 'UUI_Option_Audio::Slider_MasterVolume' has a wrong offset!");
static_assert(offsetof(UUI_Option_Audio, Panel_AnnouncerVoice) == 0x000600, "Member 'UUI_Option_Audio::Panel_AnnouncerVoice' has a wrong offset!");
static_assert(offsetof(UUI_Option_Audio, ComboBox_AnnouncerVoice) == 0x000608, "Member 'UUI_Option_Audio::ComboBox_AnnouncerVoice' has a wrong offset!");
static_assert(offsetof(UUI_Option_Audio, Panel_TotalBGMVolume) == 0x000610, "Member 'UUI_Option_Audio::Panel_TotalBGMVolume' has a wrong offset!");
static_assert(offsetof(UUI_Option_Audio, Slider_TotalBGMVolume) == 0x000618, "Member 'UUI_Option_Audio::Slider_TotalBGMVolume' has a wrong offset!");
static_assert(offsetof(UUI_Option_Audio, Panel_LobbyBGMVolume) == 0x000620, "Member 'UUI_Option_Audio::Panel_LobbyBGMVolume' has a wrong offset!");
static_assert(offsetof(UUI_Option_Audio, Slider_LobbyBGMVolume) == 0x000628, "Member 'UUI_Option_Audio::Slider_LobbyBGMVolume' has a wrong offset!");
static_assert(offsetof(UUI_Option_Audio, Panel_BattleBGMVolume) == 0x000630, "Member 'UUI_Option_Audio::Panel_BattleBGMVolume' has a wrong offset!");
static_assert(offsetof(UUI_Option_Audio, Slider_BattleBGMVolume) == 0x000638, "Member 'UUI_Option_Audio::Slider_BattleBGMVolume' has a wrong offset!");
static_assert(offsetof(UUI_Option_Audio, Panel_TotalFXVolume) == 0x000640, "Member 'UUI_Option_Audio::Panel_TotalFXVolume' has a wrong offset!");
static_assert(offsetof(UUI_Option_Audio, Slider_TotalFXVolume) == 0x000648, "Member 'UUI_Option_Audio::Slider_TotalFXVolume' has a wrong offset!");
static_assert(offsetof(UUI_Option_Audio, Panel_FootPrintFXVolume) == 0x000650, "Member 'UUI_Option_Audio::Panel_FootPrintFXVolume' has a wrong offset!");
static_assert(offsetof(UUI_Option_Audio, Slider_FootPrintFXVolume) == 0x000658, "Member 'UUI_Option_Audio::Slider_FootPrintFXVolume' has a wrong offset!");
static_assert(offsetof(UUI_Option_Audio, Panel_HitDetectionFXVolume) == 0x000660, "Member 'UUI_Option_Audio::Panel_HitDetectionFXVolume' has a wrong offset!");
static_assert(offsetof(UUI_Option_Audio, Slider_HitDetectionFXVolume) == 0x000668, "Member 'UUI_Option_Audio::Slider_HitDetectionFXVolume' has a wrong offset!");
static_assert(offsetof(UUI_Option_Audio, Panel_CartridgeFXVolume) == 0x000670, "Member 'UUI_Option_Audio::Panel_CartridgeFXVolume' has a wrong offset!");
static_assert(offsetof(UUI_Option_Audio, Slider_CartridgeFXVolume) == 0x000678, "Member 'UUI_Option_Audio::Slider_CartridgeFXVolume' has a wrong offset!");
static_assert(offsetof(UUI_Option_Audio, Panel_AmbientFXVolume) == 0x000680, "Member 'UUI_Option_Audio::Panel_AmbientFXVolume' has a wrong offset!");
static_assert(offsetof(UUI_Option_Audio, Slider_AmbientFXVolume) == 0x000688, "Member 'UUI_Option_Audio::Slider_AmbientFXVolume' has a wrong offset!");
static_assert(offsetof(UUI_Option_Audio, Panel_UIFXVolume) == 0x000690, "Member 'UUI_Option_Audio::Panel_UIFXVolume' has a wrong offset!");
static_assert(offsetof(UUI_Option_Audio, Slider_UIFXVolume) == 0x000698, "Member 'UUI_Option_Audio::Slider_UIFXVolume' has a wrong offset!");
static_assert(offsetof(UUI_Option_Audio, Panel_TotalVoiceVolume) == 0x0006A0, "Member 'UUI_Option_Audio::Panel_TotalVoiceVolume' has a wrong offset!");
static_assert(offsetof(UUI_Option_Audio, Slider_TotalVoiceVolume) == 0x0006A8, "Member 'UUI_Option_Audio::Slider_TotalVoiceVolume' has a wrong offset!");
static_assert(offsetof(UUI_Option_Audio, Panel_AnnounceVoiceVolume) == 0x0006B0, "Member 'UUI_Option_Audio::Panel_AnnounceVoiceVolume' has a wrong offset!");
static_assert(offsetof(UUI_Option_Audio, Slider_AnnounceVoiceVolume) == 0x0006B8, "Member 'UUI_Option_Audio::Slider_AnnounceVoiceVolume' has a wrong offset!");
static_assert(offsetof(UUI_Option_Audio, Panel_CharaVoiceVolume) == 0x0006C0, "Member 'UUI_Option_Audio::Panel_CharaVoiceVolume' has a wrong offset!");
static_assert(offsetof(UUI_Option_Audio, Slider_CharaVoiceVolume) == 0x0006C8, "Member 'UUI_Option_Audio::Slider_CharaVoiceVolume' has a wrong offset!");

// Class Stigma.UI_Option_ColorBlindDescBase
// 0x0038 (0x0528 - 0x04F0)
class UUI_Option_ColorBlindDescBase : public UUI_Option_DescBase
{
public:
	class UTextBlock*                             TXT_DescTitle;                                     // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_DescContext;                                   // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Allies_Color;                                      // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Enemies_Color;                                     // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 My_Color;                                          // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Party_Color;                                       // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Team_Color;                                        // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Setup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Option_ColorBlindDescBase">();
	}
	static class UUI_Option_ColorBlindDescBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Option_ColorBlindDescBase>();
	}
};
static_assert(alignof(UUI_Option_ColorBlindDescBase) == 0x000008, "Wrong alignment on UUI_Option_ColorBlindDescBase");
static_assert(sizeof(UUI_Option_ColorBlindDescBase) == 0x000528, "Wrong size on UUI_Option_ColorBlindDescBase");
static_assert(offsetof(UUI_Option_ColorBlindDescBase, TXT_DescTitle) == 0x0004F0, "Member 'UUI_Option_ColorBlindDescBase::TXT_DescTitle' has a wrong offset!");
static_assert(offsetof(UUI_Option_ColorBlindDescBase, TXT_DescContext) == 0x0004F8, "Member 'UUI_Option_ColorBlindDescBase::TXT_DescContext' has a wrong offset!");
static_assert(offsetof(UUI_Option_ColorBlindDescBase, Allies_Color) == 0x000500, "Member 'UUI_Option_ColorBlindDescBase::Allies_Color' has a wrong offset!");
static_assert(offsetof(UUI_Option_ColorBlindDescBase, Enemies_Color) == 0x000508, "Member 'UUI_Option_ColorBlindDescBase::Enemies_Color' has a wrong offset!");
static_assert(offsetof(UUI_Option_ColorBlindDescBase, My_Color) == 0x000510, "Member 'UUI_Option_ColorBlindDescBase::My_Color' has a wrong offset!");
static_assert(offsetof(UUI_Option_ColorBlindDescBase, Party_Color) == 0x000518, "Member 'UUI_Option_ColorBlindDescBase::Party_Color' has a wrong offset!");
static_assert(offsetof(UUI_Option_ColorBlindDescBase, Team_Color) == 0x000520, "Member 'UUI_Option_ColorBlindDescBase::Team_Color' has a wrong offset!");

// Class Stigma.UI_Option_Control
// 0x0848 (0x0E38 - 0x05F0)
class UUI_Option_Control : public UUI_OptionPageBase
{
public:
	uint8                                         Pad_2620[0x18];                                    // 0x05F0(0x0018)(Fixing Size After Last Property [ Dumper-69 ])
	class UCtrl_ControlMasterTabBase*             Ctrl_Control_MasterTab;                            // 0x0608(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_SensitivityOnAim;                            // 0x0610(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 Slider_SensitivityOnAim;                           // 0x0618(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_SensitivityOnSnipeAim;                       // 0x0620(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 Slider_SensitivityOnSnipeAim;                      // 0x0628(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_SensitivityAtNormal;                         // 0x0630(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 Slider_SensitivityAtNormal;                        // 0x0638(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_HorizontalInvert;                            // 0x0640(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_RadioButtonGroupBase*             Radio_HorizontalInvert;                            // 0x0648(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_VerticalInvert;                              // 0x0650(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_RadioButtonGroupBase*             Radio_VerticalInvert;                              // 0x0658(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_Forward;                                     // 0x0660(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_Forward;                       // 0x0668(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_Forward;                      // 0x0670(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_Forward;                   // 0x0678(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_Backward;                                    // 0x0680(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_Backward;                      // 0x0688(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_Backward;                     // 0x0690(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_Backward;                  // 0x0698(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_Left;                                        // 0x06A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_Left;                          // 0x06A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_Left;                         // 0x06B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_Left;                      // 0x06B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_Right;                                       // 0x06C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_Right;                         // 0x06C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_Right;                        // 0x06D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_Right;                     // 0x06D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_Crouch;                                      // 0x06E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_Crouch;                        // 0x06E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_Crouch;                       // 0x06F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_Crouch;                    // 0x06F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_HoldCrouch;                                  // 0x0700(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_RadioButtonGroupBase*             Radio_HoldCrouch;                                  // 0x0708(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_Interaction;                                 // 0x0710(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_Interaction;                   // 0x0718(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_Interaction;                  // 0x0720(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_Interaction;               // 0x0728(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_OpenStore;                                   // 0x0730(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_OpenStore;                     // 0x0738(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_OpenStore;                    // 0x0740(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_OpenStore;                 // 0x0748(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_Fire;                                        // 0x0750(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_Fire;                          // 0x0758(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_Fire;                         // 0x0760(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_Fire;                      // 0x0768(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_Aiming;                                      // 0x0770(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_Aiming;                        // 0x0778(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_Aiming;                       // 0x0780(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_Aiming;                    // 0x0788(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_HoldAiming;                                  // 0x0790(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_RadioButtonGroupBase*             Radio_HoldAiming;                                  // 0x0798(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_Reload;                                      // 0x07A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_Reload;                        // 0x07A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_Reload;                       // 0x07B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_Reload;                    // 0x07B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_ShowLaserSight;                              // 0x07C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_ShowLaserSight;                // 0x07C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_ShowLaserSight;               // 0x07D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_ShowLaserSight;            // 0x07D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_SendPing;                                    // 0x07E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_SendPing;                      // 0x07E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_SendPing;                     // 0x07F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_SendPing;                  // 0x07F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_SelectPing;                                  // 0x0800(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_SelectPing;                    // 0x0808(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_SelectPing;                   // 0x0810(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_SelectPing;                // 0x0818(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_ActiveSkill1;                                // 0x0820(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_ActiveSkill1;                  // 0x0828(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_ActiveSkill1;                 // 0x0830(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_ActiveSkill1;              // 0x0838(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_ActiveSkill2;                                // 0x0840(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_ActiveSkill2;                  // 0x0848(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_ActiveSkill2;                 // 0x0850(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_ActiveSkill2;              // 0x0858(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_ActiveSkill3;                                // 0x0860(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_ActiveSkill3;                  // 0x0868(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_ActiveSkill3;                 // 0x0870(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_ActiveSkill3;              // 0x0878(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_FastMove;                                    // 0x0880(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_FastMove;                      // 0x0888(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_FastMove;                     // 0x0890(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_FastMove;                  // 0x0898(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_BoosterSlot1;                                // 0x08A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_BoosterSlot1;                  // 0x08A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_BoosterSlot1;                 // 0x08B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_BoosterSlot1;              // 0x08B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_BoosterSlot2;                                // 0x08C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_BoosterSlot2;                  // 0x08C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_BoosterSlot2;                 // 0x08D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_BoosterSlot2;              // 0x08D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_BoosterSlot3;                                // 0x08E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_BoosterSlot3;                  // 0x08E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_BoosterSlot3;                 // 0x08F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_BoosterSlot3;              // 0x08F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_BoosterSlot4;                                // 0x0900(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_BoosterSlot4;                  // 0x0908(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_BoosterSlot4;                 // 0x0910(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_BoosterSlot4;              // 0x0918(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_ShowStatusBoard;                             // 0x0920(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_ShowStatusBoard;               // 0x0928(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_ShowStatusBoard;              // 0x0930(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_ShowStatusBoard;           // 0x0938(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_HoldShowStatusBoard;                         // 0x0940(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_RadioButtonGroupBase*             Radio_HoldShowStatusBoard;                         // 0x0948(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_NoticeActiveSkillCombo;                      // 0x0950(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_RadioButtonGroupBase*             Radio_NoticeActiveSkillCombo;                      // 0x0958(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_RadioChatAll;                                // 0x0960(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_RadioChatAll;                  // 0x0968(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_RadioChatAll;                 // 0x0970(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_RadioChatAll;              // 0x0978(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_RadioChat1;                                  // 0x0980(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_RadioChat1;                    // 0x0988(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_RadioChat1;                   // 0x0990(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_RadioChat1;                // 0x0998(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_RadioChat2;                                  // 0x09A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_RadioChat2;                    // 0x09A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_RadioChat2;                   // 0x09B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_RadioChat2;                // 0x09B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_RadioChat3;                                  // 0x09C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_RadioChat3;                    // 0x09C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_RadioChat3;                   // 0x09D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_RadioChat3;                // 0x09D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_RadioChat4;                                  // 0x09E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_RadioChat4;                    // 0x09E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_RadioChat4;                   // 0x09F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_RadioChat4;                // 0x09F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_HideHUD;                                     // 0x0A00(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_HideHUD;                       // 0x0A08(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_HideHUD;                      // 0x0A10(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_HideHUD;                   // 0x0A18(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_AutoBoosters;                                // 0x0A20(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_AutoBoosters;                  // 0x0A28(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_AutoBoosters;                 // 0x0A30(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_AutoBoosters;              // 0x0A38(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_AutoBoosters_Radio;                          // 0x0A40(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_RadioButtonGroupBase*             Radio_AutoBoosters;                                // 0x0A48(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_SteamScreenshot;                             // 0x0A50(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_SteamScreenshot;               // 0x0A58(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_SteamScreenshot;              // 0x0A60(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_SteamScreenshot;           // 0x0A68(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_GamePause;                                   // 0x0A70(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_GamePause;                     // 0x0A78(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_GamePause;                    // 0x0A80(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_GamePause;                 // 0x0A88(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_PlayerSightLine;                             // 0x0A90(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_PlayerSightLine;               // 0x0A98(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_PlayerSightLine;              // 0x0AA0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_PlayerSightLine;           // 0x0AA8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_Player1Camera;                               // 0x0AB0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_Player1Camera;                 // 0x0AB8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_Player1Camera;                // 0x0AC0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_Player1Camera;             // 0x0AC8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_Player2Camera;                               // 0x0AD0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_Player2Camera;                 // 0x0AD8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_Player2Camera;                // 0x0AE0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_Player2Camera;             // 0x0AE8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_Player3Camera;                               // 0x0AF0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_Player3Camera;                 // 0x0AF8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_Player3Camera;                // 0x0B00(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_Player3Camera;             // 0x0B08(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_Player4Camera;                               // 0x0B10(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_Player4Camera;                 // 0x0B18(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_Player4Camera;                // 0x0B20(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_Player4Camera;             // 0x0B28(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_Player5Camera;                               // 0x0B30(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_Player5Camera;                 // 0x0B38(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_Player5Camera;                // 0x0B40(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_Player5Camera;             // 0x0B48(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_Player6Camera;                               // 0x0B50(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_Player6Camera;                 // 0x0B58(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_Player6Camera;                // 0x0B60(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_Player6Camera;             // 0x0B68(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_Player7Camera;                               // 0x0B70(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_Player7Camera;                 // 0x0B78(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_Player7Camera;                // 0x0B80(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_Player7Camera;             // 0x0B88(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_Player8Camera;                               // 0x0B90(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_Player8Camera;                 // 0x0B98(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_Player8Camera;                // 0x0BA0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_Player8Camera;             // 0x0BA8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_Player9Camera;                               // 0x0BB0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_Player9Camera;                 // 0x0BB8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_Player9Camera;                // 0x0BC0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_Player9Camera;             // 0x0BC8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_Player10Camera;                              // 0x0BD0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_Player10Camera;                // 0x0BD8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_Player10Camera;               // 0x0BE0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_Player10Camera;            // 0x0BE8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_Player11Camera;                              // 0x0BF0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_Player11Camera;                // 0x0BF8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_Player11Camera;               // 0x0C00(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_Player11Camera;            // 0x0C08(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_Player12Camera;                              // 0x0C10(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_Player12Camera;                // 0x0C18(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_Player12Camera;               // 0x0C20(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_Player12Camera;            // 0x0C28(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_NextPlayerCamera;                            // 0x0C30(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_NextPlayerCamera;              // 0x0C38(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_NextPlayerCamera;             // 0x0C40(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_NextPlayerCamera;          // 0x0C48(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_PrevPlayerCamera;                            // 0x0C50(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_PrevPlayerCamera;              // 0x0C58(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_PrevPlayerCamera;             // 0x0C60(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_PrevPlayerCamera;          // 0x0C68(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_FreeCamera;                                  // 0x0C70(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_FreeCamera;                    // 0x0C78(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_FreeCamera;                   // 0x0C80(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_FreeCamera;                // 0x0C88(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_CameraForward;                               // 0x0C90(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_CameraForward;                 // 0x0C98(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_CameraForward;                // 0x0CA0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_CameraForward;             // 0x0CA8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_CameraBackward;                              // 0x0CB0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_CameraBackward;                // 0x0CB8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_CameraBackward;               // 0x0CC0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_CameraBackward;            // 0x0CC8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_CameraLeft;                                  // 0x0CD0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_CameraLeft;                    // 0x0CD8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_CameraLeft;                   // 0x0CE0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_CameraLeft;                // 0x0CE8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_CameraRight;                                 // 0x0CF0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_CameraRight;                   // 0x0CF8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_CameraRight;                  // 0x0D00(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_CameraRight;               // 0x0D08(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_CharacterOrbitCamera;                        // 0x0D10(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_CharacterOrbitCamera;          // 0x0D18(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_CharacterOrbitCamera;         // 0x0D20(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_CharacterOrbitCamera;      // 0x0D28(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_FixedCamera1;                                // 0x0D30(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_FixedCamera1;                  // 0x0D38(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_FixedCamera1;                 // 0x0D40(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_FixedCamera1;              // 0x0D48(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_FixedCamera2;                                // 0x0D50(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_FixedCamera2;                  // 0x0D58(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_FixedCamera2;                 // 0x0D60(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_FixedCamera2;              // 0x0D68(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_FixedCamera3;                                // 0x0D70(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_FixedCamera3;                  // 0x0D78(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_FixedCamera3;                 // 0x0D80(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_FixedCamera3;              // 0x0D88(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_FixedCamera4;                                // 0x0D90(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_FixedCamera4;                  // 0x0D98(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_FixedCamera4;                 // 0x0DA0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_FixedCamera4;              // 0x0DA8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_FixedCamera5;                                // 0x0DB0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_FixedCamera5;                  // 0x0DB8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_FixedCamera5;                 // 0x0DC0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_FixedCamera5;              // 0x0DC8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_FixedCamera6;                                // 0x0DD0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_FixedCamera6;                  // 0x0DD8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_FixedCamera6;                 // 0x0DE0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_FixedCamera6;              // 0x0DE8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_FixedCamera7;                                // 0x0DF0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_FixedCamera7;                  // 0x0DF8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_FixedCamera7;                 // 0x0E00(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_FixedCamera7;              // 0x0E08(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_FixedCamera8;                                // 0x0E10(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_First_FixedCamera8;                  // 0x0E18(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_KBM_Second_FixedCamera8;                 // 0x0E20(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionKeyBindBase*                KeyBinder_GamePad_First_FixedCamera8;              // 0x0E28(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2621[0x8];                                     // 0x0E30(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void InvokeOnKeyMappingChanged();
	void RegisterOnKeyMappingChanged(const TDelegate<void()>& _callback);
	void UnRegisterOnKeyMappingChanged(class UObject* _binder);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Option_Control">();
	}
	static class UUI_Option_Control* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Option_Control>();
	}
};
static_assert(alignof(UUI_Option_Control) == 0x000008, "Wrong alignment on UUI_Option_Control");
static_assert(sizeof(UUI_Option_Control) == 0x000E38, "Wrong size on UUI_Option_Control");
static_assert(offsetof(UUI_Option_Control, Ctrl_Control_MasterTab) == 0x000608, "Member 'UUI_Option_Control::Ctrl_Control_MasterTab' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_SensitivityOnAim) == 0x000610, "Member 'UUI_Option_Control::Panel_SensitivityOnAim' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Slider_SensitivityOnAim) == 0x000618, "Member 'UUI_Option_Control::Slider_SensitivityOnAim' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_SensitivityOnSnipeAim) == 0x000620, "Member 'UUI_Option_Control::Panel_SensitivityOnSnipeAim' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Slider_SensitivityOnSnipeAim) == 0x000628, "Member 'UUI_Option_Control::Slider_SensitivityOnSnipeAim' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_SensitivityAtNormal) == 0x000630, "Member 'UUI_Option_Control::Panel_SensitivityAtNormal' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Slider_SensitivityAtNormal) == 0x000638, "Member 'UUI_Option_Control::Slider_SensitivityAtNormal' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_HorizontalInvert) == 0x000640, "Member 'UUI_Option_Control::Panel_HorizontalInvert' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Radio_HorizontalInvert) == 0x000648, "Member 'UUI_Option_Control::Radio_HorizontalInvert' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_VerticalInvert) == 0x000650, "Member 'UUI_Option_Control::Panel_VerticalInvert' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Radio_VerticalInvert) == 0x000658, "Member 'UUI_Option_Control::Radio_VerticalInvert' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_Forward) == 0x000660, "Member 'UUI_Option_Control::Panel_Forward' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_Forward) == 0x000668, "Member 'UUI_Option_Control::KeyBinder_KBM_First_Forward' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_Forward) == 0x000670, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_Forward' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_Forward) == 0x000678, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_Forward' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_Backward) == 0x000680, "Member 'UUI_Option_Control::Panel_Backward' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_Backward) == 0x000688, "Member 'UUI_Option_Control::KeyBinder_KBM_First_Backward' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_Backward) == 0x000690, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_Backward' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_Backward) == 0x000698, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_Backward' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_Left) == 0x0006A0, "Member 'UUI_Option_Control::Panel_Left' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_Left) == 0x0006A8, "Member 'UUI_Option_Control::KeyBinder_KBM_First_Left' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_Left) == 0x0006B0, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_Left' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_Left) == 0x0006B8, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_Left' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_Right) == 0x0006C0, "Member 'UUI_Option_Control::Panel_Right' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_Right) == 0x0006C8, "Member 'UUI_Option_Control::KeyBinder_KBM_First_Right' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_Right) == 0x0006D0, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_Right' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_Right) == 0x0006D8, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_Right' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_Crouch) == 0x0006E0, "Member 'UUI_Option_Control::Panel_Crouch' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_Crouch) == 0x0006E8, "Member 'UUI_Option_Control::KeyBinder_KBM_First_Crouch' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_Crouch) == 0x0006F0, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_Crouch' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_Crouch) == 0x0006F8, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_Crouch' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_HoldCrouch) == 0x000700, "Member 'UUI_Option_Control::Panel_HoldCrouch' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Radio_HoldCrouch) == 0x000708, "Member 'UUI_Option_Control::Radio_HoldCrouch' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_Interaction) == 0x000710, "Member 'UUI_Option_Control::Panel_Interaction' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_Interaction) == 0x000718, "Member 'UUI_Option_Control::KeyBinder_KBM_First_Interaction' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_Interaction) == 0x000720, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_Interaction' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_Interaction) == 0x000728, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_Interaction' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_OpenStore) == 0x000730, "Member 'UUI_Option_Control::Panel_OpenStore' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_OpenStore) == 0x000738, "Member 'UUI_Option_Control::KeyBinder_KBM_First_OpenStore' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_OpenStore) == 0x000740, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_OpenStore' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_OpenStore) == 0x000748, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_OpenStore' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_Fire) == 0x000750, "Member 'UUI_Option_Control::Panel_Fire' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_Fire) == 0x000758, "Member 'UUI_Option_Control::KeyBinder_KBM_First_Fire' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_Fire) == 0x000760, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_Fire' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_Fire) == 0x000768, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_Fire' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_Aiming) == 0x000770, "Member 'UUI_Option_Control::Panel_Aiming' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_Aiming) == 0x000778, "Member 'UUI_Option_Control::KeyBinder_KBM_First_Aiming' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_Aiming) == 0x000780, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_Aiming' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_Aiming) == 0x000788, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_Aiming' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_HoldAiming) == 0x000790, "Member 'UUI_Option_Control::Panel_HoldAiming' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Radio_HoldAiming) == 0x000798, "Member 'UUI_Option_Control::Radio_HoldAiming' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_Reload) == 0x0007A0, "Member 'UUI_Option_Control::Panel_Reload' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_Reload) == 0x0007A8, "Member 'UUI_Option_Control::KeyBinder_KBM_First_Reload' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_Reload) == 0x0007B0, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_Reload' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_Reload) == 0x0007B8, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_Reload' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_ShowLaserSight) == 0x0007C0, "Member 'UUI_Option_Control::Panel_ShowLaserSight' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_ShowLaserSight) == 0x0007C8, "Member 'UUI_Option_Control::KeyBinder_KBM_First_ShowLaserSight' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_ShowLaserSight) == 0x0007D0, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_ShowLaserSight' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_ShowLaserSight) == 0x0007D8, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_ShowLaserSight' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_SendPing) == 0x0007E0, "Member 'UUI_Option_Control::Panel_SendPing' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_SendPing) == 0x0007E8, "Member 'UUI_Option_Control::KeyBinder_KBM_First_SendPing' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_SendPing) == 0x0007F0, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_SendPing' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_SendPing) == 0x0007F8, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_SendPing' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_SelectPing) == 0x000800, "Member 'UUI_Option_Control::Panel_SelectPing' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_SelectPing) == 0x000808, "Member 'UUI_Option_Control::KeyBinder_KBM_First_SelectPing' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_SelectPing) == 0x000810, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_SelectPing' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_SelectPing) == 0x000818, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_SelectPing' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_ActiveSkill1) == 0x000820, "Member 'UUI_Option_Control::Panel_ActiveSkill1' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_ActiveSkill1) == 0x000828, "Member 'UUI_Option_Control::KeyBinder_KBM_First_ActiveSkill1' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_ActiveSkill1) == 0x000830, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_ActiveSkill1' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_ActiveSkill1) == 0x000838, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_ActiveSkill1' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_ActiveSkill2) == 0x000840, "Member 'UUI_Option_Control::Panel_ActiveSkill2' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_ActiveSkill2) == 0x000848, "Member 'UUI_Option_Control::KeyBinder_KBM_First_ActiveSkill2' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_ActiveSkill2) == 0x000850, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_ActiveSkill2' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_ActiveSkill2) == 0x000858, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_ActiveSkill2' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_ActiveSkill3) == 0x000860, "Member 'UUI_Option_Control::Panel_ActiveSkill3' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_ActiveSkill3) == 0x000868, "Member 'UUI_Option_Control::KeyBinder_KBM_First_ActiveSkill3' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_ActiveSkill3) == 0x000870, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_ActiveSkill3' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_ActiveSkill3) == 0x000878, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_ActiveSkill3' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_FastMove) == 0x000880, "Member 'UUI_Option_Control::Panel_FastMove' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_FastMove) == 0x000888, "Member 'UUI_Option_Control::KeyBinder_KBM_First_FastMove' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_FastMove) == 0x000890, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_FastMove' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_FastMove) == 0x000898, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_FastMove' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_BoosterSlot1) == 0x0008A0, "Member 'UUI_Option_Control::Panel_BoosterSlot1' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_BoosterSlot1) == 0x0008A8, "Member 'UUI_Option_Control::KeyBinder_KBM_First_BoosterSlot1' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_BoosterSlot1) == 0x0008B0, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_BoosterSlot1' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_BoosterSlot1) == 0x0008B8, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_BoosterSlot1' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_BoosterSlot2) == 0x0008C0, "Member 'UUI_Option_Control::Panel_BoosterSlot2' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_BoosterSlot2) == 0x0008C8, "Member 'UUI_Option_Control::KeyBinder_KBM_First_BoosterSlot2' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_BoosterSlot2) == 0x0008D0, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_BoosterSlot2' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_BoosterSlot2) == 0x0008D8, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_BoosterSlot2' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_BoosterSlot3) == 0x0008E0, "Member 'UUI_Option_Control::Panel_BoosterSlot3' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_BoosterSlot3) == 0x0008E8, "Member 'UUI_Option_Control::KeyBinder_KBM_First_BoosterSlot3' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_BoosterSlot3) == 0x0008F0, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_BoosterSlot3' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_BoosterSlot3) == 0x0008F8, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_BoosterSlot3' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_BoosterSlot4) == 0x000900, "Member 'UUI_Option_Control::Panel_BoosterSlot4' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_BoosterSlot4) == 0x000908, "Member 'UUI_Option_Control::KeyBinder_KBM_First_BoosterSlot4' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_BoosterSlot4) == 0x000910, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_BoosterSlot4' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_BoosterSlot4) == 0x000918, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_BoosterSlot4' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_ShowStatusBoard) == 0x000920, "Member 'UUI_Option_Control::Panel_ShowStatusBoard' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_ShowStatusBoard) == 0x000928, "Member 'UUI_Option_Control::KeyBinder_KBM_First_ShowStatusBoard' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_ShowStatusBoard) == 0x000930, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_ShowStatusBoard' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_ShowStatusBoard) == 0x000938, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_ShowStatusBoard' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_HoldShowStatusBoard) == 0x000940, "Member 'UUI_Option_Control::Panel_HoldShowStatusBoard' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Radio_HoldShowStatusBoard) == 0x000948, "Member 'UUI_Option_Control::Radio_HoldShowStatusBoard' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_NoticeActiveSkillCombo) == 0x000950, "Member 'UUI_Option_Control::Panel_NoticeActiveSkillCombo' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Radio_NoticeActiveSkillCombo) == 0x000958, "Member 'UUI_Option_Control::Radio_NoticeActiveSkillCombo' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_RadioChatAll) == 0x000960, "Member 'UUI_Option_Control::Panel_RadioChatAll' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_RadioChatAll) == 0x000968, "Member 'UUI_Option_Control::KeyBinder_KBM_First_RadioChatAll' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_RadioChatAll) == 0x000970, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_RadioChatAll' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_RadioChatAll) == 0x000978, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_RadioChatAll' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_RadioChat1) == 0x000980, "Member 'UUI_Option_Control::Panel_RadioChat1' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_RadioChat1) == 0x000988, "Member 'UUI_Option_Control::KeyBinder_KBM_First_RadioChat1' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_RadioChat1) == 0x000990, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_RadioChat1' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_RadioChat1) == 0x000998, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_RadioChat1' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_RadioChat2) == 0x0009A0, "Member 'UUI_Option_Control::Panel_RadioChat2' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_RadioChat2) == 0x0009A8, "Member 'UUI_Option_Control::KeyBinder_KBM_First_RadioChat2' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_RadioChat2) == 0x0009B0, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_RadioChat2' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_RadioChat2) == 0x0009B8, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_RadioChat2' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_RadioChat3) == 0x0009C0, "Member 'UUI_Option_Control::Panel_RadioChat3' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_RadioChat3) == 0x0009C8, "Member 'UUI_Option_Control::KeyBinder_KBM_First_RadioChat3' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_RadioChat3) == 0x0009D0, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_RadioChat3' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_RadioChat3) == 0x0009D8, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_RadioChat3' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_RadioChat4) == 0x0009E0, "Member 'UUI_Option_Control::Panel_RadioChat4' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_RadioChat4) == 0x0009E8, "Member 'UUI_Option_Control::KeyBinder_KBM_First_RadioChat4' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_RadioChat4) == 0x0009F0, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_RadioChat4' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_RadioChat4) == 0x0009F8, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_RadioChat4' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_HideHUD) == 0x000A00, "Member 'UUI_Option_Control::Panel_HideHUD' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_HideHUD) == 0x000A08, "Member 'UUI_Option_Control::KeyBinder_KBM_First_HideHUD' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_HideHUD) == 0x000A10, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_HideHUD' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_HideHUD) == 0x000A18, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_HideHUD' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_AutoBoosters) == 0x000A20, "Member 'UUI_Option_Control::Panel_AutoBoosters' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_AutoBoosters) == 0x000A28, "Member 'UUI_Option_Control::KeyBinder_KBM_First_AutoBoosters' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_AutoBoosters) == 0x000A30, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_AutoBoosters' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_AutoBoosters) == 0x000A38, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_AutoBoosters' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_AutoBoosters_Radio) == 0x000A40, "Member 'UUI_Option_Control::Panel_AutoBoosters_Radio' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Radio_AutoBoosters) == 0x000A48, "Member 'UUI_Option_Control::Radio_AutoBoosters' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_SteamScreenshot) == 0x000A50, "Member 'UUI_Option_Control::Panel_SteamScreenshot' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_SteamScreenshot) == 0x000A58, "Member 'UUI_Option_Control::KeyBinder_KBM_First_SteamScreenshot' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_SteamScreenshot) == 0x000A60, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_SteamScreenshot' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_SteamScreenshot) == 0x000A68, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_SteamScreenshot' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_GamePause) == 0x000A70, "Member 'UUI_Option_Control::Panel_GamePause' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_GamePause) == 0x000A78, "Member 'UUI_Option_Control::KeyBinder_KBM_First_GamePause' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_GamePause) == 0x000A80, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_GamePause' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_GamePause) == 0x000A88, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_GamePause' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_PlayerSightLine) == 0x000A90, "Member 'UUI_Option_Control::Panel_PlayerSightLine' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_PlayerSightLine) == 0x000A98, "Member 'UUI_Option_Control::KeyBinder_KBM_First_PlayerSightLine' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_PlayerSightLine) == 0x000AA0, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_PlayerSightLine' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_PlayerSightLine) == 0x000AA8, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_PlayerSightLine' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_Player1Camera) == 0x000AB0, "Member 'UUI_Option_Control::Panel_Player1Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_Player1Camera) == 0x000AB8, "Member 'UUI_Option_Control::KeyBinder_KBM_First_Player1Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_Player1Camera) == 0x000AC0, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_Player1Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_Player1Camera) == 0x000AC8, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_Player1Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_Player2Camera) == 0x000AD0, "Member 'UUI_Option_Control::Panel_Player2Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_Player2Camera) == 0x000AD8, "Member 'UUI_Option_Control::KeyBinder_KBM_First_Player2Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_Player2Camera) == 0x000AE0, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_Player2Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_Player2Camera) == 0x000AE8, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_Player2Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_Player3Camera) == 0x000AF0, "Member 'UUI_Option_Control::Panel_Player3Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_Player3Camera) == 0x000AF8, "Member 'UUI_Option_Control::KeyBinder_KBM_First_Player3Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_Player3Camera) == 0x000B00, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_Player3Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_Player3Camera) == 0x000B08, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_Player3Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_Player4Camera) == 0x000B10, "Member 'UUI_Option_Control::Panel_Player4Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_Player4Camera) == 0x000B18, "Member 'UUI_Option_Control::KeyBinder_KBM_First_Player4Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_Player4Camera) == 0x000B20, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_Player4Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_Player4Camera) == 0x000B28, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_Player4Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_Player5Camera) == 0x000B30, "Member 'UUI_Option_Control::Panel_Player5Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_Player5Camera) == 0x000B38, "Member 'UUI_Option_Control::KeyBinder_KBM_First_Player5Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_Player5Camera) == 0x000B40, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_Player5Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_Player5Camera) == 0x000B48, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_Player5Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_Player6Camera) == 0x000B50, "Member 'UUI_Option_Control::Panel_Player6Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_Player6Camera) == 0x000B58, "Member 'UUI_Option_Control::KeyBinder_KBM_First_Player6Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_Player6Camera) == 0x000B60, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_Player6Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_Player6Camera) == 0x000B68, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_Player6Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_Player7Camera) == 0x000B70, "Member 'UUI_Option_Control::Panel_Player7Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_Player7Camera) == 0x000B78, "Member 'UUI_Option_Control::KeyBinder_KBM_First_Player7Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_Player7Camera) == 0x000B80, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_Player7Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_Player7Camera) == 0x000B88, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_Player7Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_Player8Camera) == 0x000B90, "Member 'UUI_Option_Control::Panel_Player8Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_Player8Camera) == 0x000B98, "Member 'UUI_Option_Control::KeyBinder_KBM_First_Player8Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_Player8Camera) == 0x000BA0, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_Player8Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_Player8Camera) == 0x000BA8, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_Player8Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_Player9Camera) == 0x000BB0, "Member 'UUI_Option_Control::Panel_Player9Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_Player9Camera) == 0x000BB8, "Member 'UUI_Option_Control::KeyBinder_KBM_First_Player9Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_Player9Camera) == 0x000BC0, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_Player9Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_Player9Camera) == 0x000BC8, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_Player9Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_Player10Camera) == 0x000BD0, "Member 'UUI_Option_Control::Panel_Player10Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_Player10Camera) == 0x000BD8, "Member 'UUI_Option_Control::KeyBinder_KBM_First_Player10Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_Player10Camera) == 0x000BE0, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_Player10Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_Player10Camera) == 0x000BE8, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_Player10Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_Player11Camera) == 0x000BF0, "Member 'UUI_Option_Control::Panel_Player11Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_Player11Camera) == 0x000BF8, "Member 'UUI_Option_Control::KeyBinder_KBM_First_Player11Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_Player11Camera) == 0x000C00, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_Player11Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_Player11Camera) == 0x000C08, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_Player11Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_Player12Camera) == 0x000C10, "Member 'UUI_Option_Control::Panel_Player12Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_Player12Camera) == 0x000C18, "Member 'UUI_Option_Control::KeyBinder_KBM_First_Player12Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_Player12Camera) == 0x000C20, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_Player12Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_Player12Camera) == 0x000C28, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_Player12Camera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_NextPlayerCamera) == 0x000C30, "Member 'UUI_Option_Control::Panel_NextPlayerCamera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_NextPlayerCamera) == 0x000C38, "Member 'UUI_Option_Control::KeyBinder_KBM_First_NextPlayerCamera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_NextPlayerCamera) == 0x000C40, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_NextPlayerCamera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_NextPlayerCamera) == 0x000C48, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_NextPlayerCamera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_PrevPlayerCamera) == 0x000C50, "Member 'UUI_Option_Control::Panel_PrevPlayerCamera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_PrevPlayerCamera) == 0x000C58, "Member 'UUI_Option_Control::KeyBinder_KBM_First_PrevPlayerCamera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_PrevPlayerCamera) == 0x000C60, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_PrevPlayerCamera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_PrevPlayerCamera) == 0x000C68, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_PrevPlayerCamera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_FreeCamera) == 0x000C70, "Member 'UUI_Option_Control::Panel_FreeCamera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_FreeCamera) == 0x000C78, "Member 'UUI_Option_Control::KeyBinder_KBM_First_FreeCamera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_FreeCamera) == 0x000C80, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_FreeCamera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_FreeCamera) == 0x000C88, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_FreeCamera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_CameraForward) == 0x000C90, "Member 'UUI_Option_Control::Panel_CameraForward' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_CameraForward) == 0x000C98, "Member 'UUI_Option_Control::KeyBinder_KBM_First_CameraForward' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_CameraForward) == 0x000CA0, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_CameraForward' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_CameraForward) == 0x000CA8, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_CameraForward' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_CameraBackward) == 0x000CB0, "Member 'UUI_Option_Control::Panel_CameraBackward' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_CameraBackward) == 0x000CB8, "Member 'UUI_Option_Control::KeyBinder_KBM_First_CameraBackward' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_CameraBackward) == 0x000CC0, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_CameraBackward' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_CameraBackward) == 0x000CC8, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_CameraBackward' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_CameraLeft) == 0x000CD0, "Member 'UUI_Option_Control::Panel_CameraLeft' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_CameraLeft) == 0x000CD8, "Member 'UUI_Option_Control::KeyBinder_KBM_First_CameraLeft' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_CameraLeft) == 0x000CE0, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_CameraLeft' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_CameraLeft) == 0x000CE8, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_CameraLeft' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_CameraRight) == 0x000CF0, "Member 'UUI_Option_Control::Panel_CameraRight' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_CameraRight) == 0x000CF8, "Member 'UUI_Option_Control::KeyBinder_KBM_First_CameraRight' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_CameraRight) == 0x000D00, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_CameraRight' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_CameraRight) == 0x000D08, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_CameraRight' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_CharacterOrbitCamera) == 0x000D10, "Member 'UUI_Option_Control::Panel_CharacterOrbitCamera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_CharacterOrbitCamera) == 0x000D18, "Member 'UUI_Option_Control::KeyBinder_KBM_First_CharacterOrbitCamera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_CharacterOrbitCamera) == 0x000D20, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_CharacterOrbitCamera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_CharacterOrbitCamera) == 0x000D28, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_CharacterOrbitCamera' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_FixedCamera1) == 0x000D30, "Member 'UUI_Option_Control::Panel_FixedCamera1' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_FixedCamera1) == 0x000D38, "Member 'UUI_Option_Control::KeyBinder_KBM_First_FixedCamera1' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_FixedCamera1) == 0x000D40, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_FixedCamera1' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_FixedCamera1) == 0x000D48, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_FixedCamera1' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_FixedCamera2) == 0x000D50, "Member 'UUI_Option_Control::Panel_FixedCamera2' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_FixedCamera2) == 0x000D58, "Member 'UUI_Option_Control::KeyBinder_KBM_First_FixedCamera2' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_FixedCamera2) == 0x000D60, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_FixedCamera2' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_FixedCamera2) == 0x000D68, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_FixedCamera2' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_FixedCamera3) == 0x000D70, "Member 'UUI_Option_Control::Panel_FixedCamera3' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_FixedCamera3) == 0x000D78, "Member 'UUI_Option_Control::KeyBinder_KBM_First_FixedCamera3' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_FixedCamera3) == 0x000D80, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_FixedCamera3' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_FixedCamera3) == 0x000D88, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_FixedCamera3' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_FixedCamera4) == 0x000D90, "Member 'UUI_Option_Control::Panel_FixedCamera4' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_FixedCamera4) == 0x000D98, "Member 'UUI_Option_Control::KeyBinder_KBM_First_FixedCamera4' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_FixedCamera4) == 0x000DA0, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_FixedCamera4' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_FixedCamera4) == 0x000DA8, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_FixedCamera4' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_FixedCamera5) == 0x000DB0, "Member 'UUI_Option_Control::Panel_FixedCamera5' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_FixedCamera5) == 0x000DB8, "Member 'UUI_Option_Control::KeyBinder_KBM_First_FixedCamera5' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_FixedCamera5) == 0x000DC0, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_FixedCamera5' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_FixedCamera5) == 0x000DC8, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_FixedCamera5' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_FixedCamera6) == 0x000DD0, "Member 'UUI_Option_Control::Panel_FixedCamera6' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_FixedCamera6) == 0x000DD8, "Member 'UUI_Option_Control::KeyBinder_KBM_First_FixedCamera6' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_FixedCamera6) == 0x000DE0, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_FixedCamera6' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_FixedCamera6) == 0x000DE8, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_FixedCamera6' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_FixedCamera7) == 0x000DF0, "Member 'UUI_Option_Control::Panel_FixedCamera7' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_FixedCamera7) == 0x000DF8, "Member 'UUI_Option_Control::KeyBinder_KBM_First_FixedCamera7' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_FixedCamera7) == 0x000E00, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_FixedCamera7' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_FixedCamera7) == 0x000E08, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_FixedCamera7' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, Panel_FixedCamera8) == 0x000E10, "Member 'UUI_Option_Control::Panel_FixedCamera8' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_First_FixedCamera8) == 0x000E18, "Member 'UUI_Option_Control::KeyBinder_KBM_First_FixedCamera8' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_KBM_Second_FixedCamera8) == 0x000E20, "Member 'UUI_Option_Control::KeyBinder_KBM_Second_FixedCamera8' has a wrong offset!");
static_assert(offsetof(UUI_Option_Control, KeyBinder_GamePad_First_FixedCamera8) == 0x000E28, "Member 'UUI_Option_Control::KeyBinder_GamePad_First_FixedCamera8' has a wrong offset!");

// Class Stigma.UI_Option_CrossHairDescBase
// 0x0018 (0x0508 - 0x04F0)
class UUI_Option_CrossHairDescBase : public UUI_Option_DescBase
{
public:
	class UHUD_CrossHair*                         Crosshair;                                         // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_DescTitle;                                     // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_DescContext;                                   // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Setup();
	void UpdateContext();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Option_CrossHairDescBase">();
	}
	static class UUI_Option_CrossHairDescBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Option_CrossHairDescBase>();
	}
};
static_assert(alignof(UUI_Option_CrossHairDescBase) == 0x000008, "Wrong alignment on UUI_Option_CrossHairDescBase");
static_assert(sizeof(UUI_Option_CrossHairDescBase) == 0x000508, "Wrong size on UUI_Option_CrossHairDescBase");
static_assert(offsetof(UUI_Option_CrossHairDescBase, Crosshair) == 0x0004F0, "Member 'UUI_Option_CrossHairDescBase::Crosshair' has a wrong offset!");
static_assert(offsetof(UUI_Option_CrossHairDescBase, TXT_DescTitle) == 0x0004F8, "Member 'UUI_Option_CrossHairDescBase::TXT_DescTitle' has a wrong offset!");
static_assert(offsetof(UUI_Option_CrossHairDescBase, TXT_DescContext) == 0x000500, "Member 'UUI_Option_CrossHairDescBase::TXT_DescContext' has a wrong offset!");

// Class Stigma.UI_Option_General
// 0x00B8 (0x06A8 - 0x05F0)
class UUI_Option_General : public UUI_OptionPageBase
{
public:
	class UCtrl_OptionItemPanelBase*              Panel_Language;                                    // 0x05F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionDropDownBase*               ComboBox_Language;                                 // 0x05F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_Voice_Language;                              // 0x0600(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionDropDownBase*               ComboBox_Voice_Language;                           // 0x0608(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_ColorBlindFilter;                            // 0x0610(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_NavigationStepper*                Navi_ColorBlindFilter;                             // 0x0618(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_ColorBlindFilterIntensity;                   // 0x0620(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 Slider_ColorBlindFilterIntensive;                  // 0x0628(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_AllowPartyInvitation;                        // 0x0630(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_TextCheckBoxBase*                 Check_AllowPartyInvitation_Friend;                 // 0x0638(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_TextCheckBoxBase*                 Check_AllowPartyInvitation_RecentPlayer;           // 0x0640(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_AllowFriendAsk;                              // 0x0648(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_NavigationStepper*                Navi_AllowFriendAsk;                               // 0x0650(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_NotifyFriendNotify;                          // 0x0658(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_RadioButtonGroupBase*             Radio_FriendsNotify;                               // 0x0660(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_EnemyDamageShow;                             // 0x0668(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_RadioButtonGroupBase*             Radio_EnemyDamageShow;                             // 0x0670(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_RadarMapSize;                                // 0x0678(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 Slider_RadarMapSize;                               // 0x0680(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_HitFloatingShow;                             // 0x0688(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_RadioButtonGroupBase*             Radio_HitFloatingShow;                             // 0x0690(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_HitAlliesNameTagShow;                        // 0x0698(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_RadioButtonGroupBase*             Radio_HitAlliesNameTagShow;                        // 0x06A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Option_General">();
	}
	static class UUI_Option_General* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Option_General>();
	}
};
static_assert(alignof(UUI_Option_General) == 0x000008, "Wrong alignment on UUI_Option_General");
static_assert(sizeof(UUI_Option_General) == 0x0006A8, "Wrong size on UUI_Option_General");
static_assert(offsetof(UUI_Option_General, Panel_Language) == 0x0005F0, "Member 'UUI_Option_General::Panel_Language' has a wrong offset!");
static_assert(offsetof(UUI_Option_General, ComboBox_Language) == 0x0005F8, "Member 'UUI_Option_General::ComboBox_Language' has a wrong offset!");
static_assert(offsetof(UUI_Option_General, Panel_Voice_Language) == 0x000600, "Member 'UUI_Option_General::Panel_Voice_Language' has a wrong offset!");
static_assert(offsetof(UUI_Option_General, ComboBox_Voice_Language) == 0x000608, "Member 'UUI_Option_General::ComboBox_Voice_Language' has a wrong offset!");
static_assert(offsetof(UUI_Option_General, Panel_ColorBlindFilter) == 0x000610, "Member 'UUI_Option_General::Panel_ColorBlindFilter' has a wrong offset!");
static_assert(offsetof(UUI_Option_General, Navi_ColorBlindFilter) == 0x000618, "Member 'UUI_Option_General::Navi_ColorBlindFilter' has a wrong offset!");
static_assert(offsetof(UUI_Option_General, Panel_ColorBlindFilterIntensity) == 0x000620, "Member 'UUI_Option_General::Panel_ColorBlindFilterIntensity' has a wrong offset!");
static_assert(offsetof(UUI_Option_General, Slider_ColorBlindFilterIntensive) == 0x000628, "Member 'UUI_Option_General::Slider_ColorBlindFilterIntensive' has a wrong offset!");
static_assert(offsetof(UUI_Option_General, Panel_AllowPartyInvitation) == 0x000630, "Member 'UUI_Option_General::Panel_AllowPartyInvitation' has a wrong offset!");
static_assert(offsetof(UUI_Option_General, Check_AllowPartyInvitation_Friend) == 0x000638, "Member 'UUI_Option_General::Check_AllowPartyInvitation_Friend' has a wrong offset!");
static_assert(offsetof(UUI_Option_General, Check_AllowPartyInvitation_RecentPlayer) == 0x000640, "Member 'UUI_Option_General::Check_AllowPartyInvitation_RecentPlayer' has a wrong offset!");
static_assert(offsetof(UUI_Option_General, Panel_AllowFriendAsk) == 0x000648, "Member 'UUI_Option_General::Panel_AllowFriendAsk' has a wrong offset!");
static_assert(offsetof(UUI_Option_General, Navi_AllowFriendAsk) == 0x000650, "Member 'UUI_Option_General::Navi_AllowFriendAsk' has a wrong offset!");
static_assert(offsetof(UUI_Option_General, Panel_NotifyFriendNotify) == 0x000658, "Member 'UUI_Option_General::Panel_NotifyFriendNotify' has a wrong offset!");
static_assert(offsetof(UUI_Option_General, Radio_FriendsNotify) == 0x000660, "Member 'UUI_Option_General::Radio_FriendsNotify' has a wrong offset!");
static_assert(offsetof(UUI_Option_General, Panel_EnemyDamageShow) == 0x000668, "Member 'UUI_Option_General::Panel_EnemyDamageShow' has a wrong offset!");
static_assert(offsetof(UUI_Option_General, Radio_EnemyDamageShow) == 0x000670, "Member 'UUI_Option_General::Radio_EnemyDamageShow' has a wrong offset!");
static_assert(offsetof(UUI_Option_General, Panel_RadarMapSize) == 0x000678, "Member 'UUI_Option_General::Panel_RadarMapSize' has a wrong offset!");
static_assert(offsetof(UUI_Option_General, Slider_RadarMapSize) == 0x000680, "Member 'UUI_Option_General::Slider_RadarMapSize' has a wrong offset!");
static_assert(offsetof(UUI_Option_General, Panel_HitFloatingShow) == 0x000688, "Member 'UUI_Option_General::Panel_HitFloatingShow' has a wrong offset!");
static_assert(offsetof(UUI_Option_General, Radio_HitFloatingShow) == 0x000690, "Member 'UUI_Option_General::Radio_HitFloatingShow' has a wrong offset!");
static_assert(offsetof(UUI_Option_General, Panel_HitAlliesNameTagShow) == 0x000698, "Member 'UUI_Option_General::Panel_HitAlliesNameTagShow' has a wrong offset!");
static_assert(offsetof(UUI_Option_General, Radio_HitAlliesNameTagShow) == 0x0006A0, "Member 'UUI_Option_General::Radio_HitAlliesNameTagShow' has a wrong offset!");

// Class Stigma.UI_Option_Graphic
// 0x01A8 (0x0798 - 0x05F0)
class UUI_Option_Graphic : public UUI_OptionPageBase
{
public:
	class FText                                   _SubjectText;                                      // 0x05F0(0x0018)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_DisplayMode;                                 // 0x0608(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionDropDownBase*               DropDown_DisplayMode;                              // 0x0610(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_Resolution;                                  // 0x0618(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionDropDownBase*               DropDown_Resolution;                               // 0x0620(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_Brightness;                                  // 0x0628(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 Slider_Brightness;                                 // 0x0630(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_Contrast;                                    // 0x0638(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 Slider_Contrast;                                   // 0x0640(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_Gamma;                                       // 0x0648(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 Slider_Gamma;                                      // 0x0650(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_ShowFPS;                                     // 0x0658(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_RadioButtonGroupBase*             Radio_ShowFPS;                                     // 0x0660(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_FOV;                                         // 0x0668(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 Slider_FOV;                                        // 0x0670(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_UseVsync;                                    // 0x0678(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_RadioButtonGroupBase*             Radio_UseVsync;                                    // 0x0680(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_GraphicQuality;                              // 0x0688(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_TextCheckBoxBase*                 Check_GraphicQuality;                              // 0x0690(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_GraphicQuality_Sub;                          // 0x0698(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_NavigationStepper*                Navi_GraphicQuality;                               // 0x06A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_ViewDistance;                                // 0x06A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_NavigationStepper*                Navi_ViewDistance;                                 // 0x06B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_AntiAliasingMethod;                          // 0x06B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionDropDownBase*               ComboBox_AntiAliasingMethod;                       // 0x06C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_AntiAliasing;                                // 0x06C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_NavigationStepper*                Navi_AntiAliasing;                                 // 0x06D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_PostProcessQuality;                          // 0x06D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_NavigationStepper*                Navi_PostProcessQuality;                           // 0x06E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_ShadowQuality;                               // 0x06E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_NavigationStepper*                Navi_ShadowQuality;                                // 0x06F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_GlobalIlluminationQuality;                   // 0x06F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_NavigationStepper*                Navi_GlobalIlluminationQuality;                    // 0x0700(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_ReflectionQuality;                           // 0x0708(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_NavigationStepper*                Navi_ReflectionQuality;                            // 0x0710(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_TextureQuality;                              // 0x0718(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_NavigationStepper*                Navi_TextureQuality;                               // 0x0720(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_EffectQuality;                               // 0x0728(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_NavigationStepper*                Navi_EffectQuality;                                // 0x0730(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_MaxFrameRate;                                // 0x0738(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_TextCheckBoxBase*                 Check_MaxFrameRate;                                // 0x0740(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_MaxFrameRate_Sub;                            // 0x0748(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 Slider_MaxFrameRate;                               // 0x0750(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionPaletteBase*                Palette_CrossHairColor;                            // 0x0758(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_CrossHairLength;                             // 0x0760(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 Slider_CrossHairLength;                            // 0x0768(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_CrossHairThickness;                          // 0x0770(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 Slider_CrossHairThickness;                         // 0x0778(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionPaletteBase*                Palette_OutlineColor;                              // 0x0780(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionItemPanelBase*              Panel_OutlineThickness;                            // 0x0788(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 Slider_OutlineThickness;                           // 0x0790(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Option_Graphic">();
	}
	static class UUI_Option_Graphic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Option_Graphic>();
	}
};
static_assert(alignof(UUI_Option_Graphic) == 0x000008, "Wrong alignment on UUI_Option_Graphic");
static_assert(sizeof(UUI_Option_Graphic) == 0x000798, "Wrong size on UUI_Option_Graphic");
static_assert(offsetof(UUI_Option_Graphic, _SubjectText) == 0x0005F0, "Member 'UUI_Option_Graphic::_SubjectText' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Panel_DisplayMode) == 0x000608, "Member 'UUI_Option_Graphic::Panel_DisplayMode' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, DropDown_DisplayMode) == 0x000610, "Member 'UUI_Option_Graphic::DropDown_DisplayMode' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Panel_Resolution) == 0x000618, "Member 'UUI_Option_Graphic::Panel_Resolution' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, DropDown_Resolution) == 0x000620, "Member 'UUI_Option_Graphic::DropDown_Resolution' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Panel_Brightness) == 0x000628, "Member 'UUI_Option_Graphic::Panel_Brightness' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Slider_Brightness) == 0x000630, "Member 'UUI_Option_Graphic::Slider_Brightness' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Panel_Contrast) == 0x000638, "Member 'UUI_Option_Graphic::Panel_Contrast' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Slider_Contrast) == 0x000640, "Member 'UUI_Option_Graphic::Slider_Contrast' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Panel_Gamma) == 0x000648, "Member 'UUI_Option_Graphic::Panel_Gamma' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Slider_Gamma) == 0x000650, "Member 'UUI_Option_Graphic::Slider_Gamma' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Panel_ShowFPS) == 0x000658, "Member 'UUI_Option_Graphic::Panel_ShowFPS' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Radio_ShowFPS) == 0x000660, "Member 'UUI_Option_Graphic::Radio_ShowFPS' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Panel_FOV) == 0x000668, "Member 'UUI_Option_Graphic::Panel_FOV' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Slider_FOV) == 0x000670, "Member 'UUI_Option_Graphic::Slider_FOV' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Panel_UseVsync) == 0x000678, "Member 'UUI_Option_Graphic::Panel_UseVsync' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Radio_UseVsync) == 0x000680, "Member 'UUI_Option_Graphic::Radio_UseVsync' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Panel_GraphicQuality) == 0x000688, "Member 'UUI_Option_Graphic::Panel_GraphicQuality' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Check_GraphicQuality) == 0x000690, "Member 'UUI_Option_Graphic::Check_GraphicQuality' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Panel_GraphicQuality_Sub) == 0x000698, "Member 'UUI_Option_Graphic::Panel_GraphicQuality_Sub' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Navi_GraphicQuality) == 0x0006A0, "Member 'UUI_Option_Graphic::Navi_GraphicQuality' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Panel_ViewDistance) == 0x0006A8, "Member 'UUI_Option_Graphic::Panel_ViewDistance' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Navi_ViewDistance) == 0x0006B0, "Member 'UUI_Option_Graphic::Navi_ViewDistance' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Panel_AntiAliasingMethod) == 0x0006B8, "Member 'UUI_Option_Graphic::Panel_AntiAliasingMethod' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, ComboBox_AntiAliasingMethod) == 0x0006C0, "Member 'UUI_Option_Graphic::ComboBox_AntiAliasingMethod' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Panel_AntiAliasing) == 0x0006C8, "Member 'UUI_Option_Graphic::Panel_AntiAliasing' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Navi_AntiAliasing) == 0x0006D0, "Member 'UUI_Option_Graphic::Navi_AntiAliasing' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Panel_PostProcessQuality) == 0x0006D8, "Member 'UUI_Option_Graphic::Panel_PostProcessQuality' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Navi_PostProcessQuality) == 0x0006E0, "Member 'UUI_Option_Graphic::Navi_PostProcessQuality' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Panel_ShadowQuality) == 0x0006E8, "Member 'UUI_Option_Graphic::Panel_ShadowQuality' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Navi_ShadowQuality) == 0x0006F0, "Member 'UUI_Option_Graphic::Navi_ShadowQuality' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Panel_GlobalIlluminationQuality) == 0x0006F8, "Member 'UUI_Option_Graphic::Panel_GlobalIlluminationQuality' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Navi_GlobalIlluminationQuality) == 0x000700, "Member 'UUI_Option_Graphic::Navi_GlobalIlluminationQuality' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Panel_ReflectionQuality) == 0x000708, "Member 'UUI_Option_Graphic::Panel_ReflectionQuality' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Navi_ReflectionQuality) == 0x000710, "Member 'UUI_Option_Graphic::Navi_ReflectionQuality' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Panel_TextureQuality) == 0x000718, "Member 'UUI_Option_Graphic::Panel_TextureQuality' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Navi_TextureQuality) == 0x000720, "Member 'UUI_Option_Graphic::Navi_TextureQuality' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Panel_EffectQuality) == 0x000728, "Member 'UUI_Option_Graphic::Panel_EffectQuality' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Navi_EffectQuality) == 0x000730, "Member 'UUI_Option_Graphic::Navi_EffectQuality' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Panel_MaxFrameRate) == 0x000738, "Member 'UUI_Option_Graphic::Panel_MaxFrameRate' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Check_MaxFrameRate) == 0x000740, "Member 'UUI_Option_Graphic::Check_MaxFrameRate' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Panel_MaxFrameRate_Sub) == 0x000748, "Member 'UUI_Option_Graphic::Panel_MaxFrameRate_Sub' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Slider_MaxFrameRate) == 0x000750, "Member 'UUI_Option_Graphic::Slider_MaxFrameRate' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Palette_CrossHairColor) == 0x000758, "Member 'UUI_Option_Graphic::Palette_CrossHairColor' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Panel_CrossHairLength) == 0x000760, "Member 'UUI_Option_Graphic::Panel_CrossHairLength' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Slider_CrossHairLength) == 0x000768, "Member 'UUI_Option_Graphic::Slider_CrossHairLength' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Panel_CrossHairThickness) == 0x000770, "Member 'UUI_Option_Graphic::Panel_CrossHairThickness' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Slider_CrossHairThickness) == 0x000778, "Member 'UUI_Option_Graphic::Slider_CrossHairThickness' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Palette_OutlineColor) == 0x000780, "Member 'UUI_Option_Graphic::Palette_OutlineColor' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Panel_OutlineThickness) == 0x000788, "Member 'UUI_Option_Graphic::Panel_OutlineThickness' has a wrong offset!");
static_assert(offsetof(UUI_Option_Graphic, Slider_OutlineThickness) == 0x000790, "Member 'UUI_Option_Graphic::Slider_OutlineThickness' has a wrong offset!");

// Class Stigma.UI_Option_GraphicDescBase
// 0x0018 (0x0508 - 0x04F0)
class UUI_Option_GraphicDescBase : public UUI_Option_DescBase
{
public:
	class UTextBlock*                             TXT_DescTitle;                                     // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_DescContext;                                   // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 PreviewImage;                                      // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Option_GraphicDescBase">();
	}
	static class UUI_Option_GraphicDescBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Option_GraphicDescBase>();
	}
};
static_assert(alignof(UUI_Option_GraphicDescBase) == 0x000008, "Wrong alignment on UUI_Option_GraphicDescBase");
static_assert(sizeof(UUI_Option_GraphicDescBase) == 0x000508, "Wrong size on UUI_Option_GraphicDescBase");
static_assert(offsetof(UUI_Option_GraphicDescBase, TXT_DescTitle) == 0x0004F0, "Member 'UUI_Option_GraphicDescBase::TXT_DescTitle' has a wrong offset!");
static_assert(offsetof(UUI_Option_GraphicDescBase, TXT_DescContext) == 0x0004F8, "Member 'UUI_Option_GraphicDescBase::TXT_DescContext' has a wrong offset!");
static_assert(offsetof(UUI_Option_GraphicDescBase, PreviewImage) == 0x000500, "Member 'UUI_Option_GraphicDescBase::PreviewImage' has a wrong offset!");

// Class Stigma.UI_Option_TextDescriptionBase
// 0x0010 (0x0500 - 0x04F0)
class UUI_Option_TextDescriptionBase : public UUI_Option_DescBase
{
public:
	class UTextBlock*                             TXT_DescTitle;                                     // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             TXT_DescContext;                                   // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Option_TextDescriptionBase">();
	}
	static class UUI_Option_TextDescriptionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Option_TextDescriptionBase>();
	}
};
static_assert(alignof(UUI_Option_TextDescriptionBase) == 0x000008, "Wrong alignment on UUI_Option_TextDescriptionBase");
static_assert(sizeof(UUI_Option_TextDescriptionBase) == 0x000500, "Wrong size on UUI_Option_TextDescriptionBase");
static_assert(offsetof(UUI_Option_TextDescriptionBase, TXT_DescTitle) == 0x0004F0, "Member 'UUI_Option_TextDescriptionBase::TXT_DescTitle' has a wrong offset!");
static_assert(offsetof(UUI_Option_TextDescriptionBase, TXT_DescContext) == 0x0004F8, "Member 'UUI_Option_TextDescriptionBase::TXT_DescContext' has a wrong offset!");

// Class Stigma.UI_PanelPlayerBase
// 0x0070 (0x0560 - 0x04F0)
class UUI_PanelPlayerBase : public UPreviewableWidget
{
public:
	bool                                          IsInvitable;                                       // 0x04F0(0x0001)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2622[0x7];                                     // 0x04F1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UCtrl_CommonButtonBase*                 BTN_InviteParty;                                   // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUI_PartyMemberNameTag*                 Ctrl_PartyMemberNameTag;                           // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2623[0x58];                                    // 0x0508(0x0058)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void HideNameTag();
	void InitializePanel();
	void OnHoverInviteBtn();
	void OnUnHoverInviteBtn();
	void SetActiveInviteButton(bool _flag);
	void SetActiveTooltip(bool _flag);
	void ShowNameTagByPartyMember(class UUserProfile* _member, bool _is_leader);
	void UpdateInviteButtonAcitivity();

	bool IsBoundMember() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_PanelPlayerBase">();
	}
	static class UUI_PanelPlayerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_PanelPlayerBase>();
	}
};
static_assert(alignof(UUI_PanelPlayerBase) == 0x000008, "Wrong alignment on UUI_PanelPlayerBase");
static_assert(sizeof(UUI_PanelPlayerBase) == 0x000560, "Wrong size on UUI_PanelPlayerBase");
static_assert(offsetof(UUI_PanelPlayerBase, IsInvitable) == 0x0004F0, "Member 'UUI_PanelPlayerBase::IsInvitable' has a wrong offset!");
static_assert(offsetof(UUI_PanelPlayerBase, BTN_InviteParty) == 0x0004F8, "Member 'UUI_PanelPlayerBase::BTN_InviteParty' has a wrong offset!");
static_assert(offsetof(UUI_PanelPlayerBase, Ctrl_PartyMemberNameTag) == 0x000500, "Member 'UUI_PanelPlayerBase::Ctrl_PartyMemberNameTag' has a wrong offset!");

// Class Stigma.UI_PartyMemberNameTag
// 0x00E0 (0x05D0 - 0x04F0)
class UUI_PartyMemberNameTag : public UPreviewableWidget
{
public:
	class UImage*                                 LevelBackgroundUpper;                              // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             LevelText;                                         // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 BottomTriangleMark;                                // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 LeaderIcon;                                        // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 ContentBackground;                                 // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             NicknameText;                                      // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 BottomLine;                                        // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            LevelBackgroundOriginalColor;                      // 0x0528(0x0014)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateColor                            ContentBackgroundOriginalColor;                    // 0x053C(0x0014)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateColor                            LeaderColor;                                       // 0x0550(0x0014)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateColor                            MemberColor;                                       // 0x0564(0x0014)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateColor                            MemberHoverContentBgColor;                         // 0x0578(0x0014)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateColor                            LeaderHoverContentBgColor;                         // 0x058C(0x0014)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class UUserProfile*                           _member;                                           // 0x05A0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2625[0x28];                                    // 0x05A8(0x0028)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ConstructInit();
	TArray<struct FHoverMenuEntry> GetHoverToolTipEntries();
	void InitNameTag(class UUserProfile* _party_member, bool _is_leader);
	struct FNetReply OnAck_AcceptAskFriend(EResultCode _net_result_code, const struct FACK_FriendUpdate& _response);
	struct FNetReply OnAck_AskFriend(EResultCode _net_result_code, const struct FACK_Friend& _response);
	void OnProcAskFriendClick();
	void SetToHoverState();
	void SetToNormalState();

	class UUserProfile* GetPartyMember() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_PartyMemberNameTag">();
	}
	static class UUI_PartyMemberNameTag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_PartyMemberNameTag>();
	}
};
static_assert(alignof(UUI_PartyMemberNameTag) == 0x000008, "Wrong alignment on UUI_PartyMemberNameTag");
static_assert(sizeof(UUI_PartyMemberNameTag) == 0x0005D0, "Wrong size on UUI_PartyMemberNameTag");
static_assert(offsetof(UUI_PartyMemberNameTag, LevelBackgroundUpper) == 0x0004F0, "Member 'UUI_PartyMemberNameTag::LevelBackgroundUpper' has a wrong offset!");
static_assert(offsetof(UUI_PartyMemberNameTag, LevelText) == 0x0004F8, "Member 'UUI_PartyMemberNameTag::LevelText' has a wrong offset!");
static_assert(offsetof(UUI_PartyMemberNameTag, BottomTriangleMark) == 0x000500, "Member 'UUI_PartyMemberNameTag::BottomTriangleMark' has a wrong offset!");
static_assert(offsetof(UUI_PartyMemberNameTag, LeaderIcon) == 0x000508, "Member 'UUI_PartyMemberNameTag::LeaderIcon' has a wrong offset!");
static_assert(offsetof(UUI_PartyMemberNameTag, ContentBackground) == 0x000510, "Member 'UUI_PartyMemberNameTag::ContentBackground' has a wrong offset!");
static_assert(offsetof(UUI_PartyMemberNameTag, NicknameText) == 0x000518, "Member 'UUI_PartyMemberNameTag::NicknameText' has a wrong offset!");
static_assert(offsetof(UUI_PartyMemberNameTag, BottomLine) == 0x000520, "Member 'UUI_PartyMemberNameTag::BottomLine' has a wrong offset!");
static_assert(offsetof(UUI_PartyMemberNameTag, LevelBackgroundOriginalColor) == 0x000528, "Member 'UUI_PartyMemberNameTag::LevelBackgroundOriginalColor' has a wrong offset!");
static_assert(offsetof(UUI_PartyMemberNameTag, ContentBackgroundOriginalColor) == 0x00053C, "Member 'UUI_PartyMemberNameTag::ContentBackgroundOriginalColor' has a wrong offset!");
static_assert(offsetof(UUI_PartyMemberNameTag, LeaderColor) == 0x000550, "Member 'UUI_PartyMemberNameTag::LeaderColor' has a wrong offset!");
static_assert(offsetof(UUI_PartyMemberNameTag, MemberColor) == 0x000564, "Member 'UUI_PartyMemberNameTag::MemberColor' has a wrong offset!");
static_assert(offsetof(UUI_PartyMemberNameTag, MemberHoverContentBgColor) == 0x000578, "Member 'UUI_PartyMemberNameTag::MemberHoverContentBgColor' has a wrong offset!");
static_assert(offsetof(UUI_PartyMemberNameTag, LeaderHoverContentBgColor) == 0x00058C, "Member 'UUI_PartyMemberNameTag::LeaderHoverContentBgColor' has a wrong offset!");
static_assert(offsetof(UUI_PartyMemberNameTag, _member) == 0x0005A0, "Member 'UUI_PartyMemberNameTag::_member' has a wrong offset!");

// Class Stigma.UI_PartyNotifySlot
// 0x0030 (0x0548 - 0x0518)
class UUI_PartyNotifySlot : public UUI_NotifySlot
{
public:
	struct FPartyID                               _PartyID;                                          // 0x0518(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture2D>              _FriendBgTexture;                                  // 0x0520(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnProcMsgBoxClick(const class UPopupBase* _popup, class FName _ctrl_id);
	void ReplyDenyPartyInvitation();
	void ReplyInviteParty();
	void SetBackground(const TSoftObjectPtr<class UTexture2D>& _texture);
	void SetText(const class FText& _text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_PartyNotifySlot">();
	}
	static class UUI_PartyNotifySlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_PartyNotifySlot>();
	}
};
static_assert(alignof(UUI_PartyNotifySlot) == 0x000008, "Wrong alignment on UUI_PartyNotifySlot");
static_assert(sizeof(UUI_PartyNotifySlot) == 0x000548, "Wrong size on UUI_PartyNotifySlot");
static_assert(offsetof(UUI_PartyNotifySlot, _PartyID) == 0x000518, "Member 'UUI_PartyNotifySlot::_PartyID' has a wrong offset!");
static_assert(offsetof(UUI_PartyNotifySlot, _FriendBgTexture) == 0x000520, "Member 'UUI_PartyNotifySlot::_FriendBgTexture' has a wrong offset!");

// Class Stigma.UI_PassiveSettingDetail
// 0x0008 (0x04F8 - 0x04F0)
class UUI_PassiveSettingDetail : public UPreviewableWidget
{
public:
	int32                                         _level;                                            // 0x04F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2629[0x4];                                     // 0x04F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Reset();
	void SetDesc(const class FText& _text);
	void SetIsBuffed(bool _is_buffed);
	void SetIsCurrent(bool _is_current);
	void SetIsMaxCanLevelUp(bool _is_max);
	void SetLearned(bool _learned);
	void SetLevelLockText(int32 _lock_level);
	void ShowLevelLock(bool _show);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_PassiveSettingDetail">();
	}
	static class UUI_PassiveSettingDetail* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_PassiveSettingDetail>();
	}
};
static_assert(alignof(UUI_PassiveSettingDetail) == 0x000008, "Wrong alignment on UUI_PassiveSettingDetail");
static_assert(sizeof(UUI_PassiveSettingDetail) == 0x0004F8, "Wrong size on UUI_PassiveSettingDetail");
static_assert(offsetof(UUI_PassiveSettingDetail, _level) == 0x0004F0, "Member 'UUI_PassiveSettingDetail::_level' has a wrong offset!");

// Class Stigma.UI_PassiveSettingPage
// 0x0088 (0x0598 - 0x0510)
class UUI_PassiveSettingPage : public UUI_LobbyPage
{
public:
	class UUniformGridPanel*                      UGP_PassiveSkillSlot;                              // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      UGP_PassiveSkillDetail;                            // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HB_Function;                                       // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_PassiveSettingSlot>     _SlotWidgetClass;                                  // 0x0528(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_PassiveSettingDetail>   _DetailWidgetClass;                                // 0x0530(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_ActiveFunctionBase>     _FunctionWidgetClass;                              // 0x0538(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<struct FPassiveSkillID, int32>           _ModifiedPassiveSkillMap;                          // 0x0540(0x0050)(Protected, NativeAccessSpecifierProtected)
	int32                                         _ModifiedSkillPoint;                               // 0x0590(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_262A[0x4];                                     // 0x0594(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ApplyChanges();
	void OnSelectSlot(const struct FPassiveSkillID& _skill_id);
	void OnUpdateUserEvent(EUserEvent _event);
	void SetCurrentPassiveSkillPoint(int32 _point);
	void SetTotalPassiveSkillPoint(int32 _point);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_PassiveSettingPage">();
	}
	static class UUI_PassiveSettingPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_PassiveSettingPage>();
	}
};
static_assert(alignof(UUI_PassiveSettingPage) == 0x000008, "Wrong alignment on UUI_PassiveSettingPage");
static_assert(sizeof(UUI_PassiveSettingPage) == 0x000598, "Wrong size on UUI_PassiveSettingPage");
static_assert(offsetof(UUI_PassiveSettingPage, UGP_PassiveSkillSlot) == 0x000510, "Member 'UUI_PassiveSettingPage::UGP_PassiveSkillSlot' has a wrong offset!");
static_assert(offsetof(UUI_PassiveSettingPage, UGP_PassiveSkillDetail) == 0x000518, "Member 'UUI_PassiveSettingPage::UGP_PassiveSkillDetail' has a wrong offset!");
static_assert(offsetof(UUI_PassiveSettingPage, HB_Function) == 0x000520, "Member 'UUI_PassiveSettingPage::HB_Function' has a wrong offset!");
static_assert(offsetof(UUI_PassiveSettingPage, _SlotWidgetClass) == 0x000528, "Member 'UUI_PassiveSettingPage::_SlotWidgetClass' has a wrong offset!");
static_assert(offsetof(UUI_PassiveSettingPage, _DetailWidgetClass) == 0x000530, "Member 'UUI_PassiveSettingPage::_DetailWidgetClass' has a wrong offset!");
static_assert(offsetof(UUI_PassiveSettingPage, _FunctionWidgetClass) == 0x000538, "Member 'UUI_PassiveSettingPage::_FunctionWidgetClass' has a wrong offset!");
static_assert(offsetof(UUI_PassiveSettingPage, _ModifiedPassiveSkillMap) == 0x000540, "Member 'UUI_PassiveSettingPage::_ModifiedPassiveSkillMap' has a wrong offset!");
static_assert(offsetof(UUI_PassiveSettingPage, _ModifiedSkillPoint) == 0x000590, "Member 'UUI_PassiveSettingPage::_ModifiedSkillPoint' has a wrong offset!");

// Class Stigma.UI_PassiveSettingSlot
// 0x0028 (0x0518 - 0x04F0)
class UUI_PassiveSettingSlot : public UPreviewableWidget
{
public:
	struct FPassiveSkillID                        _PassiveSkillID;                                   // 0x04F0(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_262B[0x18];                                    // 0x0500(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnClickButton(int32 _level);
	void OnInitWidget();
	void SetDesc(const class FText& _text);
	void SetIcon(const TSoftObjectPtr<class UTexture2D>& _Icon);
	void SetIsBoosted(bool _is_boosted);
	void SetIsLocked(bool _is_locked);
	void SetLevelText(const class FText& _text);
	void SetTitle(const class FText& _text);
	void ShowMinusButton(bool _show);
	void ShowPlusButton(bool _show);
	void UpdateTooltip(int32 _level);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_PassiveSettingSlot">();
	}
	static class UUI_PassiveSettingSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_PassiveSettingSlot>();
	}
};
static_assert(alignof(UUI_PassiveSettingSlot) == 0x000008, "Wrong alignment on UUI_PassiveSettingSlot");
static_assert(sizeof(UUI_PassiveSettingSlot) == 0x000518, "Wrong size on UUI_PassiveSettingSlot");
static_assert(offsetof(UUI_PassiveSettingSlot, _PassiveSkillID) == 0x0004F0, "Member 'UUI_PassiveSettingSlot::_PassiveSkillID' has a wrong offset!");

// Class Stigma.UI_PassMissionWeekContainer
// 0x0038 (0x0528 - 0x04F0)
class UUI_PassMissionWeekContainer : public UPreviewableWidget
{
public:
	uint8                                         Pad_262C[0x10];                                    // 0x04F0(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class UUniformGridPanel*                      UGP_Common;                                        // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      UGP_Premium;                                       // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_MissionPopupSlotBattlePass> _MissionPopupSlotBattlePassClass;                  // 0x0510(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_262D[0x10];                                    // 0x0518(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_PassMissionWeekContainer">();
	}
	static class UUI_PassMissionWeekContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_PassMissionWeekContainer>();
	}
};
static_assert(alignof(UUI_PassMissionWeekContainer) == 0x000008, "Wrong alignment on UUI_PassMissionWeekContainer");
static_assert(sizeof(UUI_PassMissionWeekContainer) == 0x000528, "Wrong size on UUI_PassMissionWeekContainer");
static_assert(offsetof(UUI_PassMissionWeekContainer, UGP_Common) == 0x000500, "Member 'UUI_PassMissionWeekContainer::UGP_Common' has a wrong offset!");
static_assert(offsetof(UUI_PassMissionWeekContainer, UGP_Premium) == 0x000508, "Member 'UUI_PassMissionWeekContainer::UGP_Premium' has a wrong offset!");
static_assert(offsetof(UUI_PassMissionWeekContainer, _MissionPopupSlotBattlePassClass) == 0x000510, "Member 'UUI_PassMissionWeekContainer::_MissionPopupSlotBattlePassClass' has a wrong offset!");

// Class Stigma.UI_WaitingRoom_CharacterPick
// 0x00B0 (0x0600 - 0x0550)
class alignas(0x10) UUI_WaitingRoom_CharacterPick : public UUI_CharacterPicker
{
public:
	class UMannequinManager*                      _MannequinManager;                                 // 0x0550(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton_Ready*                          BTN_Ready;                                         // 0x0558(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_ChatBox*                            ChatBox;                                           // 0x0560(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_262E[0x80];                                    // 0x0568(0x0080)(Fixing Size After Last Property [ Dumper-69 ])
	class AFollowCameraActor*                     _cam;                                              // 0x05E8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _EnableShowAvatar;                                 // 0x05F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_262F[0xF];                                     // 0x05F1(0x000F)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	class AFollowCameraActor* GetCam();
	void MovePickedCharacter(int32 _idx_move, int32 _offset);
	bool OnChange_CanReady(bool _can_ready);
	bool OnChange_PickedCharacter();
	void OnLoad_Characters();
	bool OnLOCAL_ChangeCharacterSetting(class AMatchServicedPlayerState* _ps);
	bool OnNotify_LoadCharacters();
	void SetCam(class AFollowCameraActor* _follow_cam);
	void SetCurrentPickedCharacter(int32 _idx);

	class UUI_ChatBox* GetChatBox() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_WaitingRoom_CharacterPick">();
	}
	static class UUI_WaitingRoom_CharacterPick* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_WaitingRoom_CharacterPick>();
	}
};
static_assert(alignof(UUI_WaitingRoom_CharacterPick) == 0x000010, "Wrong alignment on UUI_WaitingRoom_CharacterPick");
static_assert(sizeof(UUI_WaitingRoom_CharacterPick) == 0x000600, "Wrong size on UUI_WaitingRoom_CharacterPick");
static_assert(offsetof(UUI_WaitingRoom_CharacterPick, _MannequinManager) == 0x000550, "Member 'UUI_WaitingRoom_CharacterPick::_MannequinManager' has a wrong offset!");
static_assert(offsetof(UUI_WaitingRoom_CharacterPick, BTN_Ready) == 0x000558, "Member 'UUI_WaitingRoom_CharacterPick::BTN_Ready' has a wrong offset!");
static_assert(offsetof(UUI_WaitingRoom_CharacterPick, ChatBox) == 0x000560, "Member 'UUI_WaitingRoom_CharacterPick::ChatBox' has a wrong offset!");
static_assert(offsetof(UUI_WaitingRoom_CharacterPick, _cam) == 0x0005E8, "Member 'UUI_WaitingRoom_CharacterPick::_cam' has a wrong offset!");
static_assert(offsetof(UUI_WaitingRoom_CharacterPick, _EnableShowAvatar) == 0x0005F0, "Member 'UUI_WaitingRoom_CharacterPick::_EnableShowAvatar' has a wrong offset!");

// Class Stigma.UI_PassMissionWeekTab
// 0x0018 (0x0508 - 0x04F0)
class UUI_PassMissionWeekTab : public UPreviewableWidget
{
public:
	uint8                                         Pad_2631[0x18];                                    // 0x04F0(0x0018)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnClickWeekTab();
	void SetLocked(bool _locked);
	void SetProgress(int32 _current_count, int32 _target_count);
	void SetSelected(bool _selected);
	void SetTitle(const class FText& _text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_PassMissionWeekTab">();
	}
	static class UUI_PassMissionWeekTab* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_PassMissionWeekTab>();
	}
};
static_assert(alignof(UUI_PassMissionWeekTab) == 0x000008, "Wrong alignment on UUI_PassMissionWeekTab");
static_assert(sizeof(UUI_PassMissionWeekTab) == 0x000508, "Wrong size on UUI_PassMissionWeekTab");

// Class Stigma.UI_PingMenu
// 0x0010 (0x02D0 - 0x02C0)
class UUI_PingMenu final : public UUserWidget
{
public:
	class ABattlePlayerControllerBase*            _PC;                                               // 0x02C0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBattlePingType                               _PingType;                                         // 0x02C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2632[0x7];                                     // 0x02C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	bool ScrollPingType(float _delta);
	void SetPingType(EBattlePingType _ping_type);
	bool UpdatEBattlePingType();

	EBattlePingType GetPingType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_PingMenu">();
	}
	static class UUI_PingMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_PingMenu>();
	}
};
static_assert(alignof(UUI_PingMenu) == 0x000008, "Wrong alignment on UUI_PingMenu");
static_assert(sizeof(UUI_PingMenu) == 0x0002D0, "Wrong size on UUI_PingMenu");
static_assert(offsetof(UUI_PingMenu, _PC) == 0x0002C0, "Member 'UUI_PingMenu::_PC' has a wrong offset!");
static_assert(offsetof(UUI_PingMenu, _PingType) == 0x0002C8, "Member 'UUI_PingMenu::_PingType' has a wrong offset!");

// Class Stigma.UI_PlayerProfilePopup
// 0x0158 (0x06C8 - 0x0570)
class UUI_PlayerProfilePopup : public UPopupBase
{
public:
	class UTextBlock*                             TXT_KDATotal;                                      // 0x0570(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_KDARate;                                       // 0x0578(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        SWITCHER_CharacterKDA;                             // 0x0580(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                BOX_Empty_CharacterKDA;                            // 0x0588(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                BOX_CharacterKDA;                                  // 0x0590(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_Record_KDA_Master*                  KDA_CharacterSlot0;                                // 0x0598(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_Record_KDA_Master*                  KDA_CharacterSlot1;                                // 0x05A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_Record_KDA_Master*                  KDA_CharacterSlot2;                                // 0x05A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_TotalWinCount;                                 // 0x05B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         BOX_WinCount;                                      // 0x05B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_TotalMVPCount;                                 // 0x05C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         BOX_MVPCount;                                      // 0x05C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_HitRate;                                       // 0x05D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        SWITCHER_HitRate;                                  // 0x05D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                BOX_Empty_HitRate;                                 // 0x05E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                BOX_HitRate;                                       // 0x05E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_Record_AttackMethod*                HitRateSlot0;                                      // 0x05F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_Record_AttackMethod*                HitRateSlot1;                                      // 0x05F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_Record_AttackMethod*                HitRateSlot2;                                      // 0x0600(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_TotalDamage;                                   // 0x0608(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        SWITCHER_Damage;                                   // 0x0610(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                BOX_Empty_Damage;                                  // 0x0618(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                BOX_Damage;                                        // 0x0620(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_Record_AttackMethod*                DamageSlot0;                                       // 0x0628(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_Record_AttackMethod*                DamageSlot1;                                       // 0x0630(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_Record_AttackMethod*                DamageSlot2;                                       // 0x0638(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                KDA_Title;                                         // 0x0640(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                Win_Title;                                         // 0x0648(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                MVP_Title;                                         // 0x0650(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                HitRate_Title;                                     // 0x0658(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                Damage_Title;                                      // 0x0660(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        SWITCHER_State;                                    // 0x0668(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_Record_ModeResultCount> _ModeResultClass;                                  // 0x0670(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FUserID                                _UserID;                                           // 0x0678(0x0008)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemID                                _EmblemID;                                         // 0x0680(0x0010)(BlueprintVisible, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemID                                _ProfileCardID;                                    // 0x0690(0x0010)(BlueprintVisible, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETier                                         _tier;                                             // 0x06A0(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2634[0x7];                                     // 0x06A1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FUserName                              _nickname;                                         // 0x06A8(0x0018)(BlueprintVisible, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _level;                                            // 0x06C0(0x0004)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2635[0x4];                                     // 0x06C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Init(const struct FUserID& _in_user_id, const struct FItemID& _in_emblem_id, const struct FItemID& _in_profilecard_id, ETier _in_tier, const struct FUserName& _in_nickname, int32 _in_level);
	struct FNetReply OnACK_ReadStatistic(EResultCode _rcode, const struct FACK_ProfileStatisticRead& _ack);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_PlayerProfilePopup">();
	}
	static class UUI_PlayerProfilePopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_PlayerProfilePopup>();
	}
};
static_assert(alignof(UUI_PlayerProfilePopup) == 0x000008, "Wrong alignment on UUI_PlayerProfilePopup");
static_assert(sizeof(UUI_PlayerProfilePopup) == 0x0006C8, "Wrong size on UUI_PlayerProfilePopup");
static_assert(offsetof(UUI_PlayerProfilePopup, TXT_KDATotal) == 0x000570, "Member 'UUI_PlayerProfilePopup::TXT_KDATotal' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, TXT_KDARate) == 0x000578, "Member 'UUI_PlayerProfilePopup::TXT_KDARate' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, SWITCHER_CharacterKDA) == 0x000580, "Member 'UUI_PlayerProfilePopup::SWITCHER_CharacterKDA' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, BOX_Empty_CharacterKDA) == 0x000588, "Member 'UUI_PlayerProfilePopup::BOX_Empty_CharacterKDA' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, BOX_CharacterKDA) == 0x000590, "Member 'UUI_PlayerProfilePopup::BOX_CharacterKDA' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, KDA_CharacterSlot0) == 0x000598, "Member 'UUI_PlayerProfilePopup::KDA_CharacterSlot0' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, KDA_CharacterSlot1) == 0x0005A0, "Member 'UUI_PlayerProfilePopup::KDA_CharacterSlot1' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, KDA_CharacterSlot2) == 0x0005A8, "Member 'UUI_PlayerProfilePopup::KDA_CharacterSlot2' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, TXT_TotalWinCount) == 0x0005B0, "Member 'UUI_PlayerProfilePopup::TXT_TotalWinCount' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, BOX_WinCount) == 0x0005B8, "Member 'UUI_PlayerProfilePopup::BOX_WinCount' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, TXT_TotalMVPCount) == 0x0005C0, "Member 'UUI_PlayerProfilePopup::TXT_TotalMVPCount' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, BOX_MVPCount) == 0x0005C8, "Member 'UUI_PlayerProfilePopup::BOX_MVPCount' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, TXT_HitRate) == 0x0005D0, "Member 'UUI_PlayerProfilePopup::TXT_HitRate' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, SWITCHER_HitRate) == 0x0005D8, "Member 'UUI_PlayerProfilePopup::SWITCHER_HitRate' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, BOX_Empty_HitRate) == 0x0005E0, "Member 'UUI_PlayerProfilePopup::BOX_Empty_HitRate' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, BOX_HitRate) == 0x0005E8, "Member 'UUI_PlayerProfilePopup::BOX_HitRate' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, HitRateSlot0) == 0x0005F0, "Member 'UUI_PlayerProfilePopup::HitRateSlot0' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, HitRateSlot1) == 0x0005F8, "Member 'UUI_PlayerProfilePopup::HitRateSlot1' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, HitRateSlot2) == 0x000600, "Member 'UUI_PlayerProfilePopup::HitRateSlot2' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, TXT_TotalDamage) == 0x000608, "Member 'UUI_PlayerProfilePopup::TXT_TotalDamage' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, SWITCHER_Damage) == 0x000610, "Member 'UUI_PlayerProfilePopup::SWITCHER_Damage' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, BOX_Empty_Damage) == 0x000618, "Member 'UUI_PlayerProfilePopup::BOX_Empty_Damage' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, BOX_Damage) == 0x000620, "Member 'UUI_PlayerProfilePopup::BOX_Damage' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, DamageSlot0) == 0x000628, "Member 'UUI_PlayerProfilePopup::DamageSlot0' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, DamageSlot1) == 0x000630, "Member 'UUI_PlayerProfilePopup::DamageSlot1' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, DamageSlot2) == 0x000638, "Member 'UUI_PlayerProfilePopup::DamageSlot2' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, KDA_Title) == 0x000640, "Member 'UUI_PlayerProfilePopup::KDA_Title' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, Win_Title) == 0x000648, "Member 'UUI_PlayerProfilePopup::Win_Title' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, MVP_Title) == 0x000650, "Member 'UUI_PlayerProfilePopup::MVP_Title' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, HitRate_Title) == 0x000658, "Member 'UUI_PlayerProfilePopup::HitRate_Title' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, Damage_Title) == 0x000660, "Member 'UUI_PlayerProfilePopup::Damage_Title' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, SWITCHER_State) == 0x000668, "Member 'UUI_PlayerProfilePopup::SWITCHER_State' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, _ModeResultClass) == 0x000670, "Member 'UUI_PlayerProfilePopup::_ModeResultClass' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, _UserID) == 0x000678, "Member 'UUI_PlayerProfilePopup::_UserID' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, _EmblemID) == 0x000680, "Member 'UUI_PlayerProfilePopup::_EmblemID' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, _ProfileCardID) == 0x000690, "Member 'UUI_PlayerProfilePopup::_ProfileCardID' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, _tier) == 0x0006A0, "Member 'UUI_PlayerProfilePopup::_tier' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, _nickname) == 0x0006A8, "Member 'UUI_PlayerProfilePopup::_nickname' has a wrong offset!");
static_assert(offsetof(UUI_PlayerProfilePopup, _level) == 0x0006C0, "Member 'UUI_PlayerProfilePopup::_level' has a wrong offset!");

// Class Stigma.UI_PlayerReadyState
// 0x0010 (0x0500 - 0x04F0)
class UUI_PlayerReadyState : public UPreviewableWidget
{
public:
	uint8                                         Pad_2639[0x8];                                     // 0x04F0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class AMatchServicedPlayerState*              _BoundPlayerState;                                 // 0x04F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPlayerStateChanged(EChangedPlayerState _reason, class AMatchServicedPlayerState* _ps);
	void SetPlayerReadyState(EPlayerReadyState _state);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_PlayerReadyState">();
	}
	static class UUI_PlayerReadyState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_PlayerReadyState>();
	}
};
static_assert(alignof(UUI_PlayerReadyState) == 0x000008, "Wrong alignment on UUI_PlayerReadyState");
static_assert(sizeof(UUI_PlayerReadyState) == 0x000500, "Wrong size on UUI_PlayerReadyState");
static_assert(offsetof(UUI_PlayerReadyState, _BoundPlayerState) == 0x0004F8, "Member 'UUI_PlayerReadyState::_BoundPlayerState' has a wrong offset!");

// Class Stigma.UI_WeeklyBestRecord
// 0x0030 (0x0520 - 0x04F0)
class UUI_WeeklyBestRecord : public UPreviewableWidget
{
public:
	ERankingType                                  _CurRankingType;                                   // 0x04F0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_263B[0x7];                                     // 0x04F1(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FNetWeeklyBestRank>             _WeeklyBestRank;                                   // 0x04F8(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FSeasonID                              _SeasonID;                                         // 0x0508(0x0004)(BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_263C[0x4];                                     // 0x050C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UListView*                              BestRecordListView;                                // 0x0510(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Rank;                                          // 0x0518(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddList(ERankingType _ranking_type, EWeeklyBestRecordType _record_type, int32 _week, int32 _value, float _score);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_WeeklyBestRecord">();
	}
	static class UUI_WeeklyBestRecord* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_WeeklyBestRecord>();
	}
};
static_assert(alignof(UUI_WeeklyBestRecord) == 0x000008, "Wrong alignment on UUI_WeeklyBestRecord");
static_assert(sizeof(UUI_WeeklyBestRecord) == 0x000520, "Wrong size on UUI_WeeklyBestRecord");
static_assert(offsetof(UUI_WeeklyBestRecord, _CurRankingType) == 0x0004F0, "Member 'UUI_WeeklyBestRecord::_CurRankingType' has a wrong offset!");
static_assert(offsetof(UUI_WeeklyBestRecord, _WeeklyBestRank) == 0x0004F8, "Member 'UUI_WeeklyBestRecord::_WeeklyBestRank' has a wrong offset!");
static_assert(offsetof(UUI_WeeklyBestRecord, _SeasonID) == 0x000508, "Member 'UUI_WeeklyBestRecord::_SeasonID' has a wrong offset!");
static_assert(offsetof(UUI_WeeklyBestRecord, BestRecordListView) == 0x000510, "Member 'UUI_WeeklyBestRecord::BestRecordListView' has a wrong offset!");
static_assert(offsetof(UUI_WeeklyBestRecord, TXT_Rank) == 0x000518, "Member 'UUI_WeeklyBestRecord::TXT_Rank' has a wrong offset!");

// Class Stigma.UI_PlayerReadyStateContainer
// 0x0030 (0x0520 - 0x04F0)
class UUI_PlayerReadyStateContainer : public UPreviewableWidget
{
public:
	class UHorizontalBox*                         HB_MyTeam;                                         // 0x04F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HB_EnemyTeam1;                                     // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HB_EnemyTeam2;                                     // 0x0500(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_VS1;                                           // 0x0508(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_VS2;                                           // 0x0510(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_PlayerReadyState>       _PlayerReadyStateClass;                            // 0x0518(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void AddPlayer(class AMatchServicedPlayerState* _ps);
	void InitWidget(EGameMode _mode_type);
	void RemovePlayer(class AMatchServicedPlayerState* _ps);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_PlayerReadyStateContainer">();
	}
	static class UUI_PlayerReadyStateContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_PlayerReadyStateContainer>();
	}
};
static_assert(alignof(UUI_PlayerReadyStateContainer) == 0x000008, "Wrong alignment on UUI_PlayerReadyStateContainer");
static_assert(sizeof(UUI_PlayerReadyStateContainer) == 0x000520, "Wrong size on UUI_PlayerReadyStateContainer");
static_assert(offsetof(UUI_PlayerReadyStateContainer, HB_MyTeam) == 0x0004F0, "Member 'UUI_PlayerReadyStateContainer::HB_MyTeam' has a wrong offset!");
static_assert(offsetof(UUI_PlayerReadyStateContainer, HB_EnemyTeam1) == 0x0004F8, "Member 'UUI_PlayerReadyStateContainer::HB_EnemyTeam1' has a wrong offset!");
static_assert(offsetof(UUI_PlayerReadyStateContainer, HB_EnemyTeam2) == 0x000500, "Member 'UUI_PlayerReadyStateContainer::HB_EnemyTeam2' has a wrong offset!");
static_assert(offsetof(UUI_PlayerReadyStateContainer, Img_VS1) == 0x000508, "Member 'UUI_PlayerReadyStateContainer::Img_VS1' has a wrong offset!");
static_assert(offsetof(UUI_PlayerReadyStateContainer, Img_VS2) == 0x000510, "Member 'UUI_PlayerReadyStateContainer::Img_VS2' has a wrong offset!");
static_assert(offsetof(UUI_PlayerReadyStateContainer, _PlayerReadyStateClass) == 0x000518, "Member 'UUI_PlayerReadyStateContainer::_PlayerReadyStateClass' has a wrong offset!");

// Class Stigma.UI_PlayerResultItem
// 0x0130 (0x0620 - 0x04F0)
class UUI_PlayerResultItem : public UPreviewableWidget
{
public:
	class UWidget*                                _owner;                                            // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsMVP;                                            // 0x04F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_263E[0x7];                                     // 0x04F9(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	struct FUserBattleResult                      _PlayerResult;                                     // 0x0500(0x0090)(Edit, BlueprintVisible, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	bool                                          _ShowEmblem;                                       // 0x0590(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_263F[0x7];                                     // 0x0591(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UTextBlock*                             TXT_MVP;                                           // 0x0598(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_TeamBackground;                                // 0x05A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                BTN_Report;                                        // 0x05A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                BTN_AddFriend;                                     // 0x05B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_ProfileCard*                        ProfileCard;                                       // 0x05B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Kill;                                          // 0x05C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Death;                                         // 0x05C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Assist;                                        // 0x05D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_EXP;                                           // 0x05D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScaleBox*                              SC_RankPoint;                                      // 0x05E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_RankPoint;                                     // 0x05E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Diamond;                                       // 0x05F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScaleBox*                              SC_Score;                                          // 0x05F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Score;                                         // 0x0600(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_PlayTime;                                      // 0x0608(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               OVL_AI;                                            // 0x0610(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2640[0x8];                                     // 0x0618(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnUpdateUI_ProfileCard();
	void UpdateUI();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_PlayerResultItem">();
	}
	static class UUI_PlayerResultItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_PlayerResultItem>();
	}
};
static_assert(alignof(UUI_PlayerResultItem) == 0x000008, "Wrong alignment on UUI_PlayerResultItem");
static_assert(sizeof(UUI_PlayerResultItem) == 0x000620, "Wrong size on UUI_PlayerResultItem");
static_assert(offsetof(UUI_PlayerResultItem, _owner) == 0x0004F0, "Member 'UUI_PlayerResultItem::_owner' has a wrong offset!");
static_assert(offsetof(UUI_PlayerResultItem, _IsMVP) == 0x0004F8, "Member 'UUI_PlayerResultItem::_IsMVP' has a wrong offset!");
static_assert(offsetof(UUI_PlayerResultItem, _PlayerResult) == 0x000500, "Member 'UUI_PlayerResultItem::_PlayerResult' has a wrong offset!");
static_assert(offsetof(UUI_PlayerResultItem, _ShowEmblem) == 0x000590, "Member 'UUI_PlayerResultItem::_ShowEmblem' has a wrong offset!");
static_assert(offsetof(UUI_PlayerResultItem, TXT_MVP) == 0x000598, "Member 'UUI_PlayerResultItem::TXT_MVP' has a wrong offset!");
static_assert(offsetof(UUI_PlayerResultItem, IMG_TeamBackground) == 0x0005A0, "Member 'UUI_PlayerResultItem::IMG_TeamBackground' has a wrong offset!");
static_assert(offsetof(UUI_PlayerResultItem, BTN_Report) == 0x0005A8, "Member 'UUI_PlayerResultItem::BTN_Report' has a wrong offset!");
static_assert(offsetof(UUI_PlayerResultItem, BTN_AddFriend) == 0x0005B0, "Member 'UUI_PlayerResultItem::BTN_AddFriend' has a wrong offset!");
static_assert(offsetof(UUI_PlayerResultItem, ProfileCard) == 0x0005B8, "Member 'UUI_PlayerResultItem::ProfileCard' has a wrong offset!");
static_assert(offsetof(UUI_PlayerResultItem, TXT_Kill) == 0x0005C0, "Member 'UUI_PlayerResultItem::TXT_Kill' has a wrong offset!");
static_assert(offsetof(UUI_PlayerResultItem, TXT_Death) == 0x0005C8, "Member 'UUI_PlayerResultItem::TXT_Death' has a wrong offset!");
static_assert(offsetof(UUI_PlayerResultItem, TXT_Assist) == 0x0005D0, "Member 'UUI_PlayerResultItem::TXT_Assist' has a wrong offset!");
static_assert(offsetof(UUI_PlayerResultItem, TXT_EXP) == 0x0005D8, "Member 'UUI_PlayerResultItem::TXT_EXP' has a wrong offset!");
static_assert(offsetof(UUI_PlayerResultItem, SC_RankPoint) == 0x0005E0, "Member 'UUI_PlayerResultItem::SC_RankPoint' has a wrong offset!");
static_assert(offsetof(UUI_PlayerResultItem, TXT_RankPoint) == 0x0005E8, "Member 'UUI_PlayerResultItem::TXT_RankPoint' has a wrong offset!");
static_assert(offsetof(UUI_PlayerResultItem, TXT_Diamond) == 0x0005F0, "Member 'UUI_PlayerResultItem::TXT_Diamond' has a wrong offset!");
static_assert(offsetof(UUI_PlayerResultItem, SC_Score) == 0x0005F8, "Member 'UUI_PlayerResultItem::SC_Score' has a wrong offset!");
static_assert(offsetof(UUI_PlayerResultItem, TXT_Score) == 0x000600, "Member 'UUI_PlayerResultItem::TXT_Score' has a wrong offset!");
static_assert(offsetof(UUI_PlayerResultItem, TXT_PlayTime) == 0x000608, "Member 'UUI_PlayerResultItem::TXT_PlayTime' has a wrong offset!");
static_assert(offsetof(UUI_PlayerResultItem, OVL_AI) == 0x000610, "Member 'UUI_PlayerResultItem::OVL_AI' has a wrong offset!");

// Class Stigma.UI_Preview
// 0x0080 (0x05B8 - 0x0538)
class UUI_Preview : public UUI_PreviewBase
{
public:
	class UWidgetSwitcher*                        WidgetSwitcher;                                    // 0x0538(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_ProfileCard*                        ProfileCard;                                       // 0x0540(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class APreviewActor>              _LobbyGunPreviewerClass;                           // 0x0548(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class APreviewActor>              _LobbyCharmPreviewerClass;                         // 0x0550(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _CamTag_Chara;                                     // 0x0558(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _CamTag_Gun;                                       // 0x0560(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   _CamTag_Charm;                                     // 0x0568(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2641[0x10];                                    // 0x0570(0x0010)(Fixing Size After Last Property [ Dumper-69 ])
	class UGunObject*                             _PreviewGunObj;                                    // 0x0580(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AMannequin*                             _PreviewMannequin;                                 // 0x0588(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2642[0x8];                                     // 0x0590(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TArray<struct FRewardItem>                    _DefaultPreviewItems;                              // 0x0598(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FRewardItem>                    _LastPreviewItems;                                 // 0x05A8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	void InitDefaultItems(const TArray<struct FRewardItem>& _default_items);
	void OnShowPreviewType(EPreviewType _type);
	void ResetPreview(bool _include_default_items);
	void SetCharmPreviewer(class APreviewActor* _previewer, const struct FItemID_Gun_Charm& _charm_id);
	void SetGunPreviewer(class APreviewActor* _previewer, class UGunObject* _gun_obj);
	void SetPreviewImage(const struct FRewardItem& _item);
	void ShowPreview(const struct FRewardItem& _preview_item);
	void ShowPreviewButtons(const TSet<EPreviewType>& _preview_types);
	void ShowPreviewType(EPreviewType _type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Preview">();
	}
	static class UUI_Preview* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Preview>();
	}
};
static_assert(alignof(UUI_Preview) == 0x000008, "Wrong alignment on UUI_Preview");
static_assert(sizeof(UUI_Preview) == 0x0005B8, "Wrong size on UUI_Preview");
static_assert(offsetof(UUI_Preview, WidgetSwitcher) == 0x000538, "Member 'UUI_Preview::WidgetSwitcher' has a wrong offset!");
static_assert(offsetof(UUI_Preview, ProfileCard) == 0x000540, "Member 'UUI_Preview::ProfileCard' has a wrong offset!");
static_assert(offsetof(UUI_Preview, _LobbyGunPreviewerClass) == 0x000548, "Member 'UUI_Preview::_LobbyGunPreviewerClass' has a wrong offset!");
static_assert(offsetof(UUI_Preview, _LobbyCharmPreviewerClass) == 0x000550, "Member 'UUI_Preview::_LobbyCharmPreviewerClass' has a wrong offset!");
static_assert(offsetof(UUI_Preview, _CamTag_Chara) == 0x000558, "Member 'UUI_Preview::_CamTag_Chara' has a wrong offset!");
static_assert(offsetof(UUI_Preview, _CamTag_Gun) == 0x000560, "Member 'UUI_Preview::_CamTag_Gun' has a wrong offset!");
static_assert(offsetof(UUI_Preview, _CamTag_Charm) == 0x000568, "Member 'UUI_Preview::_CamTag_Charm' has a wrong offset!");
static_assert(offsetof(UUI_Preview, _PreviewGunObj) == 0x000580, "Member 'UUI_Preview::_PreviewGunObj' has a wrong offset!");
static_assert(offsetof(UUI_Preview, _PreviewMannequin) == 0x000588, "Member 'UUI_Preview::_PreviewMannequin' has a wrong offset!");
static_assert(offsetof(UUI_Preview, _DefaultPreviewItems) == 0x000598, "Member 'UUI_Preview::_DefaultPreviewItems' has a wrong offset!");
static_assert(offsetof(UUI_Preview, _LastPreviewItems) == 0x0005A8, "Member 'UUI_Preview::_LastPreviewItems' has a wrong offset!");

// Class Stigma.UI_PreviewPopupBase
// 0x00B0 (0x05A0 - 0x04F0)
class UUI_PreviewPopupBase : public UPreviewableWidget
{
public:
	class UCtrl_ItemTag*                          ItemTag;                                           // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_Title;                                         // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WS_Time;                                           // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_RemainDateTimer*                    RemainTimer;                                       // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_Date;                                          // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USizeBox*                               SB_Desc;                                           // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Desc;                                          // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HB_UserCurrency;                                   // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_Preview*                            Preview;                                           // 0x0530(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   _Title;                                            // 0x0538(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	class FText                                   _Desc;                                             // 0x0550(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_CurrencyBox>            _CurrencyBoxClass;                                 // 0x0568(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              _CurrencyBoxHorizontalPadding;                     // 0x0570(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2643[0x20];                                    // 0x0580(0x0020)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void AddPreviewItem(const struct FRewardItem& _item);
	void AddUserCurrency(const struct FItemID_Currency& _currency_id);
	void ClearUserCurrencies();
	void HideTime();
	void InitPreview(const TArray<struct FRewardItem>& _default_items);
	void SetDate(const class FString& _start_at_str, const class FString& _end_at_str);
	void SetDesc(const class FText& _text);
	void SetPreviewResetMannequinOnClose(bool _reset);
	void SetRemainTimer(const struct FDateTime& _end_at, int32 _alert_hour);
	void SetTags(const TArray<EItemUITag>& _tags);
	void SetTitle(const class FText& _text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_PreviewPopupBase">();
	}
	static class UUI_PreviewPopupBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_PreviewPopupBase>();
	}
};
static_assert(alignof(UUI_PreviewPopupBase) == 0x000008, "Wrong alignment on UUI_PreviewPopupBase");
static_assert(sizeof(UUI_PreviewPopupBase) == 0x0005A0, "Wrong size on UUI_PreviewPopupBase");
static_assert(offsetof(UUI_PreviewPopupBase, ItemTag) == 0x0004F0, "Member 'UUI_PreviewPopupBase::ItemTag' has a wrong offset!");
static_assert(offsetof(UUI_PreviewPopupBase, Txt_Title) == 0x0004F8, "Member 'UUI_PreviewPopupBase::Txt_Title' has a wrong offset!");
static_assert(offsetof(UUI_PreviewPopupBase, WS_Time) == 0x000500, "Member 'UUI_PreviewPopupBase::WS_Time' has a wrong offset!");
static_assert(offsetof(UUI_PreviewPopupBase, RemainTimer) == 0x000508, "Member 'UUI_PreviewPopupBase::RemainTimer' has a wrong offset!");
static_assert(offsetof(UUI_PreviewPopupBase, Txt_Date) == 0x000510, "Member 'UUI_PreviewPopupBase::Txt_Date' has a wrong offset!");
static_assert(offsetof(UUI_PreviewPopupBase, SB_Desc) == 0x000518, "Member 'UUI_PreviewPopupBase::SB_Desc' has a wrong offset!");
static_assert(offsetof(UUI_PreviewPopupBase, TXT_Desc) == 0x000520, "Member 'UUI_PreviewPopupBase::TXT_Desc' has a wrong offset!");
static_assert(offsetof(UUI_PreviewPopupBase, HB_UserCurrency) == 0x000528, "Member 'UUI_PreviewPopupBase::HB_UserCurrency' has a wrong offset!");
static_assert(offsetof(UUI_PreviewPopupBase, Preview) == 0x000530, "Member 'UUI_PreviewPopupBase::Preview' has a wrong offset!");
static_assert(offsetof(UUI_PreviewPopupBase, _Title) == 0x000538, "Member 'UUI_PreviewPopupBase::_Title' has a wrong offset!");
static_assert(offsetof(UUI_PreviewPopupBase, _Desc) == 0x000550, "Member 'UUI_PreviewPopupBase::_Desc' has a wrong offset!");
static_assert(offsetof(UUI_PreviewPopupBase, _CurrencyBoxClass) == 0x000568, "Member 'UUI_PreviewPopupBase::_CurrencyBoxClass' has a wrong offset!");
static_assert(offsetof(UUI_PreviewPopupBase, _CurrencyBoxHorizontalPadding) == 0x000570, "Member 'UUI_PreviewPopupBase::_CurrencyBoxHorizontalPadding' has a wrong offset!");

// Class Stigma.UserNameBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UUserNameBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString GetName(const struct FUserName& _Name);
	static int32 GetTag(const struct FUserName& _Name);
	static class FString ToString(const struct FUserName& _Name, bool _with_tag);
	static class FText ToText(const struct FUserName& _Name, bool _with_tag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserNameBlueprintLibrary">();
	}
	static class UUserNameBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserNameBlueprintLibrary>();
	}
};
static_assert(alignof(UUserNameBlueprintLibrary) == 0x000008, "Wrong alignment on UUserNameBlueprintLibrary");
static_assert(sizeof(UUserNameBlueprintLibrary) == 0x000028, "Wrong size on UUserNameBlueprintLibrary");

// Class Stigma.UI_ProfileCard
// 0x0048 (0x0538 - 0x04F0)
class UUI_ProfileCard : public UPreviewableWidget
{
public:
	class UOverlay*                               Ovl_WidgetContainer;                               // 0x04F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Img_Emblem;                                        // 0x04F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULocalUserProfile*                      _UserObj;                                          // 0x0500(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2648[0x30];                                    // 0x0508(0x0030)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void Bind(class ULocalUserProfile* _user_obj);
	TArray<struct FHoverMenuEntry> GetBriefToolTipEntries(const struct FUserID& _user_id);
	void OnUpdateNicknameFX(const struct FItemID& _nickfx_id);
	void SetEmblemIcon(const TSoftObjectPtr<class UTexture2D>& _Icon);
	void SetEmblemID(const struct FItemID& _item_id);
	void SetNicknameFXID(const struct FItemID& _item_id);
	void SetProfileCardID(const struct FItemID& _item_id);
	void Update(bool _is_set_master_icon);
	void UpdateEmblem();
	void UpdateNicknameFX();
	void UpdateProfileCard();

	class ULocalUserProfile* GetUserObj() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_ProfileCard">();
	}
	static class UUI_ProfileCard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_ProfileCard>();
	}
};
static_assert(alignof(UUI_ProfileCard) == 0x000008, "Wrong alignment on UUI_ProfileCard");
static_assert(sizeof(UUI_ProfileCard) == 0x000538, "Wrong size on UUI_ProfileCard");
static_assert(offsetof(UUI_ProfileCard, Ovl_WidgetContainer) == 0x0004F0, "Member 'UUI_ProfileCard::Ovl_WidgetContainer' has a wrong offset!");
static_assert(offsetof(UUI_ProfileCard, Img_Emblem) == 0x0004F8, "Member 'UUI_ProfileCard::Img_Emblem' has a wrong offset!");
static_assert(offsetof(UUI_ProfileCard, _UserObj) == 0x000500, "Member 'UUI_ProfileCard::_UserObj' has a wrong offset!");

// Class Stigma.UI_RadioChatBox
// 0x0020 (0x0510 - 0x04F0)
class UUI_RadioChatBox : public UPreviewableWidget
{
public:
	bool                                          _IsOpen;                                           // 0x04F0(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERadioChatPhase                               _CurPhase;                                         // 0x04F1(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERadioChatCategory                            _CurCategory;                                      // 0x04F2(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2649[0x5];                                     // 0x04F3(0x0005)(Fixing Size After Last Property [ Dumper-69 ])
	class UWidgetSwitcher*                        WS_Cooltime;                                       // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_RadioStock;                                    // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Cooltime;                                      // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool IsOpen();
	void SelectRadioChatCategory(int32 _idx);
	void SelectRadioChatList(ERadioChatPhase _phase, int32 _idx);
	void SelectRadioChatMsg(int32 _idx);
	void Update();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_RadioChatBox">();
	}
	static class UUI_RadioChatBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_RadioChatBox>();
	}
};
static_assert(alignof(UUI_RadioChatBox) == 0x000008, "Wrong alignment on UUI_RadioChatBox");
static_assert(sizeof(UUI_RadioChatBox) == 0x000510, "Wrong size on UUI_RadioChatBox");
static_assert(offsetof(UUI_RadioChatBox, _IsOpen) == 0x0004F0, "Member 'UUI_RadioChatBox::_IsOpen' has a wrong offset!");
static_assert(offsetof(UUI_RadioChatBox, _CurPhase) == 0x0004F1, "Member 'UUI_RadioChatBox::_CurPhase' has a wrong offset!");
static_assert(offsetof(UUI_RadioChatBox, _CurCategory) == 0x0004F2, "Member 'UUI_RadioChatBox::_CurCategory' has a wrong offset!");
static_assert(offsetof(UUI_RadioChatBox, WS_Cooltime) == 0x0004F8, "Member 'UUI_RadioChatBox::WS_Cooltime' has a wrong offset!");
static_assert(offsetof(UUI_RadioChatBox, TXT_RadioStock) == 0x000500, "Member 'UUI_RadioChatBox::TXT_RadioStock' has a wrong offset!");
static_assert(offsetof(UUI_RadioChatBox, TXT_Cooltime) == 0x000508, "Member 'UUI_RadioChatBox::TXT_Cooltime' has a wrong offset!");

// Class Stigma.UI_RankingListItem
// 0x00D8 (0x05C8 - 0x04F0)
class UUI_RankingListItem : public UPreviewableWidget
{
public:
	uint8                                         Pad_264B[0x8];                                     // 0x04F0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	TWeakObjectPtr<class ULVData_RankingItem>     _ItemData;                                         // 0x04F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           MainPanel;                                         // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_Bg;                                            // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_RankDiff;                                      // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        SWITCHER_Rank;                                     // 0x0518(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_Rank;                                          // 0x0520(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Rank;                                          // 0x0528(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        SWITCHER_ModeInfo;                                 // 0x0530(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_Tier;                                          // 0x0538(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Tier;                                          // 0x0540(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_RankPoint_Total;                               // 0x0548(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_KDA_Total;                                     // 0x0550(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_KDRate_Total;                                  // 0x0558(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_PlayTime_Total;                                // 0x0560(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_RankPoint_Default;                             // 0x0568(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_KDA_Default;                                   // 0x0570(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_KDRate_Default;                                // 0x0578(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_PlayTime_Default;                              // 0x0580(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Win;                                           // 0x0588(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Round;                                         // 0x0590(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_RankPoint_Challenge;                           // 0x0598(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_BlackCoinScore;                                // 0x05A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_GoldScore;                                     // 0x05A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_ArmorScore;                                    // 0x05B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           MyRankPanel;                                       // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_MyBG;                                          // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnSearchedUser();
	void SetUISize(float _size_x, float _size_y);
	void UpdateUI_ProfileCard();
	void UpdateUI_RankDiff(bool _is_new_rank, int32 _diff);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_RankingListItem">();
	}
	static class UUI_RankingListItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_RankingListItem>();
	}
};
static_assert(alignof(UUI_RankingListItem) == 0x000008, "Wrong alignment on UUI_RankingListItem");
static_assert(sizeof(UUI_RankingListItem) == 0x0005C8, "Wrong size on UUI_RankingListItem");
static_assert(offsetof(UUI_RankingListItem, _ItemData) == 0x0004F8, "Member 'UUI_RankingListItem::_ItemData' has a wrong offset!");
static_assert(offsetof(UUI_RankingListItem, MainPanel) == 0x000500, "Member 'UUI_RankingListItem::MainPanel' has a wrong offset!");
static_assert(offsetof(UUI_RankingListItem, IMG_Bg) == 0x000508, "Member 'UUI_RankingListItem::IMG_Bg' has a wrong offset!");
static_assert(offsetof(UUI_RankingListItem, TXT_RankDiff) == 0x000510, "Member 'UUI_RankingListItem::TXT_RankDiff' has a wrong offset!");
static_assert(offsetof(UUI_RankingListItem, SWITCHER_Rank) == 0x000518, "Member 'UUI_RankingListItem::SWITCHER_Rank' has a wrong offset!");
static_assert(offsetof(UUI_RankingListItem, IMG_Rank) == 0x000520, "Member 'UUI_RankingListItem::IMG_Rank' has a wrong offset!");
static_assert(offsetof(UUI_RankingListItem, TXT_Rank) == 0x000528, "Member 'UUI_RankingListItem::TXT_Rank' has a wrong offset!");
static_assert(offsetof(UUI_RankingListItem, SWITCHER_ModeInfo) == 0x000530, "Member 'UUI_RankingListItem::SWITCHER_ModeInfo' has a wrong offset!");
static_assert(offsetof(UUI_RankingListItem, IMG_Tier) == 0x000538, "Member 'UUI_RankingListItem::IMG_Tier' has a wrong offset!");
static_assert(offsetof(UUI_RankingListItem, TXT_Tier) == 0x000540, "Member 'UUI_RankingListItem::TXT_Tier' has a wrong offset!");
static_assert(offsetof(UUI_RankingListItem, TXT_RankPoint_Total) == 0x000548, "Member 'UUI_RankingListItem::TXT_RankPoint_Total' has a wrong offset!");
static_assert(offsetof(UUI_RankingListItem, TXT_KDA_Total) == 0x000550, "Member 'UUI_RankingListItem::TXT_KDA_Total' has a wrong offset!");
static_assert(offsetof(UUI_RankingListItem, TXT_KDRate_Total) == 0x000558, "Member 'UUI_RankingListItem::TXT_KDRate_Total' has a wrong offset!");
static_assert(offsetof(UUI_RankingListItem, TXT_PlayTime_Total) == 0x000560, "Member 'UUI_RankingListItem::TXT_PlayTime_Total' has a wrong offset!");
static_assert(offsetof(UUI_RankingListItem, TXT_RankPoint_Default) == 0x000568, "Member 'UUI_RankingListItem::TXT_RankPoint_Default' has a wrong offset!");
static_assert(offsetof(UUI_RankingListItem, TXT_KDA_Default) == 0x000570, "Member 'UUI_RankingListItem::TXT_KDA_Default' has a wrong offset!");
static_assert(offsetof(UUI_RankingListItem, TXT_KDRate_Default) == 0x000578, "Member 'UUI_RankingListItem::TXT_KDRate_Default' has a wrong offset!");
static_assert(offsetof(UUI_RankingListItem, TXT_PlayTime_Default) == 0x000580, "Member 'UUI_RankingListItem::TXT_PlayTime_Default' has a wrong offset!");
static_assert(offsetof(UUI_RankingListItem, TXT_Win) == 0x000588, "Member 'UUI_RankingListItem::TXT_Win' has a wrong offset!");
static_assert(offsetof(UUI_RankingListItem, TXT_Round) == 0x000590, "Member 'UUI_RankingListItem::TXT_Round' has a wrong offset!");
static_assert(offsetof(UUI_RankingListItem, TXT_RankPoint_Challenge) == 0x000598, "Member 'UUI_RankingListItem::TXT_RankPoint_Challenge' has a wrong offset!");
static_assert(offsetof(UUI_RankingListItem, TXT_BlackCoinScore) == 0x0005A0, "Member 'UUI_RankingListItem::TXT_BlackCoinScore' has a wrong offset!");
static_assert(offsetof(UUI_RankingListItem, TXT_GoldScore) == 0x0005A8, "Member 'UUI_RankingListItem::TXT_GoldScore' has a wrong offset!");
static_assert(offsetof(UUI_RankingListItem, TXT_ArmorScore) == 0x0005B0, "Member 'UUI_RankingListItem::TXT_ArmorScore' has a wrong offset!");
static_assert(offsetof(UUI_RankingListItem, MyRankPanel) == 0x0005B8, "Member 'UUI_RankingListItem::MyRankPanel' has a wrong offset!");
static_assert(offsetof(UUI_RankingListItem, IMG_MyBG) == 0x0005C0, "Member 'UUI_RankingListItem::IMG_MyBG' has a wrong offset!");

// Class Stigma.UI_RankingListView
// 0x0038 (0x0528 - 0x04F0)
class UUI_RankingListView : public UPreviewableWidget
{
public:
	class UListView*                              _ListView;                                         // 0x04F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _NumPreViewEntries;                                // 0x04F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_264D[0x4];                                     // 0x04FC(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	struct FVector2D                              _RankingEntryUISize;                               // 0x0500(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UTexture2D>>      _TopRankImages;                                    // 0x0510(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          _IsShownRankDiff;                                  // 0x0520(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_264E[0x7];                                     // 0x0521(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void AddRankingItem(class ULVData_RankingItem* _item);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_RankingListView">();
	}
	static class UUI_RankingListView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_RankingListView>();
	}
};
static_assert(alignof(UUI_RankingListView) == 0x000008, "Wrong alignment on UUI_RankingListView");
static_assert(sizeof(UUI_RankingListView) == 0x000528, "Wrong size on UUI_RankingListView");
static_assert(offsetof(UUI_RankingListView, _ListView) == 0x0004F0, "Member 'UUI_RankingListView::_ListView' has a wrong offset!");
static_assert(offsetof(UUI_RankingListView, _NumPreViewEntries) == 0x0004F8, "Member 'UUI_RankingListView::_NumPreViewEntries' has a wrong offset!");
static_assert(offsetof(UUI_RankingListView, _RankingEntryUISize) == 0x000500, "Member 'UUI_RankingListView::_RankingEntryUISize' has a wrong offset!");
static_assert(offsetof(UUI_RankingListView, _TopRankImages) == 0x000510, "Member 'UUI_RankingListView::_TopRankImages' has a wrong offset!");
static_assert(offsetof(UUI_RankingListView, _IsShownRankDiff) == 0x000520, "Member 'UUI_RankingListView::_IsShownRankDiff' has a wrong offset!");

// Class Stigma.UserProfiles
// 0x0000 (0x0028 - 0x0028)
class UUserProfiles final : public UBlueprintFunctionLibrary
{
public:
	static int32 ReadRegistryINT32(const class FString& Section, const class FString& Entry, int32 Default_value);
	static class FString ReadRegistryString(const class FString& Section, const class FString& Entry, const class FString& Default_value);
	static void WriteRegistryINT32(const class FString& Section, const class FString& Entry, int32 Value);
	static void WriteRegistryString(const class FString& Section, const class FString& Entry, const class FString& Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserProfiles">();
	}
	static class UUserProfiles* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserProfiles>();
	}
};
static_assert(alignof(UUserProfiles) == 0x000008, "Wrong alignment on UUserProfiles");
static_assert(sizeof(UUserProfiles) == 0x000028, "Wrong size on UUserProfiles");

// Class Stigma.UI_RecordPage_Ranking
// 0x0098 (0x05A8 - 0x0510)
class UUI_RecordPage_Ranking : public UUI_LobbyPage
{
public:
	class UCtrl_HorizontalTabPanel*               ModeTab;                                           // 0x0510(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionDropDownBase*               DropDown_Season;                                   // 0x0518(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           V_Season;                                          // 0x0520(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_StartDate;                                     // 0x0528(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_EndDate;                                       // 0x0530(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Page;                                          // 0x0538(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_Status*                           Status_NoRecord;                                   // 0x0540(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_WeeklyBestRecord*                   Panel_WeeklyBestRecord;                            // 0x0548(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_RankingListView*                    RankingListView;                                   // 0x0550(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                BTN_PrevPage;                                      // 0x0558(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                BTN_NextPage;                                      // 0x0560(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                BTN_Prev10Page;                                    // 0x0568(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                BTN_Next10Page;                                    // 0x0570(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                BTN_PlayerSearch;                                  // 0x0578(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_TextCheckBoxBase*                 TextCheckBox_OnlyMe;                               // 0x0580(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_TextCheckBoxBase*                 TextCheckBox_OnlyFriend;                           // 0x0588(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ERankingType                                  _CurRankingType;                                   // 0x0590(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2650[0x3];                                     // 0x0591(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	struct FSeasonID                              _SelectedSeasonID;                                 // 0x0594(0x0004)(BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _CurPage;                                          // 0x0598(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _IsShownOnlyFriendRanking;                         // 0x059C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2651[0x3];                                     // 0x059D(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	class UUserProfile*                           _SearchUser;                                       // 0x05A0(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FNetReply OnACK_GetChallengeRankingList(EResultCode _rcode, const struct FACK_ReadChallengeRanking& _ack);
	struct FNetReply OnACK_GetFriendRankingList(EResultCode _rcode, const struct FACK_ReadFriendRanking& _ack);
	struct FNetReply OnACK_GetRankingList(EResultCode _rcode, const struct FACK_ReadRanking& _ack);
	struct FNetReply OnACK_GetSearchedUserRankingList(EResultCode _rcode, const struct FACK_ReadSearchedUserRanking& _ack);
	struct FNetReply OnACK_GetWeeklyBestRank(EResultCode _rcode, const struct FACK_ReadWeeklyBestRank& _ack);
	void OnClickNext10Page();
	void OnClickNextPage();
	void OnClickPrev10Page();
	void OnClickPrevPage();
	void OnModeTabChanged(class FName _id, int32 _idx);
	void OnUpdateRankingType();
	void SetShowOnlyFriendRanking(bool _is_shown_only_friend_ranking, bool _update_ranking_context);
	void Setter_CurRankingType(ERankingType _ranking_type);
	void Setter_SeasonID(const struct FSeasonID& _selected_season_id);
	void UpdateFriendRankingContext(int32 _page_offset);
	void UpdateRankingContext(ERankingType _ranking_type, int32 _page_offset, class UUserProfile* _search_user);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_RecordPage_Ranking">();
	}
	static class UUI_RecordPage_Ranking* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_RecordPage_Ranking>();
	}
};
static_assert(alignof(UUI_RecordPage_Ranking) == 0x000008, "Wrong alignment on UUI_RecordPage_Ranking");
static_assert(sizeof(UUI_RecordPage_Ranking) == 0x0005A8, "Wrong size on UUI_RecordPage_Ranking");
static_assert(offsetof(UUI_RecordPage_Ranking, ModeTab) == 0x000510, "Member 'UUI_RecordPage_Ranking::ModeTab' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Ranking, DropDown_Season) == 0x000518, "Member 'UUI_RecordPage_Ranking::DropDown_Season' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Ranking, V_Season) == 0x000520, "Member 'UUI_RecordPage_Ranking::V_Season' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Ranking, TXT_StartDate) == 0x000528, "Member 'UUI_RecordPage_Ranking::TXT_StartDate' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Ranking, TXT_EndDate) == 0x000530, "Member 'UUI_RecordPage_Ranking::TXT_EndDate' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Ranking, TXT_Page) == 0x000538, "Member 'UUI_RecordPage_Ranking::TXT_Page' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Ranking, Status_NoRecord) == 0x000540, "Member 'UUI_RecordPage_Ranking::Status_NoRecord' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Ranking, Panel_WeeklyBestRecord) == 0x000548, "Member 'UUI_RecordPage_Ranking::Panel_WeeklyBestRecord' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Ranking, RankingListView) == 0x000550, "Member 'UUI_RecordPage_Ranking::RankingListView' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Ranking, BTN_PrevPage) == 0x000558, "Member 'UUI_RecordPage_Ranking::BTN_PrevPage' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Ranking, BTN_NextPage) == 0x000560, "Member 'UUI_RecordPage_Ranking::BTN_NextPage' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Ranking, BTN_Prev10Page) == 0x000568, "Member 'UUI_RecordPage_Ranking::BTN_Prev10Page' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Ranking, BTN_Next10Page) == 0x000570, "Member 'UUI_RecordPage_Ranking::BTN_Next10Page' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Ranking, BTN_PlayerSearch) == 0x000578, "Member 'UUI_RecordPage_Ranking::BTN_PlayerSearch' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Ranking, TextCheckBox_OnlyMe) == 0x000580, "Member 'UUI_RecordPage_Ranking::TextCheckBox_OnlyMe' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Ranking, TextCheckBox_OnlyFriend) == 0x000588, "Member 'UUI_RecordPage_Ranking::TextCheckBox_OnlyFriend' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Ranking, _CurRankingType) == 0x000590, "Member 'UUI_RecordPage_Ranking::_CurRankingType' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Ranking, _SelectedSeasonID) == 0x000594, "Member 'UUI_RecordPage_Ranking::_SelectedSeasonID' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Ranking, _CurPage) == 0x000598, "Member 'UUI_RecordPage_Ranking::_CurPage' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Ranking, _IsShownOnlyFriendRanking) == 0x00059C, "Member 'UUI_RecordPage_Ranking::_IsShownOnlyFriendRanking' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Ranking, _SearchUser) == 0x0005A0, "Member 'UUI_RecordPage_Ranking::_SearchUser' has a wrong offset!");

// Class Stigma.UI_RecordPage_Statistic
// 0x0128 (0x0638 - 0x0510)
class UUI_RecordPage_Statistic : public UUI_LobbyPage
{
public:
	class UTextBlock*                             TXT_KDATotal;                                      // 0x0510(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_KDARate;                                       // 0x0518(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        SWITCHER_CharacterKDA;                             // 0x0520(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                BOX_Empty_CharacterKDA;                            // 0x0528(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                BOX_CharacterKDA;                                  // 0x0530(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_Record_KDA_Master*                  KDA_CharacterSlot0;                                // 0x0538(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_Record_KDA_Master*                  KDA_CharacterSlot1;                                // 0x0540(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_Record_KDA_Master*                  KDA_CharacterSlot2;                                // 0x0548(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_TotalWinCount;                                 // 0x0550(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         BOX_WinCount;                                      // 0x0558(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_TotalMVPCount;                                 // 0x0560(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         BOX_MVPCount;                                      // 0x0568(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_HitRate;                                       // 0x0570(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        SWITCHER_HitRate;                                  // 0x0578(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                BOX_Empty_HitRate;                                 // 0x0580(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                BOX_HitRate;                                       // 0x0588(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_Record_AttackMethod*                HitRateSlot0;                                      // 0x0590(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_Record_AttackMethod*                HitRateSlot1;                                      // 0x0598(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_Record_AttackMethod*                HitRateSlot2;                                      // 0x05A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_TotalDamage;                                   // 0x05A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        SWITCHER_Damage;                                   // 0x05B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                BOX_Empty_Damage;                                  // 0x05B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                BOX_Damage;                                        // 0x05C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_Record_AttackMethod*                DamageSlot0;                                       // 0x05C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_Record_AttackMethod*                DamageSlot1;                                       // 0x05D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_Record_AttackMethod*                DamageSlot2;                                       // 0x05D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_TotalPlayTime;                                 // 0x05E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UListView*                              LISTVIEW_PlayTime;                                 // 0x05E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UListView*                              LISTVIEW_KillStreak;                               // 0x05F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                KDA_Title;                                         // 0x05F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                Win_Title;                                         // 0x0600(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                MVP_Title;                                         // 0x0608(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                HitRate_Title;                                     // 0x0610(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                Damage_Title;                                      // 0x0618(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                KillStreak_Title;                                  // 0x0620(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                PlayTime_Title;                                    // 0x0628(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_Record_ModeResultCount> _ModeResultClass;                                  // 0x0630(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_RecordPage_Statistic">();
	}
	static class UUI_RecordPage_Statistic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_RecordPage_Statistic>();
	}
};
static_assert(alignof(UUI_RecordPage_Statistic) == 0x000008, "Wrong alignment on UUI_RecordPage_Statistic");
static_assert(sizeof(UUI_RecordPage_Statistic) == 0x000638, "Wrong size on UUI_RecordPage_Statistic");
static_assert(offsetof(UUI_RecordPage_Statistic, TXT_KDATotal) == 0x000510, "Member 'UUI_RecordPage_Statistic::TXT_KDATotal' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, TXT_KDARate) == 0x000518, "Member 'UUI_RecordPage_Statistic::TXT_KDARate' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, SWITCHER_CharacterKDA) == 0x000520, "Member 'UUI_RecordPage_Statistic::SWITCHER_CharacterKDA' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, BOX_Empty_CharacterKDA) == 0x000528, "Member 'UUI_RecordPage_Statistic::BOX_Empty_CharacterKDA' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, BOX_CharacterKDA) == 0x000530, "Member 'UUI_RecordPage_Statistic::BOX_CharacterKDA' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, KDA_CharacterSlot0) == 0x000538, "Member 'UUI_RecordPage_Statistic::KDA_CharacterSlot0' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, KDA_CharacterSlot1) == 0x000540, "Member 'UUI_RecordPage_Statistic::KDA_CharacterSlot1' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, KDA_CharacterSlot2) == 0x000548, "Member 'UUI_RecordPage_Statistic::KDA_CharacterSlot2' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, TXT_TotalWinCount) == 0x000550, "Member 'UUI_RecordPage_Statistic::TXT_TotalWinCount' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, BOX_WinCount) == 0x000558, "Member 'UUI_RecordPage_Statistic::BOX_WinCount' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, TXT_TotalMVPCount) == 0x000560, "Member 'UUI_RecordPage_Statistic::TXT_TotalMVPCount' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, BOX_MVPCount) == 0x000568, "Member 'UUI_RecordPage_Statistic::BOX_MVPCount' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, TXT_HitRate) == 0x000570, "Member 'UUI_RecordPage_Statistic::TXT_HitRate' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, SWITCHER_HitRate) == 0x000578, "Member 'UUI_RecordPage_Statistic::SWITCHER_HitRate' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, BOX_Empty_HitRate) == 0x000580, "Member 'UUI_RecordPage_Statistic::BOX_Empty_HitRate' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, BOX_HitRate) == 0x000588, "Member 'UUI_RecordPage_Statistic::BOX_HitRate' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, HitRateSlot0) == 0x000590, "Member 'UUI_RecordPage_Statistic::HitRateSlot0' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, HitRateSlot1) == 0x000598, "Member 'UUI_RecordPage_Statistic::HitRateSlot1' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, HitRateSlot2) == 0x0005A0, "Member 'UUI_RecordPage_Statistic::HitRateSlot2' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, TXT_TotalDamage) == 0x0005A8, "Member 'UUI_RecordPage_Statistic::TXT_TotalDamage' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, SWITCHER_Damage) == 0x0005B0, "Member 'UUI_RecordPage_Statistic::SWITCHER_Damage' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, BOX_Empty_Damage) == 0x0005B8, "Member 'UUI_RecordPage_Statistic::BOX_Empty_Damage' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, BOX_Damage) == 0x0005C0, "Member 'UUI_RecordPage_Statistic::BOX_Damage' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, DamageSlot0) == 0x0005C8, "Member 'UUI_RecordPage_Statistic::DamageSlot0' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, DamageSlot1) == 0x0005D0, "Member 'UUI_RecordPage_Statistic::DamageSlot1' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, DamageSlot2) == 0x0005D8, "Member 'UUI_RecordPage_Statistic::DamageSlot2' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, TXT_TotalPlayTime) == 0x0005E0, "Member 'UUI_RecordPage_Statistic::TXT_TotalPlayTime' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, LISTVIEW_PlayTime) == 0x0005E8, "Member 'UUI_RecordPage_Statistic::LISTVIEW_PlayTime' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, LISTVIEW_KillStreak) == 0x0005F0, "Member 'UUI_RecordPage_Statistic::LISTVIEW_KillStreak' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, KDA_Title) == 0x0005F8, "Member 'UUI_RecordPage_Statistic::KDA_Title' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, Win_Title) == 0x000600, "Member 'UUI_RecordPage_Statistic::Win_Title' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, MVP_Title) == 0x000608, "Member 'UUI_RecordPage_Statistic::MVP_Title' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, HitRate_Title) == 0x000610, "Member 'UUI_RecordPage_Statistic::HitRate_Title' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, Damage_Title) == 0x000618, "Member 'UUI_RecordPage_Statistic::Damage_Title' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, KillStreak_Title) == 0x000620, "Member 'UUI_RecordPage_Statistic::KillStreak_Title' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, PlayTime_Title) == 0x000628, "Member 'UUI_RecordPage_Statistic::PlayTime_Title' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Statistic, _ModeResultClass) == 0x000630, "Member 'UUI_RecordPage_Statistic::_ModeResultClass' has a wrong offset!");

// Class Stigma.UI_RecordPage_Tier
// 0x00A0 (0x05B0 - 0x0510)
class UUI_RecordPage_Tier : public UUI_LobbyPage
{
public:
	struct FSeasonID                              _SelectedSeasonID;                                 // 0x0510(0x0004)(BlueprintVisible, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         _CurTierContextIdx;                                // 0x0514(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ETier                                         _MyTier;                                           // 0x0518(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2658[0x7];                                     // 0x0519(0x0007)(Fixing Size After Last Property [ Dumper-69 ])
	class UUI_WeeklyBestRecord*                   Panel_WeeklyBestRecord;                            // 0x0520(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WS_TierContext;                                    // 0x0528(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        WS_RecordStatus;                                   // 0x0530(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionDropDownBase*               DropDown_Season;                                   // 0x0538(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_StartDate;                                     // 0x0540(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_EndDate;                                       // 0x0548(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_Tier;                                          // 0x0550(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_TierText;                                      // 0x0558(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_RankPoint;                                     // 0x0560(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Rank;                                          // 0x0568(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_RankRatio;                                     // 0x0570(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_NoHistory;                                     // 0x0578(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_ModeRecords*                        Records_PlayTime;                                  // 0x0580(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_ModeRecords*                        Records_KDA;                                       // 0x0588(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_ModeRecords*                        Records_Win;                                       // 0x0590(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_SeasonPeriod;                                  // 0x0598(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UListView*                              ListView_HighRankReward;                           // 0x05A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UListView*                              ListView_RankReward;                               // 0x05A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Init();
	struct FNetReply OnACK_GetSearchedUserRankingList(EResultCode _rcode, const struct FACK_ReadSearchedUserRanking& _ack);
	struct FNetReply OnACK_GetUserTierInfo(EResultCode _rcode, const struct FACK_ReadUserTierInfo& _ack);
	void ScrollToItem(class UListView* _list_view, class UObject* _item);
	void Setter_SeasonID(const struct FSeasonID& _selected_season_id);
	void Setter_TierContextIdx(int32 _tier_ctx_idx);
	void UpdateSeasonContext();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_RecordPage_Tier">();
	}
	static class UUI_RecordPage_Tier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_RecordPage_Tier>();
	}
};
static_assert(alignof(UUI_RecordPage_Tier) == 0x000008, "Wrong alignment on UUI_RecordPage_Tier");
static_assert(sizeof(UUI_RecordPage_Tier) == 0x0005B0, "Wrong size on UUI_RecordPage_Tier");
static_assert(offsetof(UUI_RecordPage_Tier, _SelectedSeasonID) == 0x000510, "Member 'UUI_RecordPage_Tier::_SelectedSeasonID' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Tier, _CurTierContextIdx) == 0x000514, "Member 'UUI_RecordPage_Tier::_CurTierContextIdx' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Tier, _MyTier) == 0x000518, "Member 'UUI_RecordPage_Tier::_MyTier' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Tier, Panel_WeeklyBestRecord) == 0x000520, "Member 'UUI_RecordPage_Tier::Panel_WeeklyBestRecord' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Tier, WS_TierContext) == 0x000528, "Member 'UUI_RecordPage_Tier::WS_TierContext' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Tier, WS_RecordStatus) == 0x000530, "Member 'UUI_RecordPage_Tier::WS_RecordStatus' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Tier, DropDown_Season) == 0x000538, "Member 'UUI_RecordPage_Tier::DropDown_Season' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Tier, TXT_StartDate) == 0x000540, "Member 'UUI_RecordPage_Tier::TXT_StartDate' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Tier, TXT_EndDate) == 0x000548, "Member 'UUI_RecordPage_Tier::TXT_EndDate' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Tier, IMG_Tier) == 0x000550, "Member 'UUI_RecordPage_Tier::IMG_Tier' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Tier, IMG_TierText) == 0x000558, "Member 'UUI_RecordPage_Tier::IMG_TierText' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Tier, TXT_RankPoint) == 0x000560, "Member 'UUI_RecordPage_Tier::TXT_RankPoint' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Tier, TXT_Rank) == 0x000568, "Member 'UUI_RecordPage_Tier::TXT_Rank' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Tier, TXT_RankRatio) == 0x000570, "Member 'UUI_RecordPage_Tier::TXT_RankRatio' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Tier, TXT_NoHistory) == 0x000578, "Member 'UUI_RecordPage_Tier::TXT_NoHistory' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Tier, Records_PlayTime) == 0x000580, "Member 'UUI_RecordPage_Tier::Records_PlayTime' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Tier, Records_KDA) == 0x000588, "Member 'UUI_RecordPage_Tier::Records_KDA' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Tier, Records_Win) == 0x000590, "Member 'UUI_RecordPage_Tier::Records_Win' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Tier, TXT_SeasonPeriod) == 0x000598, "Member 'UUI_RecordPage_Tier::TXT_SeasonPeriod' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Tier, ListView_HighRankReward) == 0x0005A0, "Member 'UUI_RecordPage_Tier::ListView_HighRankReward' has a wrong offset!");
static_assert(offsetof(UUI_RecordPage_Tier, ListView_RankReward) == 0x0005A8, "Member 'UUI_RecordPage_Tier::ListView_RankReward' has a wrong offset!");

// Class Stigma.UI_Record_AttackMethod
// 0x0028 (0x02E8 - 0x02C0)
class UUI_Record_AttackMethod : public UUserWidget
{
public:
	class USizeBox*                               SB_Gun;                                            // 0x02C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_Gun;                                           // 0x02C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_Skill;                                         // 0x02D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Name;                                          // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_Value;                                         // 0x02E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Record_AttackMethod">();
	}
	static class UUI_Record_AttackMethod* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Record_AttackMethod>();
	}
};
static_assert(alignof(UUI_Record_AttackMethod) == 0x000008, "Wrong alignment on UUI_Record_AttackMethod");
static_assert(sizeof(UUI_Record_AttackMethod) == 0x0002E8, "Wrong size on UUI_Record_AttackMethod");
static_assert(offsetof(UUI_Record_AttackMethod, SB_Gun) == 0x0002C0, "Member 'UUI_Record_AttackMethod::SB_Gun' has a wrong offset!");
static_assert(offsetof(UUI_Record_AttackMethod, IMG_Gun) == 0x0002C8, "Member 'UUI_Record_AttackMethod::IMG_Gun' has a wrong offset!");
static_assert(offsetof(UUI_Record_AttackMethod, IMG_Skill) == 0x0002D0, "Member 'UUI_Record_AttackMethod::IMG_Skill' has a wrong offset!");
static_assert(offsetof(UUI_Record_AttackMethod, TXT_Name) == 0x0002D8, "Member 'UUI_Record_AttackMethod::TXT_Name' has a wrong offset!");
static_assert(offsetof(UUI_Record_AttackMethod, Txt_Value) == 0x0002E0, "Member 'UUI_Record_AttackMethod::Txt_Value' has a wrong offset!");

// Class Stigma.UI_Record_PlayTimeListItem
// 0x0030 (0x02F0 - 0x02C0)
class UUI_Record_PlayTimeListItem : public UUserWidget
{
public:
	uint8                                         Pad_265B[0x8];                                     // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UTextBlock*                             TXT_PlayTime;                                      // 0x02C8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Name;                                          // 0x02D0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 IMG_CharacterIcon;                                 // 0x02D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UProgressBar*                           PROGRESS_PlayTime;                                 // 0x02E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_265C[0x8];                                     // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Record_PlayTimeListItem">();
	}
	static class UUI_Record_PlayTimeListItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Record_PlayTimeListItem>();
	}
};
static_assert(alignof(UUI_Record_PlayTimeListItem) == 0x000008, "Wrong alignment on UUI_Record_PlayTimeListItem");
static_assert(sizeof(UUI_Record_PlayTimeListItem) == 0x0002F0, "Wrong size on UUI_Record_PlayTimeListItem");
static_assert(offsetof(UUI_Record_PlayTimeListItem, TXT_PlayTime) == 0x0002C8, "Member 'UUI_Record_PlayTimeListItem::TXT_PlayTime' has a wrong offset!");
static_assert(offsetof(UUI_Record_PlayTimeListItem, TXT_Name) == 0x0002D0, "Member 'UUI_Record_PlayTimeListItem::TXT_Name' has a wrong offset!");
static_assert(offsetof(UUI_Record_PlayTimeListItem, IMG_CharacterIcon) == 0x0002D8, "Member 'UUI_Record_PlayTimeListItem::IMG_CharacterIcon' has a wrong offset!");
static_assert(offsetof(UUI_Record_PlayTimeListItem, PROGRESS_PlayTime) == 0x0002E0, "Member 'UUI_Record_PlayTimeListItem::PROGRESS_PlayTime' has a wrong offset!");

// Class Stigma.UI_RecruitHistoryItem
// 0x0060 (0x0320 - 0x02C0)
class UUI_RecruitHistoryItem : public UUserWidget
{
public:
	uint8                                         Pad_265D[0x8];                                     // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class UTextBlock*                             Txt_Time;                                          // 0x02C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_RecruitName;                                   // 0x02D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_RecruitType;                                   // 0x02D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_UseCurrency;                                   // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VB_Reward;                                         // 0x02E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VB_Refund;                                         // 0x02F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_RecruitHistoryRewardText> _HistoryRewardTextClass;                           // 0x02F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UUI_RecruitHistoryRewardText*>   _RewardTextList;                                   // 0x0300(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UUI_RecruitHistoryRewardText*>   _RefundTextList;                                   // 0x0310(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_RecruitHistoryItem">();
	}
	static class UUI_RecruitHistoryItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_RecruitHistoryItem>();
	}
};
static_assert(alignof(UUI_RecruitHistoryItem) == 0x000008, "Wrong alignment on UUI_RecruitHistoryItem");
static_assert(sizeof(UUI_RecruitHistoryItem) == 0x000320, "Wrong size on UUI_RecruitHistoryItem");
static_assert(offsetof(UUI_RecruitHistoryItem, Txt_Time) == 0x0002C8, "Member 'UUI_RecruitHistoryItem::Txt_Time' has a wrong offset!");
static_assert(offsetof(UUI_RecruitHistoryItem, Txt_RecruitName) == 0x0002D0, "Member 'UUI_RecruitHistoryItem::Txt_RecruitName' has a wrong offset!");
static_assert(offsetof(UUI_RecruitHistoryItem, Txt_RecruitType) == 0x0002D8, "Member 'UUI_RecruitHistoryItem::Txt_RecruitType' has a wrong offset!");
static_assert(offsetof(UUI_RecruitHistoryItem, Txt_UseCurrency) == 0x0002E0, "Member 'UUI_RecruitHistoryItem::Txt_UseCurrency' has a wrong offset!");
static_assert(offsetof(UUI_RecruitHistoryItem, VB_Reward) == 0x0002E8, "Member 'UUI_RecruitHistoryItem::VB_Reward' has a wrong offset!");
static_assert(offsetof(UUI_RecruitHistoryItem, VB_Refund) == 0x0002F0, "Member 'UUI_RecruitHistoryItem::VB_Refund' has a wrong offset!");
static_assert(offsetof(UUI_RecruitHistoryItem, _HistoryRewardTextClass) == 0x0002F8, "Member 'UUI_RecruitHistoryItem::_HistoryRewardTextClass' has a wrong offset!");
static_assert(offsetof(UUI_RecruitHistoryItem, _RewardTextList) == 0x000300, "Member 'UUI_RecruitHistoryItem::_RewardTextList' has a wrong offset!");
static_assert(offsetof(UUI_RecruitHistoryItem, _RefundTextList) == 0x000310, "Member 'UUI_RecruitHistoryItem::_RefundTextList' has a wrong offset!");

// Class Stigma.UI_RecruitRefundItem
// 0x0020 (0x0510 - 0x04F0)
class UUI_RecruitRefundItem : public UPreviewableWidget
{
public:
	class UImage*                                 Img_RefundIcon;                                    // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Name;                                          // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               OVL_Count;                                         // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Count;                                         // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_RecruitRefundItem">();
	}
	static class UUI_RecruitRefundItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_RecruitRefundItem>();
	}
};
static_assert(alignof(UUI_RecruitRefundItem) == 0x000008, "Wrong alignment on UUI_RecruitRefundItem");
static_assert(sizeof(UUI_RecruitRefundItem) == 0x000510, "Wrong size on UUI_RecruitRefundItem");
static_assert(offsetof(UUI_RecruitRefundItem, Img_RefundIcon) == 0x0004F0, "Member 'UUI_RecruitRefundItem::Img_RefundIcon' has a wrong offset!");
static_assert(offsetof(UUI_RecruitRefundItem, TXT_Name) == 0x0004F8, "Member 'UUI_RecruitRefundItem::TXT_Name' has a wrong offset!");
static_assert(offsetof(UUI_RecruitRefundItem, OVL_Count) == 0x000500, "Member 'UUI_RecruitRefundItem::OVL_Count' has a wrong offset!");
static_assert(offsetof(UUI_RecruitRefundItem, TXT_Count) == 0x000508, "Member 'UUI_RecruitRefundItem::TXT_Count' has a wrong offset!");

// Class Stigma.UI_RecruitRewardItem
// 0x00D8 (0x05C8 - 0x04F0)
class UUI_RecruitRewardItem : public UPreviewableWidget
{
public:
	class UImage*                                 Img_Grade_Corner;                                  // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Grade_Glow;                                    // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Grade_Smoke;                                   // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Grade_Border;                                  // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_RayGlow;                                       // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               OVL_Special_VFX;                                   // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Icon;                                          // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_ScrollTextBlock*                  TXT_Name;                                          // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_SubName;                                       // 0x0530(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UOverlay*                               OVL_Count;                                         // 0x0538(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             TXT_Count;                                         // 0x0540(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_RemainDateTimer*                    UI_RemainTime;                                     // 0x0548(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UScaleBox*                              SB_SubName;                                        // 0x0550(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_RecruitRefundItem*                  Refund;                                            // 0x0558(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                Btn_Area;                                          // 0x0560(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FNetRecruitRewardItemSet               _reward;                                           // 0x0568(0x0050)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_265E[0x10];                                    // 0x05B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnClickArea();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_RecruitRewardItem">();
	}
	static class UUI_RecruitRewardItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_RecruitRewardItem>();
	}
};
static_assert(alignof(UUI_RecruitRewardItem) == 0x000008, "Wrong alignment on UUI_RecruitRewardItem");
static_assert(sizeof(UUI_RecruitRewardItem) == 0x0005C8, "Wrong size on UUI_RecruitRewardItem");
static_assert(offsetof(UUI_RecruitRewardItem, Img_Grade_Corner) == 0x0004F0, "Member 'UUI_RecruitRewardItem::Img_Grade_Corner' has a wrong offset!");
static_assert(offsetof(UUI_RecruitRewardItem, Img_Grade_Glow) == 0x0004F8, "Member 'UUI_RecruitRewardItem::Img_Grade_Glow' has a wrong offset!");
static_assert(offsetof(UUI_RecruitRewardItem, Img_Grade_Smoke) == 0x000500, "Member 'UUI_RecruitRewardItem::Img_Grade_Smoke' has a wrong offset!");
static_assert(offsetof(UUI_RecruitRewardItem, Img_Grade_Border) == 0x000508, "Member 'UUI_RecruitRewardItem::Img_Grade_Border' has a wrong offset!");
static_assert(offsetof(UUI_RecruitRewardItem, Img_RayGlow) == 0x000510, "Member 'UUI_RecruitRewardItem::Img_RayGlow' has a wrong offset!");
static_assert(offsetof(UUI_RecruitRewardItem, OVL_Special_VFX) == 0x000518, "Member 'UUI_RecruitRewardItem::OVL_Special_VFX' has a wrong offset!");
static_assert(offsetof(UUI_RecruitRewardItem, Img_Icon) == 0x000520, "Member 'UUI_RecruitRewardItem::Img_Icon' has a wrong offset!");
static_assert(offsetof(UUI_RecruitRewardItem, TXT_Name) == 0x000528, "Member 'UUI_RecruitRewardItem::TXT_Name' has a wrong offset!");
static_assert(offsetof(UUI_RecruitRewardItem, TXT_SubName) == 0x000530, "Member 'UUI_RecruitRewardItem::TXT_SubName' has a wrong offset!");
static_assert(offsetof(UUI_RecruitRewardItem, OVL_Count) == 0x000538, "Member 'UUI_RecruitRewardItem::OVL_Count' has a wrong offset!");
static_assert(offsetof(UUI_RecruitRewardItem, TXT_Count) == 0x000540, "Member 'UUI_RecruitRewardItem::TXT_Count' has a wrong offset!");
static_assert(offsetof(UUI_RecruitRewardItem, UI_RemainTime) == 0x000548, "Member 'UUI_RecruitRewardItem::UI_RemainTime' has a wrong offset!");
static_assert(offsetof(UUI_RecruitRewardItem, SB_SubName) == 0x000550, "Member 'UUI_RecruitRewardItem::SB_SubName' has a wrong offset!");
static_assert(offsetof(UUI_RecruitRewardItem, Refund) == 0x000558, "Member 'UUI_RecruitRewardItem::Refund' has a wrong offset!");
static_assert(offsetof(UUI_RecruitRewardItem, Btn_Area) == 0x000560, "Member 'UUI_RecruitRewardItem::Btn_Area' has a wrong offset!");
static_assert(offsetof(UUI_RecruitRewardItem, _reward) == 0x000568, "Member 'UUI_RecruitRewardItem::_reward' has a wrong offset!");

// Class Stigma.UI_Result_Mission
// 0x0018 (0x0508 - 0x04F0)
class UUI_Result_Mission : public UPreviewableWidget
{
public:
	class UTextBlock*                             Txt_Category;                                      // 0x04F0(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_MissionRepeatContainer*           RepeatContainer;                                   // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_ResultProgressBar*                Progress_Mission;                                  // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetDesc(const class FText& _text);
	void SetTitle(const class FText& _text);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Result_Mission">();
	}
	static class UUI_Result_Mission* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Result_Mission>();
	}
};
static_assert(alignof(UUI_Result_Mission) == 0x000008, "Wrong alignment on UUI_Result_Mission");
static_assert(sizeof(UUI_Result_Mission) == 0x000508, "Wrong size on UUI_Result_Mission");
static_assert(offsetof(UUI_Result_Mission, Txt_Category) == 0x0004F0, "Member 'UUI_Result_Mission::Txt_Category' has a wrong offset!");
static_assert(offsetof(UUI_Result_Mission, RepeatContainer) == 0x0004F8, "Member 'UUI_Result_Mission::RepeatContainer' has a wrong offset!");
static_assert(offsetof(UUI_Result_Mission, Progress_Mission) == 0x000500, "Member 'UUI_Result_Mission::Progress_Mission' has a wrong offset!");

// Class Stigma.UI_RewardedPopup
// 0x0008 (0x0578 - 0x0570)
class UUI_RewardedPopup : public UPopupBase
{
public:
	class UUI_RewardedItems*                      UI_RewardedItems;                                  // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_RewardedPopup">();
	}
	static class UUI_RewardedPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_RewardedPopup>();
	}
};
static_assert(alignof(UUI_RewardedPopup) == 0x000008, "Wrong alignment on UUI_RewardedPopup");
static_assert(sizeof(UUI_RewardedPopup) == 0x000578, "Wrong size on UUI_RewardedPopup");
static_assert(offsetof(UUI_RewardedPopup, UI_RewardedItems) == 0x000570, "Member 'UUI_RewardedPopup::UI_RewardedItems' has a wrong offset!");

// Class Stigma.UI_RewardMissionPopup
// 0x0020 (0x0590 - 0x0570)
class UUI_RewardMissionPopup : public UPopupBase
{
public:
	class UUniformGridPanel*                      UGP_Mission;                                       // 0x0570(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_RewardMissionSlot>      _SlotClass;                                        // 0x0578(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         _DelayTime;                                        // 0x0580(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_265F[0xC];                                     // 0x0584(0x000C)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_RewardMissionPopup">();
	}
	static class UUI_RewardMissionPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_RewardMissionPopup>();
	}
};
static_assert(alignof(UUI_RewardMissionPopup) == 0x000008, "Wrong alignment on UUI_RewardMissionPopup");
static_assert(sizeof(UUI_RewardMissionPopup) == 0x000590, "Wrong size on UUI_RewardMissionPopup");
static_assert(offsetof(UUI_RewardMissionPopup, UGP_Mission) == 0x000570, "Member 'UUI_RewardMissionPopup::UGP_Mission' has a wrong offset!");
static_assert(offsetof(UUI_RewardMissionPopup, _SlotClass) == 0x000578, "Member 'UUI_RewardMissionPopup::_SlotClass' has a wrong offset!");
static_assert(offsetof(UUI_RewardMissionPopup, _DelayTime) == 0x000580, "Member 'UUI_RewardMissionPopup::_DelayTime' has a wrong offset!");

// Class Stigma.UI_SearchUserPopup
// 0x0010 (0x0580 - 0x0570)
class UUI_SearchUserPopup : public UPopupBase
{
public:
	class UTextBlock*                             TXT_Help;                                          // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESearchUserPopupMode                          _mode;                                             // 0x0578(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2660[0x7];                                     // 0x0579(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void HideSearchFailedText();
	bool IsFriendAskableUser(const struct FUserName& _nickname);
	void SetPopupMode(ESearchUserPopupMode _popup_mode);
	void ShowSearchFailedText(const class FString& _nickname);

	bool CheckIsInAskFriendCoolTime(const struct FUserID& _user_id, const struct FUserName& _nickname) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_SearchUserPopup">();
	}
	static class UUI_SearchUserPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_SearchUserPopup>();
	}
};
static_assert(alignof(UUI_SearchUserPopup) == 0x000008, "Wrong alignment on UUI_SearchUserPopup");
static_assert(sizeof(UUI_SearchUserPopup) == 0x000580, "Wrong size on UUI_SearchUserPopup");
static_assert(offsetof(UUI_SearchUserPopup, TXT_Help) == 0x000570, "Member 'UUI_SearchUserPopup::TXT_Help' has a wrong offset!");
static_assert(offsetof(UUI_SearchUserPopup, _mode) == 0x000578, "Member 'UUI_SearchUserPopup::_mode' has a wrong offset!");

// Class Stigma.UI_ShopBundlePopup
// 0x0058 (0x05C8 - 0x0570)
class UUI_ShopBundlePopup : public UPopupBase
{
public:
	class UUI_PreviewPopupBase*                   PreviewPopupBase;                                  // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VB_Bonus;                                          // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      UGP_Main_Items;                                    // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUniformGridPanel*                      UGP_Bonus_Items;                                   // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_BuyLimitCount;                                 // 0x0590(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_LevelCondition;                                // 0x0598(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_PartialOwned;                                  // 0x05A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCtrl_OptionSliderBase*                 BuySlider;                                         // 0x05A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_CancellationPolicy*                 CancellationPolicy;                                // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_ItemIDListViewItem>     _ItemWidgetClass;                                  // 0x05B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UGoodsObject*                           _GoodsObj;                                         // 0x05C0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void InitBuySlider(int32 _slider_max_value);
	void InitPriceBtn(class UGoodsObject* _goods_obj, const struct FConfig_Goods& _goods_def, bool _set_enabled);
	void InitWidget(class UGoodsObject* _goods_obj);
	void OnClickItem(class UAnimatableWidget* _widget, bool _selected);
	void SetBuyLimitText(EBuyLimitType _limit_type, int32 _current_count, int32 _max_count);
	void SetPriceBtnOwned();
	void SetPriceBtnPurchased();
	void UpdatePriceBtnByCount(int32 _buy_count);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_ShopBundlePopup">();
	}
	static class UUI_ShopBundlePopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_ShopBundlePopup>();
	}
};
static_assert(alignof(UUI_ShopBundlePopup) == 0x000008, "Wrong alignment on UUI_ShopBundlePopup");
static_assert(sizeof(UUI_ShopBundlePopup) == 0x0005C8, "Wrong size on UUI_ShopBundlePopup");
static_assert(offsetof(UUI_ShopBundlePopup, PreviewPopupBase) == 0x000570, "Member 'UUI_ShopBundlePopup::PreviewPopupBase' has a wrong offset!");
static_assert(offsetof(UUI_ShopBundlePopup, VB_Bonus) == 0x000578, "Member 'UUI_ShopBundlePopup::VB_Bonus' has a wrong offset!");
static_assert(offsetof(UUI_ShopBundlePopup, UGP_Main_Items) == 0x000580, "Member 'UUI_ShopBundlePopup::UGP_Main_Items' has a wrong offset!");
static_assert(offsetof(UUI_ShopBundlePopup, UGP_Bonus_Items) == 0x000588, "Member 'UUI_ShopBundlePopup::UGP_Bonus_Items' has a wrong offset!");
static_assert(offsetof(UUI_ShopBundlePopup, Txt_BuyLimitCount) == 0x000590, "Member 'UUI_ShopBundlePopup::Txt_BuyLimitCount' has a wrong offset!");
static_assert(offsetof(UUI_ShopBundlePopup, Txt_LevelCondition) == 0x000598, "Member 'UUI_ShopBundlePopup::Txt_LevelCondition' has a wrong offset!");
static_assert(offsetof(UUI_ShopBundlePopup, Txt_PartialOwned) == 0x0005A0, "Member 'UUI_ShopBundlePopup::Txt_PartialOwned' has a wrong offset!");
static_assert(offsetof(UUI_ShopBundlePopup, BuySlider) == 0x0005A8, "Member 'UUI_ShopBundlePopup::BuySlider' has a wrong offset!");
static_assert(offsetof(UUI_ShopBundlePopup, CancellationPolicy) == 0x0005B0, "Member 'UUI_ShopBundlePopup::CancellationPolicy' has a wrong offset!");
static_assert(offsetof(UUI_ShopBundlePopup, _ItemWidgetClass) == 0x0005B8, "Member 'UUI_ShopBundlePopup::_ItemWidgetClass' has a wrong offset!");
static_assert(offsetof(UUI_ShopBundlePopup, _GoodsObj) == 0x0005C0, "Member 'UUI_ShopBundlePopup::_GoodsObj' has a wrong offset!");

// Class Stigma.UI_ShopMasterFilter
// 0x0010 (0x0540 - 0x0530)
class UUI_ShopMasterFilter : public UUI_ShopGridFilter
{
public:
	uint8                                         Pad_2666[0x10];                                    // 0x0530(0x0010)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnSelectedMasterFilter(int32 _idx);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_ShopMasterFilter">();
	}
	static class UUI_ShopMasterFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_ShopMasterFilter>();
	}
};
static_assert(alignof(UUI_ShopMasterFilter) == 0x000008, "Wrong alignment on UUI_ShopMasterFilter");
static_assert(sizeof(UUI_ShopMasterFilter) == 0x000540, "Wrong size on UUI_ShopMasterFilter");

// Class Stigma.UI_SocialPopup
// 0x0140 (0x06B0 - 0x0570)
class UUI_SocialPopup : public UPopupBase
{
public:
	class UTileView*                              LV_SlotPanel;                                      // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCtrl_SocialTabEntryBase*               FriendTab;                                         // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCtrl_SocialTabEntryBase*               RecentPlayTab;                                     // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCtrl_SocialTabEntryBase*               SteamTab;                                          // 0x0588(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCtrl_SocialTabEntryBase*               AcceptTab;                                         // 0x0590(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEditableTextBox*                       PanelSlotNotExistText;                             // 0x0598(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             TabDescriptionText;                                // 0x05A0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCheckBox*                              PartyAcceptRangeToggle_Friend;                     // 0x05A8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCheckBox*                              PartyAcceptRangeToggle_RecentPlayer;               // 0x05B0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UButton*                                RefreshButton;                                     // 0x05B8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             AllowFriendAskOption_Text;                         // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UButton*                                AllowAskFriend_LeftArrow;                          // 0x05C8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UButton*                                AllowAskFriend_RightArrow;                         // 0x05D0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 AllowAskFriendSlot_All;                            // 0x05D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 AllowAskFriendSlot_RecentPlayer;                   // 0x05E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 AllowAskFriendSlot_No;                             // 0x05E8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AllowAskFriendSlot_NotSelected_Color;              // 0x05F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AllowAskFriendSlot_Selected_Color;                 // 0x0600(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCtrl_RadioButtonGroupBase*             ConnectNotify_Switch;                              // 0x0610(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FMessageBoxSetting>             _RefuseAskFriendMsgBoxEntries;                     // 0x0618(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2667[0x88];                                    // 0x0628(0x0088)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void InitializePopup();
	void Net_ReqUpdateUserOptions();
	struct FNetReply OnAck_AskFriend(EResultCode _net_result_code, const struct FACK_Friend& _response);
	struct FNetReply OnAck_FriendAccept(EResultCode _net_result_code, const struct FACK_FriendUpdate& _response);
	struct FNetReply OnAck_FriendRefuse(EResultCode _net_result_code, const struct FACK_FriendUpdate& _response);
	void OnAllowFriendJoinPartyOptionStateChanged();
	void OnAllowLoginNotifyToFriendOptionStateChanged();
	void OnAllowPartyInviteOptionStateChanged();
	void OnAskFriendAllowOptionLeftClick();
	void OnAskFriendAllowOptionRightClick();
	void OnBriefSlotFriendDeleteRequested(const class UUserProfile* _target_user);
	void OnRefreshButtonClick();
	void OnSlotFriendAcceptClicked(const class UUserProfile* _slot);
	void OnSlotFriendLeftClicked(const class UUserProfile* _slot);
	void OnSlotFriendRefuseClicked(const class UUserProfile* _slot);
	void OnSlotFriendRightClicked(const class UUserProfile* _slot);
	void SelectTab(ESocialPopupTabType _tab_type);
	void UpdateOptionContexts();

	const class UUI_BriefUserSlot* FindCurDisplayedUserSlot(const class UUserProfile* _user) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_SocialPopup">();
	}
	static class UUI_SocialPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_SocialPopup>();
	}
};
static_assert(alignof(UUI_SocialPopup) == 0x000008, "Wrong alignment on UUI_SocialPopup");
static_assert(sizeof(UUI_SocialPopup) == 0x0006B0, "Wrong size on UUI_SocialPopup");
static_assert(offsetof(UUI_SocialPopup, LV_SlotPanel) == 0x000570, "Member 'UUI_SocialPopup::LV_SlotPanel' has a wrong offset!");
static_assert(offsetof(UUI_SocialPopup, FriendTab) == 0x000578, "Member 'UUI_SocialPopup::FriendTab' has a wrong offset!");
static_assert(offsetof(UUI_SocialPopup, RecentPlayTab) == 0x000580, "Member 'UUI_SocialPopup::RecentPlayTab' has a wrong offset!");
static_assert(offsetof(UUI_SocialPopup, SteamTab) == 0x000588, "Member 'UUI_SocialPopup::SteamTab' has a wrong offset!");
static_assert(offsetof(UUI_SocialPopup, AcceptTab) == 0x000590, "Member 'UUI_SocialPopup::AcceptTab' has a wrong offset!");
static_assert(offsetof(UUI_SocialPopup, PanelSlotNotExistText) == 0x000598, "Member 'UUI_SocialPopup::PanelSlotNotExistText' has a wrong offset!");
static_assert(offsetof(UUI_SocialPopup, TabDescriptionText) == 0x0005A0, "Member 'UUI_SocialPopup::TabDescriptionText' has a wrong offset!");
static_assert(offsetof(UUI_SocialPopup, PartyAcceptRangeToggle_Friend) == 0x0005A8, "Member 'UUI_SocialPopup::PartyAcceptRangeToggle_Friend' has a wrong offset!");
static_assert(offsetof(UUI_SocialPopup, PartyAcceptRangeToggle_RecentPlayer) == 0x0005B0, "Member 'UUI_SocialPopup::PartyAcceptRangeToggle_RecentPlayer' has a wrong offset!");
static_assert(offsetof(UUI_SocialPopup, RefreshButton) == 0x0005B8, "Member 'UUI_SocialPopup::RefreshButton' has a wrong offset!");
static_assert(offsetof(UUI_SocialPopup, AllowFriendAskOption_Text) == 0x0005C0, "Member 'UUI_SocialPopup::AllowFriendAskOption_Text' has a wrong offset!");
static_assert(offsetof(UUI_SocialPopup, AllowAskFriend_LeftArrow) == 0x0005C8, "Member 'UUI_SocialPopup::AllowAskFriend_LeftArrow' has a wrong offset!");
static_assert(offsetof(UUI_SocialPopup, AllowAskFriend_RightArrow) == 0x0005D0, "Member 'UUI_SocialPopup::AllowAskFriend_RightArrow' has a wrong offset!");
static_assert(offsetof(UUI_SocialPopup, AllowAskFriendSlot_All) == 0x0005D8, "Member 'UUI_SocialPopup::AllowAskFriendSlot_All' has a wrong offset!");
static_assert(offsetof(UUI_SocialPopup, AllowAskFriendSlot_RecentPlayer) == 0x0005E0, "Member 'UUI_SocialPopup::AllowAskFriendSlot_RecentPlayer' has a wrong offset!");
static_assert(offsetof(UUI_SocialPopup, AllowAskFriendSlot_No) == 0x0005E8, "Member 'UUI_SocialPopup::AllowAskFriendSlot_No' has a wrong offset!");
static_assert(offsetof(UUI_SocialPopup, AllowAskFriendSlot_NotSelected_Color) == 0x0005F0, "Member 'UUI_SocialPopup::AllowAskFriendSlot_NotSelected_Color' has a wrong offset!");
static_assert(offsetof(UUI_SocialPopup, AllowAskFriendSlot_Selected_Color) == 0x000600, "Member 'UUI_SocialPopup::AllowAskFriendSlot_Selected_Color' has a wrong offset!");
static_assert(offsetof(UUI_SocialPopup, ConnectNotify_Switch) == 0x000610, "Member 'UUI_SocialPopup::ConnectNotify_Switch' has a wrong offset!");
static_assert(offsetof(UUI_SocialPopup, _RefuseAskFriendMsgBoxEntries) == 0x000618, "Member 'UUI_SocialPopup::_RefuseAskFriendMsgBoxEntries' has a wrong offset!");

// Class Stigma.UI_TabInspector
// 0x01D0 (0x06C0 - 0x04F0)
class UUI_TabInspector : public UPreviewableWidget
{
public:
	class UHorizontalBox*                         HorizontalBox;                                     // 0x04F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_266B[0x8];                                     // 0x04F8(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	struct FSlateBrush                            _UI_Brush_Activated;                               // 0x0500(0x00D0)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            _UI_Brush_Deactivated;                             // 0x05D0(0x00D0)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FMargin                                _UI_Slot_Padding;                                  // 0x06A0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EHorizontalAlignment                          _UI_Slot_HorizontalAlignment;                      // 0x06B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EVerticalAlignment                            _UI_Slot_VerticalAlignment;                        // 0x06B1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_266C[0xE];                                     // 0x06B2(0x000E)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void ActivateSlot(int32 _idx);
	void InitWidget(int32 _size);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_TabInspector">();
	}
	static class UUI_TabInspector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_TabInspector>();
	}
};
static_assert(alignof(UUI_TabInspector) == 0x000010, "Wrong alignment on UUI_TabInspector");
static_assert(sizeof(UUI_TabInspector) == 0x0006C0, "Wrong size on UUI_TabInspector");
static_assert(offsetof(UUI_TabInspector, HorizontalBox) == 0x0004F0, "Member 'UUI_TabInspector::HorizontalBox' has a wrong offset!");
static_assert(offsetof(UUI_TabInspector, _UI_Brush_Activated) == 0x000500, "Member 'UUI_TabInspector::_UI_Brush_Activated' has a wrong offset!");
static_assert(offsetof(UUI_TabInspector, _UI_Brush_Deactivated) == 0x0005D0, "Member 'UUI_TabInspector::_UI_Brush_Deactivated' has a wrong offset!");
static_assert(offsetof(UUI_TabInspector, _UI_Slot_Padding) == 0x0006A0, "Member 'UUI_TabInspector::_UI_Slot_Padding' has a wrong offset!");
static_assert(offsetof(UUI_TabInspector, _UI_Slot_HorizontalAlignment) == 0x0006B0, "Member 'UUI_TabInspector::_UI_Slot_HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UUI_TabInspector, _UI_Slot_VerticalAlignment) == 0x0006B1, "Member 'UUI_TabInspector::_UI_Slot_VerticalAlignment' has a wrong offset!");

// Class Stigma.UI_TDM_SubScoreSlot
// 0x01A0 (0x0690 - 0x04F0)
class UUI_TDM_SubScoreSlot : public UPreviewableWidget
{
public:
	struct FSlateBrush                            _MyTeamBrush;                                      // 0x04F0(0x00D0)(Edit, Protected, NativeAccessSpecifierProtected)
	struct FSlateBrush                            _EnemyTeamBrush;                                   // 0x05C0(0x00D0)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	void SetTeamBrush(const struct FSlateBrush& _brush);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_TDM_SubScoreSlot">();
	}
	static class UUI_TDM_SubScoreSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_TDM_SubScoreSlot>();
	}
};
static_assert(alignof(UUI_TDM_SubScoreSlot) == 0x000010, "Wrong alignment on UUI_TDM_SubScoreSlot");
static_assert(sizeof(UUI_TDM_SubScoreSlot) == 0x000690, "Wrong size on UUI_TDM_SubScoreSlot");
static_assert(offsetof(UUI_TDM_SubScoreSlot, _MyTeamBrush) == 0x0004F0, "Member 'UUI_TDM_SubScoreSlot::_MyTeamBrush' has a wrong offset!");
static_assert(offsetof(UUI_TDM_SubScoreSlot, _EnemyTeamBrush) == 0x0005C0, "Member 'UUI_TDM_SubScoreSlot::_EnemyTeamBrush' has a wrong offset!");

// Class Stigma.UI_TierPromotionPopup
// 0x0000 (0x0570 - 0x0570)
class UUI_TierPromotionPopup : public UPopupBase
{
public:
	void SetValue(const struct FBC_TierUpdate& _packet);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_TierPromotionPopup">();
	}
	static class UUI_TierPromotionPopup* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_TierPromotionPopup>();
	}
};
static_assert(alignof(UUI_TierPromotionPopup) == 0x000008, "Wrong alignment on UUI_TierPromotionPopup");
static_assert(sizeof(UUI_TierPromotionPopup) == 0x000570, "Wrong size on UUI_TierPromotionPopup");

// Class Stigma.UI_TooltipKey
// 0x0030 (0x0520 - 0x04F0)
class UUI_TooltipKey : public UPreviewableWidget
{
public:
	struct FTooltipKeyInfo                        _KeyInfo;                                          // 0x04F0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	void SetInfoText(const class FText& _info_text);
	void SetKey(const struct FKey& _Key);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_TooltipKey">();
	}
	static class UUI_TooltipKey* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_TooltipKey>();
	}
};
static_assert(alignof(UUI_TooltipKey) == 0x000008, "Wrong alignment on UUI_TooltipKey");
static_assert(sizeof(UUI_TooltipKey) == 0x000520, "Wrong size on UUI_TooltipKey");
static_assert(offsetof(UUI_TooltipKey, _KeyInfo) == 0x0004F0, "Member 'UUI_TooltipKey::_KeyInfo' has a wrong offset!");

// Class Stigma.UI_WaitingRoom
// 0x0048 (0x05B8 - 0x0570)
class UUI_WaitingRoom final : public UPopupBase
{
public:
	TSubclassOf<class UUserWidget>                _UIClass_CustomGame;                               // 0x0570(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                _UIClass_CharacterPick;                            // 0x0578(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                _UIClass_Observer;                                 // 0x0580(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OverlapDuration;                                   // 0x0588(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_266D[0x4];                                     // 0x058C(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class UCanvasPanel*                           Root;                                              // 0x0590(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_ChatBox*                            ChatBox;                                           // 0x0598(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            _ChildUI;                                          // 0x05A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            _NewUI;                                            // 0x05A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_266E[0x8];                                     // 0x05B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void AddChat(const struct FChatMsg& _chat_msg);
	class UCanvasPanel* GetRootCanvasPanel();
	void InitEvent();
	void InitUI();
	void OnChangeWaitingRoomState(EWaitingRoomState _state);
	void OnStartChat();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_WaitingRoom">();
	}
	static class UUI_WaitingRoom* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_WaitingRoom>();
	}
};
static_assert(alignof(UUI_WaitingRoom) == 0x000008, "Wrong alignment on UUI_WaitingRoom");
static_assert(sizeof(UUI_WaitingRoom) == 0x0005B8, "Wrong size on UUI_WaitingRoom");
static_assert(offsetof(UUI_WaitingRoom, _UIClass_CustomGame) == 0x000570, "Member 'UUI_WaitingRoom::_UIClass_CustomGame' has a wrong offset!");
static_assert(offsetof(UUI_WaitingRoom, _UIClass_CharacterPick) == 0x000578, "Member 'UUI_WaitingRoom::_UIClass_CharacterPick' has a wrong offset!");
static_assert(offsetof(UUI_WaitingRoom, _UIClass_Observer) == 0x000580, "Member 'UUI_WaitingRoom::_UIClass_Observer' has a wrong offset!");
static_assert(offsetof(UUI_WaitingRoom, OverlapDuration) == 0x000588, "Member 'UUI_WaitingRoom::OverlapDuration' has a wrong offset!");
static_assert(offsetof(UUI_WaitingRoom, Root) == 0x000590, "Member 'UUI_WaitingRoom::Root' has a wrong offset!");
static_assert(offsetof(UUI_WaitingRoom, ChatBox) == 0x000598, "Member 'UUI_WaitingRoom::ChatBox' has a wrong offset!");
static_assert(offsetof(UUI_WaitingRoom, _ChildUI) == 0x0005A0, "Member 'UUI_WaitingRoom::_ChildUI' has a wrong offset!");
static_assert(offsetof(UUI_WaitingRoom, _NewUI) == 0x0005A8, "Member 'UUI_WaitingRoom::_NewUI' has a wrong offset!");

// Class Stigma.UI_Wallet
// 0x0020 (0x0590 - 0x0570)
class UUI_Wallet : public UPopupBase
{
public:
	class UButton*                                btn_close;                                         // 0x0570(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                Btn_BgClose;                                       // 0x0578(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           VB_WalletList;                                     // 0x0580(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUI_WalletListItem>         _WalletItemClass;                                  // 0x0588(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnClickClose();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_Wallet">();
	}
	static class UUI_Wallet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_Wallet>();
	}
};
static_assert(alignof(UUI_Wallet) == 0x000008, "Wrong alignment on UUI_Wallet");
static_assert(sizeof(UUI_Wallet) == 0x000590, "Wrong size on UUI_Wallet");
static_assert(offsetof(UUI_Wallet, btn_close) == 0x000570, "Member 'UUI_Wallet::btn_close' has a wrong offset!");
static_assert(offsetof(UUI_Wallet, Btn_BgClose) == 0x000578, "Member 'UUI_Wallet::Btn_BgClose' has a wrong offset!");
static_assert(offsetof(UUI_Wallet, VB_WalletList) == 0x000580, "Member 'UUI_Wallet::VB_WalletList' has a wrong offset!");
static_assert(offsetof(UUI_Wallet, _WalletItemClass) == 0x000588, "Member 'UUI_Wallet::_WalletItemClass' has a wrong offset!");

// Class Stigma.UI_WalletListItem
// 0x0060 (0x0550 - 0x04F0)
class UUI_WalletListItem : public UPreviewableWidget
{
public:
	class UImage*                                 Img_Line;                                          // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 Img_Icon;                                          // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_CurrencyName;                                  // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HB_Owned;                                          // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UHorizontalBox*                         HB_TotalEarnings;                                  // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_OwnedCount;                                    // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTextBlock*                             Txt_TotalEarningCount;                             // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UButton*                                BTN_Purchase;                                      // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPopupBase>                 _QuickPurchasePopupClass;                          // 0x0530(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FItemID                                _CurrencyID;                                       // 0x0538(0x0010)(BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_266F[0x8];                                     // 0x0548(0x0008)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void OnClickPurchase();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UI_WalletListItem">();
	}
	static class UUI_WalletListItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUI_WalletListItem>();
	}
};
static_assert(alignof(UUI_WalletListItem) == 0x000008, "Wrong alignment on UUI_WalletListItem");
static_assert(sizeof(UUI_WalletListItem) == 0x000550, "Wrong size on UUI_WalletListItem");
static_assert(offsetof(UUI_WalletListItem, Img_Line) == 0x0004F0, "Member 'UUI_WalletListItem::Img_Line' has a wrong offset!");
static_assert(offsetof(UUI_WalletListItem, Img_Icon) == 0x0004F8, "Member 'UUI_WalletListItem::Img_Icon' has a wrong offset!");
static_assert(offsetof(UUI_WalletListItem, Txt_CurrencyName) == 0x000500, "Member 'UUI_WalletListItem::Txt_CurrencyName' has a wrong offset!");
static_assert(offsetof(UUI_WalletListItem, HB_Owned) == 0x000508, "Member 'UUI_WalletListItem::HB_Owned' has a wrong offset!");
static_assert(offsetof(UUI_WalletListItem, HB_TotalEarnings) == 0x000510, "Member 'UUI_WalletListItem::HB_TotalEarnings' has a wrong offset!");
static_assert(offsetof(UUI_WalletListItem, Txt_OwnedCount) == 0x000518, "Member 'UUI_WalletListItem::Txt_OwnedCount' has a wrong offset!");
static_assert(offsetof(UUI_WalletListItem, Txt_TotalEarningCount) == 0x000520, "Member 'UUI_WalletListItem::Txt_TotalEarningCount' has a wrong offset!");
static_assert(offsetof(UUI_WalletListItem, BTN_Purchase) == 0x000528, "Member 'UUI_WalletListItem::BTN_Purchase' has a wrong offset!");
static_assert(offsetof(UUI_WalletListItem, _QuickPurchasePopupClass) == 0x000530, "Member 'UUI_WalletListItem::_QuickPurchasePopupClass' has a wrong offset!");
static_assert(offsetof(UUI_WalletListItem, _CurrencyID) == 0x000538, "Member 'UUI_WalletListItem::_CurrencyID' has a wrong offset!");

// Class Stigma.UserIDBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UUserIDBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool IsEqualUserID(const struct FUserID& _id1, const struct FUserID& _id2);
	static struct FUserID MakeUserID(int32 _id);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserIDBlueprintLibrary">();
	}
	static class UUserIDBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserIDBlueprintLibrary>();
	}
};
static_assert(alignof(UUserIDBlueprintLibrary) == 0x000008, "Wrong alignment on UUserIDBlueprintLibrary");
static_assert(sizeof(UUserIDBlueprintLibrary) == 0x000028, "Wrong size on UUserIDBlueprintLibrary");

// Class Stigma.UserMission
// 0x0078 (0x00A0 - 0x0028)
class UUserMission final : public UObject
{
public:
	TMap<struct FItemID, struct FMissions>        _TaskMissions;                                     // 0x0028(0x0050)(BlueprintVisible, BlueprintReadOnly, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_2672[0x28];                                    // 0x0078(0x0028)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserMission">();
	}
	static class UUserMission* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserMission>();
	}
};
static_assert(alignof(UUserMission) == 0x000008, "Wrong alignment on UUserMission");
static_assert(sizeof(UUserMission) == 0x0000A0, "Wrong size on UUserMission");
static_assert(offsetof(UUserMission, _TaskMissions) == 0x000028, "Member 'UUserMission::_TaskMissions' has a wrong offset!");

// Class Stigma.UserOption
// 0x02A0 (0x02D0 - 0x0030)
class UUserOption final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_2673[0x8];                                     // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	struct FGameOption                            _GameOption;                                       // 0x0038(0x0130)(NativeAccessSpecifierPrivate)
	struct FGameOption                            _BackUpGameOption;                                 // 0x0168(0x0130)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_2674[0x38];                                    // 0x0298(0x0038)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	void AddControlOptionForMaster(const struct FControlOption& _option);
	EAnnouncerType GetAnnouncerType();
	float GetBgmVolume();
	float GetBrightness();
	struct FControlOption GetControlOptionForMaster(ECharaType _type);
	TArray<struct FControlOption> GetControlOptionForMasters();
	int32 GetControlOptionMasterCount();
	bool GetControlOptionRefForMaster(ECharaType _type, struct FControlOption* _result_opt);
	EOptionLanguage GetCurrentLanguage();
	EOptionLanguage GetCurrentVoiceLanguage();
	float GetEffectVolume();
	float GetFOV();
	int32 GetGraphicQuality();
	float GetMasterVolume();
	float GetMouseAimingSensitive(ECharaType _type);
	float GetMouseAimingSensitiveX(ECharaType _type);
	float GetMouseAimingSensitiveY(ECharaType _type);
	float GetMouseNomalSensitive(ECharaType _type);
	float GetMouseNomalSensitiveX(ECharaType _type);
	float GetMouseNomalSensitiveY(ECharaType _type);
	float GetMouseSnipeAimingSensitive(ECharaType _type);
	float GetMouseSnipeAimingSensitiveX(ECharaType _type);
	float GetMouseSnipeAimingSensitiveY(ECharaType _type);
	float GetRadarMapScale();
	int32 GetResolutionHeight();
	int32 GetResolutionWidth();
	struct FGameOption GetTotalOption();
	float GetVoiceVolume();
	EWindowMode GetWindowMode();
	bool HasAnythingChangedExists();
	bool HasChangedExistInPage(EOptionCategoryType _page);
	void InitializeOption();
	bool IsAddedControlOption(ECharaType _type);
	bool IsShowAlliesNameTag();
	bool IsShowEnemyDamage();
	bool IsShowFPS();
	bool IsShowHitFloating();
	bool IsUsedAutoBoosters(ECharaType _type);
	bool IsUsedHoldAiming(ECharaType _type);
	bool IsUsedHoldCrouch(ECharaType _type);
	bool IsUsedHoldShowStatusBoard(ECharaType _type);
	bool IsUsedNoticeActiveSkillCombo(ECharaType _type);
	void LoadGameOption();
	void OnChangeLevel();
	void RegisterOnUserOptionApplied(const TDelegate<void(EOptionCategoryType _category)>& _callback);
	void RemoveControlOptionForMaster(ECharaType _type);
	void ResetAllGameOptionToDefault();
	void ResetAudioGameOptionToDefault();
	void ResetControlGameOptionToDefault();
	void ResetGeneralGameOptionToDefault();
	void ResetGraphicGameOptionToDefault();
	void RevertAllGameOptionToBackUp();
	void RevertAudioGameOptionToBackUp();
	void RevertControlGameOptionToBackUp();
	void RevertGeneralGameOptionToBackUp();
	void RevertGraphicGameOptionToBackUp();
	void SaveGameOption(bool _need_to_update);
	bool SetBrightness(float _value);
	bool SetContrast(float _value);
	bool SetGamma(float _value);
	bool SetGraphicQuality(bool _is_auto, int32 Scalability_level);
	bool SetScreenResoultion(int32 _width, int32 _height);
	void SetShowEnemyDamage(bool _enable);
	bool SetSoundVolume(class USoundMix* Sound_mix, class USoundClass* Sound_class, float Volume, float Pitch, float Fade_in_time);
	bool SetWindowMode(EWindowMode _type);
	void UpdateGameOption();
	void UpdateOptionForAudio(bool _is_user_setting_apply);
	void UpdateOptionForControl(bool _is_user_setting_apply);
	void UpdateOptionForGeneral(bool _is_user_setting_apply);
	void UpdateOptionForGraphic(bool _is_user_setting_apply);

	int32 GetWishedRegionCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserOption">();
	}
	static class UUserOption* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserOption>();
	}
};
static_assert(alignof(UUserOption) == 0x000008, "Wrong alignment on UUserOption");
static_assert(sizeof(UUserOption) == 0x0002D0, "Wrong size on UUserOption");
static_assert(offsetof(UUserOption, _GameOption) == 0x000038, "Member 'UUserOption::_GameOption' has a wrong offset!");
static_assert(offsetof(UUserOption, _BackUpGameOption) == 0x000168, "Member 'UUserOption::_BackUpGameOption' has a wrong offset!");

// Class Stigma.LocalUserProfile
// 0x0008 (0x01A8 - 0x01A0)
class ULocalUserProfile final : public UUserProfile
{
public:
	class ULocalPlayerContext*                    _LocalPlayerCtx;                                   // 0x01A0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalUserProfile">();
	}
	static class ULocalUserProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalUserProfile>();
	}
};
static_assert(alignof(ULocalUserProfile) == 0x000008, "Wrong alignment on ULocalUserProfile");
static_assert(sizeof(ULocalUserProfile) == 0x0001A8, "Wrong size on ULocalUserProfile");
static_assert(offsetof(ULocalUserProfile, _LocalPlayerCtx) == 0x0001A0, "Member 'ULocalUserProfile::_LocalPlayerCtx' has a wrong offset!");

// Class Stigma.UtilText
// 0x0000 (0x0028 - 0x0028)
class UUtilText final : public UBlueprintFunctionLibrary
{
public:
	static class FText ConvertContractionNumber(int32 _number);
	static class FText GetCurrencyRichText(ECurrencyTypes _currency_type, int32 _Amount);
	static class FText GetKeyDisplayText(const class UObject* _world_ctx, const struct FKey& _Key);
	static class FText GetLevelConditionText(int32 _start_level, int32 _end_level);
	static class FText GetPurchaseText(ECurrencyTypes _currency_type, int32 _Amount);
	static class FText GetRemainTimeText(const struct FTimespan& _span, const int32 _time_digits, const bool _show_zero_value, const int32 Max_time_units_to_show);
	static class FText GetStringTableText(const class FString& _id, const class FString& _Key);
	static class FString GetStringTableTextWithArguments(const class FString& _id, const class FString& _Key, const TMap<class FString, class FString>& _arguments);
	static class FText GetTimeText_HMS(int32 _total_seconds, int32 _max_time_units_to_show, bool _show_zero_value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UtilText">();
	}
	static class UUtilText* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUtilText>();
	}
};
static_assert(alignof(UUtilText) == 0x000008, "Wrong alignment on UUtilText");
static_assert(sizeof(UUtilText) == 0x000028, "Wrong size on UUtilText");

// Class Stigma.VoicePlay
// 0x0018 (0x0050 - 0x0038)
class UVoicePlay final : public UAnimNotify
{
public:
	class FString                                 _VoiceID;                                          // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          _Is3DSound;                                        // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_268E[0x7];                                     // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-69 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoicePlay">();
	}
	static class UVoicePlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVoicePlay>();
	}
};
static_assert(alignof(UVoicePlay) == 0x000008, "Wrong alignment on UVoicePlay");
static_assert(sizeof(UVoicePlay) == 0x000050, "Wrong size on UVoicePlay");
static_assert(offsetof(UVoicePlay, _VoiceID) == 0x000038, "Member 'UVoicePlay::_VoiceID' has a wrong offset!");
static_assert(offsetof(UVoicePlay, _Is3DSound) == 0x000048, "Member 'UVoicePlay::_Is3DSound' has a wrong offset!");

// Class Stigma.VoiceSound2DActor
// 0x0068 (0x0300 - 0x0298)
class AVoiceSound2DActor : public AActor
{
public:
	class UAudioComponent*                        _AudioComponent;                                   // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayerState*                           _OwningPlayer;                                     // 0x02A0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FToPlayVoiceInfo                       _VoiceInfo;                                        // 0x02A8(0x0058)(Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VoiceSound2DActor">();
	}
	static class AVoiceSound2DActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVoiceSound2DActor>();
	}
};
static_assert(alignof(AVoiceSound2DActor) == 0x000008, "Wrong alignment on AVoiceSound2DActor");
static_assert(sizeof(AVoiceSound2DActor) == 0x000300, "Wrong size on AVoiceSound2DActor");
static_assert(offsetof(AVoiceSound2DActor, _AudioComponent) == 0x000298, "Member 'AVoiceSound2DActor::_AudioComponent' has a wrong offset!");
static_assert(offsetof(AVoiceSound2DActor, _OwningPlayer) == 0x0002A0, "Member 'AVoiceSound2DActor::_OwningPlayer' has a wrong offset!");
static_assert(offsetof(AVoiceSound2DActor, _VoiceInfo) == 0x0002A8, "Member 'AVoiceSound2DActor::_VoiceInfo' has a wrong offset!");

// Class Stigma.WaitingRoomGameState
// 0x0820 (0x0F78 - 0x0758)
class AWaitingRoomGameState final : public AMatchServicedGameState
{
public:
	EWaitingRoomState                             _state;                                            // 0x0758(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_268F[0x3];                                     // 0x0759(0x0003)(Fixing Size After Last Property [ Dumper-69 ])
	int32                                         LeftSeconds;                                       // 0x075C(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FCustomGameSlotList                    _ATeam;                                            // 0x0760(0x0128)(Edit, BlueprintVisible, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FCustomGameSlotList                    _BTeam;                                            // 0x0888(0x0128)(Edit, BlueprintVisible, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FCustomGameSlotList                    _CTeam;                                            // 0x09B0(0x0128)(Edit, BlueprintVisible, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FCustomGameSlotList                    _ATeamCoach;                                       // 0x0AD8(0x0128)(Edit, BlueprintVisible, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FCustomGameSlotList                    _BTeamCoach;                                       // 0x0C00(0x0128)(Edit, BlueprintVisible, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FCustomGameSlotList                    _CTeamCoach;                                       // 0x0D28(0x0128)(Edit, BlueprintVisible, Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FCustomGameSlotList                    _Observers;                                        // 0x0E50(0x0128)(Edit, BlueprintVisible, Net, RepNotify, Protected, NativeAccessSpecifierProtected)

public:
	void OnRep_ATeam();
	void OnRep_ATeamCoach();
	void OnRep_BTeam();
	void OnRep_BTeamCoach();
	void OnRep_CTeam();
	void OnRep_CTeamCoach();
	void OnRep_LeftSeconds();
	void OnRep_Observers();
	void OnRep_State();
	void SERVER_CustomGame_CloseSlot(class AWaitingRoomPlayerController* _asker, const struct FCustomGameSlotIndex& _idx, bool _close);
	void SERVER_CustomGame_MoveTo(class AWaitingRoomPlayerController* _asker, const struct FCustomGameSlotIndex& _idx_from, const struct FCustomGameSlotIndex& _idx_to);
	void SERVER_CustomGame_SetIsClosed(const struct FCustomGameSlotIndex& _idx, bool _is_closed);
	void Setter_State(EWaitingRoomState _new_state);
	bool TakeCustomGameSlotChangedState(const struct FCustomGameSlotIndex& _idx);

	bool CanStartCustomGame() const;
	const struct FCustomGameSlot GetCustomGameSlot(const struct FCustomGameSlotIndex& _idx) const;
	int32 GetLeftSeconds() const;
	int32 GetMaxObserverCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaitingRoomGameState">();
	}
	static class AWaitingRoomGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWaitingRoomGameState>();
	}
};
static_assert(alignof(AWaitingRoomGameState) == 0x000008, "Wrong alignment on AWaitingRoomGameState");
static_assert(sizeof(AWaitingRoomGameState) == 0x000F78, "Wrong size on AWaitingRoomGameState");
static_assert(offsetof(AWaitingRoomGameState, _state) == 0x000758, "Member 'AWaitingRoomGameState::_state' has a wrong offset!");
static_assert(offsetof(AWaitingRoomGameState, LeftSeconds) == 0x00075C, "Member 'AWaitingRoomGameState::LeftSeconds' has a wrong offset!");
static_assert(offsetof(AWaitingRoomGameState, _ATeam) == 0x000760, "Member 'AWaitingRoomGameState::_ATeam' has a wrong offset!");
static_assert(offsetof(AWaitingRoomGameState, _BTeam) == 0x000888, "Member 'AWaitingRoomGameState::_BTeam' has a wrong offset!");
static_assert(offsetof(AWaitingRoomGameState, _CTeam) == 0x0009B0, "Member 'AWaitingRoomGameState::_CTeam' has a wrong offset!");
static_assert(offsetof(AWaitingRoomGameState, _ATeamCoach) == 0x000AD8, "Member 'AWaitingRoomGameState::_ATeamCoach' has a wrong offset!");
static_assert(offsetof(AWaitingRoomGameState, _BTeamCoach) == 0x000C00, "Member 'AWaitingRoomGameState::_BTeamCoach' has a wrong offset!");
static_assert(offsetof(AWaitingRoomGameState, _CTeamCoach) == 0x000D28, "Member 'AWaitingRoomGameState::_CTeamCoach' has a wrong offset!");
static_assert(offsetof(AWaitingRoomGameState, _Observers) == 0x000E50, "Member 'AWaitingRoomGameState::_Observers' has a wrong offset!");

// Class Stigma.WaitingRoomPlayerController
// 0x0058 (0x0A10 - 0x09B8)
class AWaitingRoomPlayerController final : public AMatchServicedPlayerController
{
public:
	TSubclassOf<class UUI_WaitingRoom>            _UIClass;                                          // 0x09B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUI_WaitingRoom*                        _TheUI;                                            // 0x09C0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2693[0x8];                                     // 0x09C8(0x0008)(Fixing Size After Last Property [ Dumper-69 ])
	class ULevelSequencePlayer*                   _CutScenePlayer;                                   // 0x09D0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULevelStreamingDynamic*                 _Level_Intro;                                      // 0x09D8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class ACharaBase*>                     _Avatars;                                          // 0x09E0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class ACharaBase*>                     _Avatars_VS;                                       // 0x09F0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         _Starting_Duration;                                // 0x0A00(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2694[0x4];                                     // 0x0A04(0x0004)(Fixing Size After Last Property [ Dumper-69 ])
	class ALevelSequenceActor*                    _Intro_Sequencer;                                  // 0x0A08(0x0008)(Edit, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void LoadIntroLevel();
	void PlayAnnouncerIntroVoice();
	void PlayCharaIntroVoice(class ACharaBase* _chara);
	void PlayStartCutScene();
	void RPC_CLIENT_BalanceTeam();
	void RPC_CLIENT_DelegateRoomLeader(const struct FUserName& _nickname);
	void RPC_CLIENT_YouAreBanned();
	void RPC_SERVER_BalanceTeam();
	void RPC_SERVER_DEBUG_AddBOT();
	void RPC_SERVER_DEBUG_ChangeToCustomGame();
	void RPC_SERVER_DEBUG_SetGameSetting(bool _is_custom_game, EGameMode _game_mode, const class FString& _map_name);
	void RPC_SERVER_DelegateRoomLeader(const struct FUserID& _user_id);
	void RPC_SERVER_RequestBan(const struct FCustomGameSlotIndex& _idx);
	void RPC_SERVER_RequestCloseSlot(const struct FCustomGameSlotIndex& _idx, bool _close);
	void RPC_SERVER_RequestMoveSlot(const struct FCustomGameSlotIndex& _from, const struct FCustomGameSlotIndex& _to);
	void RPC_SERVER_SetGameMode(EGameMode _mode);
	void RPC_SERVER_SetMap(const class FString& _map_name);
	void RPC_SERVER_SetRoomManager(const struct FUserID& _user_id, bool _is_manager);
	void RPC_SERVER_StartCharacterPick();
	void RPC_SERVER_ToggleAllowJoin();
	void RPC_SERVER_ToggleObserverChat();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WaitingRoomPlayerController">();
	}
	static class AWaitingRoomPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWaitingRoomPlayerController>();
	}
};
static_assert(alignof(AWaitingRoomPlayerController) == 0x000008, "Wrong alignment on AWaitingRoomPlayerController");
static_assert(sizeof(AWaitingRoomPlayerController) == 0x000A10, "Wrong size on AWaitingRoomPlayerController");
static_assert(offsetof(AWaitingRoomPlayerController, _UIClass) == 0x0009B8, "Member 'AWaitingRoomPlayerController::_UIClass' has a wrong offset!");
static_assert(offsetof(AWaitingRoomPlayerController, _TheUI) == 0x0009C0, "Member 'AWaitingRoomPlayerController::_TheUI' has a wrong offset!");
static_assert(offsetof(AWaitingRoomPlayerController, _CutScenePlayer) == 0x0009D0, "Member 'AWaitingRoomPlayerController::_CutScenePlayer' has a wrong offset!");
static_assert(offsetof(AWaitingRoomPlayerController, _Level_Intro) == 0x0009D8, "Member 'AWaitingRoomPlayerController::_Level_Intro' has a wrong offset!");
static_assert(offsetof(AWaitingRoomPlayerController, _Avatars) == 0x0009E0, "Member 'AWaitingRoomPlayerController::_Avatars' has a wrong offset!");
static_assert(offsetof(AWaitingRoomPlayerController, _Avatars_VS) == 0x0009F0, "Member 'AWaitingRoomPlayerController::_Avatars_VS' has a wrong offset!");
static_assert(offsetof(AWaitingRoomPlayerController, _Starting_Duration) == 0x000A00, "Member 'AWaitingRoomPlayerController::_Starting_Duration' has a wrong offset!");
static_assert(offsetof(AWaitingRoomPlayerController, _Intro_Sequencer) == 0x000A08, "Member 'AWaitingRoomPlayerController::_Intro_Sequencer' has a wrong offset!");

// Class Stigma.TimedNiagaraEffectScale
// 0x0070 (0x00E8 - 0x0078)
class UTimedNiagaraEffectScale final : public UAnimNotifyState_TimedNiagaraEffect
{
public:
	TMap<struct FItemID, class UNiagaraSystem*>   _BodyID_With_NiagaraSystem;                        // 0x0078(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x00C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         _resultTemplate;                                   // 0x00E0(0x0008)(BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimedNiagaraEffectScale">();
	}
	static class UTimedNiagaraEffectScale* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimedNiagaraEffectScale>();
	}
};
static_assert(alignof(UTimedNiagaraEffectScale) == 0x000008, "Wrong alignment on UTimedNiagaraEffectScale");
static_assert(sizeof(UTimedNiagaraEffectScale) == 0x0000E8, "Wrong size on UTimedNiagaraEffectScale");
static_assert(offsetof(UTimedNiagaraEffectScale, _BodyID_With_NiagaraSystem) == 0x000078, "Member 'UTimedNiagaraEffectScale::_BodyID_With_NiagaraSystem' has a wrong offset!");
static_assert(offsetof(UTimedNiagaraEffectScale, Scale) == 0x0000C8, "Member 'UTimedNiagaraEffectScale::Scale' has a wrong offset!");
static_assert(offsetof(UTimedNiagaraEffectScale, _resultTemplate) == 0x0000E0, "Member 'UTimedNiagaraEffectScale::_resultTemplate' has a wrong offset!");

}

